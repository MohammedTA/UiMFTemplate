(function () {
    'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function commonjsRequire () {
    	throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');
    }

    function unwrapExports (x) {
    	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
    }

    function createCommonjsModule(fn, module) {
    	return module = { exports: {} }, fn(module, module.exports), module.exports;
    }

    var alertify = createCommonjsModule(function (module) {
    /**
     * alertifyjs 1.13.1 http://alertifyjs.com
     * AlertifyJS is a javascript framework for developing pretty browser dialogs and notifications.
     * Copyright 2019 Mohammad Younes <Mohammad@alertifyjs.com> (http://alertifyjs.com) 
     * Licensed under GPL 3 <https://opensource.org/licenses/gpl-3.0>*/
    ( function ( window ) {
        var NOT_DISABLED_NOT_RESET = ':not(:disabled):not(.ajs-reset)';
        /**
         * Keys enum
         * @type {Object}
         */
        var keys = {
            ENTER: 13,
            ESC: 27,
            F1: 112,
            F12: 123,
            LEFT: 37,
            RIGHT: 39,
            TAB: 9
        };
        /**
         * Default options 
         * @type {Object}
         */
        var defaults = {
            autoReset:true,
            basic:false,
            closable:true,
            closableByDimmer:true,
            invokeOnCloseOff:false,
            frameless:false,
            defaultFocusOff:false,
            maintainFocus:true, //global default not per instance, applies to all dialogs
            maximizable:true,
            modal:true,
            movable:true,
            moveBounded:false,
            overflow:true,
            padding: true,
            pinnable:true,
            pinned:true,
            preventBodyShift:false, //global default not per instance, applies to all dialogs
            resizable:true,
            startMaximized:false,
            transition:'pulse',
            transitionOff:false,
            tabbable:['button', '[href]', 'input', 'select', 'textarea', '[tabindex]:not([tabindex^="-"])'+NOT_DISABLED_NOT_RESET].join(NOT_DISABLED_NOT_RESET+','),//global
            notifier:{
                delay:5,
                position:'bottom-right',
                closeButton:false,
                classes: {
                    base: 'alertify-notifier',
                    prefix:'ajs-',
                    message: 'ajs-message',
                    top: 'ajs-top',
                    right: 'ajs-right',
                    bottom: 'ajs-bottom',
                    left: 'ajs-left',
                    center: 'ajs-center',
                    visible: 'ajs-visible',
                    hidden: 'ajs-hidden',
                    close: 'ajs-close'
                }
            },
            glossary:{
                title:'AlertifyJS',
                ok: 'OK',
                cancel: 'Cancel',
                acccpt: 'Accept',
                deny: 'Deny',
                confirm: 'Confirm',
                decline: 'Decline',
                close: 'Close',
                maximize: 'Maximize',
                restore: 'Restore',
            },
            theme:{
                input:'ajs-input',
                ok:'ajs-ok',
                cancel:'ajs-cancel',
            },
            hooks:{
                preinit:function(){},
                postinit:function(){}
            }
        };
        
        //holds open dialogs instances
        var openDialogs = [];

        /**
         * [Helper]  Adds the specified class(es) to the element.
         *
         * @element {node}      The element
         * @className {string}  One or more space-separated classes to be added to the class attribute of the element.
         * 
         * @return {undefined}
         */
        function addClass(element,classNames){
            element.className += ' ' + classNames;
        }
        
        /**
         * [Helper]  Removes the specified class(es) from the element.
         *
         * @element {node}      The element
         * @className {string}  One or more space-separated classes to be removed from the class attribute of the element.
         * 
         * @return {undefined}
         */
        function removeClass(element, classNames) {
            var original = element.className.split(' ');
            var toBeRemoved = classNames.split(' ');
            for (var x = 0; x < toBeRemoved.length; x += 1) {
                var index = original.indexOf(toBeRemoved[x]);
                if (index > -1){
                    original.splice(index,1);
                }
            }
            element.className = original.join(' ');
        }

        /**
         * [Helper]  Checks if the document is RTL
         *
         * @return {Boolean} True if the document is RTL, false otherwise.
         */
        function isRightToLeft(){
            return window.getComputedStyle(document.body).direction === 'rtl';
        }
        /**
         * [Helper]  Get the document current scrollTop
         *
         * @return {Number} current document scrollTop value
         */
        function getScrollTop(){
            return ((document.documentElement && document.documentElement.scrollTop) || document.body.scrollTop);
        }

        /**
         * [Helper]  Get the document current scrollLeft
         *
         * @return {Number} current document scrollLeft value
         */
        function getScrollLeft(){
            return ((document.documentElement && document.documentElement.scrollLeft) || document.body.scrollLeft);
        }

        /**
        * Helper: clear contents
        *
        */
        function clearContents(element){
            while (element.lastChild) {
                element.removeChild(element.lastChild);
            }
        }
        /**
         * Extends a given prototype by merging properties from base into sub.
         *
         * @sub {Object} sub The prototype being overwritten.
         * @base {Object} base The prototype being written.
         *
         * @return {Object} The extended prototype.
         */
        function copy(src) {
            if(null === src){
                return src;
            }
            var cpy;
            if(Array.isArray(src)){
                cpy = [];
                for(var x=0;x<src.length;x+=1){
                    cpy.push(copy(src[x]));
                }
                return cpy;
            }
          
            if(src instanceof Date){
                return new Date(src.getTime());
            }
          
            if(src instanceof RegExp){
                cpy = new RegExp(src.source);
                cpy.global = src.global;
                cpy.ignoreCase = src.ignoreCase;
                cpy.multiline = src.multiline;
                cpy.lastIndex = src.lastIndex;
                return cpy;
            }
            
            if(typeof src === 'object'){
                cpy = {};
                // copy dialog pototype over definition.
                for (var prop in src) {
                    if (src.hasOwnProperty(prop)) {
                        cpy[prop] = copy(src[prop]);
                    }
                }
                return cpy;
            }
            return src;
        }
        /**
          * Helper: destruct the dialog
          *
          */
        function destruct(instance, initialize){
            if(instance.elements){
                //delete the dom and it's references.
                var root = instance.elements.root;
                root.parentNode.removeChild(root);
                delete instance.elements;
                //copy back initial settings.
                instance.settings = copy(instance.__settings);
                //re-reference init function.
                instance.__init = initialize;
                //delete __internal variable to allow re-initialization.
                delete instance.__internal;
            }
        }

        /**
         * Test to check if passive event listeners are supported.
         */
        var IsPassiveSupported = false;
        try {
            var options = Object.defineProperty({}, 'passive', {
                get: function () {
                    IsPassiveSupported = true;
                }
            });
            window.addEventListener('test', options, options);
            window.removeEventListener('test', options, options);
        } catch (e) {}

         /**
         * Removes an event listener
         *
         * @param {HTMLElement} el The EventTarget to register the listenr on.
         * @param {string} event The event type to listen for.
         * @param {Function} handler The function to handle the event.
         * @param {boolean} useCapture Specifices if the event to be dispatched to the registered listener before being dispatched to any EventTarget beneath it in the DOM tree.
         * @param {boolean} passive A Boolean which, if true, indicates that the function specified by listener will never call preventDefault().
         */
        var on = function (el, event, fn, useCapture, passive) {
            el.addEventListener(event, fn, IsPassiveSupported ? { capture: useCapture, passive: passive } : useCapture === true);
        };

        /**
         * Removes an event listener
         *
         * @param {HTMLElement} el The EventTarget to unregister the listenr from.
         * @param {string} event The event type to remove.
         * @param {Function} fn The event handler to remove.
         * @param {boolean} useCapture Specifices if the event to be dispatched to the registered listener before being dispatched to any EventTarget beneath it in the DOM tree.
         * @param {boolean} passive A Boolean which, if true, indicates that the function specified by listener will never call preventDefault().
         */
        var off = function (el, event, fn, useCapture, passive) {
            el.removeEventListener(event, fn, IsPassiveSupported ? { capture: useCapture, passive: passive } : useCapture === true);
        };

        /**
         * Prevent default event from firing
         *
         * @param  {Event} event Event object
         * @return {undefined}

        function prevent ( event ) {
            if ( event ) {
                if ( event.preventDefault ) {
                    event.preventDefault();
                } else {
                    event.returnValue = false;
                }
            }
        }
        */
        var transition = (function () {
            var t, type;
            var supported = false;
            var transitions = {
                'animation'        : 'animationend',
                'OAnimation'       : 'oAnimationEnd oanimationend',
                'msAnimation'      : 'MSAnimationEnd',
                'MozAnimation'     : 'animationend',
                'WebkitAnimation'  : 'webkitAnimationEnd'
            };

            for (t in transitions) {
                if (document.documentElement.style[t] !== undefined) {
                    type = transitions[t];
                    supported = true;
                    break;
                }
            }

            return {
                type: type,
                supported: supported
            };
        }());

        /**
        * Creates event handler delegate that sends the instance as last argument.
        * 
        * @return {Function}    a function wrapper which sends the instance as last argument.
        */
        function delegate(context, method) {
            return function () {
                if (arguments.length > 0) {
                    var args = [];
                    for (var x = 0; x < arguments.length; x += 1) {
                        args.push(arguments[x]);
                    }
                    args.push(context);
                    return method.apply(context, args);
                }
                return method.apply(context, [null, context]);
            };
        }
        /**
        * Helper for creating a dialog close event.
        * 
        * @return {object}
        */
        function createCloseEvent(index, button) {
            return {
                index: index,
                button: button,
                cancel: false
            };
        }
        /**
        * Helper for dispatching events.
        *
        * @param  {string} evenType The type of the event to disptach.
        * @param  {object} instance The dialog instance disptaching the event.
        *
        * @return   {any}   The result of the invoked function.
        */
        function dispatchEvent(eventType, instance) {
            if ( typeof instance.get(eventType) === 'function' ) {
                return instance.get(eventType).call(instance);
            }
        }


        /**
         * Super class for all dialogs
         *
         * @return {Object}		base dialog prototype
         */
        var dialog = (function () {
            var //holds the list of used keys.
                usedKeys = [],
                //dummy variable, used to trigger dom reflow.
                reflow = null,
                //holds body tab index in case it has any.
                tabindex = false,
                //condition for detecting safari
                isSafari = window.navigator.userAgent.indexOf('Safari') > -1 && window.navigator.userAgent.indexOf('Chrome') < 0,
                //dialog building blocks
                templates = {
                    dimmer:'<div class="ajs-dimmer"></div>',
                    /*tab index required to fire click event before body focus*/
                    modal: '<div class="ajs-modal" tabindex="0"></div>',
                    dialog: '<div class="ajs-dialog" tabindex="0"></div>',
                    reset: '<button class="ajs-reset"></button>',
                    commands: '<div class="ajs-commands"><button class="ajs-pin"></button><button class="ajs-maximize"></button><button class="ajs-close"></button></div>',
                    header: '<div class="ajs-header"></div>',
                    body: '<div class="ajs-body"></div>',
                    content: '<div class="ajs-content"></div>',
                    footer: '<div class="ajs-footer"></div>',
                    buttons: { primary: '<div class="ajs-primary ajs-buttons"></div>', auxiliary: '<div class="ajs-auxiliary ajs-buttons"></div>' },
                    button: '<button class="ajs-button"></button>',
                    resizeHandle: '<div class="ajs-handle"></div>',
                },
                //common class names
                classes = {
                    animationIn: 'ajs-in',
                    animationOut: 'ajs-out',
                    base: 'alertify',
                    basic:'ajs-basic',
                    capture: 'ajs-capture',
                    closable:'ajs-closable',
                    fixed: 'ajs-fixed',
                    frameless:'ajs-frameless',
                    hidden: 'ajs-hidden',
                    maximize: 'ajs-maximize',
                    maximized: 'ajs-maximized',
                    maximizable:'ajs-maximizable',
                    modeless: 'ajs-modeless',
                    movable: 'ajs-movable',
                    noSelection: 'ajs-no-selection',
                    noOverflow: 'ajs-no-overflow',
                    noPadding:'ajs-no-padding',
                    pin:'ajs-pin',
                    pinnable:'ajs-pinnable',
                    prefix: 'ajs-',
                    resizable: 'ajs-resizable',
                    restore: 'ajs-restore',
                    shake:'ajs-shake',
                    unpinned:'ajs-unpinned',
                    noTransition:'ajs-no-transition'
                };

            /**
             * Helper: initializes the dialog instance
             * 
             * @return	{Number}	The total count of currently open modals.
             */
            function initialize(instance){
                
                if(!instance.__internal){
                    //invoke preinit global hook
                    alertify.defaults.hooks.preinit(instance);
                    //no need to expose init after this.
                    delete instance.__init;
                  
                    //keep a copy of initial dialog settings
                    if(!instance.__settings){
                        instance.__settings = copy(instance.settings);
                    }
                    
                    //get dialog buttons/focus setup
                    var setup;
                    if(typeof instance.setup === 'function'){
                        setup = instance.setup();
                        setup.options = setup.options  || {};
                        setup.focus = setup.focus  || {};
                    }else{
                        setup = {
                            buttons:[],
                            focus:{
                                element:null,
                                select:false
                            },
                            options:{
                            }
                        };
                    }
                    
                    //initialize hooks object.
                    if(typeof instance.hooks !== 'object'){
                        instance.hooks = {};
                    }

                    //copy buttons defintion
                    var buttonsDefinition = [];
                    if(Array.isArray(setup.buttons)){
                        for(var b=0;b<setup.buttons.length;b+=1){
                            var ref  = setup.buttons[b],
                                cpy = {};
                            for (var i in ref) {
                                if (ref.hasOwnProperty(i)) {
                                    cpy[i] = ref[i];
                                }
                            }
                            buttonsDefinition.push(cpy);
                        }
                    }

                    var internal = instance.__internal = {
                        /**
                         * Flag holding the open state of the dialog
                         * 
                         * @type {Boolean}
                         */
                        isOpen:false,
                        /**
                         * Active element is the element that will receive focus after
                         * closing the dialog. It defaults as the body tag, but gets updated
                         * to the last focused element before the dialog was opened.
                         *
                         * @type {Node}
                         */
                        activeElement:document.body,
                        timerIn:undefined,
                        timerOut:undefined,
                        buttons: buttonsDefinition,
                        focus: setup.focus,
                        options: {
                            title: undefined,
                            modal: undefined,
                            basic:undefined,
                            frameless:undefined,
                            defaultFocusOff:undefined,
                            pinned: undefined,
                            movable: undefined,
                            moveBounded:undefined,
                            resizable: undefined,
                            autoReset: undefined,
                            closable: undefined,
                            closableByDimmer: undefined,
                            invokeOnCloseOff:undefined,
                            maximizable: undefined,
                            startMaximized: undefined,
                            pinnable: undefined,
                            transition: undefined,
                            transitionOff: undefined,
                            padding:undefined,
                            overflow:undefined,
                            onshow:undefined,
                            onclosing:undefined,
                            onclose:undefined,
                            onfocus:undefined,
                            onmove:undefined,
                            onmoved:undefined,
                            onresize:undefined,
                            onresized:undefined,
                            onmaximize:undefined,
                            onmaximized:undefined,
                            onrestore:undefined,
                            onrestored:undefined
                        },
                        resetHandler:undefined,
                        beginMoveHandler:undefined,
                        beginResizeHandler:undefined,
                        bringToFrontHandler:undefined,
                        modalClickHandler:undefined,
                        buttonsClickHandler:undefined,
                        commandsClickHandler:undefined,
                        transitionInHandler:undefined,
                        transitionOutHandler:undefined,
                        destroy:undefined
                    };

                    var elements = {};
                    //root node
                    elements.root = document.createElement('div');
                    //prevent FOUC in case of async styles loading.
                    elements.root.style.display = 'none';
                    elements.root.className = classes.base + ' ' + classes.hidden + ' ';

                    elements.root.innerHTML = templates.dimmer + templates.modal;
                    
                    //dimmer
                    elements.dimmer = elements.root.firstChild;

                    //dialog
                    elements.modal = elements.root.lastChild;
                    elements.modal.innerHTML = templates.dialog;
                    elements.dialog = elements.modal.firstChild;
                    elements.dialog.innerHTML = templates.reset + templates.commands + templates.header + templates.body + templates.footer + templates.resizeHandle + templates.reset;

                    //reset links
                    elements.reset = [];
                    elements.reset.push(elements.dialog.firstChild);
                    elements.reset.push(elements.dialog.lastChild);
                    
                    //commands
                    elements.commands = {};
                    elements.commands.container = elements.reset[0].nextSibling;
                    elements.commands.pin = elements.commands.container.firstChild;
                    elements.commands.maximize = elements.commands.pin.nextSibling;
                    elements.commands.close = elements.commands.maximize.nextSibling;
                    
                    //header
                    elements.header = elements.commands.container.nextSibling;

                    //body
                    elements.body = elements.header.nextSibling;
                    elements.body.innerHTML = templates.content;
                    elements.content = elements.body.firstChild;

                    //footer
                    elements.footer = elements.body.nextSibling;
                    elements.footer.innerHTML = templates.buttons.auxiliary + templates.buttons.primary;
                    
                    //resize handle
                    elements.resizeHandle = elements.footer.nextSibling;

                    //buttons
                    elements.buttons = {};
                    elements.buttons.auxiliary = elements.footer.firstChild;
                    elements.buttons.primary = elements.buttons.auxiliary.nextSibling;
                    elements.buttons.primary.innerHTML = templates.button;
                    elements.buttonTemplate = elements.buttons.primary.firstChild;
                    //remove button template
                    elements.buttons.primary.removeChild(elements.buttonTemplate);
                                   
                    for(var x=0; x < instance.__internal.buttons.length; x+=1) {
                        var button = instance.__internal.buttons[x];
                        
                        // add to the list of used keys.
                        if(usedKeys.indexOf(button.key) < 0){
                            usedKeys.push(button.key);
                        }

                        button.element = elements.buttonTemplate.cloneNode();
                        button.element.innerHTML = button.text;
                        if(typeof button.className === 'string' &&  button.className !== ''){
                            addClass(button.element, button.className);
                        }
                        for(var key in button.attrs){
                            if(key !== 'className' && button.attrs.hasOwnProperty(key)){
                                button.element.setAttribute(key, button.attrs[key]);
                            }
                        }
                        if(button.scope === 'auxiliary'){
                            elements.buttons.auxiliary.appendChild(button.element);
                        }else{
                            elements.buttons.primary.appendChild(button.element);
                        }
                    }
                    //make elements pubic
                    instance.elements = elements;
                    
                    //save event handlers delegates
                    internal.resetHandler = delegate(instance, onReset);
                    internal.beginMoveHandler = delegate(instance, beginMove);
                    internal.beginResizeHandler = delegate(instance, beginResize);
                    internal.bringToFrontHandler = delegate(instance, bringToFront);
                    internal.modalClickHandler = delegate(instance, modalClickHandler);
                    internal.buttonsClickHandler = delegate(instance, buttonsClickHandler);
                    internal.commandsClickHandler = delegate(instance, commandsClickHandler);
                    internal.transitionInHandler = delegate(instance, handleTransitionInEvent);
                    internal.transitionOutHandler = delegate(instance, handleTransitionOutEvent);

                    //settings
                    for(var opKey in internal.options){
                        if(setup.options[opKey] !== undefined){
                            // if found in user options
                            instance.set(opKey, setup.options[opKey]);
                        }else if(alertify.defaults.hasOwnProperty(opKey)) {
                            // else if found in defaults options
                            instance.set(opKey, alertify.defaults[opKey]);
                        }else if(opKey === 'title' ) {
                            // else if title key, use alertify.defaults.glossary
                            instance.set(opKey, alertify.defaults.glossary[opKey]);
                        }
                    }

                    // allow dom customization
                    if(typeof instance.build === 'function'){
                        instance.build();
                    }

                    //invoke postinit global hook
                    alertify.defaults.hooks.postinit(instance);
                }

                //add to the end of the DOM tree.
                document.body.appendChild(instance.elements.root);
            }

            /**
             * Helper: maintains scroll position
             *
             */
            var scrollX, scrollY;
            function saveScrollPosition(){
                scrollX = getScrollLeft();
                scrollY = getScrollTop();
            }
            function restoreScrollPosition(){
                window.scrollTo(scrollX, scrollY);
            }

            /**
             * Helper: adds/removes no-overflow class from body
             *
             */
            function ensureNoOverflow(){
                var requiresNoOverflow = 0;
                for(var x=0;x<openDialogs.length;x+=1){
                    var instance = openDialogs[x];
                    if(instance.isModal() || instance.isMaximized()){
                        requiresNoOverflow+=1;
                    }
                }
                if(requiresNoOverflow === 0 && document.body.className.indexOf(classes.noOverflow) >= 0){
                    //last open modal or last maximized one
                    removeClass(document.body, classes.noOverflow);
                    preventBodyShift(false);
                }else if(requiresNoOverflow > 0 && document.body.className.indexOf(classes.noOverflow) < 0){
                    //first open modal or first maximized one
                    preventBodyShift(true);
                    addClass(document.body, classes.noOverflow);
                }
            }
            var top = '', topScroll = 0;
            /**
             * Helper: prevents body shift.
             *
             */
            function preventBodyShift(add){
                if(alertify.defaults.preventBodyShift){
                    if(add && document.documentElement.scrollHeight > document.documentElement.clientHeight ){//&& openDialogs[openDialogs.length-1].elements.dialog.clientHeight <= document.documentElement.clientHeight){
                        topScroll = scrollY;
                        top = window.getComputedStyle(document.body).top;
                        addClass(document.body, classes.fixed);
                        document.body.style.top = -scrollY + 'px';
                    } else if(!add) {
                        scrollY = topScroll;
                        document.body.style.top = top;
                        removeClass(document.body, classes.fixed);
                        restoreScrollPosition();
                    }
                }
            }
    		
            /**
             * Sets the name of the transition used to show/hide the dialog
             * 
             * @param {Object} instance The dilog instance.
             *
             */
            function updateTransition(instance, value, oldValue){
                if(typeof oldValue === 'string'){
                    removeClass(instance.elements.root,classes.prefix +  oldValue);
                }
                addClass(instance.elements.root, classes.prefix + value);
                reflow = instance.elements.root.offsetWidth;
            }

            /**
             * Toggles the dialog no transition 
             *
             * @param {Object} instance The dilog instance.
             *
             * @return {undefined}
             */
            function updateTransitionOff(instance){
                if (instance.get('transitionOff')) {
                    // add class
                    addClass(instance.elements.root, classes.noTransition);
                } else {
                    // remove class
                    removeClass(instance.elements.root, classes.noTransition);
                }
            }

            /**
             * Toggles the dialog display mode
             *
             * @param {Object} instance The dilog instance.
             *
             * @return {undefined}
             */
            function updateDisplayMode(instance){
                if(instance.get('modal')){

                    //make modal
                    removeClass(instance.elements.root, classes.modeless);

                    //only if open
                    if(instance.isOpen()){
                        unbindModelessEvents(instance);

                        //in case a pinned modless dialog was made modal while open.
                        updateAbsPositionFix(instance);

                        ensureNoOverflow();
                    }
                }else{
                    //make modelss
                    addClass(instance.elements.root, classes.modeless);

                    //only if open
                    if(instance.isOpen()){
                        bindModelessEvents(instance);

                        //in case pin/unpin was called while a modal is open
                        updateAbsPositionFix(instance);

                        ensureNoOverflow();
                    }
                }
            }

            /**
             * Toggles the dialog basic view mode 
             *
             * @param {Object} instance The dilog instance.
             *
             * @return {undefined}
             */
            function updateBasicMode(instance){
                if (instance.get('basic')) {
                    // add class
                    addClass(instance.elements.root, classes.basic);
                } else {
                    // remove class
                    removeClass(instance.elements.root, classes.basic);
                }
            }

            /**
             * Toggles the dialog frameless view mode 
             *
             * @param {Object} instance The dilog instance.
             *
             * @return {undefined}
             */
            function updateFramelessMode(instance){
                if (instance.get('frameless')) {
                    // add class
                    addClass(instance.elements.root, classes.frameless);
                } else {
                    // remove class
                    removeClass(instance.elements.root, classes.frameless);
                }
            }
    		
            /**
             * Helper: Brings the modeless dialog to front, attached to modeless dialogs.
             *
             * @param {Event} event Focus event
             * @param {Object} instance The dilog instance.
             *
             * @return {undefined}
             */
            function bringToFront(event, instance){
                
                // Do not bring to front if preceeded by an open modal
                var index = openDialogs.indexOf(instance);
                for(var x=index+1;x<openDialogs.length;x+=1){
                    if(openDialogs[x].isModal()){
                        return;
                    }
                }
    			
                // Bring to front by making it the last child.
                if(document.body.lastChild !== instance.elements.root){
                    document.body.appendChild(instance.elements.root);
                    //also make sure its at the end of the list
                    openDialogs.splice(openDialogs.indexOf(instance),1);
                    openDialogs.push(instance);
                    setFocus(instance);
                }
    			
                return false;
            }
    		
            /**
             * Helper: reflects dialogs options updates
             *
             * @param {Object} instance The dilog instance.
             * @param {String} option The updated option name.
             *
             * @return	{undefined}	
             */
            function optionUpdated(instance, option, oldValue, newValue){
                switch(option){
                case 'title':
                    instance.setHeader(newValue);
                    break;
                case 'modal':
                    updateDisplayMode(instance);
                    break;
                case 'basic':
                    updateBasicMode(instance);
                    break;
                case 'frameless':
                    updateFramelessMode(instance);
                    break;
                case 'pinned':
                    updatePinned(instance);
                    break;
                case 'closable':
                    updateClosable(instance);
                    break;
                case 'maximizable':
                    updateMaximizable(instance);
                    break;
                case 'pinnable':
                    updatePinnable(instance);
                    break;
                case 'movable':
                    updateMovable(instance);
                    break;
                case 'resizable':
                    updateResizable(instance);
                    break;
                case 'padding':
                    if(newValue){
                        removeClass(instance.elements.root, classes.noPadding);
                    }else if(instance.elements.root.className.indexOf(classes.noPadding) < 0){
                        addClass(instance.elements.root, classes.noPadding);
                    }
                    break;
                case 'overflow':
                    if(newValue){
                        removeClass(instance.elements.root, classes.noOverflow);
                    }else if(instance.elements.root.className.indexOf(classes.noOverflow) < 0){
                        addClass(instance.elements.root, classes.noOverflow);
                    }
                    break;
                case 'transition':
                    updateTransition(instance,newValue, oldValue);
                    break;
                case 'transitionOff':
                    updateTransitionOff(instance);
                    break;
                }

                // internal on option updated event
                if(typeof instance.hooks.onupdate === 'function'){
                    instance.hooks.onupdate.call(instance, option, oldValue, newValue);
                }
            }
    		
            /**
             * Helper: reflects dialogs options updates
             *
             * @param {Object} instance The dilog instance.
             * @param {Object} obj The object to set/get a value on/from.
             * @param {Function} callback The callback function to call if the key was found.
             * @param {String|Object} key A string specifying a propery name or a collection of key value pairs.
             * @param {Object} value Optional, the value associated with the key (in case it was a string).
             * @param {String} option The updated option name.
             *
             * @return	{Object} result object 
             *	The result objects has an 'op' property, indicating of this is a SET or GET operation.
             *		GET: 
             *		- found: a flag indicating if the key was found or not.
             *		- value: the property value.
             *		SET:
             *		- items: a list of key value pairs of the properties being set.
             *				each contains:
             *					- found: a flag indicating if the key was found or not.
             *					- key: the property key.
             *					- value: the property value.
             */
            function update(instance, obj, callback, key, value){
                var result = {op:undefined, items: [] };
                if(typeof value === 'undefined' && typeof key === 'string') {
                    //get
                    result.op = 'get';
                    if(obj.hasOwnProperty(key)){
                        result.found = true;
                        result.value = obj[key];
                    }else{
                        result.found = false;
                        result.value = undefined;
                    }
                }
                else
                {
                    var old;
                    //set
                    result.op = 'set';
                    if(typeof key === 'object'){
                        //set multiple
                        var args = key;
                        for (var prop in args) {
                            if (obj.hasOwnProperty(prop)) {
                                if(obj[prop] !== args[prop]){
                                    old = obj[prop];
                                    obj[prop] = args[prop];
                                    callback.call(instance,prop, old, args[prop]);
                                }
                                result.items.push({ 'key': prop, 'value': args[prop], 'found':true});
                            }else{
                                result.items.push({ 'key': prop, 'value': args[prop], 'found':false});
                            }
                        }
                    } else if (typeof key === 'string'){
                        //set single
                        if (obj.hasOwnProperty(key)) {
                            if(obj[key] !== value){
                                old  = obj[key];
                                obj[key] = value;
                                callback.call(instance,key, old, value);
                            }
                            result.items.push({'key': key, 'value': value , 'found':true});

                        }else{
                            result.items.push({'key': key, 'value': value , 'found':false});
                        }
                    } else {
                        //invalid params
                        throw new Error('args must be a string or object');
                    }
                }
                return result;
            }


            /**
             * Triggers a close event.
             *
             * @param {Object} instance	The dilog instance.
             * 
             * @return {undefined}
             */
            function triggerClose(instance) {
                var found;
                triggerCallback(instance, function (button) {
                    return found = instance.get('invokeOnCloseOff') !== true && (button.invokeOnClose === true);
                });
                //none of the buttons registered as onclose callback
                //close the dialog
                if (!found && instance.isOpen()) {
                    instance.close();
                }
            }

            /**
             * Dialogs commands event handler, attached to the dialog commands element.
             *
             * @param {Event} event	DOM event object.
             * @param {Object} instance	The dilog instance.
             * 
             * @return {undefined}
             */
            function commandsClickHandler(event, instance) {
                var target = event.srcElement || event.target;
                switch (target) {
                case instance.elements.commands.pin:
                    if (!instance.isPinned()) {
                        pin(instance);
                    } else {
                        unpin(instance);
                    }
                    break;
                case instance.elements.commands.maximize:
                    if (!instance.isMaximized()) {
                        maximize(instance);
                    } else {
                        restore(instance);
                    }
                    break;
                case instance.elements.commands.close:
                    triggerClose(instance);
                    break;
                }
                return false;
            }

            /**
             * Helper: pins the modeless dialog.
             *
             * @param {Object} instance	The dialog instance.
             * 
             * @return {undefined}
             */
            function pin(instance) {
                //pin the dialog
                instance.set('pinned', true);
            }

            /**
             * Helper: unpins the modeless dialog.
             *
             * @param {Object} instance	The dilog instance.
             * 
             * @return {undefined}
             */
            function unpin(instance) {
                //unpin the dialog 
                instance.set('pinned', false);
            }


            /**
             * Helper: enlarges the dialog to fill the entire screen.
             *
             * @param {Object} instance	The dilog instance.
             * 
             * @return {undefined}
             */
            function maximize(instance) {
                // allow custom `onmaximize` method
                dispatchEvent('onmaximize', instance);
                //maximize the dialog 
                addClass(instance.elements.root, classes.maximized);
                if (instance.isOpen()) {
                    ensureNoOverflow();
                }
                // allow custom `onmaximized` method
                dispatchEvent('onmaximized', instance);
            }

            /**
             * Helper: returns the dialog to its former size.
             *
             * @param {Object} instance	The dilog instance.
             * 
             * @return {undefined}
             */
            function restore(instance) {
                // allow custom `onrestore` method
                dispatchEvent('onrestore', instance);
                //maximize the dialog 
                removeClass(instance.elements.root, classes.maximized);
                if (instance.isOpen()) {
                    ensureNoOverflow();
                }
                // allow custom `onrestored` method
                dispatchEvent('onrestored', instance);
            }

            /**
             * Show or hide the maximize box.
             *
             * @param {Object} instance The dilog instance.
             * @param {Boolean} on True to add the behavior, removes it otherwise.
             *
             * @return {undefined}
             */
            function updatePinnable(instance) {
                if (instance.get('pinnable')) {
                    // add class
                    addClass(instance.elements.root, classes.pinnable);
                } else {
                    // remove class
                    removeClass(instance.elements.root, classes.pinnable);
                }
            }

            /**
             * Helper: Fixes the absolutly positioned modal div position.
             *
             * @param {Object} instance The dialog instance.
             *
             * @return {undefined}
             */
            function addAbsPositionFix(instance) {
                var scrollLeft = getScrollLeft();
                instance.elements.modal.style.marginTop = getScrollTop() + 'px';
                instance.elements.modal.style.marginLeft = scrollLeft + 'px';
                instance.elements.modal.style.marginRight = (-scrollLeft) + 'px';
            }

            /**
             * Helper: Removes the absolutly positioned modal div position fix.
             *
             * @param {Object} instance The dialog instance.
             *
             * @return {undefined}
             */
            function removeAbsPositionFix(instance) {
                var marginTop = parseInt(instance.elements.modal.style.marginTop, 10);
                var marginLeft = parseInt(instance.elements.modal.style.marginLeft, 10);
                instance.elements.modal.style.marginTop = '';
                instance.elements.modal.style.marginLeft = '';
                instance.elements.modal.style.marginRight = '';

                if (instance.isOpen()) {
                    var top = 0,
                        left = 0
                    ;
                    if (instance.elements.dialog.style.top !== '') {
                        top = parseInt(instance.elements.dialog.style.top, 10);
                    }
                    instance.elements.dialog.style.top = (top + (marginTop - getScrollTop())) + 'px';

                    if (instance.elements.dialog.style.left !== '') {
                        left = parseInt(instance.elements.dialog.style.left, 10);
                    }
                    instance.elements.dialog.style.left = (left + (marginLeft - getScrollLeft())) + 'px';
                }
            }
            /**
             * Helper: Adds/Removes the absolutly positioned modal div position fix based on its pinned setting.
             *
             * @param {Object} instance The dialog instance.
             *
             * @return {undefined}
             */
            function updateAbsPositionFix(instance) {
                // if modeless and unpinned add fix
                if (!instance.get('modal') && !instance.get('pinned')) {
                    addAbsPositionFix(instance);
                } else {
                    removeAbsPositionFix(instance);
                }
            }
            /**
             * Toggles the dialog position lock | modeless only.
             *
             * @param {Object} instance The dilog instance.
             * @param {Boolean} on True to make it modal, false otherwise.
             *
             * @return {undefined}
             */
            function updatePinned(instance) {
                if (instance.get('pinned')) {
                    removeClass(instance.elements.root, classes.unpinned);
                    if (instance.isOpen()) {
                        removeAbsPositionFix(instance);
                    }
                } else {
                    addClass(instance.elements.root, classes.unpinned);
                    if (instance.isOpen() && !instance.isModal()) {
                        addAbsPositionFix(instance);
                    }
                }
            }

            /**
             * Show or hide the maximize box.
             *
             * @param {Object} instance The dilog instance.
             * @param {Boolean} on True to add the behavior, removes it otherwise.
             *
             * @return {undefined}
             */
            function updateMaximizable(instance) {
                if (instance.get('maximizable')) {
                    // add class
                    addClass(instance.elements.root, classes.maximizable);
                } else {
                    // remove class
                    removeClass(instance.elements.root, classes.maximizable);
                }
            }

            /**
             * Show or hide the close box.
             *
             * @param {Object} instance The dilog instance.
             * @param {Boolean} on True to add the behavior, removes it otherwise.
             *
             * @return {undefined}
             */
            function updateClosable(instance) {
                if (instance.get('closable')) {
                    // add class
                    addClass(instance.elements.root, classes.closable);
                    bindClosableEvents(instance);
                } else {
                    // remove class
                    removeClass(instance.elements.root, classes.closable);
                    unbindClosableEvents(instance);
                }
            }

            
            var cancelClick = false,// flag to cancel click event if already handled by end resize event (the mousedown, mousemove, mouseup sequence fires a click event.).
                modalClickHandlerTS=0 // stores last click timestamp to prevent executing the handler twice on double click.
                ;

            /**
             * Helper: closes the modal dialog when clicking the modal
             *
             * @param {Event} event	DOM event object.
             * @param {Object} instance The dilog instance.
             *
             * @return {undefined}
             */
            function modalClickHandler(event, instance) {
                if(event.timeStamp - modalClickHandlerTS > 200 && (modalClickHandlerTS = event.timeStamp) && !cancelClick){
                    var target = event.srcElement || event.target;
                    if (instance.get('closableByDimmer') === true && target === instance.elements.modal) {
                        triggerClose(instance);
                    }
                }
                cancelClick = false;
            }

            // stores last call timestamp to prevent triggering the callback twice.
            var callbackTS = 0;
            // flag to cancel keyup event if already handled by click event (pressing Enter on a focusted button).
            var cancelKeyup = false;
            /** 
             * Helper: triggers a button callback
             *
             * @param {Object}		The dilog instance.
             * @param {Function}	Callback to check which button triggered the event.
             *
             * @return {undefined}
             */
            function triggerCallback(instance, check) {
                if(Date.now() - callbackTS > 200 && (callbackTS = Date.now())){
                    for (var idx = 0; idx < instance.__internal.buttons.length; idx += 1) {
                        var button = instance.__internal.buttons[idx];
                        if (!button.element.disabled && check(button)) {
                            var closeEvent = createCloseEvent(idx, button);
                            if (typeof instance.callback === 'function') {
                                instance.callback.apply(instance, [closeEvent]);
                            }
                            //close the dialog only if not canceled.
                            if (closeEvent.cancel === false) {
                                instance.close();
                            }
                            break;
                        }
                    }
                }
            }

            /**
             * Clicks event handler, attached to the dialog footer.
             *
             * @param {Event}		DOM event object.
             * @param {Object}		The dilog instance.
             * 
             * @return {undefined}
             */
            function buttonsClickHandler(event, instance) {
                var target = event.srcElement || event.target;
                triggerCallback(instance, function (button) {
                    // if this button caused the click, cancel keyup event
                    return button.element === target && (cancelKeyup = true);
                });
            }

            /**
             * Keyup event handler, attached to the document.body
             *
             * @param {Event}		DOM event object.
             * @param {Object}		The dilog instance.
             * 
             * @return {undefined}
             */
            function keyupHandler(event) {
                //hitting enter while button has focus will trigger keyup too.
                //ignore if handled by clickHandler
                if (cancelKeyup) {
                    cancelKeyup = false;
                    return;
                }
                var instance = openDialogs[openDialogs.length - 1];
                var keyCode = event.keyCode;
                if (instance.__internal.buttons.length === 0 && keyCode === keys.ESC && instance.get('closable') === true) {
                    triggerClose(instance);
                    return false;
                }else if (usedKeys.indexOf(keyCode) > -1) {
                    triggerCallback(instance, function (button) {
                        return button.key === keyCode;
                    });
                    return false;
                }
            }
            /**
            * Keydown event handler, attached to the document.body
            *
            * @param {Event}		DOM event object.
            * @param {Object}		The dilog instance.
            * 
            * @return {undefined}
            */
            function keydownHandler(event) {
                var instance = openDialogs[openDialogs.length - 1];
                var keyCode = event.keyCode;
                if (keyCode === keys.LEFT || keyCode === keys.RIGHT) {
                    var buttons = instance.__internal.buttons;
                    for (var x = 0; x < buttons.length; x += 1) {
                        if (document.activeElement === buttons[x].element) {
                            switch (keyCode) {
                            case keys.LEFT:
                                buttons[(x || buttons.length) - 1].element.focus();
                                return;
                            case keys.RIGHT:
                                buttons[(x + 1) % buttons.length].element.focus();
                                return;
                            }
                        }
                    }
                }else if (keyCode < keys.F12 + 1 && keyCode > keys.F1 - 1 && usedKeys.indexOf(keyCode) > -1) {
                    event.preventDefault();
                    event.stopPropagation();
                    triggerCallback(instance, function (button) {
                        return button.key === keyCode;
                    });
                    return false;
                }
            }


            /**
             * Sets focus to proper dialog element
             *
             * @param {Object} instance The dilog instance.
             * @param {Node} [resetTarget=undefined] DOM element to reset focus to.
             *
             * @return {undefined}
             */
            function setFocus(instance, resetTarget) {
                // reset target has already been determined.
                if (resetTarget) {
                    resetTarget.focus();
                } else {
                    // current instance focus settings
                    var focus = instance.__internal.focus;
                    // the focus element.
                    var element = focus.element;

                    switch (typeof focus.element) {
                    // a number means a button index
                    case 'number':
                        if (instance.__internal.buttons.length > focus.element) {
                            //in basic view, skip focusing the buttons.
                            if (instance.get('basic') === true) {
                                element = instance.elements.reset[0];
                            } else {
                                element = instance.__internal.buttons[focus.element].element;
                            }
                        }
                        break;
                    // a string means querySelector to select from dialog body contents.
                    case 'string':
                        element = instance.elements.body.querySelector(focus.element);
                        break;
                    // a function should return the focus element.
                    case 'function':
                        element = focus.element.call(instance);
                        break;
                    }

                    // if no focus element, default to first reset element.
                    if (instance.get('defaultFocusOff') === true || ((typeof element === 'undefined' || element === null) && instance.__internal.buttons.length === 0)) {
                        element = instance.elements.reset[0];
                    }
                    // focus
                    if (element && element.focus) {
                        element.focus();
                        // if selectable
                        if (focus.select && element.select) {
                            element.select();
                        }
                    }
                }
            }

            /**
             * Focus event handler, attached to document.body and dialogs own reset links.
             * handles the focus for modal dialogs only.
             *
             * @param {Event} event DOM focus event object.
             * @param {Object} instance The dilog instance.
             *
             * @return {undefined}
             */
            function onReset(event, instance) {

                // should work on last modal if triggered from document.body 
                if (!instance) {
                    for (var x = openDialogs.length - 1; x > -1; x -= 1) {
                        if (openDialogs[x].isModal()) {
                            instance = openDialogs[x];
                            break;
                        }
                    }
                }

                if(instance) {
                    // if modal
                    if (instance.isModal()) {
                        // determine reset target to enable forward/backward tab cycle.
                        var firstReset = instance.elements.reset[0],
                            lastReset = instance.elements.reset[1],
                            lastFocusedElement = event.relatedTarget,
                            within = instance.elements.root.contains(lastFocusedElement),
                            target = event.srcElement || event.target,
                            resetTarget;

                        //if the previous focused element element was outside the modal do nthing
                        if(  /*first show */
                            (target === firstReset && !within) ||
                             /*focus cycle */
                            (target === lastReset && lastFocusedElement === firstReset)){
                            return;
                        }else if(target === lastReset || target === document.body){
                            resetTarget = firstReset;
                        }else if(target === firstReset && lastFocusedElement === lastReset){
                            resetTarget = findTabbable(instance);
                        }else if(target === firstReset && within){
                            resetTarget = findTabbable(instance, true);
                        }
                        // focus
                        setFocus(instance, resetTarget);
                    }
                }
            }
            function findTabbable(instance, last){
                var tabbables = [].slice.call(instance.elements.dialog.querySelectorAll(defaults.tabbable));
                if(last){
                    tabbables.reverse();
                }
                for(var x=0;x<tabbables.length;x+=1){
                    var tabbable = tabbables[x];
                    //check if visible
                    if(!!(tabbable.offsetParent || tabbable.offsetWidth || tabbable.offsetHeight || tabbable.getClientRects().length)){
                        return tabbable;
                    }
                }
            }
            function recycleTab(event) {
                var instance = openDialogs[openDialogs.length - 1];
                if (instance && event.shiftKey && event.keyCode === keys.TAB) {
                    instance.elements.reset[1].focus();
                }
            }
            /**
             * Transition in transitionend event handler. 
             *
             * @param {Event}		TransitionEnd event object.
             * @param {Object}		The dilog instance.
             *
             * @return {undefined}
             */
            function handleTransitionInEvent(event, instance) {
                // clear the timer
                clearTimeout(instance.__internal.timerIn);

                // once transition is complete, set focus
                setFocus(instance);

                // allow handling key up after transition ended.
                cancelKeyup = false;

                // allow custom `onfocus` method
                dispatchEvent('onfocus', instance);

                // unbind the event
                off(instance.elements.dialog, transition.type, instance.__internal.transitionInHandler);

                removeClass(instance.elements.root, classes.animationIn);
            }

            /**
             * Transition out transitionend event handler. 
             *
             * @param {Event}		TransitionEnd event object.
             * @param {Object}		The dilog instance.
             *
             * @return {undefined}
             */
            function handleTransitionOutEvent(event, instance) {
                // clear the timer
                clearTimeout(instance.__internal.timerOut);
                // unbind the event
                off(instance.elements.dialog, transition.type, instance.__internal.transitionOutHandler);

                // reset move updates
                resetMove(instance);
                // reset resize updates
                resetResize(instance);

                // restore if maximized
                if (instance.isMaximized() && !instance.get('startMaximized')) {
                    restore(instance);
                }

                //destory the instance
                if (typeof instance.__internal.destroy === 'function') {
                    instance.__internal.destroy.apply(instance);
                }
            }
            /* Controls moving a dialog around */
            //holde the current moving instance
            var movable = null,
                //holds the current X offset when move starts
                offsetX = 0,
                //holds the current Y offset when move starts
                offsetY = 0,
                xProp = 'pageX',
                yProp = 'pageY',
                bounds = null,
                refreshTop = false,
                moveDelegate = null
            ;

            /**
             * Helper: sets the element top/left coordinates
             *
             * @param {Event} event	DOM event object.
             * @param {Node} element The element being moved.
             * 
             * @return {undefined}
             */
            function moveElement(event, element) {
                var left = (event[xProp] - offsetX),
                    top  = (event[yProp] - offsetY);

                if(refreshTop){
                    top -= document.body.scrollTop;
                }
               
                element.style.left = left + 'px';
                element.style.top = top + 'px';
               
            }
            /**
             * Helper: sets the element top/left coordinates within screen bounds
             *
             * @param {Event} event	DOM event object.
             * @param {Node} element The element being moved.
             * 
             * @return {undefined}
             */
            function moveElementBounded(event, element) {
                var left = (event[xProp] - offsetX),
                    top  = (event[yProp] - offsetY);

                if(refreshTop){
                    top -= document.body.scrollTop;
                }
                
                element.style.left = Math.min(bounds.maxLeft, Math.max(bounds.minLeft, left)) + 'px';
                if(refreshTop){
                    element.style.top = Math.min(bounds.maxTop, Math.max(bounds.minTop, top)) + 'px';
                }else{
                    element.style.top = Math.max(bounds.minTop, top) + 'px';
                }
            }
                

            /**
             * Triggers the start of a move event, attached to the header element mouse down event.
             * Adds no-selection class to the body, disabling selection while moving.
             *
             * @param {Event} event	DOM event object.
             * @param {Object} instance The dilog instance.
             * 
             * @return {Boolean} false
             */
            function beginMove(event, instance) {
                if (resizable === null && !instance.isMaximized() && instance.get('movable')) {
                    var eventSrc, left=0, top=0;
                    if (event.type === 'touchstart') {
                        event.preventDefault();
                        eventSrc = event.targetTouches[0];
                        xProp = 'clientX';
                        yProp = 'clientY';
                    } else if (event.button === 0) {
                        eventSrc = event;
                    }

                    if (eventSrc) {

                        var element = instance.elements.dialog;
                        addClass(element, classes.capture);

                        if (element.style.left) {
                            left = parseInt(element.style.left, 10);
                        }

                        if (element.style.top) {
                            top = parseInt(element.style.top, 10);
                        }
                        
                        offsetX = eventSrc[xProp] - left;
                        offsetY = eventSrc[yProp] - top;

                        if(instance.isModal()){
                            offsetY += instance.elements.modal.scrollTop;
                        }else if(instance.isPinned()){
                            offsetY -= document.body.scrollTop;
                        }
                        
                        if(instance.get('moveBounded')){
                            var current = element,
                                offsetLeft = -left,
                                offsetTop = -top;
                            
                            //calc offset
                            do {
                                offsetLeft += current.offsetLeft;
                                offsetTop += current.offsetTop;
                            } while (current = current.offsetParent);
                            
                            bounds = {
                                maxLeft : offsetLeft,
                                minLeft : -offsetLeft,
                                maxTop  : document.documentElement.clientHeight - element.clientHeight - offsetTop,
                                minTop  : -offsetTop
                            };
                            moveDelegate = moveElementBounded;
                        }else{
                            bounds = null;
                            moveDelegate = moveElement;
                        }
                        
                        // allow custom `onmove` method
                        dispatchEvent('onmove', instance);

                        refreshTop = !instance.isModal() && instance.isPinned();
                        movable = instance;
                        moveDelegate(eventSrc, element);
                        addClass(document.body, classes.noSelection);
                        return false;
                    }
                }
            }

            /**
             * The actual move handler,  attached to document.body mousemove event.
             *
             * @param {Event} event	DOM event object.
             * 
             * @return {undefined}
             */
            function move(event) {
                if (movable) {
                    var eventSrc;
                    if (event.type === 'touchmove') {
                        event.preventDefault();
                        eventSrc = event.targetTouches[0];
                    } else if (event.button === 0) {
                        eventSrc = event;
                    }
                    if (eventSrc) {
                        moveDelegate(eventSrc, movable.elements.dialog);
                    }
                }
            }

            /**
             * Triggers the end of a move event,  attached to document.body mouseup event.
             * Removes no-selection class from document.body, allowing selection.
             *
             * @return {undefined}
             */
            function endMove() {
                if (movable) {
                    var instance = movable;
                    movable = bounds = null;
                    removeClass(document.body, classes.noSelection);
                    removeClass(instance.elements.dialog, classes.capture);
                    // allow custom `onmoved` method
                    dispatchEvent('onmoved', instance);
                }
            }

            /**
             * Resets any changes made by moving the element to its original state,
             *
             * @param {Object} instance The dilog instance.
             *
             * @return {undefined}
             */
            function resetMove(instance) {
                movable = null;
                var element = instance.elements.dialog;
                element.style.left = element.style.top = '';
            }

            /**
             * Updates the dialog move behavior.
             *
             * @param {Object} instance The dilog instance.
             * @param {Boolean} on True to add the behavior, removes it otherwise.
             *
             * @return {undefined}
             */
            function updateMovable(instance) {
                if (instance.get('movable')) {
                    // add class
                    addClass(instance.elements.root, classes.movable);
                    if (instance.isOpen()) {
                        bindMovableEvents(instance);
                    }
                } else {

                    //reset
                    resetMove(instance);
                    // remove class
                    removeClass(instance.elements.root, classes.movable);
                    if (instance.isOpen()) {
                        unbindMovableEvents(instance);
                    }
                }
            }

            /* Controls moving a dialog around */
            //holde the current instance being resized		
            var resizable = null,
                //holds the staring left offset when resize starts.
                startingLeft = Number.Nan,
                //holds the staring width when resize starts.
                startingWidth = 0,
                //holds the initial width when resized for the first time.
                minWidth = 0,
                //holds the offset of the resize handle.
                handleOffset = 0
            ;

            /**
             * Helper: sets the element width/height and updates left coordinate if neccessary.
             *
             * @param {Event} event	DOM mousemove event object.
             * @param {Node} element The element being moved.
             * @param {Boolean} pinned A flag indicating if the element being resized is pinned to the screen.
             * 
             * @return {undefined}
             */
            function resizeElement(event, element, pageRelative) {

                //calculate offsets from 0,0
                var current = element;
                var offsetLeft = 0;
                var offsetTop = 0;
                do {
                    offsetLeft += current.offsetLeft;
                    offsetTop += current.offsetTop;
                } while (current = current.offsetParent);

                // determine X,Y coordinates.
                var X, Y;
                if (pageRelative === true) {
                    X = event.pageX;
                    Y = event.pageY;
                } else {
                    X = event.clientX;
                    Y = event.clientY;
                }
                // rtl handling
                var isRTL = isRightToLeft();
                if (isRTL) {
                    // reverse X 
                    X = document.body.offsetWidth - X;
                    // if has a starting left, calculate offsetRight
                    if (!isNaN(startingLeft)) {
                        offsetLeft = document.body.offsetWidth - offsetLeft - element.offsetWidth;
                    }
                }

                // set width/height
                element.style.height = (Y - offsetTop + handleOffset) + 'px';
                element.style.width = (X - offsetLeft + handleOffset) + 'px';

                // if the element being resized has a starting left, maintain it.
                // the dialog is centered, divide by half the offset to maintain the margins.
                if (!isNaN(startingLeft)) {
                    var diff = Math.abs(element.offsetWidth - startingWidth) * 0.5;
                    if (isRTL) {
                        //negate the diff, why?
                        //when growing it should decrease left
                        //when shrinking it should increase left
                        diff *= -1;
                    }
                    if (element.offsetWidth > startingWidth) {
                        //growing
                        element.style.left = (startingLeft + diff) + 'px';
                    } else if (element.offsetWidth >= minWidth) {
                        //shrinking
                        element.style.left = (startingLeft - diff) + 'px';
                    }
                }
            }

            /**
             * Triggers the start of a resize event, attached to the resize handle element mouse down event.
             * Adds no-selection class to the body, disabling selection while moving.
             *
             * @param {Event} event	DOM event object.
             * @param {Object} instance The dilog instance.
             * 
             * @return {Boolean} false
             */
            function beginResize(event, instance) {
                if (!instance.isMaximized()) {
                    var eventSrc;
                    if (event.type === 'touchstart') {
                        event.preventDefault();
                        eventSrc = event.targetTouches[0];
                    } else if (event.button === 0) {
                        eventSrc = event;
                    }
                    if (eventSrc) {
                        // allow custom `onresize` method
                        dispatchEvent('onresize', instance);
                        
                        resizable = instance;
                        handleOffset = instance.elements.resizeHandle.offsetHeight / 2;
                        var element = instance.elements.dialog;
                        addClass(element, classes.capture);
                        startingLeft = parseInt(element.style.left, 10);
                        element.style.height = element.offsetHeight + 'px';
                        element.style.minHeight = instance.elements.header.offsetHeight + instance.elements.footer.offsetHeight + 'px';
                        element.style.width = (startingWidth = element.offsetWidth) + 'px';

                        if (element.style.maxWidth !== 'none') {
                            element.style.minWidth = (minWidth = element.offsetWidth) + 'px';
                        }
                        element.style.maxWidth = 'none';
                        addClass(document.body, classes.noSelection);
                        return false;
                    }
                }
            }

            /**
             * The actual resize handler,  attached to document.body mousemove event.
             *
             * @param {Event} event	DOM event object.
             * 
             * @return {undefined}
             */
            function resize(event) {
                if (resizable) {
                    var eventSrc;
                    if (event.type === 'touchmove') {
                        event.preventDefault();
                        eventSrc = event.targetTouches[0];
                    } else if (event.button === 0) {
                        eventSrc = event;
                    }
                    if (eventSrc) {
                        resizeElement(eventSrc, resizable.elements.dialog, !resizable.get('modal') && !resizable.get('pinned'));
                    }
                }
            }

            /**
             * Triggers the end of a resize event,  attached to document.body mouseup event.
             * Removes no-selection class from document.body, allowing selection.
             *
             * @return {undefined}
             */
            function endResize() {
                if (resizable) {
                    var instance = resizable;
                    resizable = null;
                    removeClass(document.body, classes.noSelection);
                    removeClass(instance.elements.dialog, classes.capture);
                    cancelClick = true;
                    // allow custom `onresized` method
                    dispatchEvent('onresized', instance);
                }
            }

            /**
             * Resets any changes made by resizing the element to its original state.
             *
             * @param {Object} instance The dilog instance.
             *
             * @return {undefined}
             */
            function resetResize(instance) {
                resizable = null;
                var element = instance.elements.dialog;
                if (element.style.maxWidth === 'none') {
                    //clear inline styles.
                    element.style.maxWidth = element.style.minWidth = element.style.width = element.style.height = element.style.minHeight = element.style.left = '';
                    //reset variables.
                    startingLeft = Number.Nan;
                    startingWidth = minWidth = handleOffset = 0;
                }
            }


            /**
             * Updates the dialog move behavior.
             *
             * @param {Object} instance The dilog instance.
             * @param {Boolean} on True to add the behavior, removes it otherwise.
             *
             * @return {undefined}
             */
            function updateResizable(instance) {
                if (instance.get('resizable')) {
                    // add class
                    addClass(instance.elements.root, classes.resizable);
                    if (instance.isOpen()) {
                        bindResizableEvents(instance);
                    }
                } else {
                    //reset
                    resetResize(instance);
                    // remove class
                    removeClass(instance.elements.root, classes.resizable);
                    if (instance.isOpen()) {
                        unbindResizableEvents(instance);
                    }
                }
            }

            /**
             * Reset move/resize on window resize.
             *
             * @param {Event} event	window resize event object.
             *
             * @return {undefined}
             */
            function windowResize(/*event*/) {
                for (var x = 0; x < openDialogs.length; x += 1) {
                    var instance = openDialogs[x];
                    if (instance.get('autoReset')) {
                        resetMove(instance);
                        resetResize(instance);
                    }
                }
            }
            /**
             * Bind dialogs events
             *
             * @param {Object} instance The dilog instance.
             *
             * @return {undefined}
             */
            function bindEvents(instance) {
                // if first dialog, hook global handlers
                if (openDialogs.length === 1) {
                    //global
                    on(window, 'resize', windowResize);
                    on(document.body, 'keyup', keyupHandler);
                    on(document.body, 'keydown', keydownHandler);
                    on(document.body, 'focus', onReset);

                    //move
                    on(document.documentElement, 'mousemove', move);
                    on(document.documentElement, 'touchmove', move, false, false);
                    on(document.documentElement, 'mouseup', endMove);
                    on(document.documentElement, 'touchend', endMove);
                    //resize
                    on(document.documentElement, 'mousemove', resize);
                    on(document.documentElement, 'touchmove', resize, false, false);
                    on(document.documentElement, 'mouseup', endResize);
                    on(document.documentElement, 'touchend', endResize);
                }

                // common events
                on(instance.elements.commands.container, 'click', instance.__internal.commandsClickHandler);
                on(instance.elements.footer, 'click', instance.__internal.buttonsClickHandler);
                on(instance.elements.reset[0], 'focusin', instance.__internal.resetHandler);
                on(instance.elements.reset[0], 'keydown', recycleTab);
                on(instance.elements.reset[1], 'focusin', instance.__internal.resetHandler);

                //prevent handling key up when dialog is being opened by a key stroke.
                cancelKeyup = true;
                // hook in transition handler
                on(instance.elements.dialog, transition.type, instance.__internal.transitionInHandler);

                // modelss only events
                if (!instance.get('modal')) {
                    bindModelessEvents(instance);
                }

                // resizable
                if (instance.get('resizable')) {
                    bindResizableEvents(instance);
                }

                // movable
                if (instance.get('movable')) {
                    bindMovableEvents(instance);
                }
            }

            /**
             * Unbind dialogs events
             *
             * @param {Object} instance The dilog instance.
             *
             * @return {undefined}
             */
            function unbindEvents(instance) {
                // if last dialog, remove global handlers
                if (openDialogs.length === 1) {
                    //global
                    off(window, 'resize', windowResize);
                    off(document.body, 'keyup', keyupHandler);
                    off(document.body, 'keydown', keydownHandler);
                    off(document.body, 'focus', onReset);
                    //move
                    off(document.documentElement, 'mousemove', move);
                    off(document.documentElement, 'mouseup', endMove);
                    //resize
                    off(document.documentElement, 'mousemove', resize);
                    off(document.documentElement, 'mouseup', endResize);
                }

                // common events
                off(instance.elements.commands.container, 'click', instance.__internal.commandsClickHandler);
                off(instance.elements.footer, 'click', instance.__internal.buttonsClickHandler);
                off(instance.elements.reset[0], 'focusin', instance.__internal.resetHandler);
                off(instance.elements.reset[0], 'keydown', recycleTab);
                off(instance.elements.reset[1], 'focusin', instance.__internal.resetHandler);

                // hook out transition handler
                on(instance.elements.dialog, transition.type, instance.__internal.transitionOutHandler);

                // modelss only events
                if (!instance.get('modal')) {
                    unbindModelessEvents(instance);
                }

                // movable
                if (instance.get('movable')) {
                    unbindMovableEvents(instance);
                }

                // resizable
                if (instance.get('resizable')) {
                    unbindResizableEvents(instance);
                }

            }

            /**
             * Bind modeless specific events
             *
             * @param {Object} instance The dilog instance.
             *
             * @return {undefined}
             */
            function bindModelessEvents(instance) {
                on(instance.elements.dialog, 'focus', instance.__internal.bringToFrontHandler, true);
            }

            /**
             * Unbind modeless specific events
             *
             * @param {Object} instance The dilog instance.
             *
             * @return {undefined}
             */
            function unbindModelessEvents(instance) {
                off(instance.elements.dialog, 'focus', instance.__internal.bringToFrontHandler, true);
            }



            /**
             * Bind movable specific events
             *
             * @param {Object} instance The dilog instance.
             *
             * @return {undefined}
             */
            function bindMovableEvents(instance) {
                on(instance.elements.header, 'mousedown', instance.__internal.beginMoveHandler);
                on(instance.elements.header, 'touchstart', instance.__internal.beginMoveHandler, false, false);
            }

            /**
             * Unbind movable specific events
             *
             * @param {Object} instance The dilog instance.
             *
             * @return {undefined}
             */
            function unbindMovableEvents(instance) {
                off(instance.elements.header, 'mousedown', instance.__internal.beginMoveHandler);
                off(instance.elements.header, 'touchstart', instance.__internal.beginMoveHandler, false, false);
            }



            /**
             * Bind resizable specific events
             *
             * @param {Object} instance The dilog instance.
             *
             * @return {undefined}
             */
            function bindResizableEvents(instance) {
                on(instance.elements.resizeHandle, 'mousedown', instance.__internal.beginResizeHandler);
                on(instance.elements.resizeHandle, 'touchstart', instance.__internal.beginResizeHandler, false, false);
            }

            /**
             * Unbind resizable specific events
             *
             * @param {Object} instance The dilog instance.
             *
             * @return {undefined}
             */
            function unbindResizableEvents(instance) {
                off(instance.elements.resizeHandle, 'mousedown', instance.__internal.beginResizeHandler);
                off(instance.elements.resizeHandle, 'touchstart', instance.__internal.beginResizeHandler, false, false);
            }

            /**
             * Bind closable events
             *
             * @param {Object} instance The dilog instance.
             *
             * @return {undefined}
             */
            function bindClosableEvents(instance) {
                on(instance.elements.modal, 'click', instance.__internal.modalClickHandler);
            }

            /**
             * Unbind closable specific events
             *
             * @param {Object} instance The dilog instance.
             *
             * @return {undefined}
             */
            function unbindClosableEvents(instance) {
                off(instance.elements.modal, 'click', instance.__internal.modalClickHandler);
            }
            // dialog API
            return {
                __init:initialize,
                /**
                 * Check if dialog is currently open
                 *
                 * @return {Boolean}
                 */
                isOpen: function () {
                    return this.__internal.isOpen;
                },
                isModal: function (){
                    return this.elements.root.className.indexOf(classes.modeless) < 0;
                },
                isMaximized:function(){
                    return this.elements.root.className.indexOf(classes.maximized) > -1;
                },
                isPinned:function(){
                    return this.elements.root.className.indexOf(classes.unpinned) < 0;
                },
                maximize:function(){
                    if(!this.isMaximized()){
                        maximize(this);
                    }
                    return this;
                },
                restore:function(){
                    if(this.isMaximized()){
                        restore(this);
                    }
                    return this;
                },
                pin:function(){
                    if(!this.isPinned()){
                        pin(this);
                    }
                    return this;
                },
                unpin:function(){
                    if(this.isPinned()){
                        unpin(this);
                    }
                    return this;
                },
                bringToFront:function(){
                    bringToFront(null, this);
                    return this;
                },
                /**
                 * Move the dialog to a specific x/y coordinates
                 *
                 * @param {Number} x    The new dialog x coordinate in pixels.
                 * @param {Number} y    The new dialog y coordinate in pixels.
                 *
                 * @return {Object} The dialog instance.
                 */
                moveTo:function(x,y){
                    if(!isNaN(x) && !isNaN(y)){
                        // allow custom `onmove` method
                        dispatchEvent('onmove', this);
                        
                        var element = this.elements.dialog,
                            current = element,
                            offsetLeft = 0,
                            offsetTop = 0;
                        
                        //subtract existing left,top
                        if (element.style.left) {
                            offsetLeft -= parseInt(element.style.left, 10);
                        }
                        if (element.style.top) {
                            offsetTop -= parseInt(element.style.top, 10);
                        }
                        //calc offset
                        do {
                            offsetLeft += current.offsetLeft;
                            offsetTop += current.offsetTop;
                        } while (current = current.offsetParent);

                        //calc left, top
                        var left = (x - offsetLeft);
                        var top  = (y - offsetTop);

                        //// rtl handling
                        if (isRightToLeft()) {
                            left *= -1;
                        }

                        element.style.left = left + 'px';
                        element.style.top = top + 'px';
                        
                        // allow custom `onmoved` method
                        dispatchEvent('onmoved', this);
                    }
                    return this;
                },
                /**
                 * Resize the dialog to a specific width/height (the dialog must be 'resizable').
                 * The dialog can be resized to:
                 *  A minimum width equal to the initial display width
                 *  A minimum height equal to the sum of header/footer heights.
                 *
                 *
                 * @param {Number or String} width    The new dialog width in pixels or in percent.
                 * @param {Number or String} height   The new dialog height in pixels or in percent.
                 *
                 * @return {Object} The dialog instance.
                 */
                resizeTo:function(width,height){
                    var w = parseFloat(width),
                        h = parseFloat(height),
                        regex = /(\d*\.\d+|\d+)%/
                    ;

                    if(!isNaN(w) && !isNaN(h) && this.get('resizable') === true){
                        
                        // allow custom `onresize` method
                        dispatchEvent('onresize', this);
                        
                        if(('' + width).match(regex)){
                            w = w / 100 * document.documentElement.clientWidth ;
                        }

                        if(('' + height).match(regex)){
                            h = h / 100 * document.documentElement.clientHeight;
                        }

                        var element = this.elements.dialog;
                        if (element.style.maxWidth !== 'none') {
                            element.style.minWidth = (minWidth = element.offsetWidth) + 'px';
                        }
                        element.style.maxWidth = 'none';
                        element.style.minHeight = this.elements.header.offsetHeight + this.elements.footer.offsetHeight + 'px';
                        element.style.width = w + 'px';
                        element.style.height = h + 'px';
                        
                        // allow custom `onresized` method
                        dispatchEvent('onresized', this);
                    }
                    return this;
                },
                /**
                 * Gets or Sets dialog settings/options 
                 *
                 * @param {String|Object} key A string specifying a propery name or a collection of key/value pairs.
                 * @param {Object} value Optional, the value associated with the key (in case it was a string).
                 *
                 * @return {undefined}
                 */
                setting : function (key, value) {
                    var self = this;
                    var result = update(this, this.__internal.options, function(k,o,n){ optionUpdated(self,k,o,n); }, key, value);
                    if(result.op === 'get'){
                        if(result.found){
                            return result.value;
                        }else if(typeof this.settings !== 'undefined'){
                            return update(this, this.settings, this.settingUpdated || function(){}, key, value).value;
                        }else{
                            return undefined;
                        }
                    }else if(result.op === 'set'){
                        if(result.items.length > 0){
                            var callback = this.settingUpdated || function(){};
                            for(var x=0;x<result.items.length;x+=1){
                                var item = result.items[x];
                                if(!item.found && typeof this.settings !== 'undefined'){
                                    update(this, this.settings, callback, item.key, item.value);
                                }
                            }
                        }
                        return this;
                    }
                },
                /**
                 * [Alias] Sets dialog settings/options 
                 */
                set:function(key, value){
                    this.setting(key,value);
                    return this;
                },
                /**
                 * [Alias] Gets dialog settings/options 
                 */
                get:function(key){
                    return this.setting(key);
                },
                /**
                * Sets dialog header
                * @content {string or element}
                *
                * @return {undefined}
                */
                setHeader:function(content){
                    if(typeof content === 'string'){
                        clearContents(this.elements.header);
                        this.elements.header.innerHTML = content;
                    }else if (content instanceof window.HTMLElement && this.elements.header.firstChild !== content){
                        clearContents(this.elements.header);
                        this.elements.header.appendChild(content);
                    }
                    return this;
                },
                /**
                * Sets dialog contents
                * @content {string or element}
                *
                * @return {undefined}
                */
                setContent:function(content){
                    if(typeof content === 'string'){
                        clearContents(this.elements.content);
                        this.elements.content.innerHTML = content;
                    }else if (content instanceof window.HTMLElement && this.elements.content.firstChild !== content){
                        clearContents(this.elements.content);
                        this.elements.content.appendChild(content);
                    }
                    return this;
                },
                /**
                 * Show the dialog as modal
                 *
                 * @return {Object} the dialog instance.
                 */
                showModal: function(className){
                    return this.show(true, className);
                },
                /**
                 * Show the dialog
                 *
                 * @return {Object} the dialog instance.
                 */
                show: function (modal, className) {
                    
                    // ensure initialization
                    initialize(this);

                    if ( !this.__internal.isOpen ) {

                        // add to open dialogs
                        this.__internal.isOpen = true;
                        openDialogs.push(this);

                        // save last focused element
                        if(alertify.defaults.maintainFocus){
                            this.__internal.activeElement = document.activeElement;
                        }

                        // set tabindex attribute on body element this allows script to give it focusable
                        if(!document.body.hasAttribute('tabindex')) {
                            document.body.setAttribute( 'tabindex', tabindex = '0');
                        }

                        //allow custom dom manipulation updates before showing the dialog.
                        if(typeof this.prepare === 'function'){
                            this.prepare();
                        }

                        bindEvents(this);

                        if(modal !== undefined){
                            this.set('modal', modal);
                        }

                        //save scroll to prevent document jump
                        saveScrollPosition();

                        ensureNoOverflow();

                        // allow custom dialog class on show
                        if(typeof className === 'string' && className !== ''){
                            this.__internal.className = className;
                            addClass(this.elements.root, className);
                        }

                        // maximize if start maximized
                        if ( this.get('startMaximized')) {
                            this.maximize();
                        }else if(this.isMaximized()){
                            restore(this);
                        }

                        updateAbsPositionFix(this);
                        this.elements.root.removeAttribute('style');
                        removeClass(this.elements.root, classes.animationOut);
                        addClass(this.elements.root, classes.animationIn);

                        // set 1s fallback in case transition event doesn't fire
                        clearTimeout( this.__internal.timerIn);
                        this.__internal.timerIn = setTimeout( this.__internal.transitionInHandler, transition.supported ? 1000 : 100 );

                        if(isSafari){
                            // force desktop safari reflow
                            var root = this.elements.root;
                            root.style.display  = 'none';
                            setTimeout(function(){root.style.display  = 'block';}, 0);
                        }

                        //reflow
                        reflow = this.elements.root.offsetWidth;
                      
                        // show dialog
                        removeClass(this.elements.root, classes.hidden);

                        //restore scroll to prevent document jump
                        restoreScrollPosition();

                        // internal on show event
                        if(typeof this.hooks.onshow === 'function'){
                            this.hooks.onshow.call(this);
                        }

                        // allow custom `onshow` method
                        dispatchEvent('onshow', this);

                    }else{
                        // reset move updates
                        resetMove(this);
                        // reset resize updates
                        resetResize(this);
                        // shake the dialog to indicate its already open
                        addClass(this.elements.dialog, classes.shake);
                        var self = this;
                        setTimeout(function(){
                            removeClass(self.elements.dialog, classes.shake);
                        },200);
                    }
                    return this;
                },
                /**
                 * Close the dialog
                 *
                 * @return {Object} The dialog instance
                 */
                close: function () {
                    if (this.__internal.isOpen ) {
                        // custom `onclosing` event
                        if(dispatchEvent('onclosing', this) !== false){

                            unbindEvents(this);

                            removeClass(this.elements.root, classes.animationIn);
                            addClass(this.elements.root, classes.animationOut);

                            // set 1s fallback in case transition event doesn't fire
                            clearTimeout( this.__internal.timerOut );
                            this.__internal.timerOut = setTimeout( this.__internal.transitionOutHandler, transition.supported ? 1000 : 100 );
                            // hide dialog
                            addClass(this.elements.root, classes.hidden);
                            //reflow
                            reflow = this.elements.modal.offsetWidth;

                            // return focus to the last active element
                            if (alertify.defaults.maintainFocus && this.__internal.activeElement) {
                                this.__internal.activeElement.focus();
                                this.__internal.activeElement = null;
                            }

                            // remove custom dialog class on hide
                            if (typeof this.__internal.className !== 'undefined' && this.__internal.className !== '') {
                                removeClass(this.elements.root, this.__internal.className);
                            }

                            // internal on close event
                            if(typeof this.hooks.onclose === 'function'){
                                this.hooks.onclose.call(this);
                            }

                            // allow custom `onclose` method
                            dispatchEvent('onclose', this);

                            //remove from open dialogs
                            openDialogs.splice(openDialogs.indexOf(this),1);
                            this.__internal.isOpen = false;

                            ensureNoOverflow();
                        }

                    }
                    // last dialog and tab index was set by us, remove it.
                    if(!openDialogs.length && tabindex === '0'){
                        document.body.removeAttribute('tabindex');
                    }
                    return this;
                },
                /**
                 * Close all open dialogs except this.
                 *
                 * @return {undefined}
                 */
                closeOthers:function(){
                    alertify.closeAll(this);
                    return this;
                },
                /**
                 * Destroys this dialog instance
                 *
                 * @return {undefined}
                 */
                destroy:function(){
                    if(this.__internal) {
                        if (this.__internal.isOpen ) {
                            //mark dialog for destruction, this will be called on tranistionOut event.
                            this.__internal.destroy = function(){
                                destruct(this, initialize);
                            };
                            //close the dialog to unbind all events.
                            this.close();
                        }else if(!this.__internal.destroy){
                            destruct(this, initialize);
                        }
                    }
                    return this;
                },
            };
    	} () );
        var notifier = (function () {
            var reflow,
                element,
                openInstances = [],
                classes = defaults.notifier.classes,
                baseClass = classes.base;
            /**
             * Helper: initializes the notifier instance
             *
             */
            function initialize(instance) {

                if (!instance.__internal) {
                    instance.__internal = {
                        position: alertify.defaults.notifier.position,
                        delay: alertify.defaults.notifier.delay,
                    };

                    element = document.createElement('DIV');
                    var transitionOff = 'transitionOff' in defaults.notifier ? defaults.notifier.transitionOff : defaults.transitionOff;
                    if(transitionOff){
                        baseClass = classes.base + ' ajs-no-transition';
                    }
                    updatePosition(instance);
                }

                //add to DOM tree.
                if (element.parentNode !== document.body) {
                    document.body.appendChild(element);
                }
            }

            function pushInstance(instance) {
                instance.__internal.pushed = true;
                openInstances.push(instance);
            }
            function popInstance(instance) {
                openInstances.splice(openInstances.indexOf(instance), 1);
                instance.__internal.pushed = false;
            }
            /**
             * Helper: update the notifier instance position
             *
             */
            function updatePosition(instance) {
                element.className = baseClass;
                switch (instance.__internal.position) {
                case 'top-right':
                    addClass(element, classes.top + ' ' + classes.right);
                    break;
                case 'top-left':
                    addClass(element, classes.top + ' ' + classes.left);
                    break;
                case 'top-center':
                    addClass(element, classes.top + ' ' + classes.center);
                    break;
                case 'bottom-left':
                    addClass(element, classes.bottom + ' ' + classes.left);
                    break;
                case 'bottom-center':
                    addClass(element, classes.bottom + ' ' + classes.center);
                    break;

                default:
                case 'bottom-right':
                    addClass(element, classes.bottom + ' ' + classes.right);
                    break;
                }
            }

            /**
            * creates a new notification message
            *
            * @param  {DOMElement} message	The notifier message element
            * @param  {Number} wait   Time (in ms) to wait before the message is dismissed, a value of 0 means keep open till clicked.
            * @param  {Function} callback A callback function to be invoked when the message is dismissed.
            *
            * @return {undefined}
            */
            function create(div, callback) {

                function clickDelegate(event, instance) {
                    if(!instance.__internal.closeButton || event.target.getAttribute('data-close') === 'true'){
                        instance.dismiss(true);
                    }
                }

                function transitionDone(event, instance) {
                    // unbind event
                    off(instance.element, transition.type, transitionDone);
                    // remove the message
                    element.removeChild(instance.element);
                }

                function initialize(instance) {
                    if (!instance.__internal) {
                        instance.__internal = {
                            pushed: false,
                            delay : undefined,
                            timer: undefined,
                            clickHandler: undefined,
                            transitionEndHandler: undefined,
                            transitionTimeout: undefined
                        };
                        instance.__internal.clickHandler = delegate(instance, clickDelegate);
                        instance.__internal.transitionEndHandler = delegate(instance, transitionDone);
                    }
                    return instance;
                }
                function clearTimers(instance) {
                    clearTimeout(instance.__internal.timer);
                    clearTimeout(instance.__internal.transitionTimeout);
                }
                return initialize({
                    /* notification DOM element*/
                    element: div,
                    /*
                     * Pushes a notification message
                     * @param {string or DOMElement} content The notification message content
                     * @param {Number} wait The time (in seconds) to wait before the message is dismissed, a value of 0 means keep open till clicked.
                     *
                     */
                    push: function (_content, _wait) {
                        if (!this.__internal.pushed) {

                            pushInstance(this);
                            clearTimers(this);

                            var content, wait;
                            switch (arguments.length) {
                            case 0:
                                wait = this.__internal.delay;
                                break;
                            case 1:
                                if (typeof (_content) === 'number') {
                                    wait = _content;
                                } else {
                                    content = _content;
                                    wait = this.__internal.delay;
                                }
                                break;
                            case 2:
                                content = _content;
                                wait = _wait;
                                break;
                            }
                            this.__internal.closeButton = alertify.defaults.notifier.closeButton;
                            // set contents
                            if (typeof content !== 'undefined') {
                                this.setContent(content);
                            }
                            // append or insert
                            if (notifier.__internal.position.indexOf('top') < 0) {
                                element.appendChild(this.element);
                            } else {
                                element.insertBefore(this.element, element.firstChild);
                            }
                            reflow = this.element.offsetWidth;
                            addClass(this.element, classes.visible);
                            // attach click event
                            on(this.element, 'click', this.__internal.clickHandler);
                            return this.delay(wait);
                        }
                        return this;
                    },
                    /*
                     * {Function} callback function to be invoked before dismissing the notification message.
                     * Remarks: A return value === 'false' will cancel the dismissal
                     *
                     */
                    ondismiss: function () { },
                    /*
                     * {Function} callback function to be invoked when the message is dismissed.
                     *
                     */
                    callback: callback,
                    /*
                     * Dismisses the notification message
                     * @param {Boolean} clicked A flag indicating if the dismissal was caused by a click.
                     *
                     */
                    dismiss: function (clicked) {
                        if (this.__internal.pushed) {
                            clearTimers(this);
                            if (!(typeof this.ondismiss === 'function' && this.ondismiss.call(this) === false)) {
                                //detach click event
                                off(this.element, 'click', this.__internal.clickHandler);
                                // ensure element exists
                                if (typeof this.element !== 'undefined' && this.element.parentNode === element) {
                                    //transition end or fallback
                                    this.__internal.transitionTimeout = setTimeout(this.__internal.transitionEndHandler, transition.supported ? 1000 : 100);
                                    removeClass(this.element, classes.visible);

                                    // custom callback on dismiss
                                    if (typeof this.callback === 'function') {
                                        this.callback.call(this, clicked);
                                    }
                                }
                                popInstance(this);
                            }
                        }
                        return this;
                    },
                    /*
                     * Delays the notification message dismissal
                     * @param {Number} wait The time (in seconds) to wait before the message is dismissed, a value of 0 means keep open till clicked.
                     *
                     */
                    delay: function (wait) {
                        clearTimers(this);
                        this.__internal.delay = typeof wait !== 'undefined' && !isNaN(+wait) ? +wait : notifier.__internal.delay;
                        if (this.__internal.delay > 0) {
                            var  self = this;
                            this.__internal.timer = setTimeout(function () { self.dismiss(); }, this.__internal.delay * 1000);
                        }
                        return this;
                    },
                    /*
                     * Sets the notification message contents
                     * @param {string or DOMElement} content The notification message content
                     *
                     */
                    setContent: function (content) {
                        if (typeof content === 'string') {
                            clearContents(this.element);
                            this.element.innerHTML = content;
                        } else if (content instanceof window.HTMLElement && this.element.firstChild !== content) {
                            clearContents(this.element);
                            this.element.appendChild(content);
                        }
                        if(this.__internal.closeButton){
                            var close = document.createElement('span');
                            addClass(close, classes.close);
                            close.setAttribute('data-close', true);
                            this.element.appendChild(close);
                        }
                        return this;
                    },
                    /*
                     * Dismisses all open notifications except this.
                     *
                     */
                    dismissOthers: function () {
                        notifier.dismissAll(this);
                        return this;
                    }
                });
            }

            //notifier api
            return {
                /**
                 * Gets or Sets notifier settings.
                 *
                 * @param {string} key The setting name
                 * @param {Variant} value The setting value.
                 *
                 * @return {Object}	if the called as a setter, return the notifier instance.
                 */
                setting: function (key, value) {
                    //ensure init
                    initialize(this);

                    if (typeof value === 'undefined') {
                        //get
                        return this.__internal[key];
                    } else {
                        //set
                        switch (key) {
                        case 'position':
                            this.__internal.position = value;
                            updatePosition(this);
                            break;
                        case 'delay':
                            this.__internal.delay = value;
                            break;
                        }
                    }
                    return this;
                },
                /**
                 * [Alias] Sets dialog settings/options
                 */
                set:function(key,value){
                    this.setting(key,value);
                    return this;
                },
                /**
                 * [Alias] Gets dialog settings/options
                 */
                get:function(key){
                    return this.setting(key);
                },
                /**
                 * Creates a new notification message
                 *
                 * @param {string} type The type of notification message (simply a CSS class name 'ajs-{type}' to be added).
                 * @param {Function} callback  A callback function to be invoked when the message is dismissed.
                 *
                 * @return {undefined}
                 */
                create: function (type, callback) {
                    //ensure notifier init
                    initialize(this);
                    //create new notification message
                    var div = document.createElement('div');
                    div.className = classes.message + ((typeof type === 'string' && type !== '') ? ' ' + classes.prefix + type : '');
                    return create(div, callback);
                },
                /**
                 * Dismisses all open notifications.
                 *
                 * @param {Object} excpet [optional] The notification object to exclude from dismissal.
                 *
                 */
                dismissAll: function (except) {
                    var clone = openInstances.slice(0);
                    for (var x = 0; x < clone.length; x += 1) {
                        var  instance = clone[x];
                        if (except === undefined || except !== instance) {
                            instance.dismiss();
                        }
                    }
                }
            };
        })();

        /**
         * Alertify public API
         * This contains everything that is exposed through the alertify object.
         *
         * @return {Object}
         */
        function Alertify() {

            // holds a references of created dialogs
            var dialogs = {};

            /**
             * Extends a given prototype by merging properties from base into sub.
             *
             * @sub {Object} sub The prototype being overwritten.
             * @base {Object} base The prototype being written.
             *
             * @return {Object} The extended prototype.
             */
            function extend(sub, base) {
                // copy dialog pototype over definition.
                for (var prop in base) {
                    if (base.hasOwnProperty(prop)) {
                        sub[prop] = base[prop];
                    }
                }
                return sub;
            }


            /**
            * Helper: returns a dialog instance from saved dialogs.
            * and initializes the dialog if its not already initialized.
            *
            * @name {String} name The dialog name.
            *
            * @return {Object} The dialog instance.
            */
            function get_dialog(name) {
                var dialog = dialogs[name].dialog;
                //initialize the dialog if its not already initialized.
                if (dialog && typeof dialog.__init === 'function') {
                    dialog.__init(dialog);
                }
                return dialog;
            }

            /**
             * Helper:  registers a new dialog definition.
             *
             * @name {String} name The dialog name.
             * @Factory {Function} Factory a function resposible for creating dialog prototype.
             * @transient {Boolean} transient True to create a new dialog instance each time the dialog is invoked, false otherwise.
             * @base {String} base the name of another dialog to inherit from.
             *
             * @return {Object} The dialog definition.
             */
            function register(name, Factory, transient, base) {
                var definition = {
                    dialog: null,
                    factory: Factory
                };

                //if this is based on an existing dialog, create a new definition
                //by applying the new protoype over the existing one.
                if (base !== undefined) {
                    definition.factory = function () {
                        return extend(new dialogs[base].factory(), new Factory());
                    };
                }

                if (!transient) {
                    //create a new definition based on dialog
                    definition.dialog = extend(new definition.factory(), dialog);
                }
                return dialogs[name] = definition;
            }

            return {
                /**
                 * Alertify defaults
                 * 
                 * @type {Object}
                 */
                defaults: defaults,
                /**
                 * Dialogs factory 
                 *
                 * @param {string}      Dialog name.
                 * @param {Function}    A Dialog factory function.
                 * @param {Boolean}     Indicates whether to create a singleton or transient dialog.
                 * @param {String}      The name of the base type to inherit from.
                 */
                dialog: function (name, Factory, transient, base) {

                    // get request, create a new instance and return it.
                    if (typeof Factory !== 'function') {
                        return get_dialog(name);
                    }

                    if (this.hasOwnProperty(name)) {
                        throw new Error('alertify.dialog: name already exists');
                    }

                    // register the dialog
                    var definition = register(name, Factory, transient, base);

                    if (transient) {

                        // make it public
                        this[name] = function () {
                            //if passed with no params, consider it a get request
                            if (arguments.length === 0) {
                                return definition.dialog;
                            } else {
                                var instance = extend(new definition.factory(), dialog);
                                //ensure init
                                if (instance && typeof instance.__init === 'function') {
                                    instance.__init(instance);
                                }
                                instance['main'].apply(instance, arguments);
                                return instance['show'].apply(instance);
                            }
                        };
                    } else {
                        // make it public
                        this[name] = function () {
                            //ensure init
                            if (definition.dialog && typeof definition.dialog.__init === 'function') {
                                definition.dialog.__init(definition.dialog);
                            }
                            //if passed with no params, consider it a get request
                            if (arguments.length === 0) {
                                return definition.dialog;
                            } else {
                                var dialog = definition.dialog;
                                dialog['main'].apply(definition.dialog, arguments);
                                return dialog['show'].apply(definition.dialog);
                            }
                        };
                    }
                },
                /**
                 * Close all open dialogs.
                 *
                 * @param {Object} excpet [optional] The dialog object to exclude from closing.
                 *
                 * @return {undefined}
                 */
                closeAll: function (except) {
                    var clone = openDialogs.slice(0);
                    for (var x = 0; x < clone.length; x += 1) {
                        var instance = clone[x];
                        if (except === undefined || except !== instance) {
                            instance.close();
                        }
                    }
                },
                /**
                 * Gets or Sets dialog settings/options. if the dialog is transient, this call does nothing.
                 *
                 * @param {string} name The dialog name.
                 * @param {String|Object} key A string specifying a propery name or a collection of key/value pairs.
                 * @param {Variant} value Optional, the value associated with the key (in case it was a string).
                 *
                 * @return {undefined}
                 */
                setting: function (name, key, value) {

                    if (name === 'notifier') {
                        return notifier.setting(key, value);
                    }

                    var dialog = get_dialog(name);
                    if (dialog) {
                        return dialog.setting(key, value);
                    }
                },
                /**
                 * [Alias] Sets dialog settings/options 
                 */
                set: function(name,key,value){
                    return this.setting(name, key,value);
                },
                /**
                 * [Alias] Gets dialog settings/options 
                 */
                get: function(name, key){
                    return this.setting(name, key);
                },
                /**
                 * Creates a new notification message.
                 * If a type is passed, a class name "ajs-{type}" will be added.
                 * This allows for custom look and feel for various types of notifications.
                 *
                 * @param  {String | DOMElement}    [message=undefined]		Message text
                 * @param  {String}                 [type='']				Type of log message
                 * @param  {String}                 [wait='']				Time (in seconds) to wait before auto-close
                 * @param  {Function}               [callback=undefined]	A callback function to be invoked when the log is closed.
                 *
                 * @return {Object} Notification object.
                 */
                notify: function (message, type, wait, callback) {
                    return notifier.create(type, callback).push(message, wait);
                },
                /**
                 * Creates a new notification message.
                 *
                 * @param  {String}		[message=undefined]		Message text
                 * @param  {String}     [wait='']				Time (in seconds) to wait before auto-close
                 * @param  {Function}	[callback=undefined]	A callback function to be invoked when the log is closed.
                 *
                 * @return {Object} Notification object.
                 */
                message: function (message, wait, callback) {
                    return notifier.create(null, callback).push(message, wait);
                },
                /**
                 * Creates a new notification message of type 'success'.
                 *
                 * @param  {String}		[message=undefined]		Message text
                 * @param  {String}     [wait='']				Time (in seconds) to wait before auto-close
                 * @param  {Function}	[callback=undefined]	A callback function to be invoked when the log is closed.
                 *
                 * @return {Object} Notification object.
                 */
                success: function (message, wait, callback) {
                    return notifier.create('success', callback).push(message, wait);
                },
                /**
                 * Creates a new notification message of type 'error'.
                 *
                 * @param  {String}		[message=undefined]		Message text
                 * @param  {String}     [wait='']				Time (in seconds) to wait before auto-close
                 * @param  {Function}	[callback=undefined]	A callback function to be invoked when the log is closed.
                 *
                 * @return {Object} Notification object.
                 */
                error: function (message, wait, callback) {
                    return notifier.create('error', callback).push(message, wait);
                },
                /**
                 * Creates a new notification message of type 'warning'.
                 *
                 * @param  {String}		[message=undefined]		Message text
                 * @param  {String}     [wait='']				Time (in seconds) to wait before auto-close
                 * @param  {Function}	[callback=undefined]	A callback function to be invoked when the log is closed.
                 *
                 * @return {Object} Notification object.
                 */
                warning: function (message, wait, callback) {
                    return notifier.create('warning', callback).push(message, wait);
                },
                /**
                 * Dismisses all open notifications
                 *
                 * @return {undefined}
                 */
                dismissAll: function () {
                    notifier.dismissAll();
                }
            };
        }
        var alertify = new Alertify();

        /**
        * Alert dialog definition
        *
        * invoked by:
        *	alertify.alert(message);
        *	alertify.alert(title, message);
        *	alertify.alert(message, onok);
        *	alertify.alert(title, message, onok);
         */
        alertify.dialog('alert', function () {
            return {
                main: function (_title, _message, _onok) {
                    var title, message, onok;
                    switch (arguments.length) {
                    case 1:
                        message = _title;
                        break;
                    case 2:
                        if (typeof _message === 'function') {
                            message = _title;
                            onok = _message;
                        } else {
                            title = _title;
                            message = _message;
                        }
                        break;
                    case 3:
                        title = _title;
                        message = _message;
                        onok = _onok;
                        break;
                    }
                    this.set('title', title);
                    this.set('message', message);
                    this.set('onok', onok);
                    return this;
                },
                setup: function () {
                    return {
                        buttons: [
                            {
                                text: alertify.defaults.glossary.ok,
                                key: keys.ESC,
                                invokeOnClose: true,
                                className: alertify.defaults.theme.ok,
                            }
                        ],
                        focus: {
                            element: 0,
                            select: false
                        },
                        options: {
                            maximizable: false,
                            resizable: false
                        }
                    };
                },
                build: function () {
                    // nothing
                },
                prepare: function () {
                    //nothing
                },
                setMessage: function (message) {
                    this.setContent(message);
                },
                settings: {
                    message: undefined,
                    onok: undefined,
                    label: undefined,
                },
                settingUpdated: function (key, oldValue, newValue) {
                    switch (key) {
                    case 'message':
                        this.setMessage(newValue);
                        break;
                    case 'label':
                        if (this.__internal.buttons[0].element) {
                            this.__internal.buttons[0].element.innerHTML = newValue;
                        }
                        break;
                    }
                },
                callback: function (closeEvent) {
                    if (typeof this.get('onok') === 'function') {
                        var returnValue = this.get('onok').call(this, closeEvent);
                        if (typeof returnValue !== 'undefined') {
                            closeEvent.cancel = !returnValue;
                        }
                    }
                }
            };
        });
        /**
         * Confirm dialog object
         *
         *	alertify.confirm(message);
         *	alertify.confirm(message, onok);
         *	alertify.confirm(message, onok, oncancel);
         *	alertify.confirm(title, message, onok, oncancel);
         */
        alertify.dialog('confirm', function () {

            var autoConfirm = {
                timer: null,
                index: null,
                text: null,
                duration: null,
                task: function (event, self) {
                    if (self.isOpen()) {
                        self.__internal.buttons[autoConfirm.index].element.innerHTML = autoConfirm.text + ' (&#8207;' + autoConfirm.duration + '&#8207;) ';
                        autoConfirm.duration -= 1;
                        if (autoConfirm.duration === -1) {
                            clearAutoConfirm(self);
                            var button = self.__internal.buttons[autoConfirm.index];
                            var closeEvent = createCloseEvent(autoConfirm.index, button);

                            if (typeof self.callback === 'function') {
                                self.callback.apply(self, [closeEvent]);
                            }
                            //close the dialog.
                            if (closeEvent.close !== false) {
                                self.close();
                            }
                        }
                    } else {
                        clearAutoConfirm(self);
                    }
                }
            };

            function clearAutoConfirm(self) {
                if (autoConfirm.timer !== null) {
                    clearInterval(autoConfirm.timer);
                    autoConfirm.timer = null;
                    self.__internal.buttons[autoConfirm.index].element.innerHTML = autoConfirm.text;
                }
            }

            function startAutoConfirm(self, index, duration) {
                clearAutoConfirm(self);
                autoConfirm.duration = duration;
                autoConfirm.index = index;
                autoConfirm.text = self.__internal.buttons[index].element.innerHTML;
                autoConfirm.timer = setInterval(delegate(self, autoConfirm.task), 1000);
                autoConfirm.task(null, self);
            }


            return {
                main: function (_title, _message, _onok, _oncancel) {
                    var title, message, onok, oncancel;
                    switch (arguments.length) {
                    case 1:
                        message = _title;
                        break;
                    case 2:
                        message = _title;
                        onok = _message;
                        break;
                    case 3:
                        message = _title;
                        onok = _message;
                        oncancel = _onok;
                        break;
                    case 4:
                        title = _title;
                        message = _message;
                        onok = _onok;
                        oncancel = _oncancel;
                        break;
                    }
                    this.set('title', title);
                    this.set('message', message);
                    this.set('onok', onok);
                    this.set('oncancel', oncancel);
                    return this;
                },
                setup: function () {
                    return {
                        buttons: [
                            {
                                text: alertify.defaults.glossary.ok,
                                key: keys.ENTER,
                                className: alertify.defaults.theme.ok,
                            },
                            {
                                text: alertify.defaults.glossary.cancel,
                                key: keys.ESC,
                                invokeOnClose: true,
                                className: alertify.defaults.theme.cancel,
                            }
                        ],
                        focus: {
                            element: 0,
                            select: false
                        },
                        options: {
                            maximizable: false,
                            resizable: false
                        }
                    };
                },
                build: function () {
                    //nothing
                },
                prepare: function () {
                    //nothing
                },
                setMessage: function (message) {
                    this.setContent(message);
                },
                settings: {
                    message: null,
                    labels: null,
                    onok: null,
                    oncancel: null,
                    defaultFocus: null,
                    reverseButtons: null,
                },
                settingUpdated: function (key, oldValue, newValue) {
                    switch (key) {
                    case 'message':
                        this.setMessage(newValue);
                        break;
                    case 'labels':
                        if ('ok' in newValue && this.__internal.buttons[0].element) {
                            this.__internal.buttons[0].text = newValue.ok;
                            this.__internal.buttons[0].element.innerHTML = newValue.ok;
                        }
                        if ('cancel' in newValue && this.__internal.buttons[1].element) {
                            this.__internal.buttons[1].text = newValue.cancel;
                            this.__internal.buttons[1].element.innerHTML = newValue.cancel;
                        }
                        break;
                    case 'reverseButtons':
                        if (newValue === true) {
                            this.elements.buttons.primary.appendChild(this.__internal.buttons[0].element);
                        } else {
                            this.elements.buttons.primary.appendChild(this.__internal.buttons[1].element);
                        }
                        break;
                    case 'defaultFocus':
                        this.__internal.focus.element = newValue === 'ok' ? 0 : 1;
                        break;
                    }
                },
                callback: function (closeEvent) {
                    clearAutoConfirm(this);
                    var returnValue;
                    switch (closeEvent.index) {
                    case 0:
                        if (typeof this.get('onok') === 'function') {
                            returnValue = this.get('onok').call(this, closeEvent);
                            if (typeof returnValue !== 'undefined') {
                                closeEvent.cancel = !returnValue;
                            }
                        }
                        break;
                    case 1:
                        if (typeof this.get('oncancel') === 'function') {
                            returnValue = this.get('oncancel').call(this, closeEvent);
                            if (typeof returnValue !== 'undefined') {
                                closeEvent.cancel = !returnValue;
                            }
                        }
                        break;
                    }
                },
                autoOk: function (duration) {
                    startAutoConfirm(this, 0, duration);
                    return this;
                },
                autoCancel: function (duration) {
                    startAutoConfirm(this, 1, duration);
                    return this;
                }
            };
        });
        /**
         * Prompt dialog object
         *
         * invoked by:
         *	alertify.prompt(message);
         *	alertify.prompt(message, value);
         *	alertify.prompt(message, value, onok);
         *	alertify.prompt(message, value, onok, oncancel);
         *	alertify.prompt(title, message, value, onok, oncancel);
         */
        alertify.dialog('prompt', function () {
            var input = document.createElement('INPUT');
            var p = document.createElement('P');
            return {
                main: function (_title, _message, _value, _onok, _oncancel) {
                    var title, message, value, onok, oncancel;
                    switch (arguments.length) {
                    case 1:
                        message = _title;
                        break;
                    case 2:
                        message = _title;
                        value = _message;
                        break;
                    case 3:
                        message = _title;
                        value = _message;
                        onok = _value;
                        break;
                    case 4:
                        message = _title;
                        value = _message;
                        onok = _value;
                        oncancel = _onok;
                        break;
                    case 5:
                        title = _title;
                        message = _message;
                        value = _value;
                        onok = _onok;
                        oncancel = _oncancel;
                        break;
                    }
                    this.set('title', title);
                    this.set('message', message);
                    this.set('value', value);
                    this.set('onok', onok);
                    this.set('oncancel', oncancel);
                    return this;
                },
                setup: function () {
                    return {
                        buttons: [
                            {
                                text: alertify.defaults.glossary.ok,
                                key: keys.ENTER,
                                className: alertify.defaults.theme.ok,
                            },
                            {
                                text: alertify.defaults.glossary.cancel,
                                key: keys.ESC,
                                invokeOnClose: true,
                                className: alertify.defaults.theme.cancel,
                            }
                        ],
                        focus: {
                            element: input,
                            select: true
                        },
                        options: {
                            maximizable: false,
                            resizable: false
                        }
                    };
                },
                build: function () {
                    input.className = alertify.defaults.theme.input;
                    input.setAttribute('type', 'text');
                    input.value = this.get('value');
                    this.elements.content.appendChild(p);
                    this.elements.content.appendChild(input);
                },
                prepare: function () {
                    //nothing
                },
                setMessage: function (message) {
                    if (typeof message === 'string') {
                        clearContents(p);
                        p.innerHTML = message;
                    } else if (message instanceof window.HTMLElement && p.firstChild !== message) {
                        clearContents(p);
                        p.appendChild(message);
                    }
                },
                settings: {
                    message: undefined,
                    labels: undefined,
                    onok: undefined,
                    oncancel: undefined,
                    value: '',
                    type:'text',
                    reverseButtons: undefined,
                },
                settingUpdated: function (key, oldValue, newValue) {
                    switch (key) {
                    case 'message':
                        this.setMessage(newValue);
                        break;
                    case 'value':
                        input.value = newValue;
                        break;
                    case 'type':
                        switch (newValue) {
                        case 'text':
                        case 'color':
                        case 'date':
                        case 'datetime-local':
                        case 'email':
                        case 'month':
                        case 'number':
                        case 'password':
                        case 'search':
                        case 'tel':
                        case 'time':
                        case 'week':
                            input.type = newValue;
                            break;
                        default:
                            input.type = 'text';
                            break;
                        }
                        break;
                    case 'labels':
                        if (newValue.ok && this.__internal.buttons[0].element) {
                            this.__internal.buttons[0].element.innerHTML = newValue.ok;
                        }
                        if (newValue.cancel && this.__internal.buttons[1].element) {
                            this.__internal.buttons[1].element.innerHTML = newValue.cancel;
                        }
                        break;
                    case 'reverseButtons':
                        if (newValue === true) {
                            this.elements.buttons.primary.appendChild(this.__internal.buttons[0].element);
                        } else {
                            this.elements.buttons.primary.appendChild(this.__internal.buttons[1].element);
                        }
                        break;
                    }
                },
                callback: function (closeEvent) {
                    var returnValue;
                    switch (closeEvent.index) {
                    case 0:
                        this.settings.value = input.value;
                        if (typeof this.get('onok') === 'function') {
                            returnValue = this.get('onok').call(this, closeEvent, this.settings.value);
                            if (typeof returnValue !== 'undefined') {
                                closeEvent.cancel = !returnValue;
                            }
                        }
                        break;
                    case 1:
                        if (typeof this.get('oncancel') === 'function') {
                            returnValue = this.get('oncancel').call(this, closeEvent);
                            if (typeof returnValue !== 'undefined') {
                                closeEvent.cancel = !returnValue;
                            }
                        }
                        if(!closeEvent.cancel){
                            input.value = this.settings.value;
                        }
                        break;
                    }
                }
            };
        });

        // CommonJS
        {
            module.exports = alertify;
        // AMD
        }

    } ( typeof window !== 'undefined' ? window : commonjsGlobal ) );
    });

    function noop() {}

    function assign(tar, src) {
    	for (var k in src) tar[k] = src[k];
    	return tar;
    }

    function assignTrue(tar, src) {
    	for (var k in src) tar[k] = 1;
    	return tar;
    }

    function addLoc(element, file, line, column, char) {
    	element.__svelte_meta = {
    		loc: { file, line, column, char }
    	};
    }

    function append(target, node) {
    	target.appendChild(node);
    }

    function insert(target, node, anchor) {
    	target.insertBefore(node, anchor);
    }

    function detachNode(node) {
    	node.parentNode.removeChild(node);
    }

    function detachBetween(before, after) {
    	while (before.nextSibling && before.nextSibling !== after) {
    		before.parentNode.removeChild(before.nextSibling);
    	}
    }

    function detachBefore(after) {
    	while (after.previousSibling) {
    		after.parentNode.removeChild(after.previousSibling);
    	}
    }

    function destroyEach(iterations, detach) {
    	for (var i = 0; i < iterations.length; i += 1) {
    		if (iterations[i]) iterations[i].d(detach);
    	}
    }

    function createElement(name) {
    	return document.createElement(name);
    }

    function createText(data) {
    	return document.createTextNode(data);
    }

    function createComment() {
    	return document.createComment('');
    }

    function addListener(node, event, handler, options) {
    	node.addEventListener(event, handler, options);
    }

    function removeListener(node, event, handler, options) {
    	node.removeEventListener(event, handler, options);
    }

    function setAttribute(node, attribute, value) {
    	if (value == null) node.removeAttribute(attribute);
    	else node.setAttribute(attribute, value);
    }

    function toNumber(value) {
    	return value === '' ? undefined : +value;
    }

    function setData(text, data) {
    	text.data = '' + data;
    }

    function setStyle(node, key, value) {
    	node.style.setProperty(key, value);
    }

    function selectOption(select, value) {
    	for (var i = 0; i < select.options.length; i += 1) {
    		var option = select.options[i];

    		if (option.__value === value) {
    			option.selected = true;
    			return;
    		}
    	}
    }

    function selectValue(select) {
    	var selectedOption = select.querySelector(':checked') || select.options[0];
    	return selectedOption && selectedOption.__value;
    }

    function blankObject() {
    	return Object.create(null);
    }

    function destroy(detach) {
    	this.destroy = noop;
    	this.fire('destroy');
    	this.set = noop;

    	this._fragment.d(detach !== false);
    	this._fragment = null;
    	this._state = {};
    }

    function destroyDev(detach) {
    	destroy.call(this, detach);
    	this.destroy = function() {
    		console.warn('Component was already destroyed');
    	};
    }

    function _differs(a, b) {
    	return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }

    function fire(eventName, data) {
    	var handlers =
    		eventName in this._handlers && this._handlers[eventName].slice();
    	if (!handlers) return;

    	for (var i = 0; i < handlers.length; i += 1) {
    		var handler = handlers[i];

    		if (!handler.__calling) {
    			try {
    				handler.__calling = true;
    				handler.call(this, data);
    			} finally {
    				handler.__calling = false;
    			}
    		}
    	}
    }

    function flush(component) {
    	component._lock = true;
    	callAll(component._beforecreate);
    	callAll(component._oncreate);
    	callAll(component._aftercreate);
    	component._lock = false;
    }

    function get() {
    	return this._state;
    }

    function init(component, options) {
    	component._handlers = blankObject();
    	component._slots = blankObject();
    	component._bind = options._bind;
    	component._staged = {};

    	component.options = options;
    	component.root = options.root || component;
    	component.store = options.store || component.root.store;

    	if (!options.root) {
    		component._beforecreate = [];
    		component._oncreate = [];
    		component._aftercreate = [];
    	}
    }

    function on(eventName, handler) {
    	var handlers = this._handlers[eventName] || (this._handlers[eventName] = []);
    	handlers.push(handler);

    	return {
    		cancel: function() {
    			var index = handlers.indexOf(handler);
    			if (~index) handlers.splice(index, 1);
    		}
    	};
    }

    function set(newState) {
    	this._set(assign({}, newState));
    	if (this.root._lock) return;
    	flush(this.root);
    }

    function _set(newState) {
    	var oldState = this._state,
    		changed = {},
    		dirty = false;

    	newState = assign(this._staged, newState);
    	this._staged = {};

    	for (var key in newState) {
    		if (this._differs(newState[key], oldState[key])) changed[key] = dirty = true;
    	}
    	if (!dirty) return;

    	this._state = assign(assign({}, oldState), newState);
    	this._recompute(changed, this._state);
    	if (this._bind) this._bind(changed, this._state);

    	if (this._fragment) {
    		this.fire("state", { changed: changed, current: this._state, previous: oldState });
    		this._fragment.p(changed, this._state);
    		this.fire("update", { changed: changed, current: this._state, previous: oldState });
    	}
    }

    function _stage(newState) {
    	assign(this._staged, newState);
    }

    function setDev(newState) {
    	if (typeof newState !== 'object') {
    		throw new Error(
    			this._debugName + '.set was called without an object of data key-values to update.'
    		);
    	}

    	this._checkReadOnly(newState);
    	set.call(this, newState);
    }

    function callAll(fns) {
    	while (fns && fns.length) fns.shift()();
    }

    function _mount(target, anchor) {
    	this._fragment[this._fragment.i ? 'i' : 'm'](target, anchor || null);
    }

    var protoDev = {
    	destroy: destroyDev,
    	get,
    	fire,
    	on,
    	set: setDev,
    	_recompute: noop,
    	_set,
    	_stage,
    	_mount,
    	_differs
    };

    /* src\core\ui\outputs\MyFormLink.html generated by Svelte v2.16.1 */

    const file = "src\\core\\ui\\outputs\\MyFormLink.html";

    function create_main_fragment(component, ctx) {
    	var if_block_anchor;

    	var if_block = (ctx.field.data != null) && create_if_block(component, ctx);

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (ctx.field.data != null) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block(component, ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (if_block) if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (1:0) {#if field.data != null}
    function create_if_block(component, ctx) {
    	var if_block_anchor;

    	function select_block_type(ctx) {
    		if (ctx.field.data.form != null) return create_if_block_1;
    		return create_else_block;
    	}

    	var current_block_type = select_block_type(ctx);
    	var if_block = current_block_type(component, ctx);

    	return {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(changed, ctx);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(component, ctx);
    				if_block.c();
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},

    		d: function destroy$$1(detach) {
    			if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (4:1) {:else}
    function create_else_block(component, ctx) {
    	var span, raw_value = ctx.field.data.label;

    	return {
    		c: function create() {
    			span = createElement("span");
    			addLoc(span, file, 4, 2, 172);
    		},

    		m: function mount(target, anchor) {
    			insert(target, span, anchor);
    			span.innerHTML = raw_value;
    		},

    		p: function update(changed, ctx) {
    			if ((changed.field) && raw_value !== (raw_value = ctx.field.data.label)) {
    				span.innerHTML = raw_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(span);
    			}
    		}
    	};
    }

    // (2:1) {#if field.data.form != null}
    function create_if_block_1(component, ctx) {
    	var a, raw_value = ctx.field.data.label, a_href_value;

    	return {
    		c: function create() {
    			a = createElement("a");
    			a.href = a_href_value = ctx.app.makeUrl(ctx.field.data.form, ctx.field.data.inputFieldValues);
    			addLoc(a, file, 2, 2, 60);
    		},

    		m: function mount(target, anchor) {
    			insert(target, a, anchor);
    			a.innerHTML = raw_value;
    		},

    		p: function update(changed, ctx) {
    			if ((changed.field) && raw_value !== (raw_value = ctx.field.data.label)) {
    				a.innerHTML = raw_value;
    			}

    			if ((changed.app || changed.field) && a_href_value !== (a_href_value = ctx.app.makeUrl(ctx.field.data.form, ctx.field.data.inputFieldValues))) {
    				a.href = a_href_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(a);
    			}
    		}
    	};
    }

    function SvelteComponent(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) {
    		throw new Error("'target' is a required option");
    	}

    	init(this, options);
    	this._state = assign({}, options.data);
    	if (!('field' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'field'");
    	if (!('app' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'app'");
    	this._intro = true;

    	this._fragment = create_main_fragment(this, this._state);

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);
    	}
    }

    assign(SvelteComponent.prototype, protoDev);

    SvelteComponent.prototype._checkReadOnly = function _checkReadOnly(newState) {
    };

    /* src\components\MenuItem.html generated by Svelte v2.16.1 */

    let currentInstanceId = 0;
    function nested({ item }) {
    	if (item != null && item.children.length > 0) {
    		return {
    			data: item.children[0]
    		};
    	}

    	return { data: null };
    }

    function field({ item }) {
    	return { data: item };
    }

    function data() {
    	currentInstanceId += 1;
    	return {
    		item: null,
    		id: currentInstanceId,
    		app: null,
    		field: null
    	};
    }
    const file$1 = "src\\components\\MenuItem.html";

    function get_each_context(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.child = list[i];
    	return child_ctx;
    }

    function create_main_fragment$1(component, ctx) {
    	var if_block_anchor;

    	function select_block_type(ctx) {
    		if (ctx.item.children.length === 0) return create_if_block$1;
    		return create_else_block_1;
    	}

    	var current_block_type = select_block_type(ctx);
    	var if_block = current_block_type(component, ctx);

    	return {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(changed, ctx);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(component, ctx);
    				if_block.c();
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},

    		d: function destroy$$1(detach) {
    			if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (7:0) {:else}
    function create_else_block_1(component, ctx) {
    	var div, text0, input, input_id_value, text1, if_block1_anchor;

    	function select_block_type_2(ctx) {
    		if (ctx.item.children.length > 1) return create_if_block_3;
    		return create_else_block_2;
    	}

    	var current_block_type = select_block_type_2(ctx);
    	var if_block0 = current_block_type(component, ctx);

    	var if_block1 = (ctx.item.children.length > 1) && create_if_block_2(component, ctx);

    	return {
    		c: function create() {
    			div = createElement("div");
    			if_block0.c();
    			text0 = createText("\r\n\r\n\t");
    			input = createElement("input");
    			text1 = createText("\r\n\t");
    			if (if_block1) if_block1.c();
    			if_block1_anchor = createComment();
    			div.className = "menu top-menu-div";
    			addLoc(div, file$1, 7, 1, 156);
    			setAttribute(input, "type", "checkbox");
    			input.id = input_id_value = "menu" + ctx.id;
    			input.className = "sub-nav-check";
    			addLoc(input, file$1, 15, 1, 373);
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);
    			if_block0.m(div, null);
    			insert(target, text0, anchor);
    			insert(target, input, anchor);
    			insert(target, text1, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert(target, if_block1_anchor, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (current_block_type === (current_block_type = select_block_type_2(ctx)) && if_block0) {
    				if_block0.p(changed, ctx);
    			} else {
    				if_block0.d(1);
    				if_block0 = current_block_type(component, ctx);
    				if_block0.c();
    				if_block0.m(div, null);
    			}

    			if ((changed.id) && input_id_value !== (input_id_value = "menu" + ctx.id)) {
    				input.id = input_id_value;
    			}

    			if (ctx.item.children.length > 1) {
    				if (if_block1) {
    					if_block1.p(changed, ctx);
    				} else {
    					if_block1 = create_if_block_2(component, ctx);
    					if_block1.c();
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(div);
    			}

    			if_block0.d();
    			if (detach) {
    				detachNode(text0);
    				detachNode(input);
    				detachNode(text1);
    			}

    			if (if_block1) if_block1.d(detach);
    			if (detach) {
    				detachNode(if_block1_anchor);
    			}
    		}
    	};
    }

    // (1:0) {#if item.children.length === 0}
    function create_if_block$1(component, ctx) {
    	var if_block_anchor;

    	function select_block_type_1(ctx) {
    		if (ctx.item.form != null) return create_if_block_1$1;
    		return create_else_block$1;
    	}

    	var current_block_type = select_block_type_1(ctx);
    	var if_block = current_block_type(component, ctx);

    	return {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
    				if_block.p(changed, ctx);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(component, ctx);
    				if_block.c();
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},

    		d: function destroy$$1(detach) {
    			if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (11:2) {:else}
    function create_else_block_2(component, ctx) {

    	var myformlink_initial_data = { field: ctx.nested, app: ctx.app };
    	var myformlink = new SvelteComponent({
    		root: component.root,
    		store: component.store,
    		data: myformlink_initial_data
    	});

    	return {
    		c: function create() {
    			myformlink._fragment.c();
    		},

    		m: function mount(target, anchor) {
    			myformlink._mount(target, anchor);
    		},

    		p: function update(changed, ctx) {
    			var myformlink_changes = {};
    			if (changed.nested) myformlink_changes.field = ctx.nested;
    			if (changed.app) myformlink_changes.app = ctx.app;
    			myformlink._set(myformlink_changes);
    		},

    		d: function destroy$$1(detach) {
    			myformlink.destroy(detach);
    		}
    	};
    }

    // (9:2) {#if item.children.length > 1}
    function create_if_block_3(component, ctx) {
    	var label, text_value = ctx.item.label, text, label_for_value;

    	return {
    		c: function create() {
    			label = createElement("label");
    			text = createText(text_value);
    			label.htmlFor = label_for_value = "menu" + ctx.id;
    			label.className = "toggle-sub";
    			setAttribute(label, "onclick", "");
    			addLoc(label, file$1, 9, 2, 225);
    		},

    		m: function mount(target, anchor) {
    			insert(target, label, anchor);
    			append(label, text);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.item) && text_value !== (text_value = ctx.item.label)) {
    				setData(text, text_value);
    			}

    			if ((changed.id) && label_for_value !== (label_for_value = "menu" + ctx.id)) {
    				label.htmlFor = label_for_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(label);
    			}
    		}
    	};
    }

    // (17:1) {#if item.children.length > 1}
    function create_if_block_2(component, ctx) {
    	var ul;

    	var each_value = ctx.item.children;

    	var each_blocks = [];

    	for (var i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block(component, get_each_context(ctx, each_value, i));
    	}

    	return {
    		c: function create() {
    			ul = createElement("ul");

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}
    			ul.className = "sub-nav";
    			addLoc(ul, file$1, 17, 1, 470);
    		},

    		m: function mount(target, anchor) {
    			insert(target, ul, anchor);

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}
    		},

    		p: function update(changed, ctx) {
    			if (changed.item || changed.menu || changed.app) {
    				each_value = ctx.item.children;

    				for (var i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    					} else {
    						each_blocks[i] = create_each_block(component, child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(ul, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}
    				each_blocks.length = each_value.length;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(ul);
    			}

    			destroyEach(each_blocks, detach);
    		}
    	};
    }

    // (19:2) {#each item.children as child}
    function create_each_block(component, ctx) {
    	var li, text;

    	var sveltecomponent_initial_data = {
    	 	item: ctx.child,
    	 	menu: ctx.menu,
    	 	app: ctx.app
    	 };
    	var sveltecomponent = new SvelteComponent$1({
    		root: component.root,
    		store: component.store,
    		data: sveltecomponent_initial_data
    	});

    	return {
    		c: function create() {
    			li = createElement("li");
    			sveltecomponent._fragment.c();
    			text = createText("\r\n\t\t");
    			addLoc(li, file$1, 19, 2, 528);
    		},

    		m: function mount(target, anchor) {
    			insert(target, li, anchor);
    			sveltecomponent._mount(li, null);
    			append(li, text);
    		},

    		p: function update(changed, ctx) {
    			var sveltecomponent_changes = {};
    			if (changed.item) sveltecomponent_changes.item = ctx.child;
    			if (changed.menu) sveltecomponent_changes.menu = ctx.menu;
    			if (changed.app) sveltecomponent_changes.app = ctx.app;
    			sveltecomponent._set(sveltecomponent_changes);
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(li);
    			}

    			sveltecomponent.destroy();
    		}
    	};
    }

    // (4:1) {:else}
    function create_else_block$1(component, ctx) {
    	var span, text_value = ctx.item.label, text;

    	return {
    		c: function create() {
    			span = createElement("span");
    			text = createText(text_value);
    			addLoc(span, file$1, 4, 1, 111);
    		},

    		m: function mount(target, anchor) {
    			insert(target, span, anchor);
    			append(span, text);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.item) && text_value !== (text_value = ctx.item.label)) {
    				setData(text, text_value);
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(span);
    			}
    		}
    	};
    }

    // (2:1) {#if item.form != null}
    function create_if_block_1$1(component, ctx) {

    	var myformlink_initial_data = { field: ctx.field, app: ctx.app };
    	var myformlink = new SvelteComponent({
    		root: component.root,
    		store: component.store,
    		data: myformlink_initial_data
    	});

    	return {
    		c: function create() {
    			myformlink._fragment.c();
    		},

    		m: function mount(target, anchor) {
    			myformlink._mount(target, anchor);
    		},

    		p: function update(changed, ctx) {
    			var myformlink_changes = {};
    			if (changed.field) myformlink_changes.field = ctx.field;
    			if (changed.app) myformlink_changes.app = ctx.app;
    			myformlink._set(myformlink_changes);
    		},

    		d: function destroy$$1(detach) {
    			myformlink.destroy(detach);
    		}
    	};
    }

    function SvelteComponent$1(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) {
    		throw new Error("'target' is a required option");
    	}

    	init(this, options);
    	this._state = assign(data(), options.data);

    	this._recompute({ item: 1 }, this._state);
    	if (!('item' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'item'");

    	if (!('app' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'app'");
    	if (!('id' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'id'");

    	if (!('menu' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'menu'");
    	this._intro = true;

    	this._fragment = create_main_fragment$1(this, this._state);

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);

    		flush(this);
    	}
    }

    assign(SvelteComponent$1.prototype, protoDev);

    SvelteComponent$1.prototype._checkReadOnly = function _checkReadOnly(newState) {
    	if ('nested' in newState && !this._updatingReadonlyProperty) throw new Error("<SvelteComponent>: Cannot set read-only property 'nested'");
    	if ('field' in newState && !this._updatingReadonlyProperty) throw new Error("<SvelteComponent>: Cannot set read-only property 'field'");
    };

    SvelteComponent$1.prototype._recompute = function _recompute(changed, state) {
    	if (changed.item) {
    		if (this._differs(state.nested, (state.nested = nested(state)))) changed.nested = true;
    		if (this._differs(state.field, (state.field = field(state)))) changed.field = true;
    	}
    };

    /* src\components\Menu.html generated by Svelte v2.16.1 */

    function data$1() {
    	return {
    		menu: null,
    		self: this
    	};
    }
    function onstate({ previous }) {
    	if (previous === undefined) {
    		this.set({ self: this });
    	}
    }
    const file$2 = "src\\components\\Menu.html";

    function get_each_context$1(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.item = list[i];
    	return child_ctx;
    }

    function create_main_fragment$2(component, ctx) {
    	var if_block_anchor;

    	var if_block = (ctx.menu != null) && create_if_block$2(component, ctx);

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (ctx.menu != null) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block$2(component, ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (if_block) if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (1:0) {#if menu != null}
    function create_if_block$2(component, ctx) {
    	var ul;

    	var each_value = ctx.menu.children;

    	var each_blocks = [];

    	for (var i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1(component, get_each_context$1(ctx, each_value, i));
    	}

    	return {
    		c: function create() {
    			ul = createElement("ul");

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}
    			ul.className = "menu";
    			addLoc(ul, file$2, 1, 0, 20);
    		},

    		m: function mount(target, anchor) {
    			insert(target, ul, anchor);

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}
    		},

    		p: function update(changed, ctx) {
    			if (changed.menu || changed.self || changed.app) {
    				each_value = ctx.menu.children;

    				for (var i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    					} else {
    						each_blocks[i] = create_each_block$1(component, child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(ul, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}
    				each_blocks.length = each_value.length;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(ul);
    			}

    			destroyEach(each_blocks, detach);
    		}
    	};
    }

    // (3:1) {#each menu.children as item}
    function create_each_block$1(component, ctx) {
    	var li, text;

    	var menuitem_initial_data = {
    	 	item: ctx.item,
    	 	menu: ctx.self,
    	 	app: ctx.app
    	 };
    	var menuitem = new SvelteComponent$1({
    		root: component.root,
    		store: component.store,
    		data: menuitem_initial_data
    	});

    	return {
    		c: function create() {
    			li = createElement("li");
    			menuitem._fragment.c();
    			text = createText("\r\n\t");
    			addLoc(li, file$2, 3, 1, 72);
    		},

    		m: function mount(target, anchor) {
    			insert(target, li, anchor);
    			menuitem._mount(li, null);
    			append(li, text);
    		},

    		p: function update(changed, ctx) {
    			var menuitem_changes = {};
    			if (changed.menu) menuitem_changes.item = ctx.item;
    			if (changed.self) menuitem_changes.menu = ctx.self;
    			if (changed.app) menuitem_changes.app = ctx.app;
    			menuitem._set(menuitem_changes);
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(li);
    			}

    			menuitem.destroy();
    		}
    	};
    }

    function SvelteComponent$2(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) {
    		throw new Error("'target' is a required option");
    	}

    	init(this, options);
    	this._state = assign(data$1(), options.data);
    	if (!('menu' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'menu'");
    	if (!('self' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'self'");
    	if (!('app' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'app'");
    	this._intro = true;

    	this._handlers.state = [onstate];

    	onstate.call(this, { changed: assignTrue({}, this._state), current: this._state });

    	this._fragment = create_main_fragment$2(this, this._state);

    	this.root._oncreate.push(() => {
    		this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
    	});

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);

    		flush(this);
    	}
    }

    assign(SvelteComponent$2.prototype, protoDev);

    SvelteComponent$2.prototype._checkReadOnly = function _checkReadOnly(newState) {
    };

    var bind = function bind(fn, thisArg) {
      return function wrap() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        return fn.apply(thisArg, args);
      };
    };

    /*!
     * Determine if an object is a Buffer
     *
     * @author   Feross Aboukhadijeh <https://feross.org>
     * @license  MIT
     */

    // The _isBuffer check is for Safari 5-7 support, because it's missing
    // Object.prototype.constructor. Remove this eventually
    var isBuffer_1 = function (obj) {
      return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
    };

    function isBuffer (obj) {
      return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
    }

    // For Node v0.10 support. Remove this eventually.
    function isSlowBuffer (obj) {
      return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
    }

    /*global toString:true*/

    // utils is a library of generic helper functions non-specific to axios

    var toString = Object.prototype.toString;

    /**
     * Determine if a value is an Array
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is an Array, otherwise false
     */
    function isArray(val) {
      return toString.call(val) === '[object Array]';
    }

    /**
     * Determine if a value is an ArrayBuffer
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is an ArrayBuffer, otherwise false
     */
    function isArrayBuffer(val) {
      return toString.call(val) === '[object ArrayBuffer]';
    }

    /**
     * Determine if a value is a FormData
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is an FormData, otherwise false
     */
    function isFormData(val) {
      return (typeof FormData !== 'undefined') && (val instanceof FormData);
    }

    /**
     * Determine if a value is a view on an ArrayBuffer
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
     */
    function isArrayBufferView(val) {
      var result;
      if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
        result = ArrayBuffer.isView(val);
      } else {
        result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
      }
      return result;
    }

    /**
     * Determine if a value is a String
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a String, otherwise false
     */
    function isString(val) {
      return typeof val === 'string';
    }

    /**
     * Determine if a value is a Number
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Number, otherwise false
     */
    function isNumber(val) {
      return typeof val === 'number';
    }

    /**
     * Determine if a value is undefined
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if the value is undefined, otherwise false
     */
    function isUndefined(val) {
      return typeof val === 'undefined';
    }

    /**
     * Determine if a value is an Object
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is an Object, otherwise false
     */
    function isObject(val) {
      return val !== null && typeof val === 'object';
    }

    /**
     * Determine if a value is a Date
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Date, otherwise false
     */
    function isDate(val) {
      return toString.call(val) === '[object Date]';
    }

    /**
     * Determine if a value is a File
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a File, otherwise false
     */
    function isFile(val) {
      return toString.call(val) === '[object File]';
    }

    /**
     * Determine if a value is a Blob
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Blob, otherwise false
     */
    function isBlob(val) {
      return toString.call(val) === '[object Blob]';
    }

    /**
     * Determine if a value is a Function
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Function, otherwise false
     */
    function isFunction(val) {
      return toString.call(val) === '[object Function]';
    }

    /**
     * Determine if a value is a Stream
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Stream, otherwise false
     */
    function isStream(val) {
      return isObject(val) && isFunction(val.pipe);
    }

    /**
     * Determine if a value is a URLSearchParams object
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a URLSearchParams object, otherwise false
     */
    function isURLSearchParams(val) {
      return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
    }

    /**
     * Trim excess whitespace off the beginning and end of a string
     *
     * @param {String} str The String to trim
     * @returns {String} The String freed of excess whitespace
     */
    function trim(str) {
      return str.replace(/^\s*/, '').replace(/\s*$/, '');
    }

    /**
     * Determine if we're running in a standard browser environment
     *
     * This allows axios to run in a web worker, and react-native.
     * Both environments support XMLHttpRequest, but not fully standard globals.
     *
     * web workers:
     *  typeof window -> undefined
     *  typeof document -> undefined
     *
     * react-native:
     *  navigator.product -> 'ReactNative'
     */
    function isStandardBrowserEnv() {
      if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {
        return false;
      }
      return (
        typeof window !== 'undefined' &&
        typeof document !== 'undefined'
      );
    }

    /**
     * Iterate over an Array or an Object invoking a function for each item.
     *
     * If `obj` is an Array callback will be called passing
     * the value, index, and complete array for each item.
     *
     * If 'obj' is an Object callback will be called passing
     * the value, key, and complete object for each property.
     *
     * @param {Object|Array} obj The object to iterate
     * @param {Function} fn The callback to invoke for each item
     */
    function forEach(obj, fn) {
      // Don't bother if no value provided
      if (obj === null || typeof obj === 'undefined') {
        return;
      }

      // Force an array if not already something iterable
      if (typeof obj !== 'object' && !isArray(obj)) {
        /*eslint no-param-reassign:0*/
        obj = [obj];
      }

      if (isArray(obj)) {
        // Iterate over array values
        for (var i = 0, l = obj.length; i < l; i++) {
          fn.call(null, obj[i], i, obj);
        }
      } else {
        // Iterate over object keys
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            fn.call(null, obj[key], key, obj);
          }
        }
      }
    }

    /**
     * Accepts varargs expecting each argument to be an object, then
     * immutably merges the properties of each object and returns result.
     *
     * When multiple objects contain the same key the later object in
     * the arguments list will take precedence.
     *
     * Example:
     *
     * ```js
     * var result = merge({foo: 123}, {foo: 456});
     * console.log(result.foo); // outputs 456
     * ```
     *
     * @param {Object} obj1 Object to merge
     * @returns {Object} Result of all merge properties
     */
    function merge(/* obj1, obj2, obj3, ... */) {
      var result = {};
      function assignValue(val, key) {
        if (typeof result[key] === 'object' && typeof val === 'object') {
          result[key] = merge(result[key], val);
        } else {
          result[key] = val;
        }
      }

      for (var i = 0, l = arguments.length; i < l; i++) {
        forEach(arguments[i], assignValue);
      }
      return result;
    }

    /**
     * Extends object a by mutably adding to it the properties of object b.
     *
     * @param {Object} a The object to be extended
     * @param {Object} b The object to copy properties from
     * @param {Object} thisArg The object to bind function to
     * @return {Object} The resulting value of object a
     */
    function extend(a, b, thisArg) {
      forEach(b, function assignValue(val, key) {
        if (thisArg && typeof val === 'function') {
          a[key] = bind(val, thisArg);
        } else {
          a[key] = val;
        }
      });
      return a;
    }

    var utils = {
      isArray: isArray,
      isArrayBuffer: isArrayBuffer,
      isBuffer: isBuffer_1,
      isFormData: isFormData,
      isArrayBufferView: isArrayBufferView,
      isString: isString,
      isNumber: isNumber,
      isObject: isObject,
      isUndefined: isUndefined,
      isDate: isDate,
      isFile: isFile,
      isBlob: isBlob,
      isFunction: isFunction,
      isStream: isStream,
      isURLSearchParams: isURLSearchParams,
      isStandardBrowserEnv: isStandardBrowserEnv,
      forEach: forEach,
      merge: merge,
      extend: extend,
      trim: trim
    };

    var global$1 = (typeof global !== "undefined" ? global :
                typeof self !== "undefined" ? self :
                typeof window !== "undefined" ? window : {});

    // shim for using process in browser
    // based off https://github.com/defunctzombie/node-process/blob/master/browser.js

    function defaultSetTimout() {
        throw new Error('setTimeout has not been defined');
    }
    function defaultClearTimeout () {
        throw new Error('clearTimeout has not been defined');
    }
    var cachedSetTimeout = defaultSetTimout;
    var cachedClearTimeout = defaultClearTimeout;
    if (typeof global$1.setTimeout === 'function') {
        cachedSetTimeout = setTimeout;
    }
    if (typeof global$1.clearTimeout === 'function') {
        cachedClearTimeout = clearTimeout;
    }

    function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
            //normal enviroments in sane situations
            return setTimeout(fun, 0);
        }
        // if setTimeout wasn't available but was latter defined
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
            cachedSetTimeout = setTimeout;
            return setTimeout(fun, 0);
        }
        try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedSetTimeout(fun, 0);
        } catch(e){
            try {
                // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                return cachedSetTimeout.call(null, fun, 0);
            } catch(e){
                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                return cachedSetTimeout.call(this, fun, 0);
            }
        }


    }
    function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
            //normal enviroments in sane situations
            return clearTimeout(marker);
        }
        // if clearTimeout wasn't available but was latter defined
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
            cachedClearTimeout = clearTimeout;
            return clearTimeout(marker);
        }
        try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedClearTimeout(marker);
        } catch (e){
            try {
                // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                return cachedClearTimeout.call(null, marker);
            } catch (e){
                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                return cachedClearTimeout.call(this, marker);
            }
        }



    }
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;

    function cleanUpNextTick() {
        if (!draining || !currentQueue) {
            return;
        }
        draining = false;
        if (currentQueue.length) {
            queue = currentQueue.concat(queue);
        } else {
            queueIndex = -1;
        }
        if (queue.length) {
            drainQueue();
        }
    }

    function drainQueue() {
        if (draining) {
            return;
        }
        var timeout = runTimeout(cleanUpNextTick);
        draining = true;

        var len = queue.length;
        while(len) {
            currentQueue = queue;
            queue = [];
            while (++queueIndex < len) {
                if (currentQueue) {
                    currentQueue[queueIndex].run();
                }
            }
            queueIndex = -1;
            len = queue.length;
        }
        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
    }
    function nextTick(fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
            for (var i = 1; i < arguments.length; i++) {
                args[i - 1] = arguments[i];
            }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
            runTimeout(drainQueue);
        }
    }
    // v8 likes predictible objects
    function Item(fun, array) {
        this.fun = fun;
        this.array = array;
    }
    Item.prototype.run = function () {
        this.fun.apply(null, this.array);
    };
    var title = 'browser';
    var platform = 'browser';
    var browser = true;
    var env = {};
    var argv = [];
    var version = ''; // empty string to avoid regexp issues
    var versions = {};
    var release = {};
    var config = {};

    function noop$1() {}

    var on$1 = noop$1;
    var addListener$1 = noop$1;
    var once = noop$1;
    var off = noop$1;
    var removeListener$1 = noop$1;
    var removeAllListeners = noop$1;
    var emit = noop$1;

    function binding(name) {
        throw new Error('process.binding is not supported');
    }

    function cwd () { return '/' }
    function chdir (dir) {
        throw new Error('process.chdir is not supported');
    }function umask() { return 0; }

    // from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
    var performance$1 = global$1.performance || {};
    var performanceNow =
      performance$1.now        ||
      performance$1.mozNow     ||
      performance$1.msNow      ||
      performance$1.oNow       ||
      performance$1.webkitNow  ||
      function(){ return (new Date()).getTime() };

    // generate timestamp or delta
    // see http://nodejs.org/api/process.html#process_process_hrtime
    function hrtime(previousTimestamp){
      var clocktime = performanceNow.call(performance$1)*1e-3;
      var seconds = Math.floor(clocktime);
      var nanoseconds = Math.floor((clocktime%1)*1e9);
      if (previousTimestamp) {
        seconds = seconds - previousTimestamp[0];
        nanoseconds = nanoseconds - previousTimestamp[1];
        if (nanoseconds<0) {
          seconds--;
          nanoseconds += 1e9;
        }
      }
      return [seconds,nanoseconds]
    }

    var startTime = new Date();
    function uptime() {
      var currentTime = new Date();
      var dif = currentTime - startTime;
      return dif / 1000;
    }

    var process = {
      nextTick: nextTick,
      title: title,
      browser: browser,
      env: env,
      argv: argv,
      version: version,
      versions: versions,
      on: on$1,
      addListener: addListener$1,
      once: once,
      off: off,
      removeListener: removeListener$1,
      removeAllListeners: removeAllListeners,
      emit: emit,
      binding: binding,
      cwd: cwd,
      chdir: chdir,
      umask: umask,
      hrtime: hrtime,
      platform: platform,
      release: release,
      config: config,
      uptime: uptime
    };

    var normalizeHeaderName = function normalizeHeaderName(headers, normalizedName) {
      utils.forEach(headers, function processHeader(value, name) {
        if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
          headers[normalizedName] = value;
          delete headers[name];
        }
      });
    };

    /**
     * Update an Error with the specified config, error code, and response.
     *
     * @param {Error} error The error to update.
     * @param {Object} config The config.
     * @param {string} [code] The error code (for example, 'ECONNABORTED').
     * @param {Object} [request] The request.
     * @param {Object} [response] The response.
     * @returns {Error} The error.
     */
    var enhanceError = function enhanceError(error, config, code, request, response) {
      error.config = config;
      if (code) {
        error.code = code;
      }
      error.request = request;
      error.response = response;
      return error;
    };

    /**
     * Create an Error with the specified message, config, error code, request and response.
     *
     * @param {string} message The error message.
     * @param {Object} config The config.
     * @param {string} [code] The error code (for example, 'ECONNABORTED').
     * @param {Object} [request] The request.
     * @param {Object} [response] The response.
     * @returns {Error} The created error.
     */
    var createError = function createError(message, config, code, request, response) {
      var error = new Error(message);
      return enhanceError(error, config, code, request, response);
    };

    /**
     * Resolve or reject a Promise based on response status.
     *
     * @param {Function} resolve A function that resolves the promise.
     * @param {Function} reject A function that rejects the promise.
     * @param {object} response The response.
     */
    var settle = function settle(resolve, reject, response) {
      var validateStatus = response.config.validateStatus;
      // Note: status is not exposed by XDomainRequest
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve(response);
      } else {
        reject(createError(
          'Request failed with status code ' + response.status,
          response.config,
          null,
          response.request,
          response
        ));
      }
    };

    function encode(val) {
      return encodeURIComponent(val).
        replace(/%40/gi, '@').
        replace(/%3A/gi, ':').
        replace(/%24/g, '$').
        replace(/%2C/gi, ',').
        replace(/%20/g, '+').
        replace(/%5B/gi, '[').
        replace(/%5D/gi, ']');
    }

    /**
     * Build a URL by appending params to the end
     *
     * @param {string} url The base of the url (e.g., http://www.google.com)
     * @param {object} [params] The params to be appended
     * @returns {string} The formatted url
     */
    var buildURL = function buildURL(url, params, paramsSerializer) {
      /*eslint no-param-reassign:0*/
      if (!params) {
        return url;
      }

      var serializedParams;
      if (paramsSerializer) {
        serializedParams = paramsSerializer(params);
      } else if (utils.isURLSearchParams(params)) {
        serializedParams = params.toString();
      } else {
        var parts = [];

        utils.forEach(params, function serialize(val, key) {
          if (val === null || typeof val === 'undefined') {
            return;
          }

          if (utils.isArray(val)) {
            key = key + '[]';
          }

          if (!utils.isArray(val)) {
            val = [val];
          }

          utils.forEach(val, function parseValue(v) {
            if (utils.isDate(v)) {
              v = v.toISOString();
            } else if (utils.isObject(v)) {
              v = JSON.stringify(v);
            }
            parts.push(encode(key) + '=' + encode(v));
          });
        });

        serializedParams = parts.join('&');
      }

      if (serializedParams) {
        url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
      }

      return url;
    };

    /**
     * Parse headers into an object
     *
     * ```
     * Date: Wed, 27 Aug 2014 08:58:49 GMT
     * Content-Type: application/json
     * Connection: keep-alive
     * Transfer-Encoding: chunked
     * ```
     *
     * @param {String} headers Headers needing to be parsed
     * @returns {Object} Headers parsed into an object
     */
    var parseHeaders = function parseHeaders(headers) {
      var parsed = {};
      var key;
      var val;
      var i;

      if (!headers) { return parsed; }

      utils.forEach(headers.split('\n'), function parser(line) {
        i = line.indexOf(':');
        key = utils.trim(line.substr(0, i)).toLowerCase();
        val = utils.trim(line.substr(i + 1));

        if (key) {
          parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
        }
      });

      return parsed;
    };

    var isURLSameOrigin = (
      utils.isStandardBrowserEnv() ?

      // Standard browser envs have full support of the APIs needed to test
      // whether the request URL is of the same origin as current location.
      (function standardBrowserEnv() {
        var msie = /(msie|trident)/i.test(navigator.userAgent);
        var urlParsingNode = document.createElement('a');
        var originURL;

        /**
        * Parse a URL to discover it's components
        *
        * @param {String} url The URL to be parsed
        * @returns {Object}
        */
        function resolveURL(url) {
          var href = url;

          if (msie) {
            // IE needs attribute set twice to normalize properties
            urlParsingNode.setAttribute('href', href);
            href = urlParsingNode.href;
          }

          urlParsingNode.setAttribute('href', href);

          // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
          return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
                      urlParsingNode.pathname :
                      '/' + urlParsingNode.pathname
          };
        }

        originURL = resolveURL(window.location.href);

        /**
        * Determine if a URL shares the same origin as the current location
        *
        * @param {String} requestURL The URL to test
        * @returns {boolean} True if URL shares the same origin, otherwise false
        */
        return function isURLSameOrigin(requestURL) {
          var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
          return (parsed.protocol === originURL.protocol &&
                parsed.host === originURL.host);
        };
      })() :

      // Non standard browser envs (web workers, react-native) lack needed support.
      (function nonStandardBrowserEnv() {
        return function isURLSameOrigin() {
          return true;
        };
      })()
    );

    // btoa polyfill for IE<10 courtesy https://github.com/davidchambers/Base64.js

    var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

    function E() {
      this.message = 'String contains an invalid character';
    }
    E.prototype = new Error;
    E.prototype.code = 5;
    E.prototype.name = 'InvalidCharacterError';

    function btoa(input) {
      var str = String(input);
      var output = '';
      for (
        // initialize result and counter
        var block, charCode, idx = 0, map = chars;
        // if the next str index does not exist:
        //   change the mapping table to "="
        //   check if d has no fractional digits
        str.charAt(idx | 0) || (map = '=', idx % 1);
        // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
        output += map.charAt(63 & block >> 8 - idx % 1 * 8)
      ) {
        charCode = str.charCodeAt(idx += 3 / 4);
        if (charCode > 0xFF) {
          throw new E();
        }
        block = block << 8 | charCode;
      }
      return output;
    }

    var btoa_1 = btoa;

    var cookies = (
      utils.isStandardBrowserEnv() ?

      // Standard browser envs support document.cookie
      (function standardBrowserEnv() {
        return {
          write: function write(name, value, expires, path, domain, secure) {
            var cookie = [];
            cookie.push(name + '=' + encodeURIComponent(value));

            if (utils.isNumber(expires)) {
              cookie.push('expires=' + new Date(expires).toGMTString());
            }

            if (utils.isString(path)) {
              cookie.push('path=' + path);
            }

            if (utils.isString(domain)) {
              cookie.push('domain=' + domain);
            }

            if (secure === true) {
              cookie.push('secure');
            }

            document.cookie = cookie.join('; ');
          },

          read: function read(name) {
            var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
            return (match ? decodeURIComponent(match[3]) : null);
          },

          remove: function remove(name) {
            this.write(name, '', Date.now() - 86400000);
          }
        };
      })() :

      // Non standard browser env (web workers, react-native) lack needed support.
      (function nonStandardBrowserEnv() {
        return {
          write: function write() {},
          read: function read() { return null; },
          remove: function remove() {}
        };
      })()
    );

    var btoa$1 = (typeof window !== 'undefined' && window.btoa && window.btoa.bind(window)) || btoa_1;

    var xhr = function xhrAdapter(config$$1) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        var requestData = config$$1.data;
        var requestHeaders = config$$1.headers;

        if (utils.isFormData(requestData)) {
          delete requestHeaders['Content-Type']; // Let the browser set it
        }

        var request = new XMLHttpRequest();
        var loadEvent = 'onreadystatechange';
        var xDomain = false;

        // For IE 8/9 CORS support
        // Only supports POST and GET calls and doesn't returns the response headers.
        // DON'T do this for testing b/c XMLHttpRequest is mocked, not XDomainRequest.
        if (process.env.NODE_ENV !== 'test' &&
            typeof window !== 'undefined' &&
            window.XDomainRequest && !('withCredentials' in request) &&
            !isURLSameOrigin(config$$1.url)) {
          request = new window.XDomainRequest();
          loadEvent = 'onload';
          xDomain = true;
          request.onprogress = function handleProgress() {};
          request.ontimeout = function handleTimeout() {};
        }

        // HTTP basic authentication
        if (config$$1.auth) {
          var username = config$$1.auth.username || '';
          var password = config$$1.auth.password || '';
          requestHeaders.Authorization = 'Basic ' + btoa$1(username + ':' + password);
        }

        request.open(config$$1.method.toUpperCase(), buildURL(config$$1.url, config$$1.params, config$$1.paramsSerializer), true);

        // Set the request timeout in MS
        request.timeout = config$$1.timeout;

        // Listen for ready state
        request[loadEvent] = function handleLoad() {
          if (!request || (request.readyState !== 4 && !xDomain)) {
            return;
          }

          // The request errored out and we didn't get a response, this will be
          // handled by onerror instead
          // With one exception: request that using file: protocol, most browsers
          // will return status as 0 even though it's a successful request
          if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
            return;
          }

          // Prepare the response
          var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
          var responseData = !config$$1.responseType || config$$1.responseType === 'text' ? request.responseText : request.response;
          var response = {
            data: responseData,
            // IE sends 1223 instead of 204 (https://github.com/mzabriskie/axios/issues/201)
            status: request.status === 1223 ? 204 : request.status,
            statusText: request.status === 1223 ? 'No Content' : request.statusText,
            headers: responseHeaders,
            config: config$$1,
            request: request
          };

          settle(resolve, reject, response);

          // Clean up request
          request = null;
        };

        // Handle low level network errors
        request.onerror = function handleError() {
          // Real errors are hidden from us by the browser
          // onerror should only fire if it's a network error
          reject(createError('Network Error', config$$1, null, request));

          // Clean up request
          request = null;
        };

        // Handle timeout
        request.ontimeout = function handleTimeout() {
          reject(createError('timeout of ' + config$$1.timeout + 'ms exceeded', config$$1, 'ECONNABORTED',
            request));

          // Clean up request
          request = null;
        };

        // Add xsrf header
        // This is only done if running in a standard browser environment.
        // Specifically not if we're in a web worker, or react-native.
        if (utils.isStandardBrowserEnv()) {
          var cookies$$1 = cookies;

          // Add xsrf header
          var xsrfValue = (config$$1.withCredentials || isURLSameOrigin(config$$1.url)) && config$$1.xsrfCookieName ?
              cookies$$1.read(config$$1.xsrfCookieName) :
              undefined;

          if (xsrfValue) {
            requestHeaders[config$$1.xsrfHeaderName] = xsrfValue;
          }
        }

        // Add headers to the request
        if ('setRequestHeader' in request) {
          utils.forEach(requestHeaders, function setRequestHeader(val, key) {
            if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
              // Remove Content-Type if data is undefined
              delete requestHeaders[key];
            } else {
              // Otherwise add header to the request
              request.setRequestHeader(key, val);
            }
          });
        }

        // Add withCredentials to request if needed
        if (config$$1.withCredentials) {
          request.withCredentials = true;
        }

        // Add responseType to request if needed
        if (config$$1.responseType) {
          try {
            request.responseType = config$$1.responseType;
          } catch (e) {
            // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
            // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
            if (config$$1.responseType !== 'json') {
              throw e;
            }
          }
        }

        // Handle progress if needed
        if (typeof config$$1.onDownloadProgress === 'function') {
          request.addEventListener('progress', config$$1.onDownloadProgress);
        }

        // Not all browsers support upload events
        if (typeof config$$1.onUploadProgress === 'function' && request.upload) {
          request.upload.addEventListener('progress', config$$1.onUploadProgress);
        }

        if (config$$1.cancelToken) {
          // Handle cancellation
          config$$1.cancelToken.promise.then(function onCanceled(cancel) {
            if (!request) {
              return;
            }

            request.abort();
            reject(cancel);
            // Clean up request
            request = null;
          });
        }

        if (requestData === undefined) {
          requestData = null;
        }

        // Send the request
        request.send(requestData);
      });
    };

    var DEFAULT_CONTENT_TYPE = {
      'Content-Type': 'application/x-www-form-urlencoded'
    };

    function setContentTypeIfUnset(headers, value) {
      if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
        headers['Content-Type'] = value;
      }
    }

    function getDefaultAdapter() {
      var adapter;
      if (typeof XMLHttpRequest !== 'undefined') {
        // For browsers use XHR adapter
        adapter = xhr;
      } else if (typeof process !== 'undefined') {
        // For node use HTTP adapter
        adapter = xhr;
      }
      return adapter;
    }

    var defaults = {
      adapter: getDefaultAdapter(),

      transformRequest: [function transformRequest(data, headers) {
        normalizeHeaderName(headers, 'Content-Type');
        if (utils.isFormData(data) ||
          utils.isArrayBuffer(data) ||
          utils.isBuffer(data) ||
          utils.isStream(data) ||
          utils.isFile(data) ||
          utils.isBlob(data)
        ) {
          return data;
        }
        if (utils.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils.isURLSearchParams(data)) {
          setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
          return data.toString();
        }
        if (utils.isObject(data)) {
          setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
          return JSON.stringify(data);
        }
        return data;
      }],

      transformResponse: [function transformResponse(data) {
        /*eslint no-param-reassign:0*/
        if (typeof data === 'string') {
          try {
            data = JSON.parse(data);
          } catch (e) { /* Ignore */ }
        }
        return data;
      }],

      timeout: 0,

      xsrfCookieName: 'XSRF-TOKEN',
      xsrfHeaderName: 'X-XSRF-TOKEN',

      maxContentLength: -1,

      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      }
    };

    defaults.headers = {
      common: {
        'Accept': 'application/json, text/plain, */*'
      }
    };

    utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
      defaults.headers[method] = {};
    });

    utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
      defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
    });

    var defaults_1 = defaults;

    function InterceptorManager() {
      this.handlers = [];
    }

    /**
     * Add a new interceptor to the stack
     *
     * @param {Function} fulfilled The function to handle `then` for a `Promise`
     * @param {Function} rejected The function to handle `reject` for a `Promise`
     *
     * @return {Number} An ID used to remove interceptor later
     */
    InterceptorManager.prototype.use = function use(fulfilled, rejected) {
      this.handlers.push({
        fulfilled: fulfilled,
        rejected: rejected
      });
      return this.handlers.length - 1;
    };

    /**
     * Remove an interceptor from the stack
     *
     * @param {Number} id The ID that was returned by `use`
     */
    InterceptorManager.prototype.eject = function eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    };

    /**
     * Iterate over all the registered interceptors
     *
     * This method is particularly useful for skipping over any
     * interceptors that may have become `null` calling `eject`.
     *
     * @param {Function} fn The function to call for each interceptor
     */
    InterceptorManager.prototype.forEach = function forEach(fn) {
      utils.forEach(this.handlers, function forEachHandler(h) {
        if (h !== null) {
          fn(h);
        }
      });
    };

    var InterceptorManager_1 = InterceptorManager;

    /**
     * Transform the data for a request or a response
     *
     * @param {Object|String} data The data to be transformed
     * @param {Array} headers The headers for the request or response
     * @param {Array|Function} fns A single function or Array of functions
     * @returns {*} The resulting transformed data
     */
    var transformData = function transformData(data, headers, fns) {
      /*eslint no-param-reassign:0*/
      utils.forEach(fns, function transform(fn) {
        data = fn(data, headers);
      });

      return data;
    };

    var isCancel = function isCancel(value) {
      return !!(value && value.__CANCEL__);
    };

    /**
     * Throws a `Cancel` if cancellation has been requested.
     */
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
    }

    /**
     * Dispatch a request to the server using the configured adapter.
     *
     * @param {object} config The config that is to be used for the request
     * @returns {Promise} The Promise to be fulfilled
     */
    var dispatchRequest = function dispatchRequest(config) {
      throwIfCancellationRequested(config);

      // Ensure headers exist
      config.headers = config.headers || {};

      // Transform request data
      config.data = transformData(
        config.data,
        config.headers,
        config.transformRequest
      );

      // Flatten headers
      config.headers = utils.merge(
        config.headers.common || {},
        config.headers[config.method] || {},
        config.headers || {}
      );

      utils.forEach(
        ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
        function cleanHeaderConfig(method) {
          delete config.headers[method];
        }
      );

      var adapter = config.adapter || defaults_1.adapter;

      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);

        // Transform response data
        response.data = transformData(
          response.data,
          response.headers,
          config.transformResponse
        );

        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config);

          // Transform response data
          if (reason && reason.response) {
            reason.response.data = transformData(
              reason.response.data,
              reason.response.headers,
              config.transformResponse
            );
          }
        }

        return Promise.reject(reason);
      });
    };

    /**
     * Determines whether the specified URL is absolute
     *
     * @param {string} url The URL to test
     * @returns {boolean} True if the specified URL is absolute, otherwise false
     */
    var isAbsoluteURL = function isAbsoluteURL(url) {
      // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
      // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
      // by any combination of letters, digits, plus, period, or hyphen.
      return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
    };

    /**
     * Creates a new URL by combining the specified URLs
     *
     * @param {string} baseURL The base URL
     * @param {string} relativeURL The relative URL
     * @returns {string} The combined URL
     */
    var combineURLs = function combineURLs(baseURL, relativeURL) {
      return relativeURL
        ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
        : baseURL;
    };

    /**
     * Create a new instance of Axios
     *
     * @param {Object} instanceConfig The default config for the instance
     */
    function Axios(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager_1(),
        response: new InterceptorManager_1()
      };
    }

    /**
     * Dispatch a request
     *
     * @param {Object} config The config specific for this request (merged with this.defaults)
     */
    Axios.prototype.request = function request(config) {
      /*eslint no-param-reassign:0*/
      // Allow for axios('example/url'[, config]) a la fetch API
      if (typeof config === 'string') {
        config = utils.merge({
          url: arguments[0]
        }, arguments[1]);
      }

      config = utils.merge(defaults_1, this.defaults, { method: 'get' }, config);
      config.method = config.method.toLowerCase();

      // Support baseURL config
      if (config.baseURL && !isAbsoluteURL(config.url)) {
        config.url = combineURLs(config.baseURL, config.url);
      }

      // Hook up interceptors middleware
      var chain = [dispatchRequest, undefined];
      var promise = Promise.resolve(config);

      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        chain.unshift(interceptor.fulfilled, interceptor.rejected);
      });

      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        chain.push(interceptor.fulfilled, interceptor.rejected);
      });

      while (chain.length) {
        promise = promise.then(chain.shift(), chain.shift());
      }

      return promise;
    };

    // Provide aliases for supported request methods
    utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
      /*eslint func-names:0*/
      Axios.prototype[method] = function(url, config) {
        return this.request(utils.merge(config || {}, {
          method: method,
          url: url
        }));
      };
    });

    utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
      /*eslint func-names:0*/
      Axios.prototype[method] = function(url, data, config) {
        return this.request(utils.merge(config || {}, {
          method: method,
          url: url,
          data: data
        }));
      };
    });

    var Axios_1 = Axios;

    /**
     * A `Cancel` is an object that is thrown when an operation is canceled.
     *
     * @class
     * @param {string=} message The message.
     */
    function Cancel(message) {
      this.message = message;
    }

    Cancel.prototype.toString = function toString() {
      return 'Cancel' + (this.message ? ': ' + this.message : '');
    };

    Cancel.prototype.__CANCEL__ = true;

    var Cancel_1 = Cancel;

    /**
     * A `CancelToken` is an object that can be used to request cancellation of an operation.
     *
     * @class
     * @param {Function} executor The executor function.
     */
    function CancelToken(executor) {
      if (typeof executor !== 'function') {
        throw new TypeError('executor must be a function.');
      }

      var resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve) {
        resolvePromise = resolve;
      });

      var token = this;
      executor(function cancel(message) {
        if (token.reason) {
          // Cancellation has already been requested
          return;
        }

        token.reason = new Cancel_1(message);
        resolvePromise(token.reason);
      });
    }

    /**
     * Throws a `Cancel` if cancellation has been requested.
     */
    CancelToken.prototype.throwIfRequested = function throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    };

    /**
     * Returns an object that contains a new `CancelToken` and a function that, when called,
     * cancels the `CancelToken`.
     */
    CancelToken.source = function source() {
      var cancel;
      var token = new CancelToken(function executor(c) {
        cancel = c;
      });
      return {
        token: token,
        cancel: cancel
      };
    };

    var CancelToken_1 = CancelToken;

    /**
     * Syntactic sugar for invoking a function and expanding an array for arguments.
     *
     * Common use case would be to use `Function.prototype.apply`.
     *
     *  ```js
     *  function f(x, y, z) {}
     *  var args = [1, 2, 3];
     *  f.apply(null, args);
     *  ```
     *
     * With `spread` this example can be re-written.
     *
     *  ```js
     *  spread(function(x, y, z) {})([1, 2, 3]);
     *  ```
     *
     * @param {Function} callback
     * @returns {Function}
     */
    var spread$1 = function spread(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    };

    /**
     * Create an instance of Axios
     *
     * @param {Object} defaultConfig The default config for the instance
     * @return {Axios} A new instance of Axios
     */
    function createInstance(defaultConfig) {
      var context = new Axios_1(defaultConfig);
      var instance = bind(Axios_1.prototype.request, context);

      // Copy axios.prototype to instance
      utils.extend(instance, Axios_1.prototype, context);

      // Copy context to instance
      utils.extend(instance, context);

      return instance;
    }

    // Create the default instance to be exported
    var axios = createInstance(defaults_1);

    // Expose Axios class to allow class inheritance
    axios.Axios = Axios_1;

    // Factory for creating new instances
    axios.create = function create(instanceConfig) {
      return createInstance(utils.merge(defaults_1, instanceConfig));
    };

    // Expose Cancel & CancelToken
    axios.Cancel = Cancel_1;
    axios.CancelToken = CancelToken_1;
    axios.isCancel = isCancel;

    // Expose all/spread
    axios.all = function all(promises) {
      return Promise.all(promises);
    };
    axios.spread = spread$1;

    var axios_1 = axios;

    // Allow use of default import syntax in TypeScript
    var default_1 = axios;
    axios_1.default = default_1;

    var axios$1 = axios_1;

    /**
     * Represents metadata for a single input field. *
     */
    var InputFieldMetadata = /** @class */ (function () {
        function InputFieldMetadata(metadata) {
            for (var _i = 0, _a = Object.keys(metadata); _i < _a.length; _i++) {
                var property = _a[_i];
                this[property] = metadata[property];
            }
        }
        /**
         * Gets value of a custom property.
         * @param name name of the custom property to get.
         * @returns value of the custom property or null if the property is undefined.
         */
        InputFieldMetadata.prototype.getCustomProperty = function (name) {
            if (this.customProperties != null && this.customProperties[name]) {
                return this.customProperties[name];
            }
            return null;
        };
        return InputFieldMetadata;
    }());

    /**
     * Represents metadata for a single output field.
     */
    var OutputFieldMetadata = /** @class */ (function () {
        function OutputFieldMetadata(metadata) {
            for (var _i = 0, _a = Object.keys(metadata); _i < _a.length; _i++) {
                var property = _a[_i];
                this[property] = metadata[property];
            }
            // Special case for "paginated-data", to ensure that each column is also
            // an instance of OutputFieldMetadata class, instead of a plain javascript object.
            if (this.customProperties != null && this.customProperties.columns != null) {
                for (var columnPropertyName in this.customProperties.columns) {
                    // Convert column to OutputFieldMetadata instance.
                    var metadataAsJsonObject = this.customProperties.columns[columnPropertyName];
                    this.customProperties.columns[columnPropertyName] = new OutputFieldMetadata(metadataAsJsonObject);
                }
            }
        }
        /**
         * Gets value of a custom property.
         * @param name name of the custom property to get.
         * @returns value of the custom property or null if the property is undefined.
         */
        OutputFieldMetadata.prototype.getCustomProperty = function (name) {
            if (this.customProperties != null && this.customProperties[name]) {
                return this.customProperties[name];
            }
            return null;
        };
        return OutputFieldMetadata;
    }());

    /**
     * Encapsulates all information needed to render a form.
     */
    var FormMetadata = /** @class */ (function () {
        function FormMetadata(metadata) {
            for (var _i = 0, _a = Object.keys(metadata); _i < _a.length; _i++) {
                var property = _a[_i];
                this[property] = metadata[property];
            }
            this.inputFields = metadata.inputFields.map(function (t) { return new InputFieldMetadata(t); });
            this.outputFields = metadata.outputFields.map(function (t) { return new OutputFieldMetadata(t); });
        }
        /**
         * Gets value of a custom property.
         * @param name name of the custom property to get.
         * @returns value of the custom property or null if the property is undefined.
         */
        FormMetadata.prototype.getCustomProperty = function (name) {
            if (this.customProperties != null && this.customProperties[name]) {
                return this.customProperties[name];
            }
            return null;
        };
        return FormMetadata;
    }());

    /**
     * Represents a reference to a form.
     */

    /**
     * Represents response of a form.
     */
    var FormResponse = /** @class */ (function (_super) {
        __extends(FormResponse, _super);
        function FormResponse() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return FormResponse;
    }(Object));

    /**
     * Represents a function.
     */
    var ClientFunctionMetadata = /** @class */ (function () {
        function ClientFunctionMetadata(metadata) {
            for (var _i = 0, _a = Object.keys(metadata); _i < _a.length; _i++) {
                var property = _a[_i];
                this[property] = metadata[property];
            }
        }
        /**
         * Gets value of a custom property.
         * @param name name of the custom property to get.
         * @returns value of the custom property or null if the property is undefined.
         */
        ClientFunctionMetadata.prototype.getCustomProperty = function (name) {
            if (this.customProperties != null && this.customProperties[name]) {
                return this.customProperties[name];
            }
            return null;
        };
        return ClientFunctionMetadata;
    }());

    /**
     * Represents a function which can be run at a specific time during form's lifecycle.
     */
    var EventHandlerMetadata = /** @class */ (function (_super) {
        __extends(EventHandlerMetadata, _super);
        function EventHandlerMetadata() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return EventHandlerMetadata;
    }(ClientFunctionMetadata));

    /**
     * Metadata describing how to handle the response.
     */
    var FormResponseMetadata = /** @class */ (function () {
        function FormResponseMetadata() {
        }
        return FormResponseMetadata;
    }());

    var axios$2 = axios$1;
    var UmfServer = /** @class */ (function () {
        /**
         * Creates a new instance of UmfApp.
         */
        function UmfServer(getMetadataUrl, postFormUrl, getMenuUrl) {
            this.eventHandlers = {};
            this.getMetadataUrl = getMetadataUrl;
            this.postFormUrl = postFormUrl;
            this.getMenuUrl = getMenuUrl;
        }
        UmfServer.prototype.on = function (event, handler) {
            this.eventHandlers[event] = this.eventHandlers[event] || [];
            this.eventHandlers[event].push(handler);
        };
        UmfServer.prototype.fire = function (event, params) {
            var handlersForEvent = this.eventHandlers[event];
            if (handlersForEvent != null && handlersForEvent.length > 0) {
                for (var _i = 0, handlersForEvent_1 = handlersForEvent; _i < handlersForEvent_1.length; _i++) {
                    var handler = handlersForEvent_1[_i];
                    handler(params);
                }
            }
        };
        UmfServer.prototype.getMetadata = function (formId) {
            var _this = this;
            this.fire("request:started");
            return axios$2.get(this.getMetadataUrl + "/" + formId).then(function (response) {
                _this.fire("request:completed");
                return response.data;
            }).catch(function (e) {
                // tslint:disable-next-line:no-console
                console.warn("Did not find form \"" + formId + "\".");
                _this.fire("request:completed");
                return null;
            });
        };
        UmfServer.prototype.getAllMetadata = function () {
            var _this = this;
            this.fire("request:started");
            return axios$2
                .get(this.getMetadataUrl, {
                headers: {
                    "Content-Type": "application/json"
                }
            })
                .then(function (response) {
                _this.fire("request:completed");
                return response.data;
            });
        };
        UmfServer.prototype.getAllMenu = function () {
            return axios$2.get(this.getMenuUrl).then(function (response) {
                return response.data;
            });
        };
        UmfServer.prototype.postForm = function (form, data) {
            var _this = this;
            this.fire("request:started");
            return axios$2.post(this.postFormUrl, JSON.stringify([{
                    Form: form,
                    RequestId: 1,
                    InputFieldValues: data
                }]), {
                headers: {
                    "Content-Type": "application/json"
                }
            }).then(function (response) {
                var invokeFormResponses = response.data;
                // Make sure metadata is never null.
                invokeFormResponses[0].data.metadata = invokeFormResponses[0].data.metadata || new FormResponseMetadata();
                _this.fire("request:completed");
                return invokeFormResponses[0].data;
            }).catch(function (error) {
                _this.fire("request:completed", error.response.data.error);
                return null;
            });
        };
        return UmfServer;
    }());

    var FormEventArguments = /** @class */ (function () {
        function FormEventArguments(app) {
            this.app = app;
        }
        return FormEventArguments;
    }());

    var FormResponseEventArguments = /** @class */ (function (_super) {
        __extends(FormResponseEventArguments, _super);
        function FormResponseEventArguments(app, response) {
            var _this = _super.call(this, app) || this;
            _this.response = response;
            return _this;
        }
        return FormResponseEventArguments;
    }(FormEventArguments));

    var FormInstance = /** @class */ (function () {
        function FormInstance(metadata, controlRegister) {
            this.outputs = [];
            this.inputs = [];
            this.metadata = new FormMetadata(metadata);
            this.inputs = controlRegister.createInputControllers(this.metadata.inputFields);
        }
        FormInstance.prototype.enforceCanPostOnLoad = function () {
            // If user is trying to auto-submit a form which is not enabled for `PostOnLoad`.
            if (!this.metadata.postOnLoad) {
                throw new Error("Invalid invocation of form '" + this.metadata.id + "'. Form cannot be auto-posted, because *PostOnLoad* is set to false.");
            }
        };
        FormInstance.prototype.allRequiredInputsHaveData = function (asPostOnLoad) {
            return __awaiter(this, void 0, void 0, function () {
                var formData;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (asPostOnLoad) {
                                this.enforceCanPostOnLoad();
                            }
                            return [4 /*yield*/, this.getFormData(asPostOnLoad)];
                        case 1:
                            formData = _a.sent();
                            return [2 /*return*/, formData != null];
                    }
                });
            });
        };
        FormInstance.prototype.submit = function (app, asPostOnLoad, args) {
            return __awaiter(this, void 0, void 0, function () {
                var formData, response;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (asPostOnLoad) {
                                this.enforceCanPostOnLoad();
                            }
                            return [4 /*yield*/, this.getFormData(asPostOnLoad)];
                        case 1:
                            formData = _a.sent();
                            // If not all required inputs are filled.
                            if (formData == null) {
                                throw new Error("Form '" + this.metadata.id + "' cannot be submitted, because some required input fields do not have values.");
                            }
                            return [4 /*yield*/, this.fire("form:posting", new FormEventArguments(app))];
                        case 2:
                            _a.sent();
                            return [4 /*yield*/, app.server.postForm(this.metadata.id, formData)];
                        case 3:
                            response = _a.sent();
                            return [4 /*yield*/, this.fire("form:responseReceived", new FormResponseEventArguments(app, response))];
                        case 4:
                            _a.sent();
                            this.setOutputFieldValues(response);
                            // Null response is treated as a server-side error.
                            if (response == null) {
                                throw new Error("Received null response.");
                            }
                            return [4 /*yield*/, app.runFunctions(response.metadata.functionsToRun)];
                        case 5:
                            _a.sent();
                            app.handleResponse(response, this, args);
                            return [4 /*yield*/, this.fire("form:responseHandled", new FormResponseEventArguments(app, response))];
                        case 6:
                            _a.sent();
                            return [2 /*return*/, response];
                    }
                });
            });
        };
        FormInstance.prototype.initializeInputFields = function (data) {
            var promises = [];
            for (var _i = 0, _a = this.inputs; _i < _a.length; _i++) {
                var fieldMetadata = _a[_i];
                var value = null;
                if (data != null) {
                    for (var _b = 0, _c = Object.keys(data); _b < _c.length; _b++) {
                        var prop = _c[_b];
                        if (prop.toLowerCase() === fieldMetadata.metadata.id.toLowerCase()) {
                            value = data[prop];
                            break;
                        }
                    }
                }
                promises.push(fieldMetadata.init(value));
            }
            return Promise.all(promises);
        };
        FormInstance.prototype.setInputFields = function (data) {
            for (var _i = 0, _a = this.inputs; _i < _a.length; _i++) {
                var field = _a[_i];
                field.value = data[field.metadata.id];
            }
        };
        FormInstance.prototype.getSerializedInputValues = function () {
            var data = {};
            var promises = [];
            var _loop_1 = function (input) {
                var promise = input.serialize().then(function (t) {
                    // Don't include inputs without values, because we only
                    // want to serialize "non-default" values.
                    if (t.value != null && t.value !== "") {
                        data[input.metadata.id] = t.value;
                    }
                });
                promises.push(promise);
            };
            for (var _i = 0, _a = this.inputs; _i < _a.length; _i++) {
                var input = _a[_i];
                _loop_1(input);
            }
            return Promise.all(promises).then(function () { return data; });
        };
        FormInstance.prototype.getSerializedInputValuesFromObject = function (value) {
            var data = {};
            if (value == null || data === undefined) {
                return data;
            }
            var normalizedObject = {};
            for (var _i = 0, _a = Object.keys(value); _i < _a.length; _i++) {
                var prop = _a[_i];
                normalizedObject[prop.toLowerCase()] = value[prop];
            }
            for (var _b = 0, _c = this.inputs; _b < _c.length; _b++) {
                var input = _c[_b];
                var valueAsString = input.serializeValue(normalizedObject[input.metadata.id.toLowerCase()]);
                // Don't include inputs without values, because we only
                // want to serialize "non-default" values.
                if (valueAsString != null && valueAsString !== "") {
                    data[input.metadata.id] = valueAsString;
                }
            }
            return data;
        };
        FormInstance.getOutputFieldValues = function (outputFieldsMetadata, response) {
            var fields = Array();
            var normalizedResponse = FormInstance.getNormalizedObject(response);
            for (var _i = 0, outputFieldsMetadata_1 = outputFieldsMetadata; _i < outputFieldsMetadata_1.length; _i++) {
                var field = outputFieldsMetadata_1[_i];
                var normalizedId = field.id.toLowerCase();
                fields.push({
                    metadata: field,
                    data: normalizedResponse[normalizedId]
                });
            }
            fields.sort(function (a, b) {
                return a.metadata.orderIndex - b.metadata.orderIndex;
            });
            return fields;
        };
        FormInstance.prototype.setOutputFieldValues = function (response) {
            if (response == null) {
                this.outputs = [];
                return;
            }
            var fields = Array();
            var normalizedResponse = FormInstance.getNormalizedObject(response);
            for (var _i = 0, _a = this.metadata.outputFields; _i < _a.length; _i++) {
                var field = _a[_i];
                fields.push({
                    metadata: field,
                    data: normalizedResponse[field.id.toLowerCase()]
                });
            }
            fields.sort(function (a, b) {
                return a.metadata.orderIndex - b.metadata.orderIndex;
            });
            this.outputs = fields;
        };
        FormInstance.prototype.handleEvent = function (eventName, eventMetadata, parameters) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.fire(eventName, parameters)];
                        case 1:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        };
        FormInstance.prototype.fire = function (eventName, parameters) {
            return __awaiter(this, void 0, void 0, function () {
                var promises, _i, _a, input, _b, _c, eventHandlerMetadata, handler, promise, _d, _e, output, _f, _g, eventHandlerMetadata, handler, promise;
                var _this = this;
                return __generator(this, function (_h) {
                    switch (_h.label) {
                        case 0:
                            promises = [];
                            // Run input event handlers.
                            for (_i = 0, _a = this.inputs; _i < _a.length; _i++) {
                                input = _a[_i];
                                if (input.metadata.eventHandlers != null) {
                                    for (_b = 0, _c = input.metadata.eventHandlers; _b < _c.length; _b++) {
                                        eventHandlerMetadata = _c[_b];
                                        if (eventHandlerMetadata.runAt === eventName) {
                                            handler = parameters.app.controlRegister.inputFieldEventHandlers[eventHandlerMetadata.id];
                                            if (handler == null) {
                                                throw new Error("Could not find input event handler '" + eventHandlerMetadata.id + "'.");
                                            }
                                            promise = handler.run(input, eventHandlerMetadata, parameters);
                                            promises.push(promise);
                                        }
                                    }
                                }
                            }
                            // Run output event handlers.
                            for (_d = 0, _e = this.outputs; _d < _e.length; _d++) {
                                output = _e[_d];
                                if (output.metadata.eventHandlers != null) {
                                    for (_f = 0, _g = output.metadata.eventHandlers; _f < _g.length; _f++) {
                                        eventHandlerMetadata = _g[_f];
                                        if (eventHandlerMetadata.runAt === eventName) {
                                            handler = parameters.app.controlRegister.outputFieldEventHandlers[eventHandlerMetadata.id];
                                            if (handler == null) {
                                                throw new Error("Could not find output event handler '" + eventHandlerMetadata.id + "'.");
                                            }
                                            promise = handler.run(output, eventHandlerMetadata, parameters);
                                            promises.push(promise);
                                        }
                                    }
                                }
                            }
                            // Run form event handlers.
                            this.metadata.eventHandlers
                                .filter(function (t) { return t.runAt === eventName; })
                                .forEach(function (t) {
                                var handler = parameters.app.controlRegister.formEventHandlers[t.id];
                                if (handler == null) {
                                    throw new Error("Could not find form event handler '" + t.id + "'.");
                                }
                                var promise = handler.run(_this, t, parameters);
                                promises.push(promise);
                            });
                            return [4 /*yield*/, Promise.all(promises)];
                        case 1:
                            _h.sent();
                            return [2 /*return*/];
                    }
                });
            });
        };
        FormInstance.prototype.getFormData = function (asPostOnLoad) {
            return __awaiter(this, void 0, void 0, function () {
                var data, promises, hasRequiredMissingInput, _loop_2, _i, _a, input, skipValidation;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            data = {};
                            promises = [];
                            hasRequiredMissingInput = false;
                            _loop_2 = function (input) {
                                var promise = input.getValue().then(function (value) {
                                    data[input.metadata.id] = value;
                                    var isVisible = !input.metadata.eventHandlers.length ||
                                        input.metadata.eventHandlers.find(function (t) { return t.id === "depend-on"; }) == null;
                                    if (isVisible && input.metadata.required && (value == null || (typeof (value) === "string" && value === ""))) {
                                        hasRequiredMissingInput = true;
                                    }
                                });
                                promises.push(promise);
                            };
                            for (_i = 0, _a = this.inputs; _i < _a.length; _i++) {
                                input = _a[_i];
                                _loop_2(input);
                            }
                            return [4 /*yield*/, Promise.all(promises)];
                        case 1:
                            _b.sent();
                            skipValidation = !this.metadata.postOnLoadValidation &&
                                this.metadata.postOnLoad &&
                                // if initialization of the form, i.e. - first post.
                                asPostOnLoad;
                            // If not all required inputs were entered, then do not post.
                            if (hasRequiredMissingInput &&
                                !skipValidation) {
                                return [2 /*return*/, null];
                            }
                            return [2 /*return*/, data];
                    }
                });
            });
        };
        FormInstance.getNormalizedObject = function (response) {
            var normalizedResponse = {};
            for (var _i = 0, _a = Object.keys(response); _i < _a.length; _i++) {
                var field = _a[_i];
                if (field !== "metadata") {
                    normalizedResponse[field.toLowerCase()] = response[field];
                }
            }
            return normalizedResponse;
        };
        return FormInstance;
    }());

    var UmfApp = /** @class */ (function () {
        function UmfApp(server, controlRegister) {
            var _this = this;
            this.formsById = {};
            this.eventHandlers = [];
            this.formResponseHandlers = {};
            this.server = server;
            this.controlRegister = controlRegister;
            var _loop_1 = function (e) {
                this_1.server.on(e, function (params) {
                    _this.fire(e, params);
                });
            };
            var this_1 = this;
            for (var _i = 0, _a = ["request:started", "request:completed"]; _i < _a.length; _i++) {
                var e = _a[_i];
                _loop_1(e);
            }
        }
        UmfApp.prototype.on = function (event, handler) {
            this.eventHandlers[event] = this.eventHandlers[event] || [];
            this.eventHandlers[event].push(handler);
        };
        UmfApp.prototype.fire = function (event, params) {
            var handlersForEvent = this.eventHandlers[event];
            if (handlersForEvent != null && handlersForEvent.length > 0) {
                for (var _i = 0, handlersForEvent_1 = handlersForEvent; _i < handlersForEvent_1.length; _i++) {
                    var handler = handlersForEvent_1[_i];
                    handler(params);
                }
            }
        };
        UmfApp.prototype.useRouter = function (router) {
            this.go = function (form, values) {
                return router.go(form, values);
            };
            this.makeUrl = function (form, values) {
                return router.makeUrl(form, values);
            };
        };
        UmfApp.prototype.registerResponseHandler = function (handler) {
            this.formResponseHandlers[handler.name] = handler;
        };
        UmfApp.prototype.load = function () {
            var _this = this;
            return this.server.getAllMetadata()
                .then(function (response) {
                _this.forms = response.forms;
                _this.menu = response.menu;
                _this.formsById = {};
                for (var _i = 0, _a = _this.forms; _i < _a.length; _i++) {
                    var form = _a[_i];
                    _this.formsById[form.id] = new FormMetadata(form);
                }
            });
        };
        UmfApp.prototype.loadMenu = function () {
            var _this = this;
            return this.server.getAllMenu()
                .then(function (response) {
                _this.menu = response.menu;
            });
        };
        UmfApp.prototype.getForm = function (id) {
            return this.formsById[id];
        };
        UmfApp.prototype.getFormInstance = function (formId, throwError) {
            if (throwError === void 0) { throwError = false; }
            var metadata = this.getForm(formId);
            if (metadata == null) {
                if (throwError) {
                    throw Error("Form " + formId + " not found.");
                }
                return null;
            }
            return new FormInstance(metadata, this.controlRegister);
        };
        UmfApp.prototype.handleResponse = function (response, form, args) {
            var responseMetadata = response.metadata || new FormResponseMetadata();
            var handler = this.formResponseHandlers[responseMetadata.handler || "default"];
            if (handler == null) {
                throw new Error("Cannot find FormResponseHandler \"" + responseMetadata.handler + "\".");
            }
            return handler.handle(response, form, args);
        };
        UmfApp.prototype.runFunctions = function (functionMetadata, eventArgs) {
            if (functionMetadata == null) {
                return Promise.resolve();
            }
            var promises = [];
            for (var _i = 0, functionMetadata_1 = functionMetadata; _i < functionMetadata_1.length; _i++) {
                var f = functionMetadata_1[_i];
                var handler = this.controlRegister.functions[f.id];
                if (handler == null) {
                    throw new Error("Could not find function '" + f.id + "'.");
                }
                var promise = handler.run(f, eventArgs);
                promises.push(promise);
            }
            return Promise.all(promises);
        };
        return UmfApp;
    }());

    var InputController = /** @class */ (function () {
        function InputController(metadata) {
            this.metadata = metadata;
        }
        InputController.prototype.serialize = function () {
            var _this = this;
            return this.getValue().then(function (t) {
                var valueAsString = _this.serializeValue(t);
                return {
                    value: valueAsString,
                    input: _this
                };
            });
        };
        return InputController;
    }());

    var StringInputController = /** @class */ (function (_super) {
        __extends(StringInputController, _super);
        function StringInputController(metadata) {
            return _super.call(this, metadata) || this;
        }
        StringInputController.prototype.serializeValue = function (value) {
            // Ensure we don't return "undefined", but return null instead.
            return value != null ? value.toString() : null;
        };
        StringInputController.prototype.init = function (value) {
            this.value = value;
            return Promise.resolve(this);
        };
        StringInputController.prototype.getValue = function () {
            return Promise.resolve(this.value);
        };
        return StringInputController;
    }(InputController));

    var ControlRegister = /** @class */ (function () {
        function ControlRegister() {
            this.inputs = {};
            this.outputs = {};
            this.inputFieldEventHandlers = {};
            this.outputFieldEventHandlers = {};
            this.formEventHandlers = {};
            this.functions = {};
        }
        ControlRegister.prototype.createInputControllers = function (fields) {
            var result = [];
            for (var _i = 0, fields_1 = fields; _i < fields_1.length; _i++) {
                var field = fields_1[_i];
                // Instantiate new input controller.
                var entry = this.inputs[field.type];
                var ctor = entry != null && entry.controller != null
                    ? entry.controller
                    : StringInputController;
                result.push(new ctor(field));
            }
            result.sort(function (a, b) {
                return a.metadata.orderIndex - b.metadata.orderIndex;
            });
            return result;
        };
        ControlRegister.prototype.getOutput = function (field) {
            return field != null
                ? this.outputs[field.metadata.type] || this.outputs.text
                : this.outputs.text;
        };
        ControlRegister.prototype.getInput = function (type) {
            return type != null
                ? this.inputs[type] || this.inputs.text
                : this.inputs.text;
        };
        ControlRegister.prototype.registerInputFieldControl = function (name, svelteComponent, controller, constants) {
            if (constants === void 0) { constants = null; }
            this.inputs[name] = {
                controller: controller,
                component: svelteComponent,
                constants: constants
            };
        };
        ControlRegister.prototype.registerOutputFieldControl = function (name, svelteComponent, constants) {
            if (constants === void 0) { constants = null; }
            this.outputs[name] = {
                constructor: svelteComponent,
                constants: constants
            };
        };
        ControlRegister.prototype.registerFormEventHandler = function (name, handler) {
            this.formEventHandlers[name] = handler;
        };
        ControlRegister.prototype.registerInputFieldEventHandler = function (name, handler) {
            this.inputFieldEventHandlers[name] = handler;
        };
        ControlRegister.prototype.registerOutputFieldEventHandler = function (name, handler) {
            this.outputFieldEventHandlers[name] = handler;
        };
        ControlRegister.prototype.registerFunction = function (name, fn) {
            this.functions[name] = fn;
        };
        return ControlRegister;
    }());

    var OutputControlConfiguration = /** @class */ (function () {
        function OutputControlConfiguration(alwaysHideLabel, block) {
            if (alwaysHideLabel === void 0) { alwaysHideLabel = false; }
            if (block === void 0) { block = true; }
            this.alwaysHideLabel = false;
            this.block = true;
            this.alwaysHideLabel = alwaysHideLabel;
            this.block = block;
        }
        return OutputControlConfiguration;
    }());

    var OutputFieldValue = /** @class */ (function () {
        function OutputFieldValue() {
        }
        return OutputFieldValue;
    }());

    var FormEventHandler = /** @class */ (function () {
        function FormEventHandler() {
        }
        return FormEventHandler;
    }());

    var InputFieldEventHandler = /** @class */ (function () {
        function InputFieldEventHandler() {
        }
        return InputFieldEventHandler;
    }());

    var OutputFieldEventHandler = /** @class */ (function () {
        function OutputFieldEventHandler() {
        }
        return OutputFieldEventHandler;
    }());

    var InputEventArguments = /** @class */ (function (_super) {
        __extends(InputEventArguments, _super);
        function InputEventArguments(app, input) {
            var _this = _super.call(this, app) || this;
            _this.input = input;
            return _this;
        }
        return InputEventArguments;
    }(FormEventArguments));

    var MessageResponseHandler = /** @class */ (function () {
        function MessageResponseHandler() {
            this.name = "message";
        }
        MessageResponseHandler.prototype.handle = function (response, form) {
            alert(response.message);
        };
        return MessageResponseHandler;
    }());

    var RedirectResponseHandler = /** @class */ (function () {
        function RedirectResponseHandler(goToForm) {
            this.name = "redirect";
            this.goToForm = goToForm;
        }
        RedirectResponseHandler.prototype.handle = function (response, form) {
            this.goToForm(response.form, response.inputFieldValues);
        };
        return RedirectResponseHandler;
    }());

    var ReloadResponseHandler = /** @class */ (function () {
        function ReloadResponseHandler(getFormUrl) {
            this.name = "reload";
            this.getFormUrl = getFormUrl;
        }
        ReloadResponseHandler.prototype.handle = function (response, form) {
            this.getFormUrl(response.form, response.inputFieldValues).then(function (url) {
                window.location.href = url;
            });
        };
        return ReloadResponseHandler;
    }());

    var FormComponentResponseHandler = /** @class */ (function () {
        function FormComponentResponseHandler() {
            this.name = "default";
        }
        FormComponentResponseHandler.prototype.handle = function (response, form, args) {
            if (args != null && args.formComponent != null) {
                args.formComponent.renderResponse(response);
            }
        };
        return FormComponentResponseHandler;
    }());

    var momentWithLocales = createCommonjsModule(function (module, exports) {
    (function (global, factory) {
        module.exports = factory();
    }(commonjsGlobal, (function () {
        var hookCallback;

        function hooks() {
            return hookCallback.apply(null, arguments);
        }

        // This is done to register the method called with moment()
        // without creating circular dependencies.
        function setHookCallback(callback) {
            hookCallback = callback;
        }

        function isArray(input) {
            return (
                input instanceof Array ||
                Object.prototype.toString.call(input) === '[object Array]'
            );
        }

        function isObject(input) {
            // IE8 will treat undefined and null as object if it wasn't for
            // input != null
            return (
                input != null &&
                Object.prototype.toString.call(input) === '[object Object]'
            );
        }

        function hasOwnProp(a, b) {
            return Object.prototype.hasOwnProperty.call(a, b);
        }

        function isObjectEmpty(obj) {
            if (Object.getOwnPropertyNames) {
                return Object.getOwnPropertyNames(obj).length === 0;
            } else {
                var k;
                for (k in obj) {
                    if (hasOwnProp(obj, k)) {
                        return false;
                    }
                }
                return true;
            }
        }

        function isUndefined(input) {
            return input === void 0;
        }

        function isNumber(input) {
            return (
                typeof input === 'number' ||
                Object.prototype.toString.call(input) === '[object Number]'
            );
        }

        function isDate(input) {
            return (
                input instanceof Date ||
                Object.prototype.toString.call(input) === '[object Date]'
            );
        }

        function map(arr, fn) {
            var res = [],
                i;
            for (i = 0; i < arr.length; ++i) {
                res.push(fn(arr[i], i));
            }
            return res;
        }

        function extend(a, b) {
            for (var i in b) {
                if (hasOwnProp(b, i)) {
                    a[i] = b[i];
                }
            }

            if (hasOwnProp(b, 'toString')) {
                a.toString = b.toString;
            }

            if (hasOwnProp(b, 'valueOf')) {
                a.valueOf = b.valueOf;
            }

            return a;
        }

        function createUTC(input, format, locale, strict) {
            return createLocalOrUTC(input, format, locale, strict, true).utc();
        }

        function defaultParsingFlags() {
            // We need to deep clone this object.
            return {
                empty: false,
                unusedTokens: [],
                unusedInput: [],
                overflow: -2,
                charsLeftOver: 0,
                nullInput: false,
                invalidEra: null,
                invalidMonth: null,
                invalidFormat: false,
                userInvalidated: false,
                iso: false,
                parsedDateParts: [],
                era: null,
                meridiem: null,
                rfc2822: false,
                weekdayMismatch: false,
            };
        }

        function getParsingFlags(m) {
            if (m._pf == null) {
                m._pf = defaultParsingFlags();
            }
            return m._pf;
        }

        var some;
        if (Array.prototype.some) {
            some = Array.prototype.some;
        } else {
            some = function (fun) {
                var t = Object(this),
                    len = t.length >>> 0,
                    i;

                for (i = 0; i < len; i++) {
                    if (i in t && fun.call(this, t[i], i, t)) {
                        return true;
                    }
                }

                return false;
            };
        }

        function isValid(m) {
            if (m._isValid == null) {
                var flags = getParsingFlags(m),
                    parsedParts = some.call(flags.parsedDateParts, function (i) {
                        return i != null;
                    }),
                    isNowValid =
                        !isNaN(m._d.getTime()) &&
                        flags.overflow < 0 &&
                        !flags.empty &&
                        !flags.invalidEra &&
                        !flags.invalidMonth &&
                        !flags.invalidWeekday &&
                        !flags.weekdayMismatch &&
                        !flags.nullInput &&
                        !flags.invalidFormat &&
                        !flags.userInvalidated &&
                        (!flags.meridiem || (flags.meridiem && parsedParts));

                if (m._strict) {
                    isNowValid =
                        isNowValid &&
                        flags.charsLeftOver === 0 &&
                        flags.unusedTokens.length === 0 &&
                        flags.bigHour === undefined;
                }

                if (Object.isFrozen == null || !Object.isFrozen(m)) {
                    m._isValid = isNowValid;
                } else {
                    return isNowValid;
                }
            }
            return m._isValid;
        }

        function createInvalid(flags) {
            var m = createUTC(NaN);
            if (flags != null) {
                extend(getParsingFlags(m), flags);
            } else {
                getParsingFlags(m).userInvalidated = true;
            }

            return m;
        }

        // Plugins that add properties should also add the key here (null value),
        // so we can properly clone ourselves.
        var momentProperties = (hooks.momentProperties = []),
            updateInProgress = false;

        function copyConfig(to, from) {
            var i, prop, val;

            if (!isUndefined(from._isAMomentObject)) {
                to._isAMomentObject = from._isAMomentObject;
            }
            if (!isUndefined(from._i)) {
                to._i = from._i;
            }
            if (!isUndefined(from._f)) {
                to._f = from._f;
            }
            if (!isUndefined(from._l)) {
                to._l = from._l;
            }
            if (!isUndefined(from._strict)) {
                to._strict = from._strict;
            }
            if (!isUndefined(from._tzm)) {
                to._tzm = from._tzm;
            }
            if (!isUndefined(from._isUTC)) {
                to._isUTC = from._isUTC;
            }
            if (!isUndefined(from._offset)) {
                to._offset = from._offset;
            }
            if (!isUndefined(from._pf)) {
                to._pf = getParsingFlags(from);
            }
            if (!isUndefined(from._locale)) {
                to._locale = from._locale;
            }

            if (momentProperties.length > 0) {
                for (i = 0; i < momentProperties.length; i++) {
                    prop = momentProperties[i];
                    val = from[prop];
                    if (!isUndefined(val)) {
                        to[prop] = val;
                    }
                }
            }

            return to;
        }

        // Moment prototype object
        function Moment(config) {
            copyConfig(this, config);
            this._d = new Date(config._d != null ? config._d.getTime() : NaN);
            if (!this.isValid()) {
                this._d = new Date(NaN);
            }
            // Prevent infinite loop in case updateOffset creates new moment
            // objects.
            if (updateInProgress === false) {
                updateInProgress = true;
                hooks.updateOffset(this);
                updateInProgress = false;
            }
        }

        function isMoment(obj) {
            return (
                obj instanceof Moment || (obj != null && obj._isAMomentObject != null)
            );
        }

        function warn(msg) {
            if (
                hooks.suppressDeprecationWarnings === false &&
                typeof console !== 'undefined' &&
                console.warn
            ) {
                console.warn('Deprecation warning: ' + msg);
            }
        }

        function deprecate(msg, fn) {
            var firstTime = true;

            return extend(function () {
                if (hooks.deprecationHandler != null) {
                    hooks.deprecationHandler(null, msg);
                }
                if (firstTime) {
                    var args = [],
                        arg,
                        i,
                        key;
                    for (i = 0; i < arguments.length; i++) {
                        arg = '';
                        if (typeof arguments[i] === 'object') {
                            arg += '\n[' + i + '] ';
                            for (key in arguments[0]) {
                                if (hasOwnProp(arguments[0], key)) {
                                    arg += key + ': ' + arguments[0][key] + ', ';
                                }
                            }
                            arg = arg.slice(0, -2); // Remove trailing comma and space
                        } else {
                            arg = arguments[i];
                        }
                        args.push(arg);
                    }
                    warn(
                        msg +
                            '\nArguments: ' +
                            Array.prototype.slice.call(args).join('') +
                            '\n' +
                            new Error().stack
                    );
                    firstTime = false;
                }
                return fn.apply(this, arguments);
            }, fn);
        }

        var deprecations = {};

        function deprecateSimple(name, msg) {
            if (hooks.deprecationHandler != null) {
                hooks.deprecationHandler(name, msg);
            }
            if (!deprecations[name]) {
                warn(msg);
                deprecations[name] = true;
            }
        }

        hooks.suppressDeprecationWarnings = false;
        hooks.deprecationHandler = null;

        function isFunction(input) {
            return (
                (typeof Function !== 'undefined' && input instanceof Function) ||
                Object.prototype.toString.call(input) === '[object Function]'
            );
        }

        function set(config) {
            var prop, i;
            for (i in config) {
                if (hasOwnProp(config, i)) {
                    prop = config[i];
                    if (isFunction(prop)) {
                        this[i] = prop;
                    } else {
                        this['_' + i] = prop;
                    }
                }
            }
            this._config = config;
            // Lenient ordinal parsing accepts just a number in addition to
            // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
            // TODO: Remove "ordinalParse" fallback in next major release.
            this._dayOfMonthOrdinalParseLenient = new RegExp(
                (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
                    '|' +
                    /\d{1,2}/.source
            );
        }

        function mergeConfigs(parentConfig, childConfig) {
            var res = extend({}, parentConfig),
                prop;
            for (prop in childConfig) {
                if (hasOwnProp(childConfig, prop)) {
                    if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                        res[prop] = {};
                        extend(res[prop], parentConfig[prop]);
                        extend(res[prop], childConfig[prop]);
                    } else if (childConfig[prop] != null) {
                        res[prop] = childConfig[prop];
                    } else {
                        delete res[prop];
                    }
                }
            }
            for (prop in parentConfig) {
                if (
                    hasOwnProp(parentConfig, prop) &&
                    !hasOwnProp(childConfig, prop) &&
                    isObject(parentConfig[prop])
                ) {
                    // make sure changes to properties don't modify parent config
                    res[prop] = extend({}, res[prop]);
                }
            }
            return res;
        }

        function Locale(config) {
            if (config != null) {
                this.set(config);
            }
        }

        var keys;

        if (Object.keys) {
            keys = Object.keys;
        } else {
            keys = function (obj) {
                var i,
                    res = [];
                for (i in obj) {
                    if (hasOwnProp(obj, i)) {
                        res.push(i);
                    }
                }
                return res;
            };
        }

        var defaultCalendar = {
            sameDay: '[Today at] LT',
            nextDay: '[Tomorrow at] LT',
            nextWeek: 'dddd [at] LT',
            lastDay: '[Yesterday at] LT',
            lastWeek: '[Last] dddd [at] LT',
            sameElse: 'L',
        };

        function calendar(key, mom, now) {
            var output = this._calendar[key] || this._calendar['sameElse'];
            return isFunction(output) ? output.call(mom, now) : output;
        }

        function zeroFill(number, targetLength, forceSign) {
            var absNumber = '' + Math.abs(number),
                zerosToFill = targetLength - absNumber.length,
                sign = number >= 0;
            return (
                (sign ? (forceSign ? '+' : '') : '-') +
                Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) +
                absNumber
            );
        }

        var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,
            localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,
            formatFunctions = {},
            formatTokenFunctions = {};

        // token:    'M'
        // padded:   ['MM', 2]
        // ordinal:  'Mo'
        // callback: function () { this.month() + 1 }
        function addFormatToken(token, padded, ordinal, callback) {
            var func = callback;
            if (typeof callback === 'string') {
                func = function () {
                    return this[callback]();
                };
            }
            if (token) {
                formatTokenFunctions[token] = func;
            }
            if (padded) {
                formatTokenFunctions[padded[0]] = function () {
                    return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
                };
            }
            if (ordinal) {
                formatTokenFunctions[ordinal] = function () {
                    return this.localeData().ordinal(
                        func.apply(this, arguments),
                        token
                    );
                };
            }
        }

        function removeFormattingTokens(input) {
            if (input.match(/\[[\s\S]/)) {
                return input.replace(/^\[|\]$/g, '');
            }
            return input.replace(/\\/g, '');
        }

        function makeFormatFunction(format) {
            var array = format.match(formattingTokens),
                i,
                length;

            for (i = 0, length = array.length; i < length; i++) {
                if (formatTokenFunctions[array[i]]) {
                    array[i] = formatTokenFunctions[array[i]];
                } else {
                    array[i] = removeFormattingTokens(array[i]);
                }
            }

            return function (mom) {
                var output = '',
                    i;
                for (i = 0; i < length; i++) {
                    output += isFunction(array[i])
                        ? array[i].call(mom, format)
                        : array[i];
                }
                return output;
            };
        }

        // format date using native date object
        function formatMoment(m, format) {
            if (!m.isValid()) {
                return m.localeData().invalidDate();
            }

            format = expandFormat(format, m.localeData());
            formatFunctions[format] =
                formatFunctions[format] || makeFormatFunction(format);

            return formatFunctions[format](m);
        }

        function expandFormat(format, locale) {
            var i = 5;

            function replaceLongDateFormatTokens(input) {
                return locale.longDateFormat(input) || input;
            }

            localFormattingTokens.lastIndex = 0;
            while (i >= 0 && localFormattingTokens.test(format)) {
                format = format.replace(
                    localFormattingTokens,
                    replaceLongDateFormatTokens
                );
                localFormattingTokens.lastIndex = 0;
                i -= 1;
            }

            return format;
        }

        var defaultLongDateFormat = {
            LTS: 'h:mm:ss A',
            LT: 'h:mm A',
            L: 'MM/DD/YYYY',
            LL: 'MMMM D, YYYY',
            LLL: 'MMMM D, YYYY h:mm A',
            LLLL: 'dddd, MMMM D, YYYY h:mm A',
        };

        function longDateFormat(key) {
            var format = this._longDateFormat[key],
                formatUpper = this._longDateFormat[key.toUpperCase()];

            if (format || !formatUpper) {
                return format;
            }

            this._longDateFormat[key] = formatUpper
                .match(formattingTokens)
                .map(function (tok) {
                    if (
                        tok === 'MMMM' ||
                        tok === 'MM' ||
                        tok === 'DD' ||
                        tok === 'dddd'
                    ) {
                        return tok.slice(1);
                    }
                    return tok;
                })
                .join('');

            return this._longDateFormat[key];
        }

        var defaultInvalidDate = 'Invalid date';

        function invalidDate() {
            return this._invalidDate;
        }

        var defaultOrdinal = '%d',
            defaultDayOfMonthOrdinalParse = /\d{1,2}/;

        function ordinal(number) {
            return this._ordinal.replace('%d', number);
        }

        var defaultRelativeTime = {
            future: 'in %s',
            past: '%s ago',
            s: 'a few seconds',
            ss: '%d seconds',
            m: 'a minute',
            mm: '%d minutes',
            h: 'an hour',
            hh: '%d hours',
            d: 'a day',
            dd: '%d days',
            w: 'a week',
            ww: '%d weeks',
            M: 'a month',
            MM: '%d months',
            y: 'a year',
            yy: '%d years',
        };

        function relativeTime(number, withoutSuffix, string, isFuture) {
            var output = this._relativeTime[string];
            return isFunction(output)
                ? output(number, withoutSuffix, string, isFuture)
                : output.replace(/%d/i, number);
        }

        function pastFuture(diff, output) {
            var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
            return isFunction(format) ? format(output) : format.replace(/%s/i, output);
        }

        var aliases = {};

        function addUnitAlias(unit, shorthand) {
            var lowerCase = unit.toLowerCase();
            aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
        }

        function normalizeUnits(units) {
            return typeof units === 'string'
                ? aliases[units] || aliases[units.toLowerCase()]
                : undefined;
        }

        function normalizeObjectUnits(inputObject) {
            var normalizedInput = {},
                normalizedProp,
                prop;

            for (prop in inputObject) {
                if (hasOwnProp(inputObject, prop)) {
                    normalizedProp = normalizeUnits(prop);
                    if (normalizedProp) {
                        normalizedInput[normalizedProp] = inputObject[prop];
                    }
                }
            }

            return normalizedInput;
        }

        var priorities = {};

        function addUnitPriority(unit, priority) {
            priorities[unit] = priority;
        }

        function getPrioritizedUnits(unitsObj) {
            var units = [],
                u;
            for (u in unitsObj) {
                if (hasOwnProp(unitsObj, u)) {
                    units.push({ unit: u, priority: priorities[u] });
                }
            }
            units.sort(function (a, b) {
                return a.priority - b.priority;
            });
            return units;
        }

        function isLeapYear(year) {
            return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
        }

        function absFloor(number) {
            if (number < 0) {
                // -0 -> 0
                return Math.ceil(number) || 0;
            } else {
                return Math.floor(number);
            }
        }

        function toInt(argumentForCoercion) {
            var coercedNumber = +argumentForCoercion,
                value = 0;

            if (coercedNumber !== 0 && isFinite(coercedNumber)) {
                value = absFloor(coercedNumber);
            }

            return value;
        }

        function makeGetSet(unit, keepTime) {
            return function (value) {
                if (value != null) {
                    set$1(this, unit, value);
                    hooks.updateOffset(this, keepTime);
                    return this;
                } else {
                    return get(this, unit);
                }
            };
        }

        function get(mom, unit) {
            return mom.isValid()
                ? mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]()
                : NaN;
        }

        function set$1(mom, unit, value) {
            if (mom.isValid() && !isNaN(value)) {
                if (
                    unit === 'FullYear' &&
                    isLeapYear(mom.year()) &&
                    mom.month() === 1 &&
                    mom.date() === 29
                ) {
                    value = toInt(value);
                    mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](
                        value,
                        mom.month(),
                        daysInMonth(value, mom.month())
                    );
                } else {
                    mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
                }
            }
        }

        // MOMENTS

        function stringGet(units) {
            units = normalizeUnits(units);
            if (isFunction(this[units])) {
                return this[units]();
            }
            return this;
        }

        function stringSet(units, value) {
            if (typeof units === 'object') {
                units = normalizeObjectUnits(units);
                var prioritized = getPrioritizedUnits(units),
                    i;
                for (i = 0; i < prioritized.length; i++) {
                    this[prioritized[i].unit](units[prioritized[i].unit]);
                }
            } else {
                units = normalizeUnits(units);
                if (isFunction(this[units])) {
                    return this[units](value);
                }
            }
            return this;
        }

        var match1 = /\d/, //       0 - 9
            match2 = /\d\d/, //      00 - 99
            match3 = /\d{3}/, //     000 - 999
            match4 = /\d{4}/, //    0000 - 9999
            match6 = /[+-]?\d{6}/, // -999999 - 999999
            match1to2 = /\d\d?/, //       0 - 99
            match3to4 = /\d\d\d\d?/, //     999 - 9999
            match5to6 = /\d\d\d\d\d\d?/, //   99999 - 999999
            match1to3 = /\d{1,3}/, //       0 - 999
            match1to4 = /\d{1,4}/, //       0 - 9999
            match1to6 = /[+-]?\d{1,6}/, // -999999 - 999999
            matchUnsigned = /\d+/, //       0 - inf
            matchSigned = /[+-]?\d+/, //    -inf - inf
            matchOffset = /Z|[+-]\d\d:?\d\d/gi, // +00:00 -00:00 +0000 -0000 or Z
            matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, // +00 -00 +00:00 -00:00 +0000 -0000 or Z
            matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, // 123456789 123456789.123
            // any word (or two) characters or numbers including two/three word month in arabic.
            // includes scottish gaelic two word and hyphenated months
            matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i,
            regexes;

        regexes = {};

        function addRegexToken(token, regex, strictRegex) {
            regexes[token] = isFunction(regex)
                ? regex
                : function (isStrict, localeData) {
                      return isStrict && strictRegex ? strictRegex : regex;
                  };
        }

        function getParseRegexForToken(token, config) {
            if (!hasOwnProp(regexes, token)) {
                return new RegExp(unescapeFormat(token));
            }

            return regexes[token](config._strict, config._locale);
        }

        // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
        function unescapeFormat(s) {
            return regexEscape(
                s
                    .replace('\\', '')
                    .replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (
                        matched,
                        p1,
                        p2,
                        p3,
                        p4
                    ) {
                        return p1 || p2 || p3 || p4;
                    })
            );
        }

        function regexEscape(s) {
            return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
        }

        var tokens = {};

        function addParseToken(token, callback) {
            var i,
                func = callback;
            if (typeof token === 'string') {
                token = [token];
            }
            if (isNumber(callback)) {
                func = function (input, array) {
                    array[callback] = toInt(input);
                };
            }
            for (i = 0; i < token.length; i++) {
                tokens[token[i]] = func;
            }
        }

        function addWeekParseToken(token, callback) {
            addParseToken(token, function (input, array, config, token) {
                config._w = config._w || {};
                callback(input, config._w, config, token);
            });
        }

        function addTimeToArrayFromToken(token, input, config) {
            if (input != null && hasOwnProp(tokens, token)) {
                tokens[token](input, config._a, config, token);
            }
        }

        var YEAR = 0,
            MONTH = 1,
            DATE = 2,
            HOUR = 3,
            MINUTE = 4,
            SECOND = 5,
            MILLISECOND = 6,
            WEEK = 7,
            WEEKDAY = 8;

        function mod(n, x) {
            return ((n % x) + x) % x;
        }

        var indexOf;

        if (Array.prototype.indexOf) {
            indexOf = Array.prototype.indexOf;
        } else {
            indexOf = function (o) {
                // I know
                var i;
                for (i = 0; i < this.length; ++i) {
                    if (this[i] === o) {
                        return i;
                    }
                }
                return -1;
            };
        }

        function daysInMonth(year, month) {
            if (isNaN(year) || isNaN(month)) {
                return NaN;
            }
            var modMonth = mod(month, 12);
            year += (month - modMonth) / 12;
            return modMonth === 1
                ? isLeapYear(year)
                    ? 29
                    : 28
                : 31 - ((modMonth % 7) % 2);
        }

        // FORMATTING

        addFormatToken('M', ['MM', 2], 'Mo', function () {
            return this.month() + 1;
        });

        addFormatToken('MMM', 0, 0, function (format) {
            return this.localeData().monthsShort(this, format);
        });

        addFormatToken('MMMM', 0, 0, function (format) {
            return this.localeData().months(this, format);
        });

        // ALIASES

        addUnitAlias('month', 'M');

        // PRIORITY

        addUnitPriority('month', 8);

        // PARSING

        addRegexToken('M', match1to2);
        addRegexToken('MM', match1to2, match2);
        addRegexToken('MMM', function (isStrict, locale) {
            return locale.monthsShortRegex(isStrict);
        });
        addRegexToken('MMMM', function (isStrict, locale) {
            return locale.monthsRegex(isStrict);
        });

        addParseToken(['M', 'MM'], function (input, array) {
            array[MONTH] = toInt(input) - 1;
        });

        addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
            var month = config._locale.monthsParse(input, token, config._strict);
            // if we didn't find a month name, mark the date as invalid.
            if (month != null) {
                array[MONTH] = month;
            } else {
                getParsingFlags(config).invalidMonth = input;
            }
        });

        // LOCALES

        var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split(
                '_'
            ),
            defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split(
                '_'
            ),
            MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,
            defaultMonthsShortRegex = matchWord,
            defaultMonthsRegex = matchWord;

        function localeMonths(m, format) {
            if (!m) {
                return isArray(this._months)
                    ? this._months
                    : this._months['standalone'];
            }
            return isArray(this._months)
                ? this._months[m.month()]
                : this._months[
                      (this._months.isFormat || MONTHS_IN_FORMAT).test(format)
                          ? 'format'
                          : 'standalone'
                  ][m.month()];
        }

        function localeMonthsShort(m, format) {
            if (!m) {
                return isArray(this._monthsShort)
                    ? this._monthsShort
                    : this._monthsShort['standalone'];
            }
            return isArray(this._monthsShort)
                ? this._monthsShort[m.month()]
                : this._monthsShort[
                      MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'
                  ][m.month()];
        }

        function handleStrictParse(monthName, format, strict) {
            var i,
                ii,
                mom,
                llc = monthName.toLocaleLowerCase();
            if (!this._monthsParse) {
                // this is not used
                this._monthsParse = [];
                this._longMonthsParse = [];
                this._shortMonthsParse = [];
                for (i = 0; i < 12; ++i) {
                    mom = createUTC([2000, i]);
                    this._shortMonthsParse[i] = this.monthsShort(
                        mom,
                        ''
                    ).toLocaleLowerCase();
                    this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
                }
            }

            if (strict) {
                if (format === 'MMM') {
                    ii = indexOf.call(this._shortMonthsParse, llc);
                    return ii !== -1 ? ii : null;
                } else {
                    ii = indexOf.call(this._longMonthsParse, llc);
                    return ii !== -1 ? ii : null;
                }
            } else {
                if (format === 'MMM') {
                    ii = indexOf.call(this._shortMonthsParse, llc);
                    if (ii !== -1) {
                        return ii;
                    }
                    ii = indexOf.call(this._longMonthsParse, llc);
                    return ii !== -1 ? ii : null;
                } else {
                    ii = indexOf.call(this._longMonthsParse, llc);
                    if (ii !== -1) {
                        return ii;
                    }
                    ii = indexOf.call(this._shortMonthsParse, llc);
                    return ii !== -1 ? ii : null;
                }
            }
        }

        function localeMonthsParse(monthName, format, strict) {
            var i, mom, regex;

            if (this._monthsParseExact) {
                return handleStrictParse.call(this, monthName, format, strict);
            }

            if (!this._monthsParse) {
                this._monthsParse = [];
                this._longMonthsParse = [];
                this._shortMonthsParse = [];
            }

            // TODO: add sorting
            // Sorting makes sure if one month (or abbr) is a prefix of another
            // see sorting in computeMonthsParse
            for (i = 0; i < 12; i++) {
                // make the regex if we don't have it already
                mom = createUTC([2000, i]);
                if (strict && !this._longMonthsParse[i]) {
                    this._longMonthsParse[i] = new RegExp(
                        '^' + this.months(mom, '').replace('.', '') + '$',
                        'i'
                    );
                    this._shortMonthsParse[i] = new RegExp(
                        '^' + this.monthsShort(mom, '').replace('.', '') + '$',
                        'i'
                    );
                }
                if (!strict && !this._monthsParse[i]) {
                    regex =
                        '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                    this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
                }
                // test the regex
                if (
                    strict &&
                    format === 'MMMM' &&
                    this._longMonthsParse[i].test(monthName)
                ) {
                    return i;
                } else if (
                    strict &&
                    format === 'MMM' &&
                    this._shortMonthsParse[i].test(monthName)
                ) {
                    return i;
                } else if (!strict && this._monthsParse[i].test(monthName)) {
                    return i;
                }
            }
        }

        // MOMENTS

        function setMonth(mom, value) {
            var dayOfMonth;

            if (!mom.isValid()) {
                // No op
                return mom;
            }

            if (typeof value === 'string') {
                if (/^\d+$/.test(value)) {
                    value = toInt(value);
                } else {
                    value = mom.localeData().monthsParse(value);
                    // TODO: Another silent failure?
                    if (!isNumber(value)) {
                        return mom;
                    }
                }
            }

            dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
            mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
            return mom;
        }

        function getSetMonth(value) {
            if (value != null) {
                setMonth(this, value);
                hooks.updateOffset(this, true);
                return this;
            } else {
                return get(this, 'Month');
            }
        }

        function getDaysInMonth() {
            return daysInMonth(this.year(), this.month());
        }

        function monthsShortRegex(isStrict) {
            if (this._monthsParseExact) {
                if (!hasOwnProp(this, '_monthsRegex')) {
                    computeMonthsParse.call(this);
                }
                if (isStrict) {
                    return this._monthsShortStrictRegex;
                } else {
                    return this._monthsShortRegex;
                }
            } else {
                if (!hasOwnProp(this, '_monthsShortRegex')) {
                    this._monthsShortRegex = defaultMonthsShortRegex;
                }
                return this._monthsShortStrictRegex && isStrict
                    ? this._monthsShortStrictRegex
                    : this._monthsShortRegex;
            }
        }

        function monthsRegex(isStrict) {
            if (this._monthsParseExact) {
                if (!hasOwnProp(this, '_monthsRegex')) {
                    computeMonthsParse.call(this);
                }
                if (isStrict) {
                    return this._monthsStrictRegex;
                } else {
                    return this._monthsRegex;
                }
            } else {
                if (!hasOwnProp(this, '_monthsRegex')) {
                    this._monthsRegex = defaultMonthsRegex;
                }
                return this._monthsStrictRegex && isStrict
                    ? this._monthsStrictRegex
                    : this._monthsRegex;
            }
        }

        function computeMonthsParse() {
            function cmpLenRev(a, b) {
                return b.length - a.length;
            }

            var shortPieces = [],
                longPieces = [],
                mixedPieces = [],
                i,
                mom;
            for (i = 0; i < 12; i++) {
                // make the regex if we don't have it already
                mom = createUTC([2000, i]);
                shortPieces.push(this.monthsShort(mom, ''));
                longPieces.push(this.months(mom, ''));
                mixedPieces.push(this.months(mom, ''));
                mixedPieces.push(this.monthsShort(mom, ''));
            }
            // Sorting makes sure if one month (or abbr) is a prefix of another it
            // will match the longer piece.
            shortPieces.sort(cmpLenRev);
            longPieces.sort(cmpLenRev);
            mixedPieces.sort(cmpLenRev);
            for (i = 0; i < 12; i++) {
                shortPieces[i] = regexEscape(shortPieces[i]);
                longPieces[i] = regexEscape(longPieces[i]);
            }
            for (i = 0; i < 24; i++) {
                mixedPieces[i] = regexEscape(mixedPieces[i]);
            }

            this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
            this._monthsShortRegex = this._monthsRegex;
            this._monthsStrictRegex = new RegExp(
                '^(' + longPieces.join('|') + ')',
                'i'
            );
            this._monthsShortStrictRegex = new RegExp(
                '^(' + shortPieces.join('|') + ')',
                'i'
            );
        }

        // FORMATTING

        addFormatToken('Y', 0, 0, function () {
            var y = this.year();
            return y <= 9999 ? zeroFill(y, 4) : '+' + y;
        });

        addFormatToken(0, ['YY', 2], 0, function () {
            return this.year() % 100;
        });

        addFormatToken(0, ['YYYY', 4], 0, 'year');
        addFormatToken(0, ['YYYYY', 5], 0, 'year');
        addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

        // ALIASES

        addUnitAlias('year', 'y');

        // PRIORITIES

        addUnitPriority('year', 1);

        // PARSING

        addRegexToken('Y', matchSigned);
        addRegexToken('YY', match1to2, match2);
        addRegexToken('YYYY', match1to4, match4);
        addRegexToken('YYYYY', match1to6, match6);
        addRegexToken('YYYYYY', match1to6, match6);

        addParseToken(['YYYYY', 'YYYYYY'], YEAR);
        addParseToken('YYYY', function (input, array) {
            array[YEAR] =
                input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
        });
        addParseToken('YY', function (input, array) {
            array[YEAR] = hooks.parseTwoDigitYear(input);
        });
        addParseToken('Y', function (input, array) {
            array[YEAR] = parseInt(input, 10);
        });

        // HELPERS

        function daysInYear(year) {
            return isLeapYear(year) ? 366 : 365;
        }

        // HOOKS

        hooks.parseTwoDigitYear = function (input) {
            return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
        };

        // MOMENTS

        var getSetYear = makeGetSet('FullYear', true);

        function getIsLeapYear() {
            return isLeapYear(this.year());
        }

        function createDate(y, m, d, h, M, s, ms) {
            // can't just apply() to create a date:
            // https://stackoverflow.com/q/181348
            var date;
            // the date constructor remaps years 0-99 to 1900-1999
            if (y < 100 && y >= 0) {
                // preserve leap years using a full 400 year cycle, then reset
                date = new Date(y + 400, m, d, h, M, s, ms);
                if (isFinite(date.getFullYear())) {
                    date.setFullYear(y);
                }
            } else {
                date = new Date(y, m, d, h, M, s, ms);
            }

            return date;
        }

        function createUTCDate(y) {
            var date, args;
            // the Date.UTC function remaps years 0-99 to 1900-1999
            if (y < 100 && y >= 0) {
                args = Array.prototype.slice.call(arguments);
                // preserve leap years using a full 400 year cycle, then reset
                args[0] = y + 400;
                date = new Date(Date.UTC.apply(null, args));
                if (isFinite(date.getUTCFullYear())) {
                    date.setUTCFullYear(y);
                }
            } else {
                date = new Date(Date.UTC.apply(null, arguments));
            }

            return date;
        }

        // start-of-first-week - start-of-year
        function firstWeekOffset(year, dow, doy) {
            var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
                fwd = 7 + dow - doy,
                // first-week day local weekday -- which local weekday is fwd
                fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

            return -fwdlw + fwd - 1;
        }

        // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
        function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
            var localWeekday = (7 + weekday - dow) % 7,
                weekOffset = firstWeekOffset(year, dow, doy),
                dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
                resYear,
                resDayOfYear;

            if (dayOfYear <= 0) {
                resYear = year - 1;
                resDayOfYear = daysInYear(resYear) + dayOfYear;
            } else if (dayOfYear > daysInYear(year)) {
                resYear = year + 1;
                resDayOfYear = dayOfYear - daysInYear(year);
            } else {
                resYear = year;
                resDayOfYear = dayOfYear;
            }

            return {
                year: resYear,
                dayOfYear: resDayOfYear,
            };
        }

        function weekOfYear(mom, dow, doy) {
            var weekOffset = firstWeekOffset(mom.year(), dow, doy),
                week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
                resWeek,
                resYear;

            if (week < 1) {
                resYear = mom.year() - 1;
                resWeek = week + weeksInYear(resYear, dow, doy);
            } else if (week > weeksInYear(mom.year(), dow, doy)) {
                resWeek = week - weeksInYear(mom.year(), dow, doy);
                resYear = mom.year() + 1;
            } else {
                resYear = mom.year();
                resWeek = week;
            }

            return {
                week: resWeek,
                year: resYear,
            };
        }

        function weeksInYear(year, dow, doy) {
            var weekOffset = firstWeekOffset(year, dow, doy),
                weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
            return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
        }

        // FORMATTING

        addFormatToken('w', ['ww', 2], 'wo', 'week');
        addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

        // ALIASES

        addUnitAlias('week', 'w');
        addUnitAlias('isoWeek', 'W');

        // PRIORITIES

        addUnitPriority('week', 5);
        addUnitPriority('isoWeek', 5);

        // PARSING

        addRegexToken('w', match1to2);
        addRegexToken('ww', match1to2, match2);
        addRegexToken('W', match1to2);
        addRegexToken('WW', match1to2, match2);

        addWeekParseToken(['w', 'ww', 'W', 'WW'], function (
            input,
            week,
            config,
            token
        ) {
            week[token.substr(0, 1)] = toInt(input);
        });

        // HELPERS

        // LOCALES

        function localeWeek(mom) {
            return weekOfYear(mom, this._week.dow, this._week.doy).week;
        }

        var defaultLocaleWeek = {
            dow: 0, // Sunday is the first day of the week.
            doy: 6, // The week that contains Jan 6th is the first week of the year.
        };

        function localeFirstDayOfWeek() {
            return this._week.dow;
        }

        function localeFirstDayOfYear() {
            return this._week.doy;
        }

        // MOMENTS

        function getSetWeek(input) {
            var week = this.localeData().week(this);
            return input == null ? week : this.add((input - week) * 7, 'd');
        }

        function getSetISOWeek(input) {
            var week = weekOfYear(this, 1, 4).week;
            return input == null ? week : this.add((input - week) * 7, 'd');
        }

        // FORMATTING

        addFormatToken('d', 0, 'do', 'day');

        addFormatToken('dd', 0, 0, function (format) {
            return this.localeData().weekdaysMin(this, format);
        });

        addFormatToken('ddd', 0, 0, function (format) {
            return this.localeData().weekdaysShort(this, format);
        });

        addFormatToken('dddd', 0, 0, function (format) {
            return this.localeData().weekdays(this, format);
        });

        addFormatToken('e', 0, 0, 'weekday');
        addFormatToken('E', 0, 0, 'isoWeekday');

        // ALIASES

        addUnitAlias('day', 'd');
        addUnitAlias('weekday', 'e');
        addUnitAlias('isoWeekday', 'E');

        // PRIORITY
        addUnitPriority('day', 11);
        addUnitPriority('weekday', 11);
        addUnitPriority('isoWeekday', 11);

        // PARSING

        addRegexToken('d', match1to2);
        addRegexToken('e', match1to2);
        addRegexToken('E', match1to2);
        addRegexToken('dd', function (isStrict, locale) {
            return locale.weekdaysMinRegex(isStrict);
        });
        addRegexToken('ddd', function (isStrict, locale) {
            return locale.weekdaysShortRegex(isStrict);
        });
        addRegexToken('dddd', function (isStrict, locale) {
            return locale.weekdaysRegex(isStrict);
        });

        addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
            var weekday = config._locale.weekdaysParse(input, token, config._strict);
            // if we didn't get a weekday name, mark the date as invalid
            if (weekday != null) {
                week.d = weekday;
            } else {
                getParsingFlags(config).invalidWeekday = input;
            }
        });

        addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
            week[token] = toInt(input);
        });

        // HELPERS

        function parseWeekday(input, locale) {
            if (typeof input !== 'string') {
                return input;
            }

            if (!isNaN(input)) {
                return parseInt(input, 10);
            }

            input = locale.weekdaysParse(input);
            if (typeof input === 'number') {
                return input;
            }

            return null;
        }

        function parseIsoWeekday(input, locale) {
            if (typeof input === 'string') {
                return locale.weekdaysParse(input) % 7 || 7;
            }
            return isNaN(input) ? null : input;
        }

        // LOCALES
        function shiftWeekdays(ws, n) {
            return ws.slice(n, 7).concat(ws.slice(0, n));
        }

        var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split(
                '_'
            ),
            defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
            defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
            defaultWeekdaysRegex = matchWord,
            defaultWeekdaysShortRegex = matchWord,
            defaultWeekdaysMinRegex = matchWord;

        function localeWeekdays(m, format) {
            var weekdays = isArray(this._weekdays)
                ? this._weekdays
                : this._weekdays[
                      m && m !== true && this._weekdays.isFormat.test(format)
                          ? 'format'
                          : 'standalone'
                  ];
            return m === true
                ? shiftWeekdays(weekdays, this._week.dow)
                : m
                ? weekdays[m.day()]
                : weekdays;
        }

        function localeWeekdaysShort(m) {
            return m === true
                ? shiftWeekdays(this._weekdaysShort, this._week.dow)
                : m
                ? this._weekdaysShort[m.day()]
                : this._weekdaysShort;
        }

        function localeWeekdaysMin(m) {
            return m === true
                ? shiftWeekdays(this._weekdaysMin, this._week.dow)
                : m
                ? this._weekdaysMin[m.day()]
                : this._weekdaysMin;
        }

        function handleStrictParse$1(weekdayName, format, strict) {
            var i,
                ii,
                mom,
                llc = weekdayName.toLocaleLowerCase();
            if (!this._weekdaysParse) {
                this._weekdaysParse = [];
                this._shortWeekdaysParse = [];
                this._minWeekdaysParse = [];

                for (i = 0; i < 7; ++i) {
                    mom = createUTC([2000, 1]).day(i);
                    this._minWeekdaysParse[i] = this.weekdaysMin(
                        mom,
                        ''
                    ).toLocaleLowerCase();
                    this._shortWeekdaysParse[i] = this.weekdaysShort(
                        mom,
                        ''
                    ).toLocaleLowerCase();
                    this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
                }
            }

            if (strict) {
                if (format === 'dddd') {
                    ii = indexOf.call(this._weekdaysParse, llc);
                    return ii !== -1 ? ii : null;
                } else if (format === 'ddd') {
                    ii = indexOf.call(this._shortWeekdaysParse, llc);
                    return ii !== -1 ? ii : null;
                } else {
                    ii = indexOf.call(this._minWeekdaysParse, llc);
                    return ii !== -1 ? ii : null;
                }
            } else {
                if (format === 'dddd') {
                    ii = indexOf.call(this._weekdaysParse, llc);
                    if (ii !== -1) {
                        return ii;
                    }
                    ii = indexOf.call(this._shortWeekdaysParse, llc);
                    if (ii !== -1) {
                        return ii;
                    }
                    ii = indexOf.call(this._minWeekdaysParse, llc);
                    return ii !== -1 ? ii : null;
                } else if (format === 'ddd') {
                    ii = indexOf.call(this._shortWeekdaysParse, llc);
                    if (ii !== -1) {
                        return ii;
                    }
                    ii = indexOf.call(this._weekdaysParse, llc);
                    if (ii !== -1) {
                        return ii;
                    }
                    ii = indexOf.call(this._minWeekdaysParse, llc);
                    return ii !== -1 ? ii : null;
                } else {
                    ii = indexOf.call(this._minWeekdaysParse, llc);
                    if (ii !== -1) {
                        return ii;
                    }
                    ii = indexOf.call(this._weekdaysParse, llc);
                    if (ii !== -1) {
                        return ii;
                    }
                    ii = indexOf.call(this._shortWeekdaysParse, llc);
                    return ii !== -1 ? ii : null;
                }
            }
        }

        function localeWeekdaysParse(weekdayName, format, strict) {
            var i, mom, regex;

            if (this._weekdaysParseExact) {
                return handleStrictParse$1.call(this, weekdayName, format, strict);
            }

            if (!this._weekdaysParse) {
                this._weekdaysParse = [];
                this._minWeekdaysParse = [];
                this._shortWeekdaysParse = [];
                this._fullWeekdaysParse = [];
            }

            for (i = 0; i < 7; i++) {
                // make the regex if we don't have it already

                mom = createUTC([2000, 1]).day(i);
                if (strict && !this._fullWeekdaysParse[i]) {
                    this._fullWeekdaysParse[i] = new RegExp(
                        '^' + this.weekdays(mom, '').replace('.', '\\.?') + '$',
                        'i'
                    );
                    this._shortWeekdaysParse[i] = new RegExp(
                        '^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$',
                        'i'
                    );
                    this._minWeekdaysParse[i] = new RegExp(
                        '^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$',
                        'i'
                    );
                }
                if (!this._weekdaysParse[i]) {
                    regex =
                        '^' +
                        this.weekdays(mom, '') +
                        '|^' +
                        this.weekdaysShort(mom, '') +
                        '|^' +
                        this.weekdaysMin(mom, '');
                    this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
                }
                // test the regex
                if (
                    strict &&
                    format === 'dddd' &&
                    this._fullWeekdaysParse[i].test(weekdayName)
                ) {
                    return i;
                } else if (
                    strict &&
                    format === 'ddd' &&
                    this._shortWeekdaysParse[i].test(weekdayName)
                ) {
                    return i;
                } else if (
                    strict &&
                    format === 'dd' &&
                    this._minWeekdaysParse[i].test(weekdayName)
                ) {
                    return i;
                } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                    return i;
                }
            }
        }

        // MOMENTS

        function getSetDayOfWeek(input) {
            if (!this.isValid()) {
                return input != null ? this : NaN;
            }
            var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
            if (input != null) {
                input = parseWeekday(input, this.localeData());
                return this.add(input - day, 'd');
            } else {
                return day;
            }
        }

        function getSetLocaleDayOfWeek(input) {
            if (!this.isValid()) {
                return input != null ? this : NaN;
            }
            var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
            return input == null ? weekday : this.add(input - weekday, 'd');
        }

        function getSetISODayOfWeek(input) {
            if (!this.isValid()) {
                return input != null ? this : NaN;
            }

            // behaves the same as moment#day except
            // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
            // as a setter, sunday should belong to the previous week.

            if (input != null) {
                var weekday = parseIsoWeekday(input, this.localeData());
                return this.day(this.day() % 7 ? weekday : weekday - 7);
            } else {
                return this.day() || 7;
            }
        }

        function weekdaysRegex(isStrict) {
            if (this._weekdaysParseExact) {
                if (!hasOwnProp(this, '_weekdaysRegex')) {
                    computeWeekdaysParse.call(this);
                }
                if (isStrict) {
                    return this._weekdaysStrictRegex;
                } else {
                    return this._weekdaysRegex;
                }
            } else {
                if (!hasOwnProp(this, '_weekdaysRegex')) {
                    this._weekdaysRegex = defaultWeekdaysRegex;
                }
                return this._weekdaysStrictRegex && isStrict
                    ? this._weekdaysStrictRegex
                    : this._weekdaysRegex;
            }
        }

        function weekdaysShortRegex(isStrict) {
            if (this._weekdaysParseExact) {
                if (!hasOwnProp(this, '_weekdaysRegex')) {
                    computeWeekdaysParse.call(this);
                }
                if (isStrict) {
                    return this._weekdaysShortStrictRegex;
                } else {
                    return this._weekdaysShortRegex;
                }
            } else {
                if (!hasOwnProp(this, '_weekdaysShortRegex')) {
                    this._weekdaysShortRegex = defaultWeekdaysShortRegex;
                }
                return this._weekdaysShortStrictRegex && isStrict
                    ? this._weekdaysShortStrictRegex
                    : this._weekdaysShortRegex;
            }
        }

        function weekdaysMinRegex(isStrict) {
            if (this._weekdaysParseExact) {
                if (!hasOwnProp(this, '_weekdaysRegex')) {
                    computeWeekdaysParse.call(this);
                }
                if (isStrict) {
                    return this._weekdaysMinStrictRegex;
                } else {
                    return this._weekdaysMinRegex;
                }
            } else {
                if (!hasOwnProp(this, '_weekdaysMinRegex')) {
                    this._weekdaysMinRegex = defaultWeekdaysMinRegex;
                }
                return this._weekdaysMinStrictRegex && isStrict
                    ? this._weekdaysMinStrictRegex
                    : this._weekdaysMinRegex;
            }
        }

        function computeWeekdaysParse() {
            function cmpLenRev(a, b) {
                return b.length - a.length;
            }

            var minPieces = [],
                shortPieces = [],
                longPieces = [],
                mixedPieces = [],
                i,
                mom,
                minp,
                shortp,
                longp;
            for (i = 0; i < 7; i++) {
                // make the regex if we don't have it already
                mom = createUTC([2000, 1]).day(i);
                minp = regexEscape(this.weekdaysMin(mom, ''));
                shortp = regexEscape(this.weekdaysShort(mom, ''));
                longp = regexEscape(this.weekdays(mom, ''));
                minPieces.push(minp);
                shortPieces.push(shortp);
                longPieces.push(longp);
                mixedPieces.push(minp);
                mixedPieces.push(shortp);
                mixedPieces.push(longp);
            }
            // Sorting makes sure if one weekday (or abbr) is a prefix of another it
            // will match the longer piece.
            minPieces.sort(cmpLenRev);
            shortPieces.sort(cmpLenRev);
            longPieces.sort(cmpLenRev);
            mixedPieces.sort(cmpLenRev);

            this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
            this._weekdaysShortRegex = this._weekdaysRegex;
            this._weekdaysMinRegex = this._weekdaysRegex;

            this._weekdaysStrictRegex = new RegExp(
                '^(' + longPieces.join('|') + ')',
                'i'
            );
            this._weekdaysShortStrictRegex = new RegExp(
                '^(' + shortPieces.join('|') + ')',
                'i'
            );
            this._weekdaysMinStrictRegex = new RegExp(
                '^(' + minPieces.join('|') + ')',
                'i'
            );
        }

        // FORMATTING

        function hFormat() {
            return this.hours() % 12 || 12;
        }

        function kFormat() {
            return this.hours() || 24;
        }

        addFormatToken('H', ['HH', 2], 0, 'hour');
        addFormatToken('h', ['hh', 2], 0, hFormat);
        addFormatToken('k', ['kk', 2], 0, kFormat);

        addFormatToken('hmm', 0, 0, function () {
            return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
        });

        addFormatToken('hmmss', 0, 0, function () {
            return (
                '' +
                hFormat.apply(this) +
                zeroFill(this.minutes(), 2) +
                zeroFill(this.seconds(), 2)
            );
        });

        addFormatToken('Hmm', 0, 0, function () {
            return '' + this.hours() + zeroFill(this.minutes(), 2);
        });

        addFormatToken('Hmmss', 0, 0, function () {
            return (
                '' +
                this.hours() +
                zeroFill(this.minutes(), 2) +
                zeroFill(this.seconds(), 2)
            );
        });

        function meridiem(token, lowercase) {
            addFormatToken(token, 0, 0, function () {
                return this.localeData().meridiem(
                    this.hours(),
                    this.minutes(),
                    lowercase
                );
            });
        }

        meridiem('a', true);
        meridiem('A', false);

        // ALIASES

        addUnitAlias('hour', 'h');

        // PRIORITY
        addUnitPriority('hour', 13);

        // PARSING

        function matchMeridiem(isStrict, locale) {
            return locale._meridiemParse;
        }

        addRegexToken('a', matchMeridiem);
        addRegexToken('A', matchMeridiem);
        addRegexToken('H', match1to2);
        addRegexToken('h', match1to2);
        addRegexToken('k', match1to2);
        addRegexToken('HH', match1to2, match2);
        addRegexToken('hh', match1to2, match2);
        addRegexToken('kk', match1to2, match2);

        addRegexToken('hmm', match3to4);
        addRegexToken('hmmss', match5to6);
        addRegexToken('Hmm', match3to4);
        addRegexToken('Hmmss', match5to6);

        addParseToken(['H', 'HH'], HOUR);
        addParseToken(['k', 'kk'], function (input, array, config) {
            var kInput = toInt(input);
            array[HOUR] = kInput === 24 ? 0 : kInput;
        });
        addParseToken(['a', 'A'], function (input, array, config) {
            config._isPm = config._locale.isPM(input);
            config._meridiem = input;
        });
        addParseToken(['h', 'hh'], function (input, array, config) {
            array[HOUR] = toInt(input);
            getParsingFlags(config).bigHour = true;
        });
        addParseToken('hmm', function (input, array, config) {
            var pos = input.length - 2;
            array[HOUR] = toInt(input.substr(0, pos));
            array[MINUTE] = toInt(input.substr(pos));
            getParsingFlags(config).bigHour = true;
        });
        addParseToken('hmmss', function (input, array, config) {
            var pos1 = input.length - 4,
                pos2 = input.length - 2;
            array[HOUR] = toInt(input.substr(0, pos1));
            array[MINUTE] = toInt(input.substr(pos1, 2));
            array[SECOND] = toInt(input.substr(pos2));
            getParsingFlags(config).bigHour = true;
        });
        addParseToken('Hmm', function (input, array, config) {
            var pos = input.length - 2;
            array[HOUR] = toInt(input.substr(0, pos));
            array[MINUTE] = toInt(input.substr(pos));
        });
        addParseToken('Hmmss', function (input, array, config) {
            var pos1 = input.length - 4,
                pos2 = input.length - 2;
            array[HOUR] = toInt(input.substr(0, pos1));
            array[MINUTE] = toInt(input.substr(pos1, 2));
            array[SECOND] = toInt(input.substr(pos2));
        });

        // LOCALES

        function localeIsPM(input) {
            // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
            // Using charAt should be more compatible.
            return (input + '').toLowerCase().charAt(0) === 'p';
        }

        var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i,
            // Setting the hour should keep the time, because the user explicitly
            // specified which hour they want. So trying to maintain the same hour (in
            // a new timezone) makes sense. Adding/subtracting hours does not follow
            // this rule.
            getSetHour = makeGetSet('Hours', true);

        function localeMeridiem(hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? 'pm' : 'PM';
            } else {
                return isLower ? 'am' : 'AM';
            }
        }

        var baseConfig = {
            calendar: defaultCalendar,
            longDateFormat: defaultLongDateFormat,
            invalidDate: defaultInvalidDate,
            ordinal: defaultOrdinal,
            dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
            relativeTime: defaultRelativeTime,

            months: defaultLocaleMonths,
            monthsShort: defaultLocaleMonthsShort,

            week: defaultLocaleWeek,

            weekdays: defaultLocaleWeekdays,
            weekdaysMin: defaultLocaleWeekdaysMin,
            weekdaysShort: defaultLocaleWeekdaysShort,

            meridiemParse: defaultLocaleMeridiemParse,
        };

        // internal storage for locale config files
        var locales = {},
            localeFamilies = {},
            globalLocale;

        function commonPrefix(arr1, arr2) {
            var i,
                minl = Math.min(arr1.length, arr2.length);
            for (i = 0; i < minl; i += 1) {
                if (arr1[i] !== arr2[i]) {
                    return i;
                }
            }
            return minl;
        }

        function normalizeLocale(key) {
            return key ? key.toLowerCase().replace('_', '-') : key;
        }

        // pick the locale from the array
        // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
        // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
        function chooseLocale(names) {
            var i = 0,
                j,
                next,
                locale,
                split;

            while (i < names.length) {
                split = normalizeLocale(names[i]).split('-');
                j = split.length;
                next = normalizeLocale(names[i + 1]);
                next = next ? next.split('-') : null;
                while (j > 0) {
                    locale = loadLocale(split.slice(0, j).join('-'));
                    if (locale) {
                        return locale;
                    }
                    if (
                        next &&
                        next.length >= j &&
                        commonPrefix(split, next) >= j - 1
                    ) {
                        //the next array item is better than a shallower substring of this one
                        break;
                    }
                    j--;
                }
                i++;
            }
            return globalLocale;
        }

        function loadLocale(name) {
            var oldLocale = null,
                aliasedRequire;
            // TODO: Find a better way to register and load all the locales in Node
            if (
                locales[name] === undefined &&
                'object' !== 'undefined' &&
                module &&
                module.exports
            ) {
                try {
                    oldLocale = globalLocale._abbr;
                    aliasedRequire = commonjsRequire;
                    aliasedRequire('./locale/' + name);
                    getSetGlobalLocale(oldLocale);
                } catch (e) {
                    // mark as not found to avoid repeating expensive file require call causing high CPU
                    // when trying to find en-US, en_US, en-us for every format call
                    locales[name] = null; // null means not found
                }
            }
            return locales[name];
        }

        // This function will load locale and then set the global locale.  If
        // no arguments are passed in, it will simply return the current global
        // locale key.
        function getSetGlobalLocale(key, values) {
            var data;
            if (key) {
                if (isUndefined(values)) {
                    data = getLocale(key);
                } else {
                    data = defineLocale(key, values);
                }

                if (data) {
                    // moment.duration._locale = moment._locale = data;
                    globalLocale = data;
                } else {
                    if (typeof console !== 'undefined' && console.warn) {
                        //warn user if arguments are passed but the locale could not be set
                        console.warn(
                            'Locale ' + key + ' not found. Did you forget to load it?'
                        );
                    }
                }
            }

            return globalLocale._abbr;
        }

        function defineLocale(name, config) {
            if (config !== null) {
                var locale,
                    parentConfig = baseConfig;
                config.abbr = name;
                if (locales[name] != null) {
                    deprecateSimple(
                        'defineLocaleOverride',
                        'use moment.updateLocale(localeName, config) to change ' +
                            'an existing locale. moment.defineLocale(localeName, ' +
                            'config) should only be used for creating a new locale ' +
                            'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.'
                    );
                    parentConfig = locales[name]._config;
                } else if (config.parentLocale != null) {
                    if (locales[config.parentLocale] != null) {
                        parentConfig = locales[config.parentLocale]._config;
                    } else {
                        locale = loadLocale(config.parentLocale);
                        if (locale != null) {
                            parentConfig = locale._config;
                        } else {
                            if (!localeFamilies[config.parentLocale]) {
                                localeFamilies[config.parentLocale] = [];
                            }
                            localeFamilies[config.parentLocale].push({
                                name: name,
                                config: config,
                            });
                            return null;
                        }
                    }
                }
                locales[name] = new Locale(mergeConfigs(parentConfig, config));

                if (localeFamilies[name]) {
                    localeFamilies[name].forEach(function (x) {
                        defineLocale(x.name, x.config);
                    });
                }

                // backwards compat for now: also set the locale
                // make sure we set the locale AFTER all child locales have been
                // created, so we won't end up with the child locale set.
                getSetGlobalLocale(name);

                return locales[name];
            } else {
                // useful for testing
                delete locales[name];
                return null;
            }
        }

        function updateLocale(name, config) {
            if (config != null) {
                var locale,
                    tmpLocale,
                    parentConfig = baseConfig;

                if (locales[name] != null && locales[name].parentLocale != null) {
                    // Update existing child locale in-place to avoid memory-leaks
                    locales[name].set(mergeConfigs(locales[name]._config, config));
                } else {
                    // MERGE
                    tmpLocale = loadLocale(name);
                    if (tmpLocale != null) {
                        parentConfig = tmpLocale._config;
                    }
                    config = mergeConfigs(parentConfig, config);
                    if (tmpLocale == null) {
                        // updateLocale is called for creating a new locale
                        // Set abbr so it will have a name (getters return
                        // undefined otherwise).
                        config.abbr = name;
                    }
                    locale = new Locale(config);
                    locale.parentLocale = locales[name];
                    locales[name] = locale;
                }

                // backwards compat for now: also set the locale
                getSetGlobalLocale(name);
            } else {
                // pass null for config to unupdate, useful for tests
                if (locales[name] != null) {
                    if (locales[name].parentLocale != null) {
                        locales[name] = locales[name].parentLocale;
                        if (name === getSetGlobalLocale()) {
                            getSetGlobalLocale(name);
                        }
                    } else if (locales[name] != null) {
                        delete locales[name];
                    }
                }
            }
            return locales[name];
        }

        // returns locale data
        function getLocale(key) {
            var locale;

            if (key && key._locale && key._locale._abbr) {
                key = key._locale._abbr;
            }

            if (!key) {
                return globalLocale;
            }

            if (!isArray(key)) {
                //short-circuit everything else
                locale = loadLocale(key);
                if (locale) {
                    return locale;
                }
                key = [key];
            }

            return chooseLocale(key);
        }

        function listLocales() {
            return keys(locales);
        }

        function checkOverflow(m) {
            var overflow,
                a = m._a;

            if (a && getParsingFlags(m).overflow === -2) {
                overflow =
                    a[MONTH] < 0 || a[MONTH] > 11
                        ? MONTH
                        : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH])
                        ? DATE
                        : a[HOUR] < 0 ||
                          a[HOUR] > 24 ||
                          (a[HOUR] === 24 &&
                              (a[MINUTE] !== 0 ||
                                  a[SECOND] !== 0 ||
                                  a[MILLISECOND] !== 0))
                        ? HOUR
                        : a[MINUTE] < 0 || a[MINUTE] > 59
                        ? MINUTE
                        : a[SECOND] < 0 || a[SECOND] > 59
                        ? SECOND
                        : a[MILLISECOND] < 0 || a[MILLISECOND] > 999
                        ? MILLISECOND
                        : -1;

                if (
                    getParsingFlags(m)._overflowDayOfYear &&
                    (overflow < YEAR || overflow > DATE)
                ) {
                    overflow = DATE;
                }
                if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                    overflow = WEEK;
                }
                if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                    overflow = WEEKDAY;
                }

                getParsingFlags(m).overflow = overflow;
            }

            return m;
        }

        // iso 8601 regex
        // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
        var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
            basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
            tzRegex = /Z|[+-]\d\d(?::?\d\d)?/,
            isoDates = [
                ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
                ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
                ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
                ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
                ['YYYY-DDD', /\d{4}-\d{3}/],
                ['YYYY-MM', /\d{4}-\d\d/, false],
                ['YYYYYYMMDD', /[+-]\d{10}/],
                ['YYYYMMDD', /\d{8}/],
                ['GGGG[W]WWE', /\d{4}W\d{3}/],
                ['GGGG[W]WW', /\d{4}W\d{2}/, false],
                ['YYYYDDD', /\d{7}/],
                ['YYYYMM', /\d{6}/, false],
                ['YYYY', /\d{4}/, false],
            ],
            // iso time formats and regexes
            isoTimes = [
                ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
                ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
                ['HH:mm:ss', /\d\d:\d\d:\d\d/],
                ['HH:mm', /\d\d:\d\d/],
                ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
                ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
                ['HHmmss', /\d\d\d\d\d\d/],
                ['HHmm', /\d\d\d\d/],
                ['HH', /\d\d/],
            ],
            aspNetJsonRegex = /^\/?Date\((-?\d+)/i,
            // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
            rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/,
            obsOffsets = {
                UT: 0,
                GMT: 0,
                EDT: -4 * 60,
                EST: -5 * 60,
                CDT: -5 * 60,
                CST: -6 * 60,
                MDT: -6 * 60,
                MST: -7 * 60,
                PDT: -7 * 60,
                PST: -8 * 60,
            };

        // date from iso format
        function configFromISO(config) {
            var i,
                l,
                string = config._i,
                match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
                allowTime,
                dateFormat,
                timeFormat,
                tzFormat;

            if (match) {
                getParsingFlags(config).iso = true;

                for (i = 0, l = isoDates.length; i < l; i++) {
                    if (isoDates[i][1].exec(match[1])) {
                        dateFormat = isoDates[i][0];
                        allowTime = isoDates[i][2] !== false;
                        break;
                    }
                }
                if (dateFormat == null) {
                    config._isValid = false;
                    return;
                }
                if (match[3]) {
                    for (i = 0, l = isoTimes.length; i < l; i++) {
                        if (isoTimes[i][1].exec(match[3])) {
                            // match[2] should be 'T' or space
                            timeFormat = (match[2] || ' ') + isoTimes[i][0];
                            break;
                        }
                    }
                    if (timeFormat == null) {
                        config._isValid = false;
                        return;
                    }
                }
                if (!allowTime && timeFormat != null) {
                    config._isValid = false;
                    return;
                }
                if (match[4]) {
                    if (tzRegex.exec(match[4])) {
                        tzFormat = 'Z';
                    } else {
                        config._isValid = false;
                        return;
                    }
                }
                config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
                configFromStringAndFormat(config);
            } else {
                config._isValid = false;
            }
        }

        function extractFromRFC2822Strings(
            yearStr,
            monthStr,
            dayStr,
            hourStr,
            minuteStr,
            secondStr
        ) {
            var result = [
                untruncateYear(yearStr),
                defaultLocaleMonthsShort.indexOf(monthStr),
                parseInt(dayStr, 10),
                parseInt(hourStr, 10),
                parseInt(minuteStr, 10),
            ];

            if (secondStr) {
                result.push(parseInt(secondStr, 10));
            }

            return result;
        }

        function untruncateYear(yearStr) {
            var year = parseInt(yearStr, 10);
            if (year <= 49) {
                return 2000 + year;
            } else if (year <= 999) {
                return 1900 + year;
            }
            return year;
        }

        function preprocessRFC2822(s) {
            // Remove comments and folding whitespace and replace multiple-spaces with a single space
            return s
                .replace(/\([^)]*\)|[\n\t]/g, ' ')
                .replace(/(\s\s+)/g, ' ')
                .replace(/^\s\s*/, '')
                .replace(/\s\s*$/, '');
        }

        function checkWeekday(weekdayStr, parsedInput, config) {
            if (weekdayStr) {
                // TODO: Replace the vanilla JS Date object with an independent day-of-week check.
                var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
                    weekdayActual = new Date(
                        parsedInput[0],
                        parsedInput[1],
                        parsedInput[2]
                    ).getDay();
                if (weekdayProvided !== weekdayActual) {
                    getParsingFlags(config).weekdayMismatch = true;
                    config._isValid = false;
                    return false;
                }
            }
            return true;
        }

        function calculateOffset(obsOffset, militaryOffset, numOffset) {
            if (obsOffset) {
                return obsOffsets[obsOffset];
            } else if (militaryOffset) {
                // the only allowed military tz is Z
                return 0;
            } else {
                var hm = parseInt(numOffset, 10),
                    m = hm % 100,
                    h = (hm - m) / 100;
                return h * 60 + m;
            }
        }

        // date and time from ref 2822 format
        function configFromRFC2822(config) {
            var match = rfc2822.exec(preprocessRFC2822(config._i)),
                parsedArray;
            if (match) {
                parsedArray = extractFromRFC2822Strings(
                    match[4],
                    match[3],
                    match[2],
                    match[5],
                    match[6],
                    match[7]
                );
                if (!checkWeekday(match[1], parsedArray, config)) {
                    return;
                }

                config._a = parsedArray;
                config._tzm = calculateOffset(match[8], match[9], match[10]);

                config._d = createUTCDate.apply(null, config._a);
                config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

                getParsingFlags(config).rfc2822 = true;
            } else {
                config._isValid = false;
            }
        }

        // date from 1) ASP.NET, 2) ISO, 3) RFC 2822 formats, or 4) optional fallback if parsing isn't strict
        function configFromString(config) {
            var matched = aspNetJsonRegex.exec(config._i);
            if (matched !== null) {
                config._d = new Date(+matched[1]);
                return;
            }

            configFromISO(config);
            if (config._isValid === false) {
                delete config._isValid;
            } else {
                return;
            }

            configFromRFC2822(config);
            if (config._isValid === false) {
                delete config._isValid;
            } else {
                return;
            }

            if (config._strict) {
                config._isValid = false;
            } else {
                // Final attempt, use Input Fallback
                hooks.createFromInputFallback(config);
            }
        }

        hooks.createFromInputFallback = deprecate(
            'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
                'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
                'discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.',
            function (config) {
                config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
            }
        );

        // Pick the first defined of two or three arguments.
        function defaults(a, b, c) {
            if (a != null) {
                return a;
            }
            if (b != null) {
                return b;
            }
            return c;
        }

        function currentDateArray(config) {
            // hooks is actually the exported moment object
            var nowValue = new Date(hooks.now());
            if (config._useUTC) {
                return [
                    nowValue.getUTCFullYear(),
                    nowValue.getUTCMonth(),
                    nowValue.getUTCDate(),
                ];
            }
            return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
        }

        // convert an array to a date.
        // the array should mirror the parameters below
        // note: all values past the year are optional and will default to the lowest possible value.
        // [year, month, day , hour, minute, second, millisecond]
        function configFromArray(config) {
            var i,
                date,
                input = [],
                currentDate,
                expectedWeekday,
                yearToUse;

            if (config._d) {
                return;
            }

            currentDate = currentDateArray(config);

            //compute day of the year from weeks and weekdays
            if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
                dayOfYearFromWeekInfo(config);
            }

            //if the day of the year is set, figure out what it is
            if (config._dayOfYear != null) {
                yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

                if (
                    config._dayOfYear > daysInYear(yearToUse) ||
                    config._dayOfYear === 0
                ) {
                    getParsingFlags(config)._overflowDayOfYear = true;
                }

                date = createUTCDate(yearToUse, 0, config._dayOfYear);
                config._a[MONTH] = date.getUTCMonth();
                config._a[DATE] = date.getUTCDate();
            }

            // Default to current date.
            // * if no year, month, day of month are given, default to today
            // * if day of month is given, default month and year
            // * if month is given, default only year
            // * if year is given, don't default anything
            for (i = 0; i < 3 && config._a[i] == null; ++i) {
                config._a[i] = input[i] = currentDate[i];
            }

            // Zero out whatever was not defaulted, including time
            for (; i < 7; i++) {
                config._a[i] = input[i] =
                    config._a[i] == null ? (i === 2 ? 1 : 0) : config._a[i];
            }

            // Check for 24:00:00.000
            if (
                config._a[HOUR] === 24 &&
                config._a[MINUTE] === 0 &&
                config._a[SECOND] === 0 &&
                config._a[MILLISECOND] === 0
            ) {
                config._nextDay = true;
                config._a[HOUR] = 0;
            }

            config._d = (config._useUTC ? createUTCDate : createDate).apply(
                null,
                input
            );
            expectedWeekday = config._useUTC
                ? config._d.getUTCDay()
                : config._d.getDay();

            // Apply timezone offset from input. The actual utcOffset can be changed
            // with parseZone.
            if (config._tzm != null) {
                config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
            }

            if (config._nextDay) {
                config._a[HOUR] = 24;
            }

            // check for mismatching day of week
            if (
                config._w &&
                typeof config._w.d !== 'undefined' &&
                config._w.d !== expectedWeekday
            ) {
                getParsingFlags(config).weekdayMismatch = true;
            }
        }

        function dayOfYearFromWeekInfo(config) {
            var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;

            w = config._w;
            if (w.GG != null || w.W != null || w.E != null) {
                dow = 1;
                doy = 4;

                // TODO: We need to take the current isoWeekYear, but that depends on
                // how we interpret now (local, utc, fixed offset). So create
                // a now version of current config (take local/utc/offset flags, and
                // create now).
                weekYear = defaults(
                    w.GG,
                    config._a[YEAR],
                    weekOfYear(createLocal(), 1, 4).year
                );
                week = defaults(w.W, 1);
                weekday = defaults(w.E, 1);
                if (weekday < 1 || weekday > 7) {
                    weekdayOverflow = true;
                }
            } else {
                dow = config._locale._week.dow;
                doy = config._locale._week.doy;

                curWeek = weekOfYear(createLocal(), dow, doy);

                weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

                // Default to current week.
                week = defaults(w.w, curWeek.week);

                if (w.d != null) {
                    // weekday -- low day numbers are considered next week
                    weekday = w.d;
                    if (weekday < 0 || weekday > 6) {
                        weekdayOverflow = true;
                    }
                } else if (w.e != null) {
                    // local weekday -- counting starts from beginning of week
                    weekday = w.e + dow;
                    if (w.e < 0 || w.e > 6) {
                        weekdayOverflow = true;
                    }
                } else {
                    // default to beginning of week
                    weekday = dow;
                }
            }
            if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
                getParsingFlags(config)._overflowWeeks = true;
            } else if (weekdayOverflow != null) {
                getParsingFlags(config)._overflowWeekday = true;
            } else {
                temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
                config._a[YEAR] = temp.year;
                config._dayOfYear = temp.dayOfYear;
            }
        }

        // constant that refers to the ISO standard
        hooks.ISO_8601 = function () {};

        // constant that refers to the RFC 2822 form
        hooks.RFC_2822 = function () {};

        // date from string and format string
        function configFromStringAndFormat(config) {
            // TODO: Move this to another part of the creation flow to prevent circular deps
            if (config._f === hooks.ISO_8601) {
                configFromISO(config);
                return;
            }
            if (config._f === hooks.RFC_2822) {
                configFromRFC2822(config);
                return;
            }
            config._a = [];
            getParsingFlags(config).empty = true;

            // This array is used to make a Date, either with `new Date` or `Date.UTC`
            var string = '' + config._i,
                i,
                parsedInput,
                tokens,
                token,
                skipped,
                stringLength = string.length,
                totalParsedInputLength = 0,
                era;

            tokens =
                expandFormat(config._f, config._locale).match(formattingTokens) || [];

            for (i = 0; i < tokens.length; i++) {
                token = tokens[i];
                parsedInput = (string.match(getParseRegexForToken(token, config)) ||
                    [])[0];
                if (parsedInput) {
                    skipped = string.substr(0, string.indexOf(parsedInput));
                    if (skipped.length > 0) {
                        getParsingFlags(config).unusedInput.push(skipped);
                    }
                    string = string.slice(
                        string.indexOf(parsedInput) + parsedInput.length
                    );
                    totalParsedInputLength += parsedInput.length;
                }
                // don't parse if it's not a known token
                if (formatTokenFunctions[token]) {
                    if (parsedInput) {
                        getParsingFlags(config).empty = false;
                    } else {
                        getParsingFlags(config).unusedTokens.push(token);
                    }
                    addTimeToArrayFromToken(token, parsedInput, config);
                } else if (config._strict && !parsedInput) {
                    getParsingFlags(config).unusedTokens.push(token);
                }
            }

            // add remaining unparsed input length to the string
            getParsingFlags(config).charsLeftOver =
                stringLength - totalParsedInputLength;
            if (string.length > 0) {
                getParsingFlags(config).unusedInput.push(string);
            }

            // clear _12h flag if hour is <= 12
            if (
                config._a[HOUR] <= 12 &&
                getParsingFlags(config).bigHour === true &&
                config._a[HOUR] > 0
            ) {
                getParsingFlags(config).bigHour = undefined;
            }

            getParsingFlags(config).parsedDateParts = config._a.slice(0);
            getParsingFlags(config).meridiem = config._meridiem;
            // handle meridiem
            config._a[HOUR] = meridiemFixWrap(
                config._locale,
                config._a[HOUR],
                config._meridiem
            );

            // handle era
            era = getParsingFlags(config).era;
            if (era !== null) {
                config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
            }

            configFromArray(config);
            checkOverflow(config);
        }

        function meridiemFixWrap(locale, hour, meridiem) {
            var isPm;

            if (meridiem == null) {
                // nothing to do
                return hour;
            }
            if (locale.meridiemHour != null) {
                return locale.meridiemHour(hour, meridiem);
            } else if (locale.isPM != null) {
                // Fallback
                isPm = locale.isPM(meridiem);
                if (isPm && hour < 12) {
                    hour += 12;
                }
                if (!isPm && hour === 12) {
                    hour = 0;
                }
                return hour;
            } else {
                // this is not supposed to happen
                return hour;
            }
        }

        // date from string and array of format strings
        function configFromStringAndArray(config) {
            var tempConfig,
                bestMoment,
                scoreToBeat,
                i,
                currentScore,
                validFormatFound,
                bestFormatIsValid = false;

            if (config._f.length === 0) {
                getParsingFlags(config).invalidFormat = true;
                config._d = new Date(NaN);
                return;
            }

            for (i = 0; i < config._f.length; i++) {
                currentScore = 0;
                validFormatFound = false;
                tempConfig = copyConfig({}, config);
                if (config._useUTC != null) {
                    tempConfig._useUTC = config._useUTC;
                }
                tempConfig._f = config._f[i];
                configFromStringAndFormat(tempConfig);

                if (isValid(tempConfig)) {
                    validFormatFound = true;
                }

                // if there is any input that was not parsed add a penalty for that format
                currentScore += getParsingFlags(tempConfig).charsLeftOver;

                //or tokens
                currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

                getParsingFlags(tempConfig).score = currentScore;

                if (!bestFormatIsValid) {
                    if (
                        scoreToBeat == null ||
                        currentScore < scoreToBeat ||
                        validFormatFound
                    ) {
                        scoreToBeat = currentScore;
                        bestMoment = tempConfig;
                        if (validFormatFound) {
                            bestFormatIsValid = true;
                        }
                    }
                } else {
                    if (currentScore < scoreToBeat) {
                        scoreToBeat = currentScore;
                        bestMoment = tempConfig;
                    }
                }
            }

            extend(config, bestMoment || tempConfig);
        }

        function configFromObject(config) {
            if (config._d) {
                return;
            }

            var i = normalizeObjectUnits(config._i),
                dayOrDate = i.day === undefined ? i.date : i.day;
            config._a = map(
                [i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond],
                function (obj) {
                    return obj && parseInt(obj, 10);
                }
            );

            configFromArray(config);
        }

        function createFromConfig(config) {
            var res = new Moment(checkOverflow(prepareConfig(config)));
            if (res._nextDay) {
                // Adding is smart enough around DST
                res.add(1, 'd');
                res._nextDay = undefined;
            }

            return res;
        }

        function prepareConfig(config) {
            var input = config._i,
                format = config._f;

            config._locale = config._locale || getLocale(config._l);

            if (input === null || (format === undefined && input === '')) {
                return createInvalid({ nullInput: true });
            }

            if (typeof input === 'string') {
                config._i = input = config._locale.preparse(input);
            }

            if (isMoment(input)) {
                return new Moment(checkOverflow(input));
            } else if (isDate(input)) {
                config._d = input;
            } else if (isArray(format)) {
                configFromStringAndArray(config);
            } else if (format) {
                configFromStringAndFormat(config);
            } else {
                configFromInput(config);
            }

            if (!isValid(config)) {
                config._d = null;
            }

            return config;
        }

        function configFromInput(config) {
            var input = config._i;
            if (isUndefined(input)) {
                config._d = new Date(hooks.now());
            } else if (isDate(input)) {
                config._d = new Date(input.valueOf());
            } else if (typeof input === 'string') {
                configFromString(config);
            } else if (isArray(input)) {
                config._a = map(input.slice(0), function (obj) {
                    return parseInt(obj, 10);
                });
                configFromArray(config);
            } else if (isObject(input)) {
                configFromObject(config);
            } else if (isNumber(input)) {
                // from milliseconds
                config._d = new Date(input);
            } else {
                hooks.createFromInputFallback(config);
            }
        }

        function createLocalOrUTC(input, format, locale, strict, isUTC) {
            var c = {};

            if (format === true || format === false) {
                strict = format;
                format = undefined;
            }

            if (locale === true || locale === false) {
                strict = locale;
                locale = undefined;
            }

            if (
                (isObject(input) && isObjectEmpty(input)) ||
                (isArray(input) && input.length === 0)
            ) {
                input = undefined;
            }
            // object construction must be done this way.
            // https://github.com/moment/moment/issues/1423
            c._isAMomentObject = true;
            c._useUTC = c._isUTC = isUTC;
            c._l = locale;
            c._i = input;
            c._f = format;
            c._strict = strict;

            return createFromConfig(c);
        }

        function createLocal(input, format, locale, strict) {
            return createLocalOrUTC(input, format, locale, strict, false);
        }

        var prototypeMin = deprecate(
                'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
                function () {
                    var other = createLocal.apply(null, arguments);
                    if (this.isValid() && other.isValid()) {
                        return other < this ? this : other;
                    } else {
                        return createInvalid();
                    }
                }
            ),
            prototypeMax = deprecate(
                'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
                function () {
                    var other = createLocal.apply(null, arguments);
                    if (this.isValid() && other.isValid()) {
                        return other > this ? this : other;
                    } else {
                        return createInvalid();
                    }
                }
            );

        // Pick a moment m from moments so that m[fn](other) is true for all
        // other. This relies on the function fn to be transitive.
        //
        // moments should either be an array of moment objects or an array, whose
        // first element is an array of moment objects.
        function pickBy(fn, moments) {
            var res, i;
            if (moments.length === 1 && isArray(moments[0])) {
                moments = moments[0];
            }
            if (!moments.length) {
                return createLocal();
            }
            res = moments[0];
            for (i = 1; i < moments.length; ++i) {
                if (!moments[i].isValid() || moments[i][fn](res)) {
                    res = moments[i];
                }
            }
            return res;
        }

        // TODO: Use [].sort instead?
        function min() {
            var args = [].slice.call(arguments, 0);

            return pickBy('isBefore', args);
        }

        function max() {
            var args = [].slice.call(arguments, 0);

            return pickBy('isAfter', args);
        }

        var now = function () {
            return Date.now ? Date.now() : +new Date();
        };

        var ordering = [
            'year',
            'quarter',
            'month',
            'week',
            'day',
            'hour',
            'minute',
            'second',
            'millisecond',
        ];

        function isDurationValid(m) {
            var key,
                unitHasDecimal = false,
                i;
            for (key in m) {
                if (
                    hasOwnProp(m, key) &&
                    !(
                        indexOf.call(ordering, key) !== -1 &&
                        (m[key] == null || !isNaN(m[key]))
                    )
                ) {
                    return false;
                }
            }

            for (i = 0; i < ordering.length; ++i) {
                if (m[ordering[i]]) {
                    if (unitHasDecimal) {
                        return false; // only allow non-integers for smallest unit
                    }
                    if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                        unitHasDecimal = true;
                    }
                }
            }

            return true;
        }

        function isValid$1() {
            return this._isValid;
        }

        function createInvalid$1() {
            return createDuration(NaN);
        }

        function Duration(duration) {
            var normalizedInput = normalizeObjectUnits(duration),
                years = normalizedInput.year || 0,
                quarters = normalizedInput.quarter || 0,
                months = normalizedInput.month || 0,
                weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
                days = normalizedInput.day || 0,
                hours = normalizedInput.hour || 0,
                minutes = normalizedInput.minute || 0,
                seconds = normalizedInput.second || 0,
                milliseconds = normalizedInput.millisecond || 0;

            this._isValid = isDurationValid(normalizedInput);

            // representation for dateAddRemove
            this._milliseconds =
                +milliseconds +
                seconds * 1e3 + // 1000
                minutes * 6e4 + // 1000 * 60
                hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
            // Because of dateAddRemove treats 24 hours as different from a
            // day when working around DST, we need to store them separately
            this._days = +days + weeks * 7;
            // It is impossible to translate months into days without knowing
            // which months you are are talking about, so we have to store
            // it separately.
            this._months = +months + quarters * 3 + years * 12;

            this._data = {};

            this._locale = getLocale();

            this._bubble();
        }

        function isDuration(obj) {
            return obj instanceof Duration;
        }

        function absRound(number) {
            if (number < 0) {
                return Math.round(-1 * number) * -1;
            } else {
                return Math.round(number);
            }
        }

        // compare two arrays, return the number of differences
        function compareArrays(array1, array2, dontConvert) {
            var len = Math.min(array1.length, array2.length),
                lengthDiff = Math.abs(array1.length - array2.length),
                diffs = 0,
                i;
            for (i = 0; i < len; i++) {
                if (
                    (dontConvert && array1[i] !== array2[i]) ||
                    (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))
                ) {
                    diffs++;
                }
            }
            return diffs + lengthDiff;
        }

        // FORMATTING

        function offset(token, separator) {
            addFormatToken(token, 0, 0, function () {
                var offset = this.utcOffset(),
                    sign = '+';
                if (offset < 0) {
                    offset = -offset;
                    sign = '-';
                }
                return (
                    sign +
                    zeroFill(~~(offset / 60), 2) +
                    separator +
                    zeroFill(~~offset % 60, 2)
                );
            });
        }

        offset('Z', ':');
        offset('ZZ', '');

        // PARSING

        addRegexToken('Z', matchShortOffset);
        addRegexToken('ZZ', matchShortOffset);
        addParseToken(['Z', 'ZZ'], function (input, array, config) {
            config._useUTC = true;
            config._tzm = offsetFromString(matchShortOffset, input);
        });

        // HELPERS

        // timezone chunker
        // '+10:00' > ['10',  '00']
        // '-1530'  > ['-15', '30']
        var chunkOffset = /([\+\-]|\d\d)/gi;

        function offsetFromString(matcher, string) {
            var matches = (string || '').match(matcher),
                chunk,
                parts,
                minutes;

            if (matches === null) {
                return null;
            }

            chunk = matches[matches.length - 1] || [];
            parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
            minutes = +(parts[1] * 60) + toInt(parts[2]);

            return minutes === 0 ? 0 : parts[0] === '+' ? minutes : -minutes;
        }

        // Return a moment from input, that is local/utc/zone equivalent to model.
        function cloneWithOffset(input, model) {
            var res, diff;
            if (model._isUTC) {
                res = model.clone();
                diff =
                    (isMoment(input) || isDate(input)
                        ? input.valueOf()
                        : createLocal(input).valueOf()) - res.valueOf();
                // Use low-level api, because this fn is low-level api.
                res._d.setTime(res._d.valueOf() + diff);
                hooks.updateOffset(res, false);
                return res;
            } else {
                return createLocal(input).local();
            }
        }

        function getDateOffset(m) {
            // On Firefox.24 Date#getTimezoneOffset returns a floating point.
            // https://github.com/moment/moment/pull/1871
            return -Math.round(m._d.getTimezoneOffset());
        }

        // HOOKS

        // This function will be called whenever a moment is mutated.
        // It is intended to keep the offset in sync with the timezone.
        hooks.updateOffset = function () {};

        // MOMENTS

        // keepLocalTime = true means only change the timezone, without
        // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
        // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
        // +0200, so we adjust the time as needed, to be valid.
        //
        // Keeping the time actually adds/subtracts (one hour)
        // from the actual represented time. That is why we call updateOffset
        // a second time. In case it wants us to change the offset again
        // _changeInProgress == true case, then we have to adjust, because
        // there is no such time in the given timezone.
        function getSetOffset(input, keepLocalTime, keepMinutes) {
            var offset = this._offset || 0,
                localAdjust;
            if (!this.isValid()) {
                return input != null ? this : NaN;
            }
            if (input != null) {
                if (typeof input === 'string') {
                    input = offsetFromString(matchShortOffset, input);
                    if (input === null) {
                        return this;
                    }
                } else if (Math.abs(input) < 16 && !keepMinutes) {
                    input = input * 60;
                }
                if (!this._isUTC && keepLocalTime) {
                    localAdjust = getDateOffset(this);
                }
                this._offset = input;
                this._isUTC = true;
                if (localAdjust != null) {
                    this.add(localAdjust, 'm');
                }
                if (offset !== input) {
                    if (!keepLocalTime || this._changeInProgress) {
                        addSubtract(
                            this,
                            createDuration(input - offset, 'm'),
                            1,
                            false
                        );
                    } else if (!this._changeInProgress) {
                        this._changeInProgress = true;
                        hooks.updateOffset(this, true);
                        this._changeInProgress = null;
                    }
                }
                return this;
            } else {
                return this._isUTC ? offset : getDateOffset(this);
            }
        }

        function getSetZone(input, keepLocalTime) {
            if (input != null) {
                if (typeof input !== 'string') {
                    input = -input;
                }

                this.utcOffset(input, keepLocalTime);

                return this;
            } else {
                return -this.utcOffset();
            }
        }

        function setOffsetToUTC(keepLocalTime) {
            return this.utcOffset(0, keepLocalTime);
        }

        function setOffsetToLocal(keepLocalTime) {
            if (this._isUTC) {
                this.utcOffset(0, keepLocalTime);
                this._isUTC = false;

                if (keepLocalTime) {
                    this.subtract(getDateOffset(this), 'm');
                }
            }
            return this;
        }

        function setOffsetToParsedOffset() {
            if (this._tzm != null) {
                this.utcOffset(this._tzm, false, true);
            } else if (typeof this._i === 'string') {
                var tZone = offsetFromString(matchOffset, this._i);
                if (tZone != null) {
                    this.utcOffset(tZone);
                } else {
                    this.utcOffset(0, true);
                }
            }
            return this;
        }

        function hasAlignedHourOffset(input) {
            if (!this.isValid()) {
                return false;
            }
            input = input ? createLocal(input).utcOffset() : 0;

            return (this.utcOffset() - input) % 60 === 0;
        }

        function isDaylightSavingTime() {
            return (
                this.utcOffset() > this.clone().month(0).utcOffset() ||
                this.utcOffset() > this.clone().month(5).utcOffset()
            );
        }

        function isDaylightSavingTimeShifted() {
            if (!isUndefined(this._isDSTShifted)) {
                return this._isDSTShifted;
            }

            var c = {},
                other;

            copyConfig(c, this);
            c = prepareConfig(c);

            if (c._a) {
                other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
                this._isDSTShifted =
                    this.isValid() && compareArrays(c._a, other.toArray()) > 0;
            } else {
                this._isDSTShifted = false;
            }

            return this._isDSTShifted;
        }

        function isLocal() {
            return this.isValid() ? !this._isUTC : false;
        }

        function isUtcOffset() {
            return this.isValid() ? this._isUTC : false;
        }

        function isUtc() {
            return this.isValid() ? this._isUTC && this._offset === 0 : false;
        }

        // ASP.NET json date format regex
        var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/,
            // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
            // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
            // and further modified to allow for strings containing both week and day
            isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

        function createDuration(input, key) {
            var duration = input,
                // matching against regexp is expensive, do it on demand
                match = null,
                sign,
                ret,
                diffRes;

            if (isDuration(input)) {
                duration = {
                    ms: input._milliseconds,
                    d: input._days,
                    M: input._months,
                };
            } else if (isNumber(input) || !isNaN(+input)) {
                duration = {};
                if (key) {
                    duration[key] = +input;
                } else {
                    duration.milliseconds = +input;
                }
            } else if ((match = aspNetRegex.exec(input))) {
                sign = match[1] === '-' ? -1 : 1;
                duration = {
                    y: 0,
                    d: toInt(match[DATE]) * sign,
                    h: toInt(match[HOUR]) * sign,
                    m: toInt(match[MINUTE]) * sign,
                    s: toInt(match[SECOND]) * sign,
                    ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign, // the millisecond decimal point is included in the match
                };
            } else if ((match = isoRegex.exec(input))) {
                sign = match[1] === '-' ? -1 : 1;
                duration = {
                    y: parseIso(match[2], sign),
                    M: parseIso(match[3], sign),
                    w: parseIso(match[4], sign),
                    d: parseIso(match[5], sign),
                    h: parseIso(match[6], sign),
                    m: parseIso(match[7], sign),
                    s: parseIso(match[8], sign),
                };
            } else if (duration == null) {
                // checks for null or undefined
                duration = {};
            } else if (
                typeof duration === 'object' &&
                ('from' in duration || 'to' in duration)
            ) {
                diffRes = momentsDifference(
                    createLocal(duration.from),
                    createLocal(duration.to)
                );

                duration = {};
                duration.ms = diffRes.milliseconds;
                duration.M = diffRes.months;
            }

            ret = new Duration(duration);

            if (isDuration(input) && hasOwnProp(input, '_locale')) {
                ret._locale = input._locale;
            }

            if (isDuration(input) && hasOwnProp(input, '_isValid')) {
                ret._isValid = input._isValid;
            }

            return ret;
        }

        createDuration.fn = Duration.prototype;
        createDuration.invalid = createInvalid$1;

        function parseIso(inp, sign) {
            // We'd normally use ~~inp for this, but unfortunately it also
            // converts floats to ints.
            // inp may be undefined, so careful calling replace on it.
            var res = inp && parseFloat(inp.replace(',', '.'));
            // apply sign while we're at it
            return (isNaN(res) ? 0 : res) * sign;
        }

        function positiveMomentsDifference(base, other) {
            var res = {};

            res.months =
                other.month() - base.month() + (other.year() - base.year()) * 12;
            if (base.clone().add(res.months, 'M').isAfter(other)) {
                --res.months;
            }

            res.milliseconds = +other - +base.clone().add(res.months, 'M');

            return res;
        }

        function momentsDifference(base, other) {
            var res;
            if (!(base.isValid() && other.isValid())) {
                return { milliseconds: 0, months: 0 };
            }

            other = cloneWithOffset(other, base);
            if (base.isBefore(other)) {
                res = positiveMomentsDifference(base, other);
            } else {
                res = positiveMomentsDifference(other, base);
                res.milliseconds = -res.milliseconds;
                res.months = -res.months;
            }

            return res;
        }

        // TODO: remove 'name' arg after deprecation is removed
        function createAdder(direction, name) {
            return function (val, period) {
                var dur, tmp;
                //invert the arguments, but complain about it
                if (period !== null && !isNaN(+period)) {
                    deprecateSimple(
                        name,
                        'moment().' +
                            name +
                            '(period, number) is deprecated. Please use moment().' +
                            name +
                            '(number, period). ' +
                            'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.'
                    );
                    tmp = val;
                    val = period;
                    period = tmp;
                }

                dur = createDuration(val, period);
                addSubtract(this, dur, direction);
                return this;
            };
        }

        function addSubtract(mom, duration, isAdding, updateOffset) {
            var milliseconds = duration._milliseconds,
                days = absRound(duration._days),
                months = absRound(duration._months);

            if (!mom.isValid()) {
                // No op
                return;
            }

            updateOffset = updateOffset == null ? true : updateOffset;

            if (months) {
                setMonth(mom, get(mom, 'Month') + months * isAdding);
            }
            if (days) {
                set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
            }
            if (milliseconds) {
                mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
            }
            if (updateOffset) {
                hooks.updateOffset(mom, days || months);
            }
        }

        var add = createAdder(1, 'add'),
            subtract = createAdder(-1, 'subtract');

        function isString(input) {
            return typeof input === 'string' || input instanceof String;
        }

        // type MomentInput = Moment | Date | string | number | (number | string)[] | MomentInputObject | void; // null | undefined
        function isMomentInput(input) {
            return (
                isMoment(input) ||
                isDate(input) ||
                isString(input) ||
                isNumber(input) ||
                isNumberOrStringArray(input) ||
                isMomentInputObject(input) ||
                input === null ||
                input === undefined
            );
        }

        function isMomentInputObject(input) {
            var objectTest = isObject(input) && !isObjectEmpty(input),
                propertyTest = false,
                properties = [
                    'years',
                    'year',
                    'y',
                    'months',
                    'month',
                    'M',
                    'days',
                    'day',
                    'd',
                    'dates',
                    'date',
                    'D',
                    'hours',
                    'hour',
                    'h',
                    'minutes',
                    'minute',
                    'm',
                    'seconds',
                    'second',
                    's',
                    'milliseconds',
                    'millisecond',
                    'ms',
                ],
                i,
                property;

            for (i = 0; i < properties.length; i += 1) {
                property = properties[i];
                propertyTest = propertyTest || hasOwnProp(input, property);
            }

            return objectTest && propertyTest;
        }

        function isNumberOrStringArray(input) {
            var arrayTest = isArray(input),
                dataTypeTest = false;
            if (arrayTest) {
                dataTypeTest =
                    input.filter(function (item) {
                        return !isNumber(item) && isString(input);
                    }).length === 0;
            }
            return arrayTest && dataTypeTest;
        }

        function isCalendarSpec(input) {
            var objectTest = isObject(input) && !isObjectEmpty(input),
                propertyTest = false,
                properties = [
                    'sameDay',
                    'nextDay',
                    'lastDay',
                    'nextWeek',
                    'lastWeek',
                    'sameElse',
                ],
                i,
                property;

            for (i = 0; i < properties.length; i += 1) {
                property = properties[i];
                propertyTest = propertyTest || hasOwnProp(input, property);
            }

            return objectTest && propertyTest;
        }

        function getCalendarFormat(myMoment, now) {
            var diff = myMoment.diff(now, 'days', true);
            return diff < -6
                ? 'sameElse'
                : diff < -1
                ? 'lastWeek'
                : diff < 0
                ? 'lastDay'
                : diff < 1
                ? 'sameDay'
                : diff < 2
                ? 'nextDay'
                : diff < 7
                ? 'nextWeek'
                : 'sameElse';
        }

        function calendar$1(time, formats) {
            // Support for single parameter, formats only overload to the calendar function
            if (arguments.length === 1) {
                if (!arguments[0]) {
                    time = undefined;
                    formats = undefined;
                } else if (isMomentInput(arguments[0])) {
                    time = arguments[0];
                    formats = undefined;
                } else if (isCalendarSpec(arguments[0])) {
                    formats = arguments[0];
                    time = undefined;
                }
            }
            // We want to compare the start of today, vs this.
            // Getting start-of-today depends on whether we're local/utc/offset or not.
            var now = time || createLocal(),
                sod = cloneWithOffset(now, this).startOf('day'),
                format = hooks.calendarFormat(this, sod) || 'sameElse',
                output =
                    formats &&
                    (isFunction(formats[format])
                        ? formats[format].call(this, now)
                        : formats[format]);

            return this.format(
                output || this.localeData().calendar(format, this, createLocal(now))
            );
        }

        function clone() {
            return new Moment(this);
        }

        function isAfter(input, units) {
            var localInput = isMoment(input) ? input : createLocal(input);
            if (!(this.isValid() && localInput.isValid())) {
                return false;
            }
            units = normalizeUnits(units) || 'millisecond';
            if (units === 'millisecond') {
                return this.valueOf() > localInput.valueOf();
            } else {
                return localInput.valueOf() < this.clone().startOf(units).valueOf();
            }
        }

        function isBefore(input, units) {
            var localInput = isMoment(input) ? input : createLocal(input);
            if (!(this.isValid() && localInput.isValid())) {
                return false;
            }
            units = normalizeUnits(units) || 'millisecond';
            if (units === 'millisecond') {
                return this.valueOf() < localInput.valueOf();
            } else {
                return this.clone().endOf(units).valueOf() < localInput.valueOf();
            }
        }

        function isBetween(from, to, units, inclusivity) {
            var localFrom = isMoment(from) ? from : createLocal(from),
                localTo = isMoment(to) ? to : createLocal(to);
            if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
                return false;
            }
            inclusivity = inclusivity || '()';
            return (
                (inclusivity[0] === '('
                    ? this.isAfter(localFrom, units)
                    : !this.isBefore(localFrom, units)) &&
                (inclusivity[1] === ')'
                    ? this.isBefore(localTo, units)
                    : !this.isAfter(localTo, units))
            );
        }

        function isSame(input, units) {
            var localInput = isMoment(input) ? input : createLocal(input),
                inputMs;
            if (!(this.isValid() && localInput.isValid())) {
                return false;
            }
            units = normalizeUnits(units) || 'millisecond';
            if (units === 'millisecond') {
                return this.valueOf() === localInput.valueOf();
            } else {
                inputMs = localInput.valueOf();
                return (
                    this.clone().startOf(units).valueOf() <= inputMs &&
                    inputMs <= this.clone().endOf(units).valueOf()
                );
            }
        }

        function isSameOrAfter(input, units) {
            return this.isSame(input, units) || this.isAfter(input, units);
        }

        function isSameOrBefore(input, units) {
            return this.isSame(input, units) || this.isBefore(input, units);
        }

        function diff(input, units, asFloat) {
            var that, zoneDelta, output;

            if (!this.isValid()) {
                return NaN;
            }

            that = cloneWithOffset(input, this);

            if (!that.isValid()) {
                return NaN;
            }

            zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

            units = normalizeUnits(units);

            switch (units) {
                case 'year':
                    output = monthDiff(this, that) / 12;
                    break;
                case 'month':
                    output = monthDiff(this, that);
                    break;
                case 'quarter':
                    output = monthDiff(this, that) / 3;
                    break;
                case 'second':
                    output = (this - that) / 1e3;
                    break; // 1000
                case 'minute':
                    output = (this - that) / 6e4;
                    break; // 1000 * 60
                case 'hour':
                    output = (this - that) / 36e5;
                    break; // 1000 * 60 * 60
                case 'day':
                    output = (this - that - zoneDelta) / 864e5;
                    break; // 1000 * 60 * 60 * 24, negate dst
                case 'week':
                    output = (this - that - zoneDelta) / 6048e5;
                    break; // 1000 * 60 * 60 * 24 * 7, negate dst
                default:
                    output = this - that;
            }

            return asFloat ? output : absFloor(output);
        }

        function monthDiff(a, b) {
            if (a.date() < b.date()) {
                // end-of-month calculations work correct when the start month has more
                // days than the end month.
                return -monthDiff(b, a);
            }
            // difference in months
            var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()),
                // b is in (anchor - 1 month, anchor + 1 month)
                anchor = a.clone().add(wholeMonthDiff, 'months'),
                anchor2,
                adjust;

            if (b - anchor < 0) {
                anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
                // linear across the month
                adjust = (b - anchor) / (anchor - anchor2);
            } else {
                anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
                // linear across the month
                adjust = (b - anchor) / (anchor2 - anchor);
            }

            //check for negative zero, return zero if negative zero
            return -(wholeMonthDiff + adjust) || 0;
        }

        hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
        hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

        function toString() {
            return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
        }

        function toISOString(keepOffset) {
            if (!this.isValid()) {
                return null;
            }
            var utc = keepOffset !== true,
                m = utc ? this.clone().utc() : this;
            if (m.year() < 0 || m.year() > 9999) {
                return formatMoment(
                    m,
                    utc
                        ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]'
                        : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ'
                );
            }
            if (isFunction(Date.prototype.toISOString)) {
                // native implementation is ~50x faster, use it when we can
                if (utc) {
                    return this.toDate().toISOString();
                } else {
                    return new Date(this.valueOf() + this.utcOffset() * 60 * 1000)
                        .toISOString()
                        .replace('Z', formatMoment(m, 'Z'));
                }
            }
            return formatMoment(
                m,
                utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ'
            );
        }

        /**
         * Return a human readable representation of a moment that can
         * also be evaluated to get a new moment which is the same
         *
         * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
         */
        function inspect() {
            if (!this.isValid()) {
                return 'moment.invalid(/* ' + this._i + ' */)';
            }
            var func = 'moment',
                zone = '',
                prefix,
                year,
                datetime,
                suffix;
            if (!this.isLocal()) {
                func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
                zone = 'Z';
            }
            prefix = '[' + func + '("]';
            year = 0 <= this.year() && this.year() <= 9999 ? 'YYYY' : 'YYYYYY';
            datetime = '-MM-DD[T]HH:mm:ss.SSS';
            suffix = zone + '[")]';

            return this.format(prefix + year + datetime + suffix);
        }

        function format(inputString) {
            if (!inputString) {
                inputString = this.isUtc()
                    ? hooks.defaultFormatUtc
                    : hooks.defaultFormat;
            }
            var output = formatMoment(this, inputString);
            return this.localeData().postformat(output);
        }

        function from(time, withoutSuffix) {
            if (
                this.isValid() &&
                ((isMoment(time) && time.isValid()) || createLocal(time).isValid())
            ) {
                return createDuration({ to: this, from: time })
                    .locale(this.locale())
                    .humanize(!withoutSuffix);
            } else {
                return this.localeData().invalidDate();
            }
        }

        function fromNow(withoutSuffix) {
            return this.from(createLocal(), withoutSuffix);
        }

        function to(time, withoutSuffix) {
            if (
                this.isValid() &&
                ((isMoment(time) && time.isValid()) || createLocal(time).isValid())
            ) {
                return createDuration({ from: this, to: time })
                    .locale(this.locale())
                    .humanize(!withoutSuffix);
            } else {
                return this.localeData().invalidDate();
            }
        }

        function toNow(withoutSuffix) {
            return this.to(createLocal(), withoutSuffix);
        }

        // If passed a locale key, it will set the locale for this
        // instance.  Otherwise, it will return the locale configuration
        // variables for this instance.
        function locale(key) {
            var newLocaleData;

            if (key === undefined) {
                return this._locale._abbr;
            } else {
                newLocaleData = getLocale(key);
                if (newLocaleData != null) {
                    this._locale = newLocaleData;
                }
                return this;
            }
        }

        var lang = deprecate(
            'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
            function (key) {
                if (key === undefined) {
                    return this.localeData();
                } else {
                    return this.locale(key);
                }
            }
        );

        function localeData() {
            return this._locale;
        }

        var MS_PER_SECOND = 1000,
            MS_PER_MINUTE = 60 * MS_PER_SECOND,
            MS_PER_HOUR = 60 * MS_PER_MINUTE,
            MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;

        // actual modulo - handles negative numbers (for dates before 1970):
        function mod$1(dividend, divisor) {
            return ((dividend % divisor) + divisor) % divisor;
        }

        function localStartOfDate(y, m, d) {
            // the date constructor remaps years 0-99 to 1900-1999
            if (y < 100 && y >= 0) {
                // preserve leap years using a full 400 year cycle, then reset
                return new Date(y + 400, m, d) - MS_PER_400_YEARS;
            } else {
                return new Date(y, m, d).valueOf();
            }
        }

        function utcStartOfDate(y, m, d) {
            // Date.UTC remaps years 0-99 to 1900-1999
            if (y < 100 && y >= 0) {
                // preserve leap years using a full 400 year cycle, then reset
                return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
            } else {
                return Date.UTC(y, m, d);
            }
        }

        function startOf(units) {
            var time, startOfDate;
            units = normalizeUnits(units);
            if (units === undefined || units === 'millisecond' || !this.isValid()) {
                return this;
            }

            startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

            switch (units) {
                case 'year':
                    time = startOfDate(this.year(), 0, 1);
                    break;
                case 'quarter':
                    time = startOfDate(
                        this.year(),
                        this.month() - (this.month() % 3),
                        1
                    );
                    break;
                case 'month':
                    time = startOfDate(this.year(), this.month(), 1);
                    break;
                case 'week':
                    time = startOfDate(
                        this.year(),
                        this.month(),
                        this.date() - this.weekday()
                    );
                    break;
                case 'isoWeek':
                    time = startOfDate(
                        this.year(),
                        this.month(),
                        this.date() - (this.isoWeekday() - 1)
                    );
                    break;
                case 'day':
                case 'date':
                    time = startOfDate(this.year(), this.month(), this.date());
                    break;
                case 'hour':
                    time = this._d.valueOf();
                    time -= mod$1(
                        time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
                        MS_PER_HOUR
                    );
                    break;
                case 'minute':
                    time = this._d.valueOf();
                    time -= mod$1(time, MS_PER_MINUTE);
                    break;
                case 'second':
                    time = this._d.valueOf();
                    time -= mod$1(time, MS_PER_SECOND);
                    break;
            }

            this._d.setTime(time);
            hooks.updateOffset(this, true);
            return this;
        }

        function endOf(units) {
            var time, startOfDate;
            units = normalizeUnits(units);
            if (units === undefined || units === 'millisecond' || !this.isValid()) {
                return this;
            }

            startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

            switch (units) {
                case 'year':
                    time = startOfDate(this.year() + 1, 0, 1) - 1;
                    break;
                case 'quarter':
                    time =
                        startOfDate(
                            this.year(),
                            this.month() - (this.month() % 3) + 3,
                            1
                        ) - 1;
                    break;
                case 'month':
                    time = startOfDate(this.year(), this.month() + 1, 1) - 1;
                    break;
                case 'week':
                    time =
                        startOfDate(
                            this.year(),
                            this.month(),
                            this.date() - this.weekday() + 7
                        ) - 1;
                    break;
                case 'isoWeek':
                    time =
                        startOfDate(
                            this.year(),
                            this.month(),
                            this.date() - (this.isoWeekday() - 1) + 7
                        ) - 1;
                    break;
                case 'day':
                case 'date':
                    time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
                    break;
                case 'hour':
                    time = this._d.valueOf();
                    time +=
                        MS_PER_HOUR -
                        mod$1(
                            time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
                            MS_PER_HOUR
                        ) -
                        1;
                    break;
                case 'minute':
                    time = this._d.valueOf();
                    time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
                    break;
                case 'second':
                    time = this._d.valueOf();
                    time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
                    break;
            }

            this._d.setTime(time);
            hooks.updateOffset(this, true);
            return this;
        }

        function valueOf() {
            return this._d.valueOf() - (this._offset || 0) * 60000;
        }

        function unix() {
            return Math.floor(this.valueOf() / 1000);
        }

        function toDate() {
            return new Date(this.valueOf());
        }

        function toArray() {
            var m = this;
            return [
                m.year(),
                m.month(),
                m.date(),
                m.hour(),
                m.minute(),
                m.second(),
                m.millisecond(),
            ];
        }

        function toObject() {
            var m = this;
            return {
                years: m.year(),
                months: m.month(),
                date: m.date(),
                hours: m.hours(),
                minutes: m.minutes(),
                seconds: m.seconds(),
                milliseconds: m.milliseconds(),
            };
        }

        function toJSON() {
            // new Date(NaN).toJSON() === null
            return this.isValid() ? this.toISOString() : null;
        }

        function isValid$2() {
            return isValid(this);
        }

        function parsingFlags() {
            return extend({}, getParsingFlags(this));
        }

        function invalidAt() {
            return getParsingFlags(this).overflow;
        }

        function creationData() {
            return {
                input: this._i,
                format: this._f,
                locale: this._locale,
                isUTC: this._isUTC,
                strict: this._strict,
            };
        }

        addFormatToken('N', 0, 0, 'eraAbbr');
        addFormatToken('NN', 0, 0, 'eraAbbr');
        addFormatToken('NNN', 0, 0, 'eraAbbr');
        addFormatToken('NNNN', 0, 0, 'eraName');
        addFormatToken('NNNNN', 0, 0, 'eraNarrow');

        addFormatToken('y', ['y', 1], 'yo', 'eraYear');
        addFormatToken('y', ['yy', 2], 0, 'eraYear');
        addFormatToken('y', ['yyy', 3], 0, 'eraYear');
        addFormatToken('y', ['yyyy', 4], 0, 'eraYear');

        addRegexToken('N', matchEraAbbr);
        addRegexToken('NN', matchEraAbbr);
        addRegexToken('NNN', matchEraAbbr);
        addRegexToken('NNNN', matchEraName);
        addRegexToken('NNNNN', matchEraNarrow);

        addParseToken(['N', 'NN', 'NNN', 'NNNN', 'NNNNN'], function (
            input,
            array,
            config,
            token
        ) {
            var era = config._locale.erasParse(input, token, config._strict);
            if (era) {
                getParsingFlags(config).era = era;
            } else {
                getParsingFlags(config).invalidEra = input;
            }
        });

        addRegexToken('y', matchUnsigned);
        addRegexToken('yy', matchUnsigned);
        addRegexToken('yyy', matchUnsigned);
        addRegexToken('yyyy', matchUnsigned);
        addRegexToken('yo', matchEraYearOrdinal);

        addParseToken(['y', 'yy', 'yyy', 'yyyy'], YEAR);
        addParseToken(['yo'], function (input, array, config, token) {
            var match;
            if (config._locale._eraYearOrdinalRegex) {
                match = input.match(config._locale._eraYearOrdinalRegex);
            }

            if (config._locale.eraYearOrdinalParse) {
                array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
            } else {
                array[YEAR] = parseInt(input, 10);
            }
        });

        function localeEras(m, format) {
            var i,
                l,
                date,
                eras = this._eras || getLocale('en')._eras;
            for (i = 0, l = eras.length; i < l; ++i) {
                switch (typeof eras[i].since) {
                    case 'string':
                        // truncate time
                        date = hooks(eras[i].since).startOf('day');
                        eras[i].since = date.valueOf();
                        break;
                }

                switch (typeof eras[i].until) {
                    case 'undefined':
                        eras[i].until = +Infinity;
                        break;
                    case 'string':
                        // truncate time
                        date = hooks(eras[i].until).startOf('day').valueOf();
                        eras[i].until = date.valueOf();
                        break;
                }
            }
            return eras;
        }

        function localeErasParse(eraName, format, strict) {
            var i,
                l,
                eras = this.eras(),
                name,
                abbr,
                narrow;
            eraName = eraName.toUpperCase();

            for (i = 0, l = eras.length; i < l; ++i) {
                name = eras[i].name.toUpperCase();
                abbr = eras[i].abbr.toUpperCase();
                narrow = eras[i].narrow.toUpperCase();

                if (strict) {
                    switch (format) {
                        case 'N':
                        case 'NN':
                        case 'NNN':
                            if (abbr === eraName) {
                                return eras[i];
                            }
                            break;

                        case 'NNNN':
                            if (name === eraName) {
                                return eras[i];
                            }
                            break;

                        case 'NNNNN':
                            if (narrow === eraName) {
                                return eras[i];
                            }
                            break;
                    }
                } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
                    return eras[i];
                }
            }
        }

        function localeErasConvertYear(era, year) {
            var dir = era.since <= era.until ? +1 : -1;
            if (year === undefined) {
                return hooks(era.since).year();
            } else {
                return hooks(era.since).year() + (year - era.offset) * dir;
            }
        }

        function getEraName() {
            var i,
                l,
                val,
                eras = this.localeData().eras();
            for (i = 0, l = eras.length; i < l; ++i) {
                // truncate time
                val = this.clone().startOf('day').valueOf();

                if (eras[i].since <= val && val <= eras[i].until) {
                    return eras[i].name;
                }
                if (eras[i].until <= val && val <= eras[i].since) {
                    return eras[i].name;
                }
            }

            return '';
        }

        function getEraNarrow() {
            var i,
                l,
                val,
                eras = this.localeData().eras();
            for (i = 0, l = eras.length; i < l; ++i) {
                // truncate time
                val = this.clone().startOf('day').valueOf();

                if (eras[i].since <= val && val <= eras[i].until) {
                    return eras[i].narrow;
                }
                if (eras[i].until <= val && val <= eras[i].since) {
                    return eras[i].narrow;
                }
            }

            return '';
        }

        function getEraAbbr() {
            var i,
                l,
                val,
                eras = this.localeData().eras();
            for (i = 0, l = eras.length; i < l; ++i) {
                // truncate time
                val = this.clone().startOf('day').valueOf();

                if (eras[i].since <= val && val <= eras[i].until) {
                    return eras[i].abbr;
                }
                if (eras[i].until <= val && val <= eras[i].since) {
                    return eras[i].abbr;
                }
            }

            return '';
        }

        function getEraYear() {
            var i,
                l,
                dir,
                val,
                eras = this.localeData().eras();
            for (i = 0, l = eras.length; i < l; ++i) {
                dir = eras[i].since <= eras[i].until ? +1 : -1;

                // truncate time
                val = this.clone().startOf('day').valueOf();

                if (
                    (eras[i].since <= val && val <= eras[i].until) ||
                    (eras[i].until <= val && val <= eras[i].since)
                ) {
                    return (
                        (this.year() - hooks(eras[i].since).year()) * dir +
                        eras[i].offset
                    );
                }
            }

            return this.year();
        }

        function erasNameRegex(isStrict) {
            if (!hasOwnProp(this, '_erasNameRegex')) {
                computeErasParse.call(this);
            }
            return isStrict ? this._erasNameRegex : this._erasRegex;
        }

        function erasAbbrRegex(isStrict) {
            if (!hasOwnProp(this, '_erasAbbrRegex')) {
                computeErasParse.call(this);
            }
            return isStrict ? this._erasAbbrRegex : this._erasRegex;
        }

        function erasNarrowRegex(isStrict) {
            if (!hasOwnProp(this, '_erasNarrowRegex')) {
                computeErasParse.call(this);
            }
            return isStrict ? this._erasNarrowRegex : this._erasRegex;
        }

        function matchEraAbbr(isStrict, locale) {
            return locale.erasAbbrRegex(isStrict);
        }

        function matchEraName(isStrict, locale) {
            return locale.erasNameRegex(isStrict);
        }

        function matchEraNarrow(isStrict, locale) {
            return locale.erasNarrowRegex(isStrict);
        }

        function matchEraYearOrdinal(isStrict, locale) {
            return locale._eraYearOrdinalRegex || matchUnsigned;
        }

        function computeErasParse() {
            var abbrPieces = [],
                namePieces = [],
                narrowPieces = [],
                mixedPieces = [],
                i,
                l,
                eras = this.eras();

            for (i = 0, l = eras.length; i < l; ++i) {
                namePieces.push(regexEscape(eras[i].name));
                abbrPieces.push(regexEscape(eras[i].abbr));
                narrowPieces.push(regexEscape(eras[i].narrow));

                mixedPieces.push(regexEscape(eras[i].name));
                mixedPieces.push(regexEscape(eras[i].abbr));
                mixedPieces.push(regexEscape(eras[i].narrow));
            }

            this._erasRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
            this._erasNameRegex = new RegExp('^(' + namePieces.join('|') + ')', 'i');
            this._erasAbbrRegex = new RegExp('^(' + abbrPieces.join('|') + ')', 'i');
            this._erasNarrowRegex = new RegExp(
                '^(' + narrowPieces.join('|') + ')',
                'i'
            );
        }

        // FORMATTING

        addFormatToken(0, ['gg', 2], 0, function () {
            return this.weekYear() % 100;
        });

        addFormatToken(0, ['GG', 2], 0, function () {
            return this.isoWeekYear() % 100;
        });

        function addWeekYearFormatToken(token, getter) {
            addFormatToken(0, [token, token.length], 0, getter);
        }

        addWeekYearFormatToken('gggg', 'weekYear');
        addWeekYearFormatToken('ggggg', 'weekYear');
        addWeekYearFormatToken('GGGG', 'isoWeekYear');
        addWeekYearFormatToken('GGGGG', 'isoWeekYear');

        // ALIASES

        addUnitAlias('weekYear', 'gg');
        addUnitAlias('isoWeekYear', 'GG');

        // PRIORITY

        addUnitPriority('weekYear', 1);
        addUnitPriority('isoWeekYear', 1);

        // PARSING

        addRegexToken('G', matchSigned);
        addRegexToken('g', matchSigned);
        addRegexToken('GG', match1to2, match2);
        addRegexToken('gg', match1to2, match2);
        addRegexToken('GGGG', match1to4, match4);
        addRegexToken('gggg', match1to4, match4);
        addRegexToken('GGGGG', match1to6, match6);
        addRegexToken('ggggg', match1to6, match6);

        addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (
            input,
            week,
            config,
            token
        ) {
            week[token.substr(0, 2)] = toInt(input);
        });

        addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
            week[token] = hooks.parseTwoDigitYear(input);
        });

        // MOMENTS

        function getSetWeekYear(input) {
            return getSetWeekYearHelper.call(
                this,
                input,
                this.week(),
                this.weekday(),
                this.localeData()._week.dow,
                this.localeData()._week.doy
            );
        }

        function getSetISOWeekYear(input) {
            return getSetWeekYearHelper.call(
                this,
                input,
                this.isoWeek(),
                this.isoWeekday(),
                1,
                4
            );
        }

        function getISOWeeksInYear() {
            return weeksInYear(this.year(), 1, 4);
        }

        function getISOWeeksInISOWeekYear() {
            return weeksInYear(this.isoWeekYear(), 1, 4);
        }

        function getWeeksInYear() {
            var weekInfo = this.localeData()._week;
            return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
        }

        function getWeeksInWeekYear() {
            var weekInfo = this.localeData()._week;
            return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
        }

        function getSetWeekYearHelper(input, week, weekday, dow, doy) {
            var weeksTarget;
            if (input == null) {
                return weekOfYear(this, dow, doy).year;
            } else {
                weeksTarget = weeksInYear(input, dow, doy);
                if (week > weeksTarget) {
                    week = weeksTarget;
                }
                return setWeekAll.call(this, input, week, weekday, dow, doy);
            }
        }

        function setWeekAll(weekYear, week, weekday, dow, doy) {
            var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
                date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

            this.year(date.getUTCFullYear());
            this.month(date.getUTCMonth());
            this.date(date.getUTCDate());
            return this;
        }

        // FORMATTING

        addFormatToken('Q', 0, 'Qo', 'quarter');

        // ALIASES

        addUnitAlias('quarter', 'Q');

        // PRIORITY

        addUnitPriority('quarter', 7);

        // PARSING

        addRegexToken('Q', match1);
        addParseToken('Q', function (input, array) {
            array[MONTH] = (toInt(input) - 1) * 3;
        });

        // MOMENTS

        function getSetQuarter(input) {
            return input == null
                ? Math.ceil((this.month() + 1) / 3)
                : this.month((input - 1) * 3 + (this.month() % 3));
        }

        // FORMATTING

        addFormatToken('D', ['DD', 2], 'Do', 'date');

        // ALIASES

        addUnitAlias('date', 'D');

        // PRIORITY
        addUnitPriority('date', 9);

        // PARSING

        addRegexToken('D', match1to2);
        addRegexToken('DD', match1to2, match2);
        addRegexToken('Do', function (isStrict, locale) {
            // TODO: Remove "ordinalParse" fallback in next major release.
            return isStrict
                ? locale._dayOfMonthOrdinalParse || locale._ordinalParse
                : locale._dayOfMonthOrdinalParseLenient;
        });

        addParseToken(['D', 'DD'], DATE);
        addParseToken('Do', function (input, array) {
            array[DATE] = toInt(input.match(match1to2)[0]);
        });

        // MOMENTS

        var getSetDayOfMonth = makeGetSet('Date', true);

        // FORMATTING

        addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

        // ALIASES

        addUnitAlias('dayOfYear', 'DDD');

        // PRIORITY
        addUnitPriority('dayOfYear', 4);

        // PARSING

        addRegexToken('DDD', match1to3);
        addRegexToken('DDDD', match3);
        addParseToken(['DDD', 'DDDD'], function (input, array, config) {
            config._dayOfYear = toInt(input);
        });

        // HELPERS

        // MOMENTS

        function getSetDayOfYear(input) {
            var dayOfYear =
                Math.round(
                    (this.clone().startOf('day') - this.clone().startOf('year')) / 864e5
                ) + 1;
            return input == null ? dayOfYear : this.add(input - dayOfYear, 'd');
        }

        // FORMATTING

        addFormatToken('m', ['mm', 2], 0, 'minute');

        // ALIASES

        addUnitAlias('minute', 'm');

        // PRIORITY

        addUnitPriority('minute', 14);

        // PARSING

        addRegexToken('m', match1to2);
        addRegexToken('mm', match1to2, match2);
        addParseToken(['m', 'mm'], MINUTE);

        // MOMENTS

        var getSetMinute = makeGetSet('Minutes', false);

        // FORMATTING

        addFormatToken('s', ['ss', 2], 0, 'second');

        // ALIASES

        addUnitAlias('second', 's');

        // PRIORITY

        addUnitPriority('second', 15);

        // PARSING

        addRegexToken('s', match1to2);
        addRegexToken('ss', match1to2, match2);
        addParseToken(['s', 'ss'], SECOND);

        // MOMENTS

        var getSetSecond = makeGetSet('Seconds', false);

        // FORMATTING

        addFormatToken('S', 0, 0, function () {
            return ~~(this.millisecond() / 100);
        });

        addFormatToken(0, ['SS', 2], 0, function () {
            return ~~(this.millisecond() / 10);
        });

        addFormatToken(0, ['SSS', 3], 0, 'millisecond');
        addFormatToken(0, ['SSSS', 4], 0, function () {
            return this.millisecond() * 10;
        });
        addFormatToken(0, ['SSSSS', 5], 0, function () {
            return this.millisecond() * 100;
        });
        addFormatToken(0, ['SSSSSS', 6], 0, function () {
            return this.millisecond() * 1000;
        });
        addFormatToken(0, ['SSSSSSS', 7], 0, function () {
            return this.millisecond() * 10000;
        });
        addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
            return this.millisecond() * 100000;
        });
        addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
            return this.millisecond() * 1000000;
        });

        // ALIASES

        addUnitAlias('millisecond', 'ms');

        // PRIORITY

        addUnitPriority('millisecond', 16);

        // PARSING

        addRegexToken('S', match1to3, match1);
        addRegexToken('SS', match1to3, match2);
        addRegexToken('SSS', match1to3, match3);

        var token, getSetMillisecond;
        for (token = 'SSSS'; token.length <= 9; token += 'S') {
            addRegexToken(token, matchUnsigned);
        }

        function parseMs(input, array) {
            array[MILLISECOND] = toInt(('0.' + input) * 1000);
        }

        for (token = 'S'; token.length <= 9; token += 'S') {
            addParseToken(token, parseMs);
        }

        getSetMillisecond = makeGetSet('Milliseconds', false);

        // FORMATTING

        addFormatToken('z', 0, 0, 'zoneAbbr');
        addFormatToken('zz', 0, 0, 'zoneName');

        // MOMENTS

        function getZoneAbbr() {
            return this._isUTC ? 'UTC' : '';
        }

        function getZoneName() {
            return this._isUTC ? 'Coordinated Universal Time' : '';
        }

        var proto = Moment.prototype;

        proto.add = add;
        proto.calendar = calendar$1;
        proto.clone = clone;
        proto.diff = diff;
        proto.endOf = endOf;
        proto.format = format;
        proto.from = from;
        proto.fromNow = fromNow;
        proto.to = to;
        proto.toNow = toNow;
        proto.get = stringGet;
        proto.invalidAt = invalidAt;
        proto.isAfter = isAfter;
        proto.isBefore = isBefore;
        proto.isBetween = isBetween;
        proto.isSame = isSame;
        proto.isSameOrAfter = isSameOrAfter;
        proto.isSameOrBefore = isSameOrBefore;
        proto.isValid = isValid$2;
        proto.lang = lang;
        proto.locale = locale;
        proto.localeData = localeData;
        proto.max = prototypeMax;
        proto.min = prototypeMin;
        proto.parsingFlags = parsingFlags;
        proto.set = stringSet;
        proto.startOf = startOf;
        proto.subtract = subtract;
        proto.toArray = toArray;
        proto.toObject = toObject;
        proto.toDate = toDate;
        proto.toISOString = toISOString;
        proto.inspect = inspect;
        if (typeof Symbol !== 'undefined' && Symbol.for != null) {
            proto[Symbol.for('nodejs.util.inspect.custom')] = function () {
                return 'Moment<' + this.format() + '>';
            };
        }
        proto.toJSON = toJSON;
        proto.toString = toString;
        proto.unix = unix;
        proto.valueOf = valueOf;
        proto.creationData = creationData;
        proto.eraName = getEraName;
        proto.eraNarrow = getEraNarrow;
        proto.eraAbbr = getEraAbbr;
        proto.eraYear = getEraYear;
        proto.year = getSetYear;
        proto.isLeapYear = getIsLeapYear;
        proto.weekYear = getSetWeekYear;
        proto.isoWeekYear = getSetISOWeekYear;
        proto.quarter = proto.quarters = getSetQuarter;
        proto.month = getSetMonth;
        proto.daysInMonth = getDaysInMonth;
        proto.week = proto.weeks = getSetWeek;
        proto.isoWeek = proto.isoWeeks = getSetISOWeek;
        proto.weeksInYear = getWeeksInYear;
        proto.weeksInWeekYear = getWeeksInWeekYear;
        proto.isoWeeksInYear = getISOWeeksInYear;
        proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
        proto.date = getSetDayOfMonth;
        proto.day = proto.days = getSetDayOfWeek;
        proto.weekday = getSetLocaleDayOfWeek;
        proto.isoWeekday = getSetISODayOfWeek;
        proto.dayOfYear = getSetDayOfYear;
        proto.hour = proto.hours = getSetHour;
        proto.minute = proto.minutes = getSetMinute;
        proto.second = proto.seconds = getSetSecond;
        proto.millisecond = proto.milliseconds = getSetMillisecond;
        proto.utcOffset = getSetOffset;
        proto.utc = setOffsetToUTC;
        proto.local = setOffsetToLocal;
        proto.parseZone = setOffsetToParsedOffset;
        proto.hasAlignedHourOffset = hasAlignedHourOffset;
        proto.isDST = isDaylightSavingTime;
        proto.isLocal = isLocal;
        proto.isUtcOffset = isUtcOffset;
        proto.isUtc = isUtc;
        proto.isUTC = isUtc;
        proto.zoneAbbr = getZoneAbbr;
        proto.zoneName = getZoneName;
        proto.dates = deprecate(
            'dates accessor is deprecated. Use date instead.',
            getSetDayOfMonth
        );
        proto.months = deprecate(
            'months accessor is deprecated. Use month instead',
            getSetMonth
        );
        proto.years = deprecate(
            'years accessor is deprecated. Use year instead',
            getSetYear
        );
        proto.zone = deprecate(
            'moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/',
            getSetZone
        );
        proto.isDSTShifted = deprecate(
            'isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information',
            isDaylightSavingTimeShifted
        );

        function createUnix(input) {
            return createLocal(input * 1000);
        }

        function createInZone() {
            return createLocal.apply(null, arguments).parseZone();
        }

        function preParsePostFormat(string) {
            return string;
        }

        var proto$1 = Locale.prototype;

        proto$1.calendar = calendar;
        proto$1.longDateFormat = longDateFormat;
        proto$1.invalidDate = invalidDate;
        proto$1.ordinal = ordinal;
        proto$1.preparse = preParsePostFormat;
        proto$1.postformat = preParsePostFormat;
        proto$1.relativeTime = relativeTime;
        proto$1.pastFuture = pastFuture;
        proto$1.set = set;
        proto$1.eras = localeEras;
        proto$1.erasParse = localeErasParse;
        proto$1.erasConvertYear = localeErasConvertYear;
        proto$1.erasAbbrRegex = erasAbbrRegex;
        proto$1.erasNameRegex = erasNameRegex;
        proto$1.erasNarrowRegex = erasNarrowRegex;

        proto$1.months = localeMonths;
        proto$1.monthsShort = localeMonthsShort;
        proto$1.monthsParse = localeMonthsParse;
        proto$1.monthsRegex = monthsRegex;
        proto$1.monthsShortRegex = monthsShortRegex;
        proto$1.week = localeWeek;
        proto$1.firstDayOfYear = localeFirstDayOfYear;
        proto$1.firstDayOfWeek = localeFirstDayOfWeek;

        proto$1.weekdays = localeWeekdays;
        proto$1.weekdaysMin = localeWeekdaysMin;
        proto$1.weekdaysShort = localeWeekdaysShort;
        proto$1.weekdaysParse = localeWeekdaysParse;

        proto$1.weekdaysRegex = weekdaysRegex;
        proto$1.weekdaysShortRegex = weekdaysShortRegex;
        proto$1.weekdaysMinRegex = weekdaysMinRegex;

        proto$1.isPM = localeIsPM;
        proto$1.meridiem = localeMeridiem;

        function get$1(format, index, field, setter) {
            var locale = getLocale(),
                utc = createUTC().set(setter, index);
            return locale[field](utc, format);
        }

        function listMonthsImpl(format, index, field) {
            if (isNumber(format)) {
                index = format;
                format = undefined;
            }

            format = format || '';

            if (index != null) {
                return get$1(format, index, field, 'month');
            }

            var i,
                out = [];
            for (i = 0; i < 12; i++) {
                out[i] = get$1(format, i, field, 'month');
            }
            return out;
        }

        // ()
        // (5)
        // (fmt, 5)
        // (fmt)
        // (true)
        // (true, 5)
        // (true, fmt, 5)
        // (true, fmt)
        function listWeekdaysImpl(localeSorted, format, index, field) {
            if (typeof localeSorted === 'boolean') {
                if (isNumber(format)) {
                    index = format;
                    format = undefined;
                }

                format = format || '';
            } else {
                format = localeSorted;
                index = format;
                localeSorted = false;

                if (isNumber(format)) {
                    index = format;
                    format = undefined;
                }

                format = format || '';
            }

            var locale = getLocale(),
                shift = localeSorted ? locale._week.dow : 0,
                i,
                out = [];

            if (index != null) {
                return get$1(format, (index + shift) % 7, field, 'day');
            }

            for (i = 0; i < 7; i++) {
                out[i] = get$1(format, (i + shift) % 7, field, 'day');
            }
            return out;
        }

        function listMonths(format, index) {
            return listMonthsImpl(format, index, 'months');
        }

        function listMonthsShort(format, index) {
            return listMonthsImpl(format, index, 'monthsShort');
        }

        function listWeekdays(localeSorted, format, index) {
            return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
        }

        function listWeekdaysShort(localeSorted, format, index) {
            return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
        }

        function listWeekdaysMin(localeSorted, format, index) {
            return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
        }

        getSetGlobalLocale('en', {
            eras: [
                {
                    since: '0001-01-01',
                    until: +Infinity,
                    offset: 1,
                    name: 'Anno Domini',
                    narrow: 'AD',
                    abbr: 'AD',
                },
                {
                    since: '0000-12-31',
                    until: -Infinity,
                    offset: 1,
                    name: 'Before Christ',
                    narrow: 'BC',
                    abbr: 'BC',
                },
            ],
            dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
            ordinal: function (number) {
                var b = number % 10,
                    output =
                        toInt((number % 100) / 10) === 1
                            ? 'th'
                            : b === 1
                            ? 'st'
                            : b === 2
                            ? 'nd'
                            : b === 3
                            ? 'rd'
                            : 'th';
                return number + output;
            },
        });

        // Side effect imports

        hooks.lang = deprecate(
            'moment.lang is deprecated. Use moment.locale instead.',
            getSetGlobalLocale
        );
        hooks.langData = deprecate(
            'moment.langData is deprecated. Use moment.localeData instead.',
            getLocale
        );

        var mathAbs = Math.abs;

        function abs() {
            var data = this._data;

            this._milliseconds = mathAbs(this._milliseconds);
            this._days = mathAbs(this._days);
            this._months = mathAbs(this._months);

            data.milliseconds = mathAbs(data.milliseconds);
            data.seconds = mathAbs(data.seconds);
            data.minutes = mathAbs(data.minutes);
            data.hours = mathAbs(data.hours);
            data.months = mathAbs(data.months);
            data.years = mathAbs(data.years);

            return this;
        }

        function addSubtract$1(duration, input, value, direction) {
            var other = createDuration(input, value);

            duration._milliseconds += direction * other._milliseconds;
            duration._days += direction * other._days;
            duration._months += direction * other._months;

            return duration._bubble();
        }

        // supports only 2.0-style add(1, 's') or add(duration)
        function add$1(input, value) {
            return addSubtract$1(this, input, value, 1);
        }

        // supports only 2.0-style subtract(1, 's') or subtract(duration)
        function subtract$1(input, value) {
            return addSubtract$1(this, input, value, -1);
        }

        function absCeil(number) {
            if (number < 0) {
                return Math.floor(number);
            } else {
                return Math.ceil(number);
            }
        }

        function bubble() {
            var milliseconds = this._milliseconds,
                days = this._days,
                months = this._months,
                data = this._data,
                seconds,
                minutes,
                hours,
                years,
                monthsFromDays;

            // if we have a mix of positive and negative values, bubble down first
            // check: https://github.com/moment/moment/issues/2166
            if (
                !(
                    (milliseconds >= 0 && days >= 0 && months >= 0) ||
                    (milliseconds <= 0 && days <= 0 && months <= 0)
                )
            ) {
                milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
                days = 0;
                months = 0;
            }

            // The following code bubbles up values, see the tests for
            // examples of what that means.
            data.milliseconds = milliseconds % 1000;

            seconds = absFloor(milliseconds / 1000);
            data.seconds = seconds % 60;

            minutes = absFloor(seconds / 60);
            data.minutes = minutes % 60;

            hours = absFloor(minutes / 60);
            data.hours = hours % 24;

            days += absFloor(hours / 24);

            // convert days to months
            monthsFromDays = absFloor(daysToMonths(days));
            months += monthsFromDays;
            days -= absCeil(monthsToDays(monthsFromDays));

            // 12 months -> 1 year
            years = absFloor(months / 12);
            months %= 12;

            data.days = days;
            data.months = months;
            data.years = years;

            return this;
        }

        function daysToMonths(days) {
            // 400 years have 146097 days (taking into account leap year rules)
            // 400 years have 12 months === 4800
            return (days * 4800) / 146097;
        }

        function monthsToDays(months) {
            // the reverse of daysToMonths
            return (months * 146097) / 4800;
        }

        function as(units) {
            if (!this.isValid()) {
                return NaN;
            }
            var days,
                months,
                milliseconds = this._milliseconds;

            units = normalizeUnits(units);

            if (units === 'month' || units === 'quarter' || units === 'year') {
                days = this._days + milliseconds / 864e5;
                months = this._months + daysToMonths(days);
                switch (units) {
                    case 'month':
                        return months;
                    case 'quarter':
                        return months / 3;
                    case 'year':
                        return months / 12;
                }
            } else {
                // handle milliseconds separately because of floating point math errors (issue #1867)
                days = this._days + Math.round(monthsToDays(this._months));
                switch (units) {
                    case 'week':
                        return days / 7 + milliseconds / 6048e5;
                    case 'day':
                        return days + milliseconds / 864e5;
                    case 'hour':
                        return days * 24 + milliseconds / 36e5;
                    case 'minute':
                        return days * 1440 + milliseconds / 6e4;
                    case 'second':
                        return days * 86400 + milliseconds / 1000;
                    // Math.floor prevents floating point math errors here
                    case 'millisecond':
                        return Math.floor(days * 864e5) + milliseconds;
                    default:
                        throw new Error('Unknown unit ' + units);
                }
            }
        }

        // TODO: Use this.as('ms')?
        function valueOf$1() {
            if (!this.isValid()) {
                return NaN;
            }
            return (
                this._milliseconds +
                this._days * 864e5 +
                (this._months % 12) * 2592e6 +
                toInt(this._months / 12) * 31536e6
            );
        }

        function makeAs(alias) {
            return function () {
                return this.as(alias);
            };
        }

        var asMilliseconds = makeAs('ms'),
            asSeconds = makeAs('s'),
            asMinutes = makeAs('m'),
            asHours = makeAs('h'),
            asDays = makeAs('d'),
            asWeeks = makeAs('w'),
            asMonths = makeAs('M'),
            asQuarters = makeAs('Q'),
            asYears = makeAs('y');

        function clone$1() {
            return createDuration(this);
        }

        function get$2(units) {
            units = normalizeUnits(units);
            return this.isValid() ? this[units + 's']() : NaN;
        }

        function makeGetter(name) {
            return function () {
                return this.isValid() ? this._data[name] : NaN;
            };
        }

        var milliseconds = makeGetter('milliseconds'),
            seconds = makeGetter('seconds'),
            minutes = makeGetter('minutes'),
            hours = makeGetter('hours'),
            days = makeGetter('days'),
            months = makeGetter('months'),
            years = makeGetter('years');

        function weeks() {
            return absFloor(this.days() / 7);
        }

        var round = Math.round,
            thresholds = {
                ss: 44, // a few seconds to seconds
                s: 45, // seconds to minute
                m: 45, // minutes to hour
                h: 22, // hours to day
                d: 26, // days to month/week
                w: null, // weeks to month
                M: 11, // months to year
            };

        // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
        function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
            return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
        }

        function relativeTime$1(posNegDuration, withoutSuffix, thresholds, locale) {
            var duration = createDuration(posNegDuration).abs(),
                seconds = round(duration.as('s')),
                minutes = round(duration.as('m')),
                hours = round(duration.as('h')),
                days = round(duration.as('d')),
                months = round(duration.as('M')),
                weeks = round(duration.as('w')),
                years = round(duration.as('y')),
                a =
                    (seconds <= thresholds.ss && ['s', seconds]) ||
                    (seconds < thresholds.s && ['ss', seconds]) ||
                    (minutes <= 1 && ['m']) ||
                    (minutes < thresholds.m && ['mm', minutes]) ||
                    (hours <= 1 && ['h']) ||
                    (hours < thresholds.h && ['hh', hours]) ||
                    (days <= 1 && ['d']) ||
                    (days < thresholds.d && ['dd', days]);

            if (thresholds.w != null) {
                a =
                    a ||
                    (weeks <= 1 && ['w']) ||
                    (weeks < thresholds.w && ['ww', weeks]);
            }
            a = a ||
                (months <= 1 && ['M']) ||
                (months < thresholds.M && ['MM', months]) ||
                (years <= 1 && ['y']) || ['yy', years];

            a[2] = withoutSuffix;
            a[3] = +posNegDuration > 0;
            a[4] = locale;
            return substituteTimeAgo.apply(null, a);
        }

        // This function allows you to set the rounding function for relative time strings
        function getSetRelativeTimeRounding(roundingFunction) {
            if (roundingFunction === undefined) {
                return round;
            }
            if (typeof roundingFunction === 'function') {
                round = roundingFunction;
                return true;
            }
            return false;
        }

        // This function allows you to set a threshold for relative time strings
        function getSetRelativeTimeThreshold(threshold, limit) {
            if (thresholds[threshold] === undefined) {
                return false;
            }
            if (limit === undefined) {
                return thresholds[threshold];
            }
            thresholds[threshold] = limit;
            if (threshold === 's') {
                thresholds.ss = limit - 1;
            }
            return true;
        }

        function humanize(argWithSuffix, argThresholds) {
            if (!this.isValid()) {
                return this.localeData().invalidDate();
            }

            var withSuffix = false,
                th = thresholds,
                locale,
                output;

            if (typeof argWithSuffix === 'object') {
                argThresholds = argWithSuffix;
                argWithSuffix = false;
            }
            if (typeof argWithSuffix === 'boolean') {
                withSuffix = argWithSuffix;
            }
            if (typeof argThresholds === 'object') {
                th = Object.assign({}, thresholds, argThresholds);
                if (argThresholds.s != null && argThresholds.ss == null) {
                    th.ss = argThresholds.s - 1;
                }
            }

            locale = this.localeData();
            output = relativeTime$1(this, !withSuffix, th, locale);

            if (withSuffix) {
                output = locale.pastFuture(+this, output);
            }

            return locale.postformat(output);
        }

        var abs$1 = Math.abs;

        function sign(x) {
            return (x > 0) - (x < 0) || +x;
        }

        function toISOString$1() {
            // for ISO strings we do not use the normal bubbling rules:
            //  * milliseconds bubble up until they become hours
            //  * days do not bubble at all
            //  * months bubble up until they become years
            // This is because there is no context-free conversion between hours and days
            // (think of clock changes)
            // and also not between days and months (28-31 days per month)
            if (!this.isValid()) {
                return this.localeData().invalidDate();
            }

            var seconds = abs$1(this._milliseconds) / 1000,
                days = abs$1(this._days),
                months = abs$1(this._months),
                minutes,
                hours,
                years,
                s,
                total = this.asSeconds(),
                totalSign,
                ymSign,
                daysSign,
                hmsSign;

            if (!total) {
                // this is the same as C#'s (Noda) and python (isodate)...
                // but not other JS (goog.date)
                return 'P0D';
            }

            // 3600 seconds -> 60 minutes -> 1 hour
            minutes = absFloor(seconds / 60);
            hours = absFloor(minutes / 60);
            seconds %= 60;
            minutes %= 60;

            // 12 months -> 1 year
            years = absFloor(months / 12);
            months %= 12;

            // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
            s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';

            totalSign = total < 0 ? '-' : '';
            ymSign = sign(this._months) !== sign(total) ? '-' : '';
            daysSign = sign(this._days) !== sign(total) ? '-' : '';
            hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';

            return (
                totalSign +
                'P' +
                (years ? ymSign + years + 'Y' : '') +
                (months ? ymSign + months + 'M' : '') +
                (days ? daysSign + days + 'D' : '') +
                (hours || minutes || seconds ? 'T' : '') +
                (hours ? hmsSign + hours + 'H' : '') +
                (minutes ? hmsSign + minutes + 'M' : '') +
                (seconds ? hmsSign + s + 'S' : '')
            );
        }

        var proto$2 = Duration.prototype;

        proto$2.isValid = isValid$1;
        proto$2.abs = abs;
        proto$2.add = add$1;
        proto$2.subtract = subtract$1;
        proto$2.as = as;
        proto$2.asMilliseconds = asMilliseconds;
        proto$2.asSeconds = asSeconds;
        proto$2.asMinutes = asMinutes;
        proto$2.asHours = asHours;
        proto$2.asDays = asDays;
        proto$2.asWeeks = asWeeks;
        proto$2.asMonths = asMonths;
        proto$2.asQuarters = asQuarters;
        proto$2.asYears = asYears;
        proto$2.valueOf = valueOf$1;
        proto$2._bubble = bubble;
        proto$2.clone = clone$1;
        proto$2.get = get$2;
        proto$2.milliseconds = milliseconds;
        proto$2.seconds = seconds;
        proto$2.minutes = minutes;
        proto$2.hours = hours;
        proto$2.days = days;
        proto$2.weeks = weeks;
        proto$2.months = months;
        proto$2.years = years;
        proto$2.humanize = humanize;
        proto$2.toISOString = toISOString$1;
        proto$2.toString = toISOString$1;
        proto$2.toJSON = toISOString$1;
        proto$2.locale = locale;
        proto$2.localeData = localeData;

        proto$2.toIsoString = deprecate(
            'toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)',
            toISOString$1
        );
        proto$2.lang = lang;

        // FORMATTING

        addFormatToken('X', 0, 0, 'unix');
        addFormatToken('x', 0, 0, 'valueOf');

        // PARSING

        addRegexToken('x', matchSigned);
        addRegexToken('X', matchTimestamp);
        addParseToken('X', function (input, array, config) {
            config._d = new Date(parseFloat(input) * 1000);
        });
        addParseToken('x', function (input, array, config) {
            config._d = new Date(toInt(input));
        });

        //! moment.js

        hooks.version = '2.29.1';

        setHookCallback(createLocal);

        hooks.fn = proto;
        hooks.min = min;
        hooks.max = max;
        hooks.now = now;
        hooks.utc = createUTC;
        hooks.unix = createUnix;
        hooks.months = listMonths;
        hooks.isDate = isDate;
        hooks.locale = getSetGlobalLocale;
        hooks.invalid = createInvalid;
        hooks.duration = createDuration;
        hooks.isMoment = isMoment;
        hooks.weekdays = listWeekdays;
        hooks.parseZone = createInZone;
        hooks.localeData = getLocale;
        hooks.isDuration = isDuration;
        hooks.monthsShort = listMonthsShort;
        hooks.weekdaysMin = listWeekdaysMin;
        hooks.defineLocale = defineLocale;
        hooks.updateLocale = updateLocale;
        hooks.locales = listLocales;
        hooks.weekdaysShort = listWeekdaysShort;
        hooks.normalizeUnits = normalizeUnits;
        hooks.relativeTimeRounding = getSetRelativeTimeRounding;
        hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
        hooks.calendarFormat = getCalendarFormat;
        hooks.prototype = proto;

        // currently HTML5 input type only supports 24-hour formats
        hooks.HTML5_FMT = {
            DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm', // <input type="datetime-local" />
            DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss', // <input type="datetime-local" step="1" />
            DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS', // <input type="datetime-local" step="0.001" />
            DATE: 'YYYY-MM-DD', // <input type="date" />
            TIME: 'HH:mm', // <input type="time" />
            TIME_SECONDS: 'HH:mm:ss', // <input type="time" step="1" />
            TIME_MS: 'HH:mm:ss.SSS', // <input type="time" step="0.001" />
            WEEK: 'GGGG-[W]WW', // <input type="week" />
            MONTH: 'YYYY-MM', // <input type="month" />
        };

        //! moment.js locale configuration

        hooks.defineLocale('af', {
            months: 'Januarie_Februarie_Maart_April_Mei_Junie_Julie_Augustus_September_Oktober_November_Desember'.split(
                '_'
            ),
            monthsShort: 'Jan_Feb_Mrt_Apr_Mei_Jun_Jul_Aug_Sep_Okt_Nov_Des'.split('_'),
            weekdays: 'Sondag_Maandag_Dinsdag_Woensdag_Donderdag_Vrydag_Saterdag'.split(
                '_'
            ),
            weekdaysShort: 'Son_Maa_Din_Woe_Don_Vry_Sat'.split('_'),
            weekdaysMin: 'So_Ma_Di_Wo_Do_Vr_Sa'.split('_'),
            meridiemParse: /vm|nm/i,
            isPM: function (input) {
                return /^nm$/i.test(input);
            },
            meridiem: function (hours, minutes, isLower) {
                if (hours < 12) {
                    return isLower ? 'vm' : 'VM';
                } else {
                    return isLower ? 'nm' : 'NM';
                }
            },
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'DD/MM/YYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY HH:mm',
                LLLL: 'dddd, D MMMM YYYY HH:mm',
            },
            calendar: {
                sameDay: '[Vandag om] LT',
                nextDay: '[Môre om] LT',
                nextWeek: 'dddd [om] LT',
                lastDay: '[Gister om] LT',
                lastWeek: '[Laas] dddd [om] LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: 'oor %s',
                past: '%s gelede',
                s: "'n paar sekondes",
                ss: '%d sekondes',
                m: "'n minuut",
                mm: '%d minute',
                h: "'n uur",
                hh: '%d ure',
                d: "'n dag",
                dd: '%d dae',
                M: "'n maand",
                MM: '%d maande',
                y: "'n jaar",
                yy: '%d jaar',
            },
            dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
            ordinal: function (number) {
                return (
                    number +
                    (number === 1 || number === 8 || number >= 20 ? 'ste' : 'de')
                ); // Thanks to Joris Röling : https://github.com/jjupiter
            },
            week: {
                dow: 1, // Maandag is die eerste dag van die week.
                doy: 4, // Die week wat die 4de Januarie bevat is die eerste week van die jaar.
            },
        });

        //! moment.js locale configuration

        var pluralForm = function (n) {
                return n === 0
                    ? 0
                    : n === 1
                    ? 1
                    : n === 2
                    ? 2
                    : n % 100 >= 3 && n % 100 <= 10
                    ? 3
                    : n % 100 >= 11
                    ? 4
                    : 5;
            },
            plurals = {
                s: [
                    'أقل من ثانية',
                    'ثانية واحدة',
                    ['ثانيتان', 'ثانيتين'],
                    '%d ثوان',
                    '%d ثانية',
                    '%d ثانية',
                ],
                m: [
                    'أقل من دقيقة',
                    'دقيقة واحدة',
                    ['دقيقتان', 'دقيقتين'],
                    '%d دقائق',
                    '%d دقيقة',
                    '%d دقيقة',
                ],
                h: [
                    'أقل من ساعة',
                    'ساعة واحدة',
                    ['ساعتان', 'ساعتين'],
                    '%d ساعات',
                    '%d ساعة',
                    '%d ساعة',
                ],
                d: [
                    'أقل من يوم',
                    'يوم واحد',
                    ['يومان', 'يومين'],
                    '%d أيام',
                    '%d يومًا',
                    '%d يوم',
                ],
                M: [
                    'أقل من شهر',
                    'شهر واحد',
                    ['شهران', 'شهرين'],
                    '%d أشهر',
                    '%d شهرا',
                    '%d شهر',
                ],
                y: [
                    'أقل من عام',
                    'عام واحد',
                    ['عامان', 'عامين'],
                    '%d أعوام',
                    '%d عامًا',
                    '%d عام',
                ],
            },
            pluralize = function (u) {
                return function (number, withoutSuffix, string, isFuture) {
                    var f = pluralForm(number),
                        str = plurals[u][pluralForm(number)];
                    if (f === 2) {
                        str = str[withoutSuffix ? 0 : 1];
                    }
                    return str.replace(/%d/i, number);
                };
            },
            months$1 = [
                'جانفي',
                'فيفري',
                'مارس',
                'أفريل',
                'ماي',
                'جوان',
                'جويلية',
                'أوت',
                'سبتمبر',
                'أكتوبر',
                'نوفمبر',
                'ديسمبر',
            ];

        hooks.defineLocale('ar-dz', {
            months: months$1,
            monthsShort: months$1,
            weekdays: 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
            weekdaysShort: 'أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت'.split('_'),
            weekdaysMin: 'ح_ن_ث_ر_خ_ج_س'.split('_'),
            weekdaysParseExact: true,
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'D/\u200FM/\u200FYYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY HH:mm',
                LLLL: 'dddd D MMMM YYYY HH:mm',
            },
            meridiemParse: /ص|م/,
            isPM: function (input) {
                return 'م' === input;
            },
            meridiem: function (hour, minute, isLower) {
                if (hour < 12) {
                    return 'ص';
                } else {
                    return 'م';
                }
            },
            calendar: {
                sameDay: '[اليوم عند الساعة] LT',
                nextDay: '[غدًا عند الساعة] LT',
                nextWeek: 'dddd [عند الساعة] LT',
                lastDay: '[أمس عند الساعة] LT',
                lastWeek: 'dddd [عند الساعة] LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: 'بعد %s',
                past: 'منذ %s',
                s: pluralize('s'),
                ss: pluralize('s'),
                m: pluralize('m'),
                mm: pluralize('m'),
                h: pluralize('h'),
                hh: pluralize('h'),
                d: pluralize('d'),
                dd: pluralize('d'),
                M: pluralize('M'),
                MM: pluralize('M'),
                y: pluralize('y'),
                yy: pluralize('y'),
            },
            postformat: function (string) {
                return string.replace(/,/g, '،');
            },
            week: {
                dow: 0, // Sunday is the first day of the week.
                doy: 4, // The week that contains Jan 4th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        hooks.defineLocale('ar-kw', {
            months: 'يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر'.split(
                '_'
            ),
            monthsShort: 'يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر'.split(
                '_'
            ),
            weekdays: 'الأحد_الإتنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
            weekdaysShort: 'احد_اتنين_ثلاثاء_اربعاء_خميس_جمعة_سبت'.split('_'),
            weekdaysMin: 'ح_ن_ث_ر_خ_ج_س'.split('_'),
            weekdaysParseExact: true,
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'DD/MM/YYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY HH:mm',
                LLLL: 'dddd D MMMM YYYY HH:mm',
            },
            calendar: {
                sameDay: '[اليوم على الساعة] LT',
                nextDay: '[غدا على الساعة] LT',
                nextWeek: 'dddd [على الساعة] LT',
                lastDay: '[أمس على الساعة] LT',
                lastWeek: 'dddd [على الساعة] LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: 'في %s',
                past: 'منذ %s',
                s: 'ثوان',
                ss: '%d ثانية',
                m: 'دقيقة',
                mm: '%d دقائق',
                h: 'ساعة',
                hh: '%d ساعات',
                d: 'يوم',
                dd: '%d أيام',
                M: 'شهر',
                MM: '%d أشهر',
                y: 'سنة',
                yy: '%d سنوات',
            },
            week: {
                dow: 0, // Sunday is the first day of the week.
                doy: 12, // The week that contains Jan 12th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        var symbolMap = {
                1: '1',
                2: '2',
                3: '3',
                4: '4',
                5: '5',
                6: '6',
                7: '7',
                8: '8',
                9: '9',
                0: '0',
            },
            pluralForm$1 = function (n) {
                return n === 0
                    ? 0
                    : n === 1
                    ? 1
                    : n === 2
                    ? 2
                    : n % 100 >= 3 && n % 100 <= 10
                    ? 3
                    : n % 100 >= 11
                    ? 4
                    : 5;
            },
            plurals$1 = {
                s: [
                    'أقل من ثانية',
                    'ثانية واحدة',
                    ['ثانيتان', 'ثانيتين'],
                    '%d ثوان',
                    '%d ثانية',
                    '%d ثانية',
                ],
                m: [
                    'أقل من دقيقة',
                    'دقيقة واحدة',
                    ['دقيقتان', 'دقيقتين'],
                    '%d دقائق',
                    '%d دقيقة',
                    '%d دقيقة',
                ],
                h: [
                    'أقل من ساعة',
                    'ساعة واحدة',
                    ['ساعتان', 'ساعتين'],
                    '%d ساعات',
                    '%d ساعة',
                    '%d ساعة',
                ],
                d: [
                    'أقل من يوم',
                    'يوم واحد',
                    ['يومان', 'يومين'],
                    '%d أيام',
                    '%d يومًا',
                    '%d يوم',
                ],
                M: [
                    'أقل من شهر',
                    'شهر واحد',
                    ['شهران', 'شهرين'],
                    '%d أشهر',
                    '%d شهرا',
                    '%d شهر',
                ],
                y: [
                    'أقل من عام',
                    'عام واحد',
                    ['عامان', 'عامين'],
                    '%d أعوام',
                    '%d عامًا',
                    '%d عام',
                ],
            },
            pluralize$1 = function (u) {
                return function (number, withoutSuffix, string, isFuture) {
                    var f = pluralForm$1(number),
                        str = plurals$1[u][pluralForm$1(number)];
                    if (f === 2) {
                        str = str[withoutSuffix ? 0 : 1];
                    }
                    return str.replace(/%d/i, number);
                };
            },
            months$2 = [
                'يناير',
                'فبراير',
                'مارس',
                'أبريل',
                'مايو',
                'يونيو',
                'يوليو',
                'أغسطس',
                'سبتمبر',
                'أكتوبر',
                'نوفمبر',
                'ديسمبر',
            ];

        hooks.defineLocale('ar-ly', {
            months: months$2,
            monthsShort: months$2,
            weekdays: 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
            weekdaysShort: 'أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت'.split('_'),
            weekdaysMin: 'ح_ن_ث_ر_خ_ج_س'.split('_'),
            weekdaysParseExact: true,
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'D/\u200FM/\u200FYYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY HH:mm',
                LLLL: 'dddd D MMMM YYYY HH:mm',
            },
            meridiemParse: /ص|م/,
            isPM: function (input) {
                return 'م' === input;
            },
            meridiem: function (hour, minute, isLower) {
                if (hour < 12) {
                    return 'ص';
                } else {
                    return 'م';
                }
            },
            calendar: {
                sameDay: '[اليوم عند الساعة] LT',
                nextDay: '[غدًا عند الساعة] LT',
                nextWeek: 'dddd [عند الساعة] LT',
                lastDay: '[أمس عند الساعة] LT',
                lastWeek: 'dddd [عند الساعة] LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: 'بعد %s',
                past: 'منذ %s',
                s: pluralize$1('s'),
                ss: pluralize$1('s'),
                m: pluralize$1('m'),
                mm: pluralize$1('m'),
                h: pluralize$1('h'),
                hh: pluralize$1('h'),
                d: pluralize$1('d'),
                dd: pluralize$1('d'),
                M: pluralize$1('M'),
                MM: pluralize$1('M'),
                y: pluralize$1('y'),
                yy: pluralize$1('y'),
            },
            preparse: function (string) {
                return string.replace(/،/g, ',');
            },
            postformat: function (string) {
                return string
                    .replace(/\d/g, function (match) {
                        return symbolMap[match];
                    })
                    .replace(/,/g, '،');
            },
            week: {
                dow: 6, // Saturday is the first day of the week.
                doy: 12, // The week that contains Jan 12th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        hooks.defineLocale('ar-ma', {
            months: 'يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر'.split(
                '_'
            ),
            monthsShort: 'يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر'.split(
                '_'
            ),
            weekdays: 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
            weekdaysShort: 'احد_اثنين_ثلاثاء_اربعاء_خميس_جمعة_سبت'.split('_'),
            weekdaysMin: 'ح_ن_ث_ر_خ_ج_س'.split('_'),
            weekdaysParseExact: true,
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'DD/MM/YYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY HH:mm',
                LLLL: 'dddd D MMMM YYYY HH:mm',
            },
            calendar: {
                sameDay: '[اليوم على الساعة] LT',
                nextDay: '[غدا على الساعة] LT',
                nextWeek: 'dddd [على الساعة] LT',
                lastDay: '[أمس على الساعة] LT',
                lastWeek: 'dddd [على الساعة] LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: 'في %s',
                past: 'منذ %s',
                s: 'ثوان',
                ss: '%d ثانية',
                m: 'دقيقة',
                mm: '%d دقائق',
                h: 'ساعة',
                hh: '%d ساعات',
                d: 'يوم',
                dd: '%d أيام',
                M: 'شهر',
                MM: '%d أشهر',
                y: 'سنة',
                yy: '%d سنوات',
            },
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 4, // The week that contains Jan 4th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        var symbolMap$1 = {
                1: '١',
                2: '٢',
                3: '٣',
                4: '٤',
                5: '٥',
                6: '٦',
                7: '٧',
                8: '٨',
                9: '٩',
                0: '٠',
            },
            numberMap = {
                '١': '1',
                '٢': '2',
                '٣': '3',
                '٤': '4',
                '٥': '5',
                '٦': '6',
                '٧': '7',
                '٨': '8',
                '٩': '9',
                '٠': '0',
            };

        hooks.defineLocale('ar-sa', {
            months: 'يناير_فبراير_مارس_أبريل_مايو_يونيو_يوليو_أغسطس_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split(
                '_'
            ),
            monthsShort: 'يناير_فبراير_مارس_أبريل_مايو_يونيو_يوليو_أغسطس_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split(
                '_'
            ),
            weekdays: 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
            weekdaysShort: 'أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت'.split('_'),
            weekdaysMin: 'ح_ن_ث_ر_خ_ج_س'.split('_'),
            weekdaysParseExact: true,
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'DD/MM/YYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY HH:mm',
                LLLL: 'dddd D MMMM YYYY HH:mm',
            },
            meridiemParse: /ص|م/,
            isPM: function (input) {
                return 'م' === input;
            },
            meridiem: function (hour, minute, isLower) {
                if (hour < 12) {
                    return 'ص';
                } else {
                    return 'م';
                }
            },
            calendar: {
                sameDay: '[اليوم على الساعة] LT',
                nextDay: '[غدا على الساعة] LT',
                nextWeek: 'dddd [على الساعة] LT',
                lastDay: '[أمس على الساعة] LT',
                lastWeek: 'dddd [على الساعة] LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: 'في %s',
                past: 'منذ %s',
                s: 'ثوان',
                ss: '%d ثانية',
                m: 'دقيقة',
                mm: '%d دقائق',
                h: 'ساعة',
                hh: '%d ساعات',
                d: 'يوم',
                dd: '%d أيام',
                M: 'شهر',
                MM: '%d أشهر',
                y: 'سنة',
                yy: '%d سنوات',
            },
            preparse: function (string) {
                return string
                    .replace(/[١٢٣٤٥٦٧٨٩٠]/g, function (match) {
                        return numberMap[match];
                    })
                    .replace(/،/g, ',');
            },
            postformat: function (string) {
                return string
                    .replace(/\d/g, function (match) {
                        return symbolMap$1[match];
                    })
                    .replace(/,/g, '،');
            },
            week: {
                dow: 0, // Sunday is the first day of the week.
                doy: 6, // The week that contains Jan 6th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        hooks.defineLocale('ar-tn', {
            months: 'جانفي_فيفري_مارس_أفريل_ماي_جوان_جويلية_أوت_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split(
                '_'
            ),
            monthsShort: 'جانفي_فيفري_مارس_أفريل_ماي_جوان_جويلية_أوت_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split(
                '_'
            ),
            weekdays: 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
            weekdaysShort: 'أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت'.split('_'),
            weekdaysMin: 'ح_ن_ث_ر_خ_ج_س'.split('_'),
            weekdaysParseExact: true,
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'DD/MM/YYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY HH:mm',
                LLLL: 'dddd D MMMM YYYY HH:mm',
            },
            calendar: {
                sameDay: '[اليوم على الساعة] LT',
                nextDay: '[غدا على الساعة] LT',
                nextWeek: 'dddd [على الساعة] LT',
                lastDay: '[أمس على الساعة] LT',
                lastWeek: 'dddd [على الساعة] LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: 'في %s',
                past: 'منذ %s',
                s: 'ثوان',
                ss: '%d ثانية',
                m: 'دقيقة',
                mm: '%d دقائق',
                h: 'ساعة',
                hh: '%d ساعات',
                d: 'يوم',
                dd: '%d أيام',
                M: 'شهر',
                MM: '%d أشهر',
                y: 'سنة',
                yy: '%d سنوات',
            },
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 4, // The week that contains Jan 4th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        var symbolMap$2 = {
                1: '١',
                2: '٢',
                3: '٣',
                4: '٤',
                5: '٥',
                6: '٦',
                7: '٧',
                8: '٨',
                9: '٩',
                0: '٠',
            },
            numberMap$1 = {
                '١': '1',
                '٢': '2',
                '٣': '3',
                '٤': '4',
                '٥': '5',
                '٦': '6',
                '٧': '7',
                '٨': '8',
                '٩': '9',
                '٠': '0',
            },
            pluralForm$2 = function (n) {
                return n === 0
                    ? 0
                    : n === 1
                    ? 1
                    : n === 2
                    ? 2
                    : n % 100 >= 3 && n % 100 <= 10
                    ? 3
                    : n % 100 >= 11
                    ? 4
                    : 5;
            },
            plurals$2 = {
                s: [
                    'أقل من ثانية',
                    'ثانية واحدة',
                    ['ثانيتان', 'ثانيتين'],
                    '%d ثوان',
                    '%d ثانية',
                    '%d ثانية',
                ],
                m: [
                    'أقل من دقيقة',
                    'دقيقة واحدة',
                    ['دقيقتان', 'دقيقتين'],
                    '%d دقائق',
                    '%d دقيقة',
                    '%d دقيقة',
                ],
                h: [
                    'أقل من ساعة',
                    'ساعة واحدة',
                    ['ساعتان', 'ساعتين'],
                    '%d ساعات',
                    '%d ساعة',
                    '%d ساعة',
                ],
                d: [
                    'أقل من يوم',
                    'يوم واحد',
                    ['يومان', 'يومين'],
                    '%d أيام',
                    '%d يومًا',
                    '%d يوم',
                ],
                M: [
                    'أقل من شهر',
                    'شهر واحد',
                    ['شهران', 'شهرين'],
                    '%d أشهر',
                    '%d شهرا',
                    '%d شهر',
                ],
                y: [
                    'أقل من عام',
                    'عام واحد',
                    ['عامان', 'عامين'],
                    '%d أعوام',
                    '%d عامًا',
                    '%d عام',
                ],
            },
            pluralize$2 = function (u) {
                return function (number, withoutSuffix, string, isFuture) {
                    var f = pluralForm$2(number),
                        str = plurals$2[u][pluralForm$2(number)];
                    if (f === 2) {
                        str = str[withoutSuffix ? 0 : 1];
                    }
                    return str.replace(/%d/i, number);
                };
            },
            months$3 = [
                'يناير',
                'فبراير',
                'مارس',
                'أبريل',
                'مايو',
                'يونيو',
                'يوليو',
                'أغسطس',
                'سبتمبر',
                'أكتوبر',
                'نوفمبر',
                'ديسمبر',
            ];

        hooks.defineLocale('ar', {
            months: months$3,
            monthsShort: months$3,
            weekdays: 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
            weekdaysShort: 'أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت'.split('_'),
            weekdaysMin: 'ح_ن_ث_ر_خ_ج_س'.split('_'),
            weekdaysParseExact: true,
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'D/\u200FM/\u200FYYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY HH:mm',
                LLLL: 'dddd D MMMM YYYY HH:mm',
            },
            meridiemParse: /ص|م/,
            isPM: function (input) {
                return 'م' === input;
            },
            meridiem: function (hour, minute, isLower) {
                if (hour < 12) {
                    return 'ص';
                } else {
                    return 'م';
                }
            },
            calendar: {
                sameDay: '[اليوم عند الساعة] LT',
                nextDay: '[غدًا عند الساعة] LT',
                nextWeek: 'dddd [عند الساعة] LT',
                lastDay: '[أمس عند الساعة] LT',
                lastWeek: 'dddd [عند الساعة] LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: 'بعد %s',
                past: 'منذ %s',
                s: pluralize$2('s'),
                ss: pluralize$2('s'),
                m: pluralize$2('m'),
                mm: pluralize$2('m'),
                h: pluralize$2('h'),
                hh: pluralize$2('h'),
                d: pluralize$2('d'),
                dd: pluralize$2('d'),
                M: pluralize$2('M'),
                MM: pluralize$2('M'),
                y: pluralize$2('y'),
                yy: pluralize$2('y'),
            },
            preparse: function (string) {
                return string
                    .replace(/[١٢٣٤٥٦٧٨٩٠]/g, function (match) {
                        return numberMap$1[match];
                    })
                    .replace(/،/g, ',');
            },
            postformat: function (string) {
                return string
                    .replace(/\d/g, function (match) {
                        return symbolMap$2[match];
                    })
                    .replace(/,/g, '،');
            },
            week: {
                dow: 6, // Saturday is the first day of the week.
                doy: 12, // The week that contains Jan 12th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        var suffixes = {
            1: '-inci',
            5: '-inci',
            8: '-inci',
            70: '-inci',
            80: '-inci',
            2: '-nci',
            7: '-nci',
            20: '-nci',
            50: '-nci',
            3: '-üncü',
            4: '-üncü',
            100: '-üncü',
            6: '-ncı',
            9: '-uncu',
            10: '-uncu',
            30: '-uncu',
            60: '-ıncı',
            90: '-ıncı',
        };

        hooks.defineLocale('az', {
            months: 'yanvar_fevral_mart_aprel_may_iyun_iyul_avqust_sentyabr_oktyabr_noyabr_dekabr'.split(
                '_'
            ),
            monthsShort: 'yan_fev_mar_apr_may_iyn_iyl_avq_sen_okt_noy_dek'.split('_'),
            weekdays: 'Bazar_Bazar ertəsi_Çərşənbə axşamı_Çərşənbə_Cümə axşamı_Cümə_Şənbə'.split(
                '_'
            ),
            weekdaysShort: 'Baz_BzE_ÇAx_Çər_CAx_Cüm_Şən'.split('_'),
            weekdaysMin: 'Bz_BE_ÇA_Çə_CA_Cü_Şə'.split('_'),
            weekdaysParseExact: true,
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'DD.MM.YYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY HH:mm',
                LLLL: 'dddd, D MMMM YYYY HH:mm',
            },
            calendar: {
                sameDay: '[bugün saat] LT',
                nextDay: '[sabah saat] LT',
                nextWeek: '[gələn həftə] dddd [saat] LT',
                lastDay: '[dünən] LT',
                lastWeek: '[keçən həftə] dddd [saat] LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: '%s sonra',
                past: '%s əvvəl',
                s: 'bir neçə saniyə',
                ss: '%d saniyə',
                m: 'bir dəqiqə',
                mm: '%d dəqiqə',
                h: 'bir saat',
                hh: '%d saat',
                d: 'bir gün',
                dd: '%d gün',
                M: 'bir ay',
                MM: '%d ay',
                y: 'bir il',
                yy: '%d il',
            },
            meridiemParse: /gecə|səhər|gündüz|axşam/,
            isPM: function (input) {
                return /^(gündüz|axşam)$/.test(input);
            },
            meridiem: function (hour, minute, isLower) {
                if (hour < 4) {
                    return 'gecə';
                } else if (hour < 12) {
                    return 'səhər';
                } else if (hour < 17) {
                    return 'gündüz';
                } else {
                    return 'axşam';
                }
            },
            dayOfMonthOrdinalParse: /\d{1,2}-(ıncı|inci|nci|üncü|ncı|uncu)/,
            ordinal: function (number) {
                if (number === 0) {
                    // special case for zero
                    return number + '-ıncı';
                }
                var a = number % 10,
                    b = (number % 100) - a,
                    c = number >= 100 ? 100 : null;
                return number + (suffixes[a] || suffixes[b] || suffixes[c]);
            },
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 7, // The week that contains Jan 7th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        function plural(word, num) {
            var forms = word.split('_');
            return num % 10 === 1 && num % 100 !== 11
                ? forms[0]
                : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20)
                ? forms[1]
                : forms[2];
        }
        function relativeTimeWithPlural(number, withoutSuffix, key) {
            var format = {
                ss: withoutSuffix ? 'секунда_секунды_секунд' : 'секунду_секунды_секунд',
                mm: withoutSuffix ? 'хвіліна_хвіліны_хвілін' : 'хвіліну_хвіліны_хвілін',
                hh: withoutSuffix ? 'гадзіна_гадзіны_гадзін' : 'гадзіну_гадзіны_гадзін',
                dd: 'дзень_дні_дзён',
                MM: 'месяц_месяцы_месяцаў',
                yy: 'год_гады_гадоў',
            };
            if (key === 'm') {
                return withoutSuffix ? 'хвіліна' : 'хвіліну';
            } else if (key === 'h') {
                return withoutSuffix ? 'гадзіна' : 'гадзіну';
            } else {
                return number + ' ' + plural(format[key], +number);
            }
        }

        hooks.defineLocale('be', {
            months: {
                format: 'студзеня_лютага_сакавіка_красавіка_траўня_чэрвеня_ліпеня_жніўня_верасня_кастрычніка_лістапада_снежня'.split(
                    '_'
                ),
                standalone: 'студзень_люты_сакавік_красавік_травень_чэрвень_ліпень_жнівень_верасень_кастрычнік_лістапад_снежань'.split(
                    '_'
                ),
            },
            monthsShort: 'студ_лют_сак_крас_трав_чэрв_ліп_жнів_вер_каст_ліст_снеж'.split(
                '_'
            ),
            weekdays: {
                format: 'нядзелю_панядзелак_аўторак_сераду_чацвер_пятніцу_суботу'.split(
                    '_'
                ),
                standalone: 'нядзеля_панядзелак_аўторак_серада_чацвер_пятніца_субота'.split(
                    '_'
                ),
                isFormat: /\[ ?[Ууў] ?(?:мінулую|наступную)? ?\] ?dddd/,
            },
            weekdaysShort: 'нд_пн_ат_ср_чц_пт_сб'.split('_'),
            weekdaysMin: 'нд_пн_ат_ср_чц_пт_сб'.split('_'),
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'DD.MM.YYYY',
                LL: 'D MMMM YYYY г.',
                LLL: 'D MMMM YYYY г., HH:mm',
                LLLL: 'dddd, D MMMM YYYY г., HH:mm',
            },
            calendar: {
                sameDay: '[Сёння ў] LT',
                nextDay: '[Заўтра ў] LT',
                lastDay: '[Учора ў] LT',
                nextWeek: function () {
                    return '[У] dddd [ў] LT';
                },
                lastWeek: function () {
                    switch (this.day()) {
                        case 0:
                        case 3:
                        case 5:
                        case 6:
                            return '[У мінулую] dddd [ў] LT';
                        case 1:
                        case 2:
                        case 4:
                            return '[У мінулы] dddd [ў] LT';
                    }
                },
                sameElse: 'L',
            },
            relativeTime: {
                future: 'праз %s',
                past: '%s таму',
                s: 'некалькі секунд',
                m: relativeTimeWithPlural,
                mm: relativeTimeWithPlural,
                h: relativeTimeWithPlural,
                hh: relativeTimeWithPlural,
                d: 'дзень',
                dd: relativeTimeWithPlural,
                M: 'месяц',
                MM: relativeTimeWithPlural,
                y: 'год',
                yy: relativeTimeWithPlural,
            },
            meridiemParse: /ночы|раніцы|дня|вечара/,
            isPM: function (input) {
                return /^(дня|вечара)$/.test(input);
            },
            meridiem: function (hour, minute, isLower) {
                if (hour < 4) {
                    return 'ночы';
                } else if (hour < 12) {
                    return 'раніцы';
                } else if (hour < 17) {
                    return 'дня';
                } else {
                    return 'вечара';
                }
            },
            dayOfMonthOrdinalParse: /\d{1,2}-(і|ы|га)/,
            ordinal: function (number, period) {
                switch (period) {
                    case 'M':
                    case 'd':
                    case 'DDD':
                    case 'w':
                    case 'W':
                        return (number % 10 === 2 || number % 10 === 3) &&
                            number % 100 !== 12 &&
                            number % 100 !== 13
                            ? number + '-і'
                            : number + '-ы';
                    case 'D':
                        return number + '-га';
                    default:
                        return number;
                }
            },
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 7, // The week that contains Jan 7th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        hooks.defineLocale('bg', {
            months: 'януари_февруари_март_април_май_юни_юли_август_септември_октомври_ноември_декември'.split(
                '_'
            ),
            monthsShort: 'яну_фев_мар_апр_май_юни_юли_авг_сеп_окт_ное_дек'.split('_'),
            weekdays: 'неделя_понеделник_вторник_сряда_четвъртък_петък_събота'.split(
                '_'
            ),
            weekdaysShort: 'нед_пон_вто_сря_чет_пет_съб'.split('_'),
            weekdaysMin: 'нд_пн_вт_ср_чт_пт_сб'.split('_'),
            longDateFormat: {
                LT: 'H:mm',
                LTS: 'H:mm:ss',
                L: 'D.MM.YYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY H:mm',
                LLLL: 'dddd, D MMMM YYYY H:mm',
            },
            calendar: {
                sameDay: '[Днес в] LT',
                nextDay: '[Утре в] LT',
                nextWeek: 'dddd [в] LT',
                lastDay: '[Вчера в] LT',
                lastWeek: function () {
                    switch (this.day()) {
                        case 0:
                        case 3:
                        case 6:
                            return '[Миналата] dddd [в] LT';
                        case 1:
                        case 2:
                        case 4:
                        case 5:
                            return '[Миналия] dddd [в] LT';
                    }
                },
                sameElse: 'L',
            },
            relativeTime: {
                future: 'след %s',
                past: 'преди %s',
                s: 'няколко секунди',
                ss: '%d секунди',
                m: 'минута',
                mm: '%d минути',
                h: 'час',
                hh: '%d часа',
                d: 'ден',
                dd: '%d дена',
                w: 'седмица',
                ww: '%d седмици',
                M: 'месец',
                MM: '%d месеца',
                y: 'година',
                yy: '%d години',
            },
            dayOfMonthOrdinalParse: /\d{1,2}-(ев|ен|ти|ви|ри|ми)/,
            ordinal: function (number) {
                var lastDigit = number % 10,
                    last2Digits = number % 100;
                if (number === 0) {
                    return number + '-ев';
                } else if (last2Digits === 0) {
                    return number + '-ен';
                } else if (last2Digits > 10 && last2Digits < 20) {
                    return number + '-ти';
                } else if (lastDigit === 1) {
                    return number + '-ви';
                } else if (lastDigit === 2) {
                    return number + '-ри';
                } else if (lastDigit === 7 || lastDigit === 8) {
                    return number + '-ми';
                } else {
                    return number + '-ти';
                }
            },
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 7, // The week that contains Jan 7th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        hooks.defineLocale('bm', {
            months: 'Zanwuyekalo_Fewuruyekalo_Marisikalo_Awirilikalo_Mɛkalo_Zuwɛnkalo_Zuluyekalo_Utikalo_Sɛtanburukalo_ɔkutɔburukalo_Nowanburukalo_Desanburukalo'.split(
                '_'
            ),
            monthsShort: 'Zan_Few_Mar_Awi_Mɛ_Zuw_Zul_Uti_Sɛt_ɔku_Now_Des'.split('_'),
            weekdays: 'Kari_Ntɛnɛn_Tarata_Araba_Alamisa_Juma_Sibiri'.split('_'),
            weekdaysShort: 'Kar_Ntɛ_Tar_Ara_Ala_Jum_Sib'.split('_'),
            weekdaysMin: 'Ka_Nt_Ta_Ar_Al_Ju_Si'.split('_'),
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'DD/MM/YYYY',
                LL: 'MMMM [tile] D [san] YYYY',
                LLL: 'MMMM [tile] D [san] YYYY [lɛrɛ] HH:mm',
                LLLL: 'dddd MMMM [tile] D [san] YYYY [lɛrɛ] HH:mm',
            },
            calendar: {
                sameDay: '[Bi lɛrɛ] LT',
                nextDay: '[Sini lɛrɛ] LT',
                nextWeek: 'dddd [don lɛrɛ] LT',
                lastDay: '[Kunu lɛrɛ] LT',
                lastWeek: 'dddd [tɛmɛnen lɛrɛ] LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: '%s kɔnɔ',
                past: 'a bɛ %s bɔ',
                s: 'sanga dama dama',
                ss: 'sekondi %d',
                m: 'miniti kelen',
                mm: 'miniti %d',
                h: 'lɛrɛ kelen',
                hh: 'lɛrɛ %d',
                d: 'tile kelen',
                dd: 'tile %d',
                M: 'kalo kelen',
                MM: 'kalo %d',
                y: 'san kelen',
                yy: 'san %d',
            },
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 4, // The week that contains Jan 4th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        var symbolMap$3 = {
                1: '১',
                2: '২',
                3: '৩',
                4: '৪',
                5: '৫',
                6: '৬',
                7: '৭',
                8: '৮',
                9: '৯',
                0: '০',
            },
            numberMap$2 = {
                '১': '1',
                '২': '2',
                '৩': '3',
                '৪': '4',
                '৫': '5',
                '৬': '6',
                '৭': '7',
                '৮': '8',
                '৯': '9',
                '০': '0',
            };

        hooks.defineLocale('bn-bd', {
            months: 'জানুয়ারি_ফেব্রুয়ারি_মার্চ_এপ্রিল_মে_জুন_জুলাই_আগস্ট_সেপ্টেম্বর_অক্টোবর_নভেম্বর_ডিসেম্বর'.split(
                '_'
            ),
            monthsShort: 'জানু_ফেব্রু_মার্চ_এপ্রিল_মে_জুন_জুলাই_আগস্ট_সেপ্ট_অক্টো_নভে_ডিসে'.split(
                '_'
            ),
            weekdays: 'রবিবার_সোমবার_মঙ্গলবার_বুধবার_বৃহস্পতিবার_শুক্রবার_শনিবার'.split(
                '_'
            ),
            weekdaysShort: 'রবি_সোম_মঙ্গল_বুধ_বৃহস্পতি_শুক্র_শনি'.split('_'),
            weekdaysMin: 'রবি_সোম_মঙ্গল_বুধ_বৃহ_শুক্র_শনি'.split('_'),
            longDateFormat: {
                LT: 'A h:mm সময়',
                LTS: 'A h:mm:ss সময়',
                L: 'DD/MM/YYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY, A h:mm সময়',
                LLLL: 'dddd, D MMMM YYYY, A h:mm সময়',
            },
            calendar: {
                sameDay: '[আজ] LT',
                nextDay: '[আগামীকাল] LT',
                nextWeek: 'dddd, LT',
                lastDay: '[গতকাল] LT',
                lastWeek: '[গত] dddd, LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: '%s পরে',
                past: '%s আগে',
                s: 'কয়েক সেকেন্ড',
                ss: '%d সেকেন্ড',
                m: 'এক মিনিট',
                mm: '%d মিনিট',
                h: 'এক ঘন্টা',
                hh: '%d ঘন্টা',
                d: 'এক দিন',
                dd: '%d দিন',
                M: 'এক মাস',
                MM: '%d মাস',
                y: 'এক বছর',
                yy: '%d বছর',
            },
            preparse: function (string) {
                return string.replace(/[১২৩৪৫৬৭৮৯০]/g, function (match) {
                    return numberMap$2[match];
                });
            },
            postformat: function (string) {
                return string.replace(/\d/g, function (match) {
                    return symbolMap$3[match];
                });
            },

            meridiemParse: /রাত|ভোর|সকাল|দুপুর|বিকাল|সন্ধ্যা|রাত/,
            meridiemHour: function (hour, meridiem) {
                if (hour === 12) {
                    hour = 0;
                }
                if (meridiem === 'রাত') {
                    return hour < 4 ? hour : hour + 12;
                } else if (meridiem === 'ভোর') {
                    return hour;
                } else if (meridiem === 'সকাল') {
                    return hour;
                } else if (meridiem === 'দুপুর') {
                    return hour >= 3 ? hour : hour + 12;
                } else if (meridiem === 'বিকাল') {
                    return hour + 12;
                } else if (meridiem === 'সন্ধ্যা') {
                    return hour + 12;
                }
            },

            meridiem: function (hour, minute, isLower) {
                if (hour < 4) {
                    return 'রাত';
                } else if (hour < 6) {
                    return 'ভোর';
                } else if (hour < 12) {
                    return 'সকাল';
                } else if (hour < 15) {
                    return 'দুপুর';
                } else if (hour < 18) {
                    return 'বিকাল';
                } else if (hour < 20) {
                    return 'সন্ধ্যা';
                } else {
                    return 'রাত';
                }
            },
            week: {
                dow: 0, // Sunday is the first day of the week.
                doy: 6, // The week that contains Jan 6th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        var symbolMap$4 = {
                1: '১',
                2: '২',
                3: '৩',
                4: '৪',
                5: '৫',
                6: '৬',
                7: '৭',
                8: '৮',
                9: '৯',
                0: '০',
            },
            numberMap$3 = {
                '১': '1',
                '২': '2',
                '৩': '3',
                '৪': '4',
                '৫': '5',
                '৬': '6',
                '৭': '7',
                '৮': '8',
                '৯': '9',
                '০': '0',
            };

        hooks.defineLocale('bn', {
            months: 'জানুয়ারি_ফেব্রুয়ারি_মার্চ_এপ্রিল_মে_জুন_জুলাই_আগস্ট_সেপ্টেম্বর_অক্টোবর_নভেম্বর_ডিসেম্বর'.split(
                '_'
            ),
            monthsShort: 'জানু_ফেব্রু_মার্চ_এপ্রিল_মে_জুন_জুলাই_আগস্ট_সেপ্ট_অক্টো_নভে_ডিসে'.split(
                '_'
            ),
            weekdays: 'রবিবার_সোমবার_মঙ্গলবার_বুধবার_বৃহস্পতিবার_শুক্রবার_শনিবার'.split(
                '_'
            ),
            weekdaysShort: 'রবি_সোম_মঙ্গল_বুধ_বৃহস্পতি_শুক্র_শনি'.split('_'),
            weekdaysMin: 'রবি_সোম_মঙ্গল_বুধ_বৃহ_শুক্র_শনি'.split('_'),
            longDateFormat: {
                LT: 'A h:mm সময়',
                LTS: 'A h:mm:ss সময়',
                L: 'DD/MM/YYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY, A h:mm সময়',
                LLLL: 'dddd, D MMMM YYYY, A h:mm সময়',
            },
            calendar: {
                sameDay: '[আজ] LT',
                nextDay: '[আগামীকাল] LT',
                nextWeek: 'dddd, LT',
                lastDay: '[গতকাল] LT',
                lastWeek: '[গত] dddd, LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: '%s পরে',
                past: '%s আগে',
                s: 'কয়েক সেকেন্ড',
                ss: '%d সেকেন্ড',
                m: 'এক মিনিট',
                mm: '%d মিনিট',
                h: 'এক ঘন্টা',
                hh: '%d ঘন্টা',
                d: 'এক দিন',
                dd: '%d দিন',
                M: 'এক মাস',
                MM: '%d মাস',
                y: 'এক বছর',
                yy: '%d বছর',
            },
            preparse: function (string) {
                return string.replace(/[১২৩৪৫৬৭৮৯০]/g, function (match) {
                    return numberMap$3[match];
                });
            },
            postformat: function (string) {
                return string.replace(/\d/g, function (match) {
                    return symbolMap$4[match];
                });
            },
            meridiemParse: /রাত|সকাল|দুপুর|বিকাল|রাত/,
            meridiemHour: function (hour, meridiem) {
                if (hour === 12) {
                    hour = 0;
                }
                if (
                    (meridiem === 'রাত' && hour >= 4) ||
                    (meridiem === 'দুপুর' && hour < 5) ||
                    meridiem === 'বিকাল'
                ) {
                    return hour + 12;
                } else {
                    return hour;
                }
            },
            meridiem: function (hour, minute, isLower) {
                if (hour < 4) {
                    return 'রাত';
                } else if (hour < 10) {
                    return 'সকাল';
                } else if (hour < 17) {
                    return 'দুপুর';
                } else if (hour < 20) {
                    return 'বিকাল';
                } else {
                    return 'রাত';
                }
            },
            week: {
                dow: 0, // Sunday is the first day of the week.
                doy: 6, // The week that contains Jan 6th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        var symbolMap$5 = {
                1: '༡',
                2: '༢',
                3: '༣',
                4: '༤',
                5: '༥',
                6: '༦',
                7: '༧',
                8: '༨',
                9: '༩',
                0: '༠',
            },
            numberMap$4 = {
                '༡': '1',
                '༢': '2',
                '༣': '3',
                '༤': '4',
                '༥': '5',
                '༦': '6',
                '༧': '7',
                '༨': '8',
                '༩': '9',
                '༠': '0',
            };

        hooks.defineLocale('bo', {
            months: 'ཟླ་བ་དང་པོ_ཟླ་བ་གཉིས་པ_ཟླ་བ་གསུམ་པ_ཟླ་བ་བཞི་པ_ཟླ་བ་ལྔ་པ_ཟླ་བ་དྲུག་པ_ཟླ་བ་བདུན་པ_ཟླ་བ་བརྒྱད་པ_ཟླ་བ་དགུ་པ_ཟླ་བ་བཅུ་པ_ཟླ་བ་བཅུ་གཅིག་པ_ཟླ་བ་བཅུ་གཉིས་པ'.split(
                '_'
            ),
            monthsShort: 'ཟླ་1_ཟླ་2_ཟླ་3_ཟླ་4_ཟླ་5_ཟླ་6_ཟླ་7_ཟླ་8_ཟླ་9_ཟླ་10_ཟླ་11_ཟླ་12'.split(
                '_'
            ),
            monthsShortRegex: /^(ཟླ་\d{1,2})/,
            monthsParseExact: true,
            weekdays: 'གཟའ་ཉི་མ་_གཟའ་ཟླ་བ་_གཟའ་མིག་དམར་_གཟའ་ལྷག་པ་_གཟའ་ཕུར་བུ_གཟའ་པ་སངས་_གཟའ་སྤེན་པ་'.split(
                '_'
            ),
            weekdaysShort: 'ཉི་མ་_ཟླ་བ་_མིག་དམར་_ལྷག་པ་_ཕུར་བུ_པ་སངས་_སྤེན་པ་'.split(
                '_'
            ),
            weekdaysMin: 'ཉི_ཟླ_མིག_ལྷག_ཕུར_སངས_སྤེན'.split('_'),
            longDateFormat: {
                LT: 'A h:mm',
                LTS: 'A h:mm:ss',
                L: 'DD/MM/YYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY, A h:mm',
                LLLL: 'dddd, D MMMM YYYY, A h:mm',
            },
            calendar: {
                sameDay: '[དི་རིང] LT',
                nextDay: '[སང་ཉིན] LT',
                nextWeek: '[བདུན་ཕྲག་རྗེས་མ], LT',
                lastDay: '[ཁ་སང] LT',
                lastWeek: '[བདུན་ཕྲག་མཐའ་མ] dddd, LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: '%s ལ་',
                past: '%s སྔན་ལ',
                s: 'ལམ་སང',
                ss: '%d སྐར་ཆ།',
                m: 'སྐར་མ་གཅིག',
                mm: '%d སྐར་མ',
                h: 'ཆུ་ཚོད་གཅིག',
                hh: '%d ཆུ་ཚོད',
                d: 'ཉིན་གཅིག',
                dd: '%d ཉིན་',
                M: 'ཟླ་བ་གཅིག',
                MM: '%d ཟླ་བ',
                y: 'ལོ་གཅིག',
                yy: '%d ལོ',
            },
            preparse: function (string) {
                return string.replace(/[༡༢༣༤༥༦༧༨༩༠]/g, function (match) {
                    return numberMap$4[match];
                });
            },
            postformat: function (string) {
                return string.replace(/\d/g, function (match) {
                    return symbolMap$5[match];
                });
            },
            meridiemParse: /མཚན་མོ|ཞོགས་ཀས|ཉིན་གུང|དགོང་དག|མཚན་མོ/,
            meridiemHour: function (hour, meridiem) {
                if (hour === 12) {
                    hour = 0;
                }
                if (
                    (meridiem === 'མཚན་མོ' && hour >= 4) ||
                    (meridiem === 'ཉིན་གུང' && hour < 5) ||
                    meridiem === 'དགོང་དག'
                ) {
                    return hour + 12;
                } else {
                    return hour;
                }
            },
            meridiem: function (hour, minute, isLower) {
                if (hour < 4) {
                    return 'མཚན་མོ';
                } else if (hour < 10) {
                    return 'ཞོགས་ཀས';
                } else if (hour < 17) {
                    return 'ཉིན་གུང';
                } else if (hour < 20) {
                    return 'དགོང་དག';
                } else {
                    return 'མཚན་མོ';
                }
            },
            week: {
                dow: 0, // Sunday is the first day of the week.
                doy: 6, // The week that contains Jan 6th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        function relativeTimeWithMutation(number, withoutSuffix, key) {
            var format = {
                mm: 'munutenn',
                MM: 'miz',
                dd: 'devezh',
            };
            return number + ' ' + mutation(format[key], number);
        }
        function specialMutationForYears(number) {
            switch (lastNumber(number)) {
                case 1:
                case 3:
                case 4:
                case 5:
                case 9:
                    return number + ' bloaz';
                default:
                    return number + ' vloaz';
            }
        }
        function lastNumber(number) {
            if (number > 9) {
                return lastNumber(number % 10);
            }
            return number;
        }
        function mutation(text, number) {
            if (number === 2) {
                return softMutation(text);
            }
            return text;
        }
        function softMutation(text) {
            var mutationTable = {
                m: 'v',
                b: 'v',
                d: 'z',
            };
            if (mutationTable[text.charAt(0)] === undefined) {
                return text;
            }
            return mutationTable[text.charAt(0)] + text.substring(1);
        }

        var monthsParse = [
                /^gen/i,
                /^c[ʼ\']hwe/i,
                /^meu/i,
                /^ebr/i,
                /^mae/i,
                /^(mez|eve)/i,
                /^gou/i,
                /^eos/i,
                /^gwe/i,
                /^her/i,
                /^du/i,
                /^ker/i,
            ],
            monthsRegex$1 = /^(genver|c[ʼ\']hwevrer|meurzh|ebrel|mae|mezheven|gouere|eost|gwengolo|here|du|kerzu|gen|c[ʼ\']hwe|meu|ebr|mae|eve|gou|eos|gwe|her|du|ker)/i,
            monthsStrictRegex = /^(genver|c[ʼ\']hwevrer|meurzh|ebrel|mae|mezheven|gouere|eost|gwengolo|here|du|kerzu)/i,
            monthsShortStrictRegex = /^(gen|c[ʼ\']hwe|meu|ebr|mae|eve|gou|eos|gwe|her|du|ker)/i,
            fullWeekdaysParse = [
                /^sul/i,
                /^lun/i,
                /^meurzh/i,
                /^merc[ʼ\']her/i,
                /^yaou/i,
                /^gwener/i,
                /^sadorn/i,
            ],
            shortWeekdaysParse = [
                /^Sul/i,
                /^Lun/i,
                /^Meu/i,
                /^Mer/i,
                /^Yao/i,
                /^Gwe/i,
                /^Sad/i,
            ],
            minWeekdaysParse = [
                /^Su/i,
                /^Lu/i,
                /^Me([^r]|$)/i,
                /^Mer/i,
                /^Ya/i,
                /^Gw/i,
                /^Sa/i,
            ];

        hooks.defineLocale('br', {
            months: 'Genver_Cʼhwevrer_Meurzh_Ebrel_Mae_Mezheven_Gouere_Eost_Gwengolo_Here_Du_Kerzu'.split(
                '_'
            ),
            monthsShort: 'Gen_Cʼhwe_Meu_Ebr_Mae_Eve_Gou_Eos_Gwe_Her_Du_Ker'.split('_'),
            weekdays: 'Sul_Lun_Meurzh_Mercʼher_Yaou_Gwener_Sadorn'.split('_'),
            weekdaysShort: 'Sul_Lun_Meu_Mer_Yao_Gwe_Sad'.split('_'),
            weekdaysMin: 'Su_Lu_Me_Mer_Ya_Gw_Sa'.split('_'),
            weekdaysParse: minWeekdaysParse,
            fullWeekdaysParse: fullWeekdaysParse,
            shortWeekdaysParse: shortWeekdaysParse,
            minWeekdaysParse: minWeekdaysParse,

            monthsRegex: monthsRegex$1,
            monthsShortRegex: monthsRegex$1,
            monthsStrictRegex: monthsStrictRegex,
            monthsShortStrictRegex: monthsShortStrictRegex,
            monthsParse: monthsParse,
            longMonthsParse: monthsParse,
            shortMonthsParse: monthsParse,

            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'DD/MM/YYYY',
                LL: 'D [a viz] MMMM YYYY',
                LLL: 'D [a viz] MMMM YYYY HH:mm',
                LLLL: 'dddd, D [a viz] MMMM YYYY HH:mm',
            },
            calendar: {
                sameDay: '[Hiziv da] LT',
                nextDay: '[Warcʼhoazh da] LT',
                nextWeek: 'dddd [da] LT',
                lastDay: '[Decʼh da] LT',
                lastWeek: 'dddd [paset da] LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: 'a-benn %s',
                past: '%s ʼzo',
                s: 'un nebeud segondennoù',
                ss: '%d eilenn',
                m: 'ur vunutenn',
                mm: relativeTimeWithMutation,
                h: 'un eur',
                hh: '%d eur',
                d: 'un devezh',
                dd: relativeTimeWithMutation,
                M: 'ur miz',
                MM: relativeTimeWithMutation,
                y: 'ur bloaz',
                yy: specialMutationForYears,
            },
            dayOfMonthOrdinalParse: /\d{1,2}(añ|vet)/,
            ordinal: function (number) {
                var output = number === 1 ? 'añ' : 'vet';
                return number + output;
            },
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 4, // The week that contains Jan 4th is the first week of the year.
            },
            meridiemParse: /a.m.|g.m./, // goude merenn | a-raok merenn
            isPM: function (token) {
                return token === 'g.m.';
            },
            meridiem: function (hour, minute, isLower) {
                return hour < 12 ? 'a.m.' : 'g.m.';
            },
        });

        //! moment.js locale configuration

        function translate(number, withoutSuffix, key) {
            var result = number + ' ';
            switch (key) {
                case 'ss':
                    if (number === 1) {
                        result += 'sekunda';
                    } else if (number === 2 || number === 3 || number === 4) {
                        result += 'sekunde';
                    } else {
                        result += 'sekundi';
                    }
                    return result;
                case 'm':
                    return withoutSuffix ? 'jedna minuta' : 'jedne minute';
                case 'mm':
                    if (number === 1) {
                        result += 'minuta';
                    } else if (number === 2 || number === 3 || number === 4) {
                        result += 'minute';
                    } else {
                        result += 'minuta';
                    }
                    return result;
                case 'h':
                    return withoutSuffix ? 'jedan sat' : 'jednog sata';
                case 'hh':
                    if (number === 1) {
                        result += 'sat';
                    } else if (number === 2 || number === 3 || number === 4) {
                        result += 'sata';
                    } else {
                        result += 'sati';
                    }
                    return result;
                case 'dd':
                    if (number === 1) {
                        result += 'dan';
                    } else {
                        result += 'dana';
                    }
                    return result;
                case 'MM':
                    if (number === 1) {
                        result += 'mjesec';
                    } else if (number === 2 || number === 3 || number === 4) {
                        result += 'mjeseca';
                    } else {
                        result += 'mjeseci';
                    }
                    return result;
                case 'yy':
                    if (number === 1) {
                        result += 'godina';
                    } else if (number === 2 || number === 3 || number === 4) {
                        result += 'godine';
                    } else {
                        result += 'godina';
                    }
                    return result;
            }
        }

        hooks.defineLocale('bs', {
            months: 'januar_februar_mart_april_maj_juni_juli_august_septembar_oktobar_novembar_decembar'.split(
                '_'
            ),
            monthsShort: 'jan._feb._mar._apr._maj._jun._jul._aug._sep._okt._nov._dec.'.split(
                '_'
            ),
            monthsParseExact: true,
            weekdays: 'nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota'.split(
                '_'
            ),
            weekdaysShort: 'ned._pon._uto._sri._čet._pet._sub.'.split('_'),
            weekdaysMin: 'ne_po_ut_sr_če_pe_su'.split('_'),
            weekdaysParseExact: true,
            longDateFormat: {
                LT: 'H:mm',
                LTS: 'H:mm:ss',
                L: 'DD.MM.YYYY',
                LL: 'D. MMMM YYYY',
                LLL: 'D. MMMM YYYY H:mm',
                LLLL: 'dddd, D. MMMM YYYY H:mm',
            },
            calendar: {
                sameDay: '[danas u] LT',
                nextDay: '[sutra u] LT',
                nextWeek: function () {
                    switch (this.day()) {
                        case 0:
                            return '[u] [nedjelju] [u] LT';
                        case 3:
                            return '[u] [srijedu] [u] LT';
                        case 6:
                            return '[u] [subotu] [u] LT';
                        case 1:
                        case 2:
                        case 4:
                        case 5:
                            return '[u] dddd [u] LT';
                    }
                },
                lastDay: '[jučer u] LT',
                lastWeek: function () {
                    switch (this.day()) {
                        case 0:
                        case 3:
                            return '[prošlu] dddd [u] LT';
                        case 6:
                            return '[prošle] [subote] [u] LT';
                        case 1:
                        case 2:
                        case 4:
                        case 5:
                            return '[prošli] dddd [u] LT';
                    }
                },
                sameElse: 'L',
            },
            relativeTime: {
                future: 'za %s',
                past: 'prije %s',
                s: 'par sekundi',
                ss: translate,
                m: translate,
                mm: translate,
                h: translate,
                hh: translate,
                d: 'dan',
                dd: translate,
                M: 'mjesec',
                MM: translate,
                y: 'godinu',
                yy: translate,
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: '%d.',
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 7, // The week that contains Jan 7th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        hooks.defineLocale('ca', {
            months: {
                standalone: 'gener_febrer_març_abril_maig_juny_juliol_agost_setembre_octubre_novembre_desembre'.split(
                    '_'
                ),
                format: "de gener_de febrer_de març_d'abril_de maig_de juny_de juliol_d'agost_de setembre_d'octubre_de novembre_de desembre".split(
                    '_'
                ),
                isFormat: /D[oD]?(\s)+MMMM/,
            },
            monthsShort: 'gen._febr._març_abr._maig_juny_jul._ag._set._oct._nov._des.'.split(
                '_'
            ),
            monthsParseExact: true,
            weekdays: 'diumenge_dilluns_dimarts_dimecres_dijous_divendres_dissabte'.split(
                '_'
            ),
            weekdaysShort: 'dg._dl._dt._dc._dj._dv._ds.'.split('_'),
            weekdaysMin: 'dg_dl_dt_dc_dj_dv_ds'.split('_'),
            weekdaysParseExact: true,
            longDateFormat: {
                LT: 'H:mm',
                LTS: 'H:mm:ss',
                L: 'DD/MM/YYYY',
                LL: 'D MMMM [de] YYYY',
                ll: 'D MMM YYYY',
                LLL: 'D MMMM [de] YYYY [a les] H:mm',
                lll: 'D MMM YYYY, H:mm',
                LLLL: 'dddd D MMMM [de] YYYY [a les] H:mm',
                llll: 'ddd D MMM YYYY, H:mm',
            },
            calendar: {
                sameDay: function () {
                    return '[avui a ' + (this.hours() !== 1 ? 'les' : 'la') + '] LT';
                },
                nextDay: function () {
                    return '[demà a ' + (this.hours() !== 1 ? 'les' : 'la') + '] LT';
                },
                nextWeek: function () {
                    return 'dddd [a ' + (this.hours() !== 1 ? 'les' : 'la') + '] LT';
                },
                lastDay: function () {
                    return '[ahir a ' + (this.hours() !== 1 ? 'les' : 'la') + '] LT';
                },
                lastWeek: function () {
                    return (
                        '[el] dddd [passat a ' +
                        (this.hours() !== 1 ? 'les' : 'la') +
                        '] LT'
                    );
                },
                sameElse: 'L',
            },
            relativeTime: {
                future: "d'aquí %s",
                past: 'fa %s',
                s: 'uns segons',
                ss: '%d segons',
                m: 'un minut',
                mm: '%d minuts',
                h: 'una hora',
                hh: '%d hores',
                d: 'un dia',
                dd: '%d dies',
                M: 'un mes',
                MM: '%d mesos',
                y: 'un any',
                yy: '%d anys',
            },
            dayOfMonthOrdinalParse: /\d{1,2}(r|n|t|è|a)/,
            ordinal: function (number, period) {
                var output =
                    number === 1
                        ? 'r'
                        : number === 2
                        ? 'n'
                        : number === 3
                        ? 'r'
                        : number === 4
                        ? 't'
                        : 'è';
                if (period === 'w' || period === 'W') {
                    output = 'a';
                }
                return number + output;
            },
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 4, // The week that contains Jan 4th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        var months$4 = 'leden_únor_březen_duben_květen_červen_červenec_srpen_září_říjen_listopad_prosinec'.split(
                '_'
            ),
            monthsShort = 'led_úno_bře_dub_kvě_čvn_čvc_srp_zář_říj_lis_pro'.split('_'),
            monthsParse$1 = [
                /^led/i,
                /^úno/i,
                /^bře/i,
                /^dub/i,
                /^kvě/i,
                /^(čvn|červen$|června)/i,
                /^(čvc|červenec|července)/i,
                /^srp/i,
                /^zář/i,
                /^říj/i,
                /^lis/i,
                /^pro/i,
            ],
            // NOTE: 'červen' is substring of 'červenec'; therefore 'červenec' must precede 'červen' in the regex to be fully matched.
            // Otherwise parser matches '1. červenec' as '1. červen' + 'ec'.
            monthsRegex$2 = /^(leden|únor|březen|duben|květen|červenec|července|červen|června|srpen|září|říjen|listopad|prosinec|led|úno|bře|dub|kvě|čvn|čvc|srp|zář|říj|lis|pro)/i;

        function plural$1(n) {
            return n > 1 && n < 5 && ~~(n / 10) !== 1;
        }
        function translate$1(number, withoutSuffix, key, isFuture) {
            var result = number + ' ';
            switch (key) {
                case 's': // a few seconds / in a few seconds / a few seconds ago
                    return withoutSuffix || isFuture ? 'pár sekund' : 'pár sekundami';
                case 'ss': // 9 seconds / in 9 seconds / 9 seconds ago
                    if (withoutSuffix || isFuture) {
                        return result + (plural$1(number) ? 'sekundy' : 'sekund');
                    } else {
                        return result + 'sekundami';
                    }
                case 'm': // a minute / in a minute / a minute ago
                    return withoutSuffix ? 'minuta' : isFuture ? 'minutu' : 'minutou';
                case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago
                    if (withoutSuffix || isFuture) {
                        return result + (plural$1(number) ? 'minuty' : 'minut');
                    } else {
                        return result + 'minutami';
                    }
                case 'h': // an hour / in an hour / an hour ago
                    return withoutSuffix ? 'hodina' : isFuture ? 'hodinu' : 'hodinou';
                case 'hh': // 9 hours / in 9 hours / 9 hours ago
                    if (withoutSuffix || isFuture) {
                        return result + (plural$1(number) ? 'hodiny' : 'hodin');
                    } else {
                        return result + 'hodinami';
                    }
                case 'd': // a day / in a day / a day ago
                    return withoutSuffix || isFuture ? 'den' : 'dnem';
                case 'dd': // 9 days / in 9 days / 9 days ago
                    if (withoutSuffix || isFuture) {
                        return result + (plural$1(number) ? 'dny' : 'dní');
                    } else {
                        return result + 'dny';
                    }
                case 'M': // a month / in a month / a month ago
                    return withoutSuffix || isFuture ? 'měsíc' : 'měsícem';
                case 'MM': // 9 months / in 9 months / 9 months ago
                    if (withoutSuffix || isFuture) {
                        return result + (plural$1(number) ? 'měsíce' : 'měsíců');
                    } else {
                        return result + 'měsíci';
                    }
                case 'y': // a year / in a year / a year ago
                    return withoutSuffix || isFuture ? 'rok' : 'rokem';
                case 'yy': // 9 years / in 9 years / 9 years ago
                    if (withoutSuffix || isFuture) {
                        return result + (plural$1(number) ? 'roky' : 'let');
                    } else {
                        return result + 'lety';
                    }
            }
        }

        hooks.defineLocale('cs', {
            months: months$4,
            monthsShort: monthsShort,
            monthsRegex: monthsRegex$2,
            monthsShortRegex: monthsRegex$2,
            // NOTE: 'červen' is substring of 'červenec'; therefore 'červenec' must precede 'červen' in the regex to be fully matched.
            // Otherwise parser matches '1. červenec' as '1. červen' + 'ec'.
            monthsStrictRegex: /^(leden|ledna|února|únor|březen|března|duben|dubna|květen|května|červenec|července|červen|června|srpen|srpna|září|říjen|října|listopadu|listopad|prosinec|prosince)/i,
            monthsShortStrictRegex: /^(led|úno|bře|dub|kvě|čvn|čvc|srp|zář|říj|lis|pro)/i,
            monthsParse: monthsParse$1,
            longMonthsParse: monthsParse$1,
            shortMonthsParse: monthsParse$1,
            weekdays: 'neděle_pondělí_úterý_středa_čtvrtek_pátek_sobota'.split('_'),
            weekdaysShort: 'ne_po_út_st_čt_pá_so'.split('_'),
            weekdaysMin: 'ne_po_út_st_čt_pá_so'.split('_'),
            longDateFormat: {
                LT: 'H:mm',
                LTS: 'H:mm:ss',
                L: 'DD.MM.YYYY',
                LL: 'D. MMMM YYYY',
                LLL: 'D. MMMM YYYY H:mm',
                LLLL: 'dddd D. MMMM YYYY H:mm',
                l: 'D. M. YYYY',
            },
            calendar: {
                sameDay: '[dnes v] LT',
                nextDay: '[zítra v] LT',
                nextWeek: function () {
                    switch (this.day()) {
                        case 0:
                            return '[v neděli v] LT';
                        case 1:
                        case 2:
                            return '[v] dddd [v] LT';
                        case 3:
                            return '[ve středu v] LT';
                        case 4:
                            return '[ve čtvrtek v] LT';
                        case 5:
                            return '[v pátek v] LT';
                        case 6:
                            return '[v sobotu v] LT';
                    }
                },
                lastDay: '[včera v] LT',
                lastWeek: function () {
                    switch (this.day()) {
                        case 0:
                            return '[minulou neděli v] LT';
                        case 1:
                        case 2:
                            return '[minulé] dddd [v] LT';
                        case 3:
                            return '[minulou středu v] LT';
                        case 4:
                        case 5:
                            return '[minulý] dddd [v] LT';
                        case 6:
                            return '[minulou sobotu v] LT';
                    }
                },
                sameElse: 'L',
            },
            relativeTime: {
                future: 'za %s',
                past: 'před %s',
                s: translate$1,
                ss: translate$1,
                m: translate$1,
                mm: translate$1,
                h: translate$1,
                hh: translate$1,
                d: translate$1,
                dd: translate$1,
                M: translate$1,
                MM: translate$1,
                y: translate$1,
                yy: translate$1,
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: '%d.',
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 4, // The week that contains Jan 4th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        hooks.defineLocale('cv', {
            months: 'кӑрлач_нарӑс_пуш_ака_май_ҫӗртме_утӑ_ҫурла_авӑн_юпа_чӳк_раштав'.split(
                '_'
            ),
            monthsShort: 'кӑр_нар_пуш_ака_май_ҫӗр_утӑ_ҫур_авн_юпа_чӳк_раш'.split('_'),
            weekdays: 'вырсарникун_тунтикун_ытларикун_юнкун_кӗҫнерникун_эрнекун_шӑматкун'.split(
                '_'
            ),
            weekdaysShort: 'выр_тун_ытл_юн_кӗҫ_эрн_шӑм'.split('_'),
            weekdaysMin: 'вр_тн_ыт_юн_кҫ_эр_шм'.split('_'),
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'DD-MM-YYYY',
                LL: 'YYYY [ҫулхи] MMMM [уйӑхӗн] D[-мӗшӗ]',
                LLL: 'YYYY [ҫулхи] MMMM [уйӑхӗн] D[-мӗшӗ], HH:mm',
                LLLL: 'dddd, YYYY [ҫулхи] MMMM [уйӑхӗн] D[-мӗшӗ], HH:mm',
            },
            calendar: {
                sameDay: '[Паян] LT [сехетре]',
                nextDay: '[Ыран] LT [сехетре]',
                lastDay: '[Ӗнер] LT [сехетре]',
                nextWeek: '[Ҫитес] dddd LT [сехетре]',
                lastWeek: '[Иртнӗ] dddd LT [сехетре]',
                sameElse: 'L',
            },
            relativeTime: {
                future: function (output) {
                    var affix = /сехет$/i.exec(output)
                        ? 'рен'
                        : /ҫул$/i.exec(output)
                        ? 'тан'
                        : 'ран';
                    return output + affix;
                },
                past: '%s каялла',
                s: 'пӗр-ик ҫеккунт',
                ss: '%d ҫеккунт',
                m: 'пӗр минут',
                mm: '%d минут',
                h: 'пӗр сехет',
                hh: '%d сехет',
                d: 'пӗр кун',
                dd: '%d кун',
                M: 'пӗр уйӑх',
                MM: '%d уйӑх',
                y: 'пӗр ҫул',
                yy: '%d ҫул',
            },
            dayOfMonthOrdinalParse: /\d{1,2}-мӗш/,
            ordinal: '%d-мӗш',
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 7, // The week that contains Jan 7th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        hooks.defineLocale('cy', {
            months: 'Ionawr_Chwefror_Mawrth_Ebrill_Mai_Mehefin_Gorffennaf_Awst_Medi_Hydref_Tachwedd_Rhagfyr'.split(
                '_'
            ),
            monthsShort: 'Ion_Chwe_Maw_Ebr_Mai_Meh_Gor_Aws_Med_Hyd_Tach_Rhag'.split(
                '_'
            ),
            weekdays: 'Dydd Sul_Dydd Llun_Dydd Mawrth_Dydd Mercher_Dydd Iau_Dydd Gwener_Dydd Sadwrn'.split(
                '_'
            ),
            weekdaysShort: 'Sul_Llun_Maw_Mer_Iau_Gwe_Sad'.split('_'),
            weekdaysMin: 'Su_Ll_Ma_Me_Ia_Gw_Sa'.split('_'),
            weekdaysParseExact: true,
            // time formats are the same as en-gb
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'DD/MM/YYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY HH:mm',
                LLLL: 'dddd, D MMMM YYYY HH:mm',
            },
            calendar: {
                sameDay: '[Heddiw am] LT',
                nextDay: '[Yfory am] LT',
                nextWeek: 'dddd [am] LT',
                lastDay: '[Ddoe am] LT',
                lastWeek: 'dddd [diwethaf am] LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: 'mewn %s',
                past: '%s yn ôl',
                s: 'ychydig eiliadau',
                ss: '%d eiliad',
                m: 'munud',
                mm: '%d munud',
                h: 'awr',
                hh: '%d awr',
                d: 'diwrnod',
                dd: '%d diwrnod',
                M: 'mis',
                MM: '%d mis',
                y: 'blwyddyn',
                yy: '%d flynedd',
            },
            dayOfMonthOrdinalParse: /\d{1,2}(fed|ain|af|il|ydd|ed|eg)/,
            // traditional ordinal numbers above 31 are not commonly used in colloquial Welsh
            ordinal: function (number) {
                var b = number,
                    output = '',
                    lookup = [
                        '',
                        'af',
                        'il',
                        'ydd',
                        'ydd',
                        'ed',
                        'ed',
                        'ed',
                        'fed',
                        'fed',
                        'fed', // 1af to 10fed
                        'eg',
                        'fed',
                        'eg',
                        'eg',
                        'fed',
                        'eg',
                        'eg',
                        'fed',
                        'eg',
                        'fed', // 11eg to 20fed
                    ];
                if (b > 20) {
                    if (b === 40 || b === 50 || b === 60 || b === 80 || b === 100) {
                        output = 'fed'; // not 30ain, 70ain or 90ain
                    } else {
                        output = 'ain';
                    }
                } else if (b > 0) {
                    output = lookup[b];
                }
                return number + output;
            },
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 4, // The week that contains Jan 4th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        hooks.defineLocale('da', {
            months: 'januar_februar_marts_april_maj_juni_juli_august_september_oktober_november_december'.split(
                '_'
            ),
            monthsShort: 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
            weekdays: 'søndag_mandag_tirsdag_onsdag_torsdag_fredag_lørdag'.split('_'),
            weekdaysShort: 'søn_man_tir_ons_tor_fre_lør'.split('_'),
            weekdaysMin: 'sø_ma_ti_on_to_fr_lø'.split('_'),
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'DD.MM.YYYY',
                LL: 'D. MMMM YYYY',
                LLL: 'D. MMMM YYYY HH:mm',
                LLLL: 'dddd [d.] D. MMMM YYYY [kl.] HH:mm',
            },
            calendar: {
                sameDay: '[i dag kl.] LT',
                nextDay: '[i morgen kl.] LT',
                nextWeek: 'på dddd [kl.] LT',
                lastDay: '[i går kl.] LT',
                lastWeek: '[i] dddd[s kl.] LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: 'om %s',
                past: '%s siden',
                s: 'få sekunder',
                ss: '%d sekunder',
                m: 'et minut',
                mm: '%d minutter',
                h: 'en time',
                hh: '%d timer',
                d: 'en dag',
                dd: '%d dage',
                M: 'en måned',
                MM: '%d måneder',
                y: 'et år',
                yy: '%d år',
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: '%d.',
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 4, // The week that contains Jan 4th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        function processRelativeTime(number, withoutSuffix, key, isFuture) {
            var format = {
                m: ['eine Minute', 'einer Minute'],
                h: ['eine Stunde', 'einer Stunde'],
                d: ['ein Tag', 'einem Tag'],
                dd: [number + ' Tage', number + ' Tagen'],
                w: ['eine Woche', 'einer Woche'],
                M: ['ein Monat', 'einem Monat'],
                MM: [number + ' Monate', number + ' Monaten'],
                y: ['ein Jahr', 'einem Jahr'],
                yy: [number + ' Jahre', number + ' Jahren'],
            };
            return withoutSuffix ? format[key][0] : format[key][1];
        }

        hooks.defineLocale('de-at', {
            months: 'Jänner_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split(
                '_'
            ),
            monthsShort: 'Jän._Feb._März_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.'.split(
                '_'
            ),
            monthsParseExact: true,
            weekdays: 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split(
                '_'
            ),
            weekdaysShort: 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
            weekdaysMin: 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
            weekdaysParseExact: true,
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'DD.MM.YYYY',
                LL: 'D. MMMM YYYY',
                LLL: 'D. MMMM YYYY HH:mm',
                LLLL: 'dddd, D. MMMM YYYY HH:mm',
            },
            calendar: {
                sameDay: '[heute um] LT [Uhr]',
                sameElse: 'L',
                nextDay: '[morgen um] LT [Uhr]',
                nextWeek: 'dddd [um] LT [Uhr]',
                lastDay: '[gestern um] LT [Uhr]',
                lastWeek: '[letzten] dddd [um] LT [Uhr]',
            },
            relativeTime: {
                future: 'in %s',
                past: 'vor %s',
                s: 'ein paar Sekunden',
                ss: '%d Sekunden',
                m: processRelativeTime,
                mm: '%d Minuten',
                h: processRelativeTime,
                hh: '%d Stunden',
                d: processRelativeTime,
                dd: processRelativeTime,
                w: processRelativeTime,
                ww: '%d Wochen',
                M: processRelativeTime,
                MM: processRelativeTime,
                y: processRelativeTime,
                yy: processRelativeTime,
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: '%d.',
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 4, // The week that contains Jan 4th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        function processRelativeTime$1(number, withoutSuffix, key, isFuture) {
            var format = {
                m: ['eine Minute', 'einer Minute'],
                h: ['eine Stunde', 'einer Stunde'],
                d: ['ein Tag', 'einem Tag'],
                dd: [number + ' Tage', number + ' Tagen'],
                w: ['eine Woche', 'einer Woche'],
                M: ['ein Monat', 'einem Monat'],
                MM: [number + ' Monate', number + ' Monaten'],
                y: ['ein Jahr', 'einem Jahr'],
                yy: [number + ' Jahre', number + ' Jahren'],
            };
            return withoutSuffix ? format[key][0] : format[key][1];
        }

        hooks.defineLocale('de-ch', {
            months: 'Januar_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split(
                '_'
            ),
            monthsShort: 'Jan._Feb._März_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.'.split(
                '_'
            ),
            monthsParseExact: true,
            weekdays: 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split(
                '_'
            ),
            weekdaysShort: 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
            weekdaysMin: 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
            weekdaysParseExact: true,
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'DD.MM.YYYY',
                LL: 'D. MMMM YYYY',
                LLL: 'D. MMMM YYYY HH:mm',
                LLLL: 'dddd, D. MMMM YYYY HH:mm',
            },
            calendar: {
                sameDay: '[heute um] LT [Uhr]',
                sameElse: 'L',
                nextDay: '[morgen um] LT [Uhr]',
                nextWeek: 'dddd [um] LT [Uhr]',
                lastDay: '[gestern um] LT [Uhr]',
                lastWeek: '[letzten] dddd [um] LT [Uhr]',
            },
            relativeTime: {
                future: 'in %s',
                past: 'vor %s',
                s: 'ein paar Sekunden',
                ss: '%d Sekunden',
                m: processRelativeTime$1,
                mm: '%d Minuten',
                h: processRelativeTime$1,
                hh: '%d Stunden',
                d: processRelativeTime$1,
                dd: processRelativeTime$1,
                w: processRelativeTime$1,
                ww: '%d Wochen',
                M: processRelativeTime$1,
                MM: processRelativeTime$1,
                y: processRelativeTime$1,
                yy: processRelativeTime$1,
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: '%d.',
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 4, // The week that contains Jan 4th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        function processRelativeTime$2(number, withoutSuffix, key, isFuture) {
            var format = {
                m: ['eine Minute', 'einer Minute'],
                h: ['eine Stunde', 'einer Stunde'],
                d: ['ein Tag', 'einem Tag'],
                dd: [number + ' Tage', number + ' Tagen'],
                w: ['eine Woche', 'einer Woche'],
                M: ['ein Monat', 'einem Monat'],
                MM: [number + ' Monate', number + ' Monaten'],
                y: ['ein Jahr', 'einem Jahr'],
                yy: [number + ' Jahre', number + ' Jahren'],
            };
            return withoutSuffix ? format[key][0] : format[key][1];
        }

        hooks.defineLocale('de', {
            months: 'Januar_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split(
                '_'
            ),
            monthsShort: 'Jan._Feb._März_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.'.split(
                '_'
            ),
            monthsParseExact: true,
            weekdays: 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split(
                '_'
            ),
            weekdaysShort: 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
            weekdaysMin: 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
            weekdaysParseExact: true,
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'DD.MM.YYYY',
                LL: 'D. MMMM YYYY',
                LLL: 'D. MMMM YYYY HH:mm',
                LLLL: 'dddd, D. MMMM YYYY HH:mm',
            },
            calendar: {
                sameDay: '[heute um] LT [Uhr]',
                sameElse: 'L',
                nextDay: '[morgen um] LT [Uhr]',
                nextWeek: 'dddd [um] LT [Uhr]',
                lastDay: '[gestern um] LT [Uhr]',
                lastWeek: '[letzten] dddd [um] LT [Uhr]',
            },
            relativeTime: {
                future: 'in %s',
                past: 'vor %s',
                s: 'ein paar Sekunden',
                ss: '%d Sekunden',
                m: processRelativeTime$2,
                mm: '%d Minuten',
                h: processRelativeTime$2,
                hh: '%d Stunden',
                d: processRelativeTime$2,
                dd: processRelativeTime$2,
                w: processRelativeTime$2,
                ww: '%d Wochen',
                M: processRelativeTime$2,
                MM: processRelativeTime$2,
                y: processRelativeTime$2,
                yy: processRelativeTime$2,
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: '%d.',
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 4, // The week that contains Jan 4th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        var months$5 = [
                'ޖެނުއަރީ',
                'ފެބްރުއަރީ',
                'މާރިޗު',
                'އޭޕްރީލު',
                'މޭ',
                'ޖޫން',
                'ޖުލައި',
                'އޯގަސްޓު',
                'ސެޕްޓެމްބަރު',
                'އޮކްޓޯބަރު',
                'ނޮވެމްބަރު',
                'ޑިސެމްބަރު',
            ],
            weekdays = [
                'އާދިއްތަ',
                'ހޯމަ',
                'އަންގާރަ',
                'ބުދަ',
                'ބުރާސްފަތި',
                'ހުކުރު',
                'ހޮނިހިރު',
            ];

        hooks.defineLocale('dv', {
            months: months$5,
            monthsShort: months$5,
            weekdays: weekdays,
            weekdaysShort: weekdays,
            weekdaysMin: 'އާދި_ހޯމަ_އަން_ބުދަ_ބުރާ_ހުކު_ހޮނި'.split('_'),
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'D/M/YYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY HH:mm',
                LLLL: 'dddd D MMMM YYYY HH:mm',
            },
            meridiemParse: /މކ|މފ/,
            isPM: function (input) {
                return 'މފ' === input;
            },
            meridiem: function (hour, minute, isLower) {
                if (hour < 12) {
                    return 'މކ';
                } else {
                    return 'މފ';
                }
            },
            calendar: {
                sameDay: '[މިއަދު] LT',
                nextDay: '[މާދަމާ] LT',
                nextWeek: 'dddd LT',
                lastDay: '[އިއްޔެ] LT',
                lastWeek: '[ފާއިތުވި] dddd LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: 'ތެރޭގައި %s',
                past: 'ކުރިން %s',
                s: 'ސިކުންތުކޮޅެއް',
                ss: 'd% ސިކުންތު',
                m: 'މިނިޓެއް',
                mm: 'މިނިޓު %d',
                h: 'ގަޑިއިރެއް',
                hh: 'ގަޑިއިރު %d',
                d: 'ދުވަހެއް',
                dd: 'ދުވަސް %d',
                M: 'މަހެއް',
                MM: 'މަސް %d',
                y: 'އަހަރެއް',
                yy: 'އަހަރު %d',
            },
            preparse: function (string) {
                return string.replace(/،/g, ',');
            },
            postformat: function (string) {
                return string.replace(/,/g, '،');
            },
            week: {
                dow: 7, // Sunday is the first day of the week.
                doy: 12, // The week that contains Jan 12th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        function isFunction$1(input) {
            return (
                (typeof Function !== 'undefined' && input instanceof Function) ||
                Object.prototype.toString.call(input) === '[object Function]'
            );
        }

        hooks.defineLocale('el', {
            monthsNominativeEl: 'Ιανουάριος_Φεβρουάριος_Μάρτιος_Απρίλιος_Μάιος_Ιούνιος_Ιούλιος_Αύγουστος_Σεπτέμβριος_Οκτώβριος_Νοέμβριος_Δεκέμβριος'.split(
                '_'
            ),
            monthsGenitiveEl: 'Ιανουαρίου_Φεβρουαρίου_Μαρτίου_Απριλίου_Μαΐου_Ιουνίου_Ιουλίου_Αυγούστου_Σεπτεμβρίου_Οκτωβρίου_Νοεμβρίου_Δεκεμβρίου'.split(
                '_'
            ),
            months: function (momentToFormat, format) {
                if (!momentToFormat) {
                    return this._monthsNominativeEl;
                } else if (
                    typeof format === 'string' &&
                    /D/.test(format.substring(0, format.indexOf('MMMM')))
                ) {
                    // if there is a day number before 'MMMM'
                    return this._monthsGenitiveEl[momentToFormat.month()];
                } else {
                    return this._monthsNominativeEl[momentToFormat.month()];
                }
            },
            monthsShort: 'Ιαν_Φεβ_Μαρ_Απρ_Μαϊ_Ιουν_Ιουλ_Αυγ_Σεπ_Οκτ_Νοε_Δεκ'.split('_'),
            weekdays: 'Κυριακή_Δευτέρα_Τρίτη_Τετάρτη_Πέμπτη_Παρασκευή_Σάββατο'.split(
                '_'
            ),
            weekdaysShort: 'Κυρ_Δευ_Τρι_Τετ_Πεμ_Παρ_Σαβ'.split('_'),
            weekdaysMin: 'Κυ_Δε_Τρ_Τε_Πε_Πα_Σα'.split('_'),
            meridiem: function (hours, minutes, isLower) {
                if (hours > 11) {
                    return isLower ? 'μμ' : 'ΜΜ';
                } else {
                    return isLower ? 'πμ' : 'ΠΜ';
                }
            },
            isPM: function (input) {
                return (input + '').toLowerCase()[0] === 'μ';
            },
            meridiemParse: /[ΠΜ]\.?Μ?\.?/i,
            longDateFormat: {
                LT: 'h:mm A',
                LTS: 'h:mm:ss A',
                L: 'DD/MM/YYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY h:mm A',
                LLLL: 'dddd, D MMMM YYYY h:mm A',
            },
            calendarEl: {
                sameDay: '[Σήμερα {}] LT',
                nextDay: '[Αύριο {}] LT',
                nextWeek: 'dddd [{}] LT',
                lastDay: '[Χθες {}] LT',
                lastWeek: function () {
                    switch (this.day()) {
                        case 6:
                            return '[το προηγούμενο] dddd [{}] LT';
                        default:
                            return '[την προηγούμενη] dddd [{}] LT';
                    }
                },
                sameElse: 'L',
            },
            calendar: function (key, mom) {
                var output = this._calendarEl[key],
                    hours = mom && mom.hours();
                if (isFunction$1(output)) {
                    output = output.apply(mom);
                }
                return output.replace('{}', hours % 12 === 1 ? 'στη' : 'στις');
            },
            relativeTime: {
                future: 'σε %s',
                past: '%s πριν',
                s: 'λίγα δευτερόλεπτα',
                ss: '%d δευτερόλεπτα',
                m: 'ένα λεπτό',
                mm: '%d λεπτά',
                h: 'μία ώρα',
                hh: '%d ώρες',
                d: 'μία μέρα',
                dd: '%d μέρες',
                M: 'ένας μήνας',
                MM: '%d μήνες',
                y: 'ένας χρόνος',
                yy: '%d χρόνια',
            },
            dayOfMonthOrdinalParse: /\d{1,2}η/,
            ordinal: '%dη',
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 4, // The week that contains Jan 4st is the first week of the year.
            },
        });

        //! moment.js locale configuration

        hooks.defineLocale('en-au', {
            months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split(
                '_'
            ),
            monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
            weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split(
                '_'
            ),
            weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
            weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
            longDateFormat: {
                LT: 'h:mm A',
                LTS: 'h:mm:ss A',
                L: 'DD/MM/YYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY h:mm A',
                LLLL: 'dddd, D MMMM YYYY h:mm A',
            },
            calendar: {
                sameDay: '[Today at] LT',
                nextDay: '[Tomorrow at] LT',
                nextWeek: 'dddd [at] LT',
                lastDay: '[Yesterday at] LT',
                lastWeek: '[Last] dddd [at] LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: 'in %s',
                past: '%s ago',
                s: 'a few seconds',
                ss: '%d seconds',
                m: 'a minute',
                mm: '%d minutes',
                h: 'an hour',
                hh: '%d hours',
                d: 'a day',
                dd: '%d days',
                M: 'a month',
                MM: '%d months',
                y: 'a year',
                yy: '%d years',
            },
            dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
            ordinal: function (number) {
                var b = number % 10,
                    output =
                        ~~((number % 100) / 10) === 1
                            ? 'th'
                            : b === 1
                            ? 'st'
                            : b === 2
                            ? 'nd'
                            : b === 3
                            ? 'rd'
                            : 'th';
                return number + output;
            },
            week: {
                dow: 0, // Sunday is the first day of the week.
                doy: 4, // The week that contains Jan 4th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        hooks.defineLocale('en-ca', {
            months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split(
                '_'
            ),
            monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
            weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split(
                '_'
            ),
            weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
            weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
            longDateFormat: {
                LT: 'h:mm A',
                LTS: 'h:mm:ss A',
                L: 'YYYY-MM-DD',
                LL: 'MMMM D, YYYY',
                LLL: 'MMMM D, YYYY h:mm A',
                LLLL: 'dddd, MMMM D, YYYY h:mm A',
            },
            calendar: {
                sameDay: '[Today at] LT',
                nextDay: '[Tomorrow at] LT',
                nextWeek: 'dddd [at] LT',
                lastDay: '[Yesterday at] LT',
                lastWeek: '[Last] dddd [at] LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: 'in %s',
                past: '%s ago',
                s: 'a few seconds',
                ss: '%d seconds',
                m: 'a minute',
                mm: '%d minutes',
                h: 'an hour',
                hh: '%d hours',
                d: 'a day',
                dd: '%d days',
                M: 'a month',
                MM: '%d months',
                y: 'a year',
                yy: '%d years',
            },
            dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
            ordinal: function (number) {
                var b = number % 10,
                    output =
                        ~~((number % 100) / 10) === 1
                            ? 'th'
                            : b === 1
                            ? 'st'
                            : b === 2
                            ? 'nd'
                            : b === 3
                            ? 'rd'
                            : 'th';
                return number + output;
            },
        });

        //! moment.js locale configuration

        hooks.defineLocale('en-gb', {
            months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split(
                '_'
            ),
            monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
            weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split(
                '_'
            ),
            weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
            weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'DD/MM/YYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY HH:mm',
                LLLL: 'dddd, D MMMM YYYY HH:mm',
            },
            calendar: {
                sameDay: '[Today at] LT',
                nextDay: '[Tomorrow at] LT',
                nextWeek: 'dddd [at] LT',
                lastDay: '[Yesterday at] LT',
                lastWeek: '[Last] dddd [at] LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: 'in %s',
                past: '%s ago',
                s: 'a few seconds',
                ss: '%d seconds',
                m: 'a minute',
                mm: '%d minutes',
                h: 'an hour',
                hh: '%d hours',
                d: 'a day',
                dd: '%d days',
                M: 'a month',
                MM: '%d months',
                y: 'a year',
                yy: '%d years',
            },
            dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
            ordinal: function (number) {
                var b = number % 10,
                    output =
                        ~~((number % 100) / 10) === 1
                            ? 'th'
                            : b === 1
                            ? 'st'
                            : b === 2
                            ? 'nd'
                            : b === 3
                            ? 'rd'
                            : 'th';
                return number + output;
            },
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 4, // The week that contains Jan 4th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        hooks.defineLocale('en-ie', {
            months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split(
                '_'
            ),
            monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
            weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split(
                '_'
            ),
            weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
            weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'DD/MM/YYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY HH:mm',
                LLLL: 'dddd D MMMM YYYY HH:mm',
            },
            calendar: {
                sameDay: '[Today at] LT',
                nextDay: '[Tomorrow at] LT',
                nextWeek: 'dddd [at] LT',
                lastDay: '[Yesterday at] LT',
                lastWeek: '[Last] dddd [at] LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: 'in %s',
                past: '%s ago',
                s: 'a few seconds',
                ss: '%d seconds',
                m: 'a minute',
                mm: '%d minutes',
                h: 'an hour',
                hh: '%d hours',
                d: 'a day',
                dd: '%d days',
                M: 'a month',
                MM: '%d months',
                y: 'a year',
                yy: '%d years',
            },
            dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
            ordinal: function (number) {
                var b = number % 10,
                    output =
                        ~~((number % 100) / 10) === 1
                            ? 'th'
                            : b === 1
                            ? 'st'
                            : b === 2
                            ? 'nd'
                            : b === 3
                            ? 'rd'
                            : 'th';
                return number + output;
            },
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 4, // The week that contains Jan 4th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        hooks.defineLocale('en-il', {
            months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split(
                '_'
            ),
            monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
            weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split(
                '_'
            ),
            weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
            weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'DD/MM/YYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY HH:mm',
                LLLL: 'dddd, D MMMM YYYY HH:mm',
            },
            calendar: {
                sameDay: '[Today at] LT',
                nextDay: '[Tomorrow at] LT',
                nextWeek: 'dddd [at] LT',
                lastDay: '[Yesterday at] LT',
                lastWeek: '[Last] dddd [at] LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: 'in %s',
                past: '%s ago',
                s: 'a few seconds',
                ss: '%d seconds',
                m: 'a minute',
                mm: '%d minutes',
                h: 'an hour',
                hh: '%d hours',
                d: 'a day',
                dd: '%d days',
                M: 'a month',
                MM: '%d months',
                y: 'a year',
                yy: '%d years',
            },
            dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
            ordinal: function (number) {
                var b = number % 10,
                    output =
                        ~~((number % 100) / 10) === 1
                            ? 'th'
                            : b === 1
                            ? 'st'
                            : b === 2
                            ? 'nd'
                            : b === 3
                            ? 'rd'
                            : 'th';
                return number + output;
            },
        });

        //! moment.js locale configuration

        hooks.defineLocale('en-in', {
            months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split(
                '_'
            ),
            monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
            weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split(
                '_'
            ),
            weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
            weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
            longDateFormat: {
                LT: 'h:mm A',
                LTS: 'h:mm:ss A',
                L: 'DD/MM/YYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY h:mm A',
                LLLL: 'dddd, D MMMM YYYY h:mm A',
            },
            calendar: {
                sameDay: '[Today at] LT',
                nextDay: '[Tomorrow at] LT',
                nextWeek: 'dddd [at] LT',
                lastDay: '[Yesterday at] LT',
                lastWeek: '[Last] dddd [at] LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: 'in %s',
                past: '%s ago',
                s: 'a few seconds',
                ss: '%d seconds',
                m: 'a minute',
                mm: '%d minutes',
                h: 'an hour',
                hh: '%d hours',
                d: 'a day',
                dd: '%d days',
                M: 'a month',
                MM: '%d months',
                y: 'a year',
                yy: '%d years',
            },
            dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
            ordinal: function (number) {
                var b = number % 10,
                    output =
                        ~~((number % 100) / 10) === 1
                            ? 'th'
                            : b === 1
                            ? 'st'
                            : b === 2
                            ? 'nd'
                            : b === 3
                            ? 'rd'
                            : 'th';
                return number + output;
            },
            week: {
                dow: 0, // Sunday is the first day of the week.
                doy: 6, // The week that contains Jan 1st is the first week of the year.
            },
        });

        //! moment.js locale configuration

        hooks.defineLocale('en-nz', {
            months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split(
                '_'
            ),
            monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
            weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split(
                '_'
            ),
            weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
            weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
            longDateFormat: {
                LT: 'h:mm A',
                LTS: 'h:mm:ss A',
                L: 'DD/MM/YYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY h:mm A',
                LLLL: 'dddd, D MMMM YYYY h:mm A',
            },
            calendar: {
                sameDay: '[Today at] LT',
                nextDay: '[Tomorrow at] LT',
                nextWeek: 'dddd [at] LT',
                lastDay: '[Yesterday at] LT',
                lastWeek: '[Last] dddd [at] LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: 'in %s',
                past: '%s ago',
                s: 'a few seconds',
                ss: '%d seconds',
                m: 'a minute',
                mm: '%d minutes',
                h: 'an hour',
                hh: '%d hours',
                d: 'a day',
                dd: '%d days',
                M: 'a month',
                MM: '%d months',
                y: 'a year',
                yy: '%d years',
            },
            dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
            ordinal: function (number) {
                var b = number % 10,
                    output =
                        ~~((number % 100) / 10) === 1
                            ? 'th'
                            : b === 1
                            ? 'st'
                            : b === 2
                            ? 'nd'
                            : b === 3
                            ? 'rd'
                            : 'th';
                return number + output;
            },
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 4, // The week that contains Jan 4th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        hooks.defineLocale('en-sg', {
            months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split(
                '_'
            ),
            monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
            weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split(
                '_'
            ),
            weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
            weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'DD/MM/YYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY HH:mm',
                LLLL: 'dddd, D MMMM YYYY HH:mm',
            },
            calendar: {
                sameDay: '[Today at] LT',
                nextDay: '[Tomorrow at] LT',
                nextWeek: 'dddd [at] LT',
                lastDay: '[Yesterday at] LT',
                lastWeek: '[Last] dddd [at] LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: 'in %s',
                past: '%s ago',
                s: 'a few seconds',
                ss: '%d seconds',
                m: 'a minute',
                mm: '%d minutes',
                h: 'an hour',
                hh: '%d hours',
                d: 'a day',
                dd: '%d days',
                M: 'a month',
                MM: '%d months',
                y: 'a year',
                yy: '%d years',
            },
            dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
            ordinal: function (number) {
                var b = number % 10,
                    output =
                        ~~((number % 100) / 10) === 1
                            ? 'th'
                            : b === 1
                            ? 'st'
                            : b === 2
                            ? 'nd'
                            : b === 3
                            ? 'rd'
                            : 'th';
                return number + output;
            },
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 4, // The week that contains Jan 4th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        hooks.defineLocale('eo', {
            months: 'januaro_februaro_marto_aprilo_majo_junio_julio_aŭgusto_septembro_oktobro_novembro_decembro'.split(
                '_'
            ),
            monthsShort: 'jan_feb_mart_apr_maj_jun_jul_aŭg_sept_okt_nov_dec'.split('_'),
            weekdays: 'dimanĉo_lundo_mardo_merkredo_ĵaŭdo_vendredo_sabato'.split('_'),
            weekdaysShort: 'dim_lun_mard_merk_ĵaŭ_ven_sab'.split('_'),
            weekdaysMin: 'di_lu_ma_me_ĵa_ve_sa'.split('_'),
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'YYYY-MM-DD',
                LL: '[la] D[-an de] MMMM, YYYY',
                LLL: '[la] D[-an de] MMMM, YYYY HH:mm',
                LLLL: 'dddd[n], [la] D[-an de] MMMM, YYYY HH:mm',
                llll: 'ddd, [la] D[-an de] MMM, YYYY HH:mm',
            },
            meridiemParse: /[ap]\.t\.m/i,
            isPM: function (input) {
                return input.charAt(0).toLowerCase() === 'p';
            },
            meridiem: function (hours, minutes, isLower) {
                if (hours > 11) {
                    return isLower ? 'p.t.m.' : 'P.T.M.';
                } else {
                    return isLower ? 'a.t.m.' : 'A.T.M.';
                }
            },
            calendar: {
                sameDay: '[Hodiaŭ je] LT',
                nextDay: '[Morgaŭ je] LT',
                nextWeek: 'dddd[n je] LT',
                lastDay: '[Hieraŭ je] LT',
                lastWeek: '[pasintan] dddd[n je] LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: 'post %s',
                past: 'antaŭ %s',
                s: 'kelkaj sekundoj',
                ss: '%d sekundoj',
                m: 'unu minuto',
                mm: '%d minutoj',
                h: 'unu horo',
                hh: '%d horoj',
                d: 'unu tago', //ne 'diurno', ĉar estas uzita por proksimumo
                dd: '%d tagoj',
                M: 'unu monato',
                MM: '%d monatoj',
                y: 'unu jaro',
                yy: '%d jaroj',
            },
            dayOfMonthOrdinalParse: /\d{1,2}a/,
            ordinal: '%da',
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 7, // The week that contains Jan 7th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split(
                '_'
            ),
            monthsShort$1 = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_'),
            monthsParse$2 = [
                /^ene/i,
                /^feb/i,
                /^mar/i,
                /^abr/i,
                /^may/i,
                /^jun/i,
                /^jul/i,
                /^ago/i,
                /^sep/i,
                /^oct/i,
                /^nov/i,
                /^dic/i,
            ],
            monthsRegex$3 = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;

        hooks.defineLocale('es-do', {
            months: 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split(
                '_'
            ),
            monthsShort: function (m, format) {
                if (!m) {
                    return monthsShortDot;
                } else if (/-MMM-/.test(format)) {
                    return monthsShort$1[m.month()];
                } else {
                    return monthsShortDot[m.month()];
                }
            },
            monthsRegex: monthsRegex$3,
            monthsShortRegex: monthsRegex$3,
            monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
            monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
            monthsParse: monthsParse$2,
            longMonthsParse: monthsParse$2,
            shortMonthsParse: monthsParse$2,
            weekdays: 'domingo_lunes_martes_miércoles_jueves_viernes_sábado'.split('_'),
            weekdaysShort: 'dom._lun._mar._mié._jue._vie._sáb.'.split('_'),
            weekdaysMin: 'do_lu_ma_mi_ju_vi_sá'.split('_'),
            weekdaysParseExact: true,
            longDateFormat: {
                LT: 'h:mm A',
                LTS: 'h:mm:ss A',
                L: 'DD/MM/YYYY',
                LL: 'D [de] MMMM [de] YYYY',
                LLL: 'D [de] MMMM [de] YYYY h:mm A',
                LLLL: 'dddd, D [de] MMMM [de] YYYY h:mm A',
            },
            calendar: {
                sameDay: function () {
                    return '[hoy a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
                },
                nextDay: function () {
                    return '[mañana a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
                },
                nextWeek: function () {
                    return 'dddd [a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
                },
                lastDay: function () {
                    return '[ayer a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
                },
                lastWeek: function () {
                    return (
                        '[el] dddd [pasado a la' +
                        (this.hours() !== 1 ? 's' : '') +
                        '] LT'
                    );
                },
                sameElse: 'L',
            },
            relativeTime: {
                future: 'en %s',
                past: 'hace %s',
                s: 'unos segundos',
                ss: '%d segundos',
                m: 'un minuto',
                mm: '%d minutos',
                h: 'una hora',
                hh: '%d horas',
                d: 'un día',
                dd: '%d días',
                w: 'una semana',
                ww: '%d semanas',
                M: 'un mes',
                MM: '%d meses',
                y: 'un año',
                yy: '%d años',
            },
            dayOfMonthOrdinalParse: /\d{1,2}º/,
            ordinal: '%dº',
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 4, // The week that contains Jan 4th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        var monthsShortDot$1 = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split(
                '_'
            ),
            monthsShort$2 = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_'),
            monthsParse$3 = [
                /^ene/i,
                /^feb/i,
                /^mar/i,
                /^abr/i,
                /^may/i,
                /^jun/i,
                /^jul/i,
                /^ago/i,
                /^sep/i,
                /^oct/i,
                /^nov/i,
                /^dic/i,
            ],
            monthsRegex$4 = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;

        hooks.defineLocale('es-mx', {
            months: 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split(
                '_'
            ),
            monthsShort: function (m, format) {
                if (!m) {
                    return monthsShortDot$1;
                } else if (/-MMM-/.test(format)) {
                    return monthsShort$2[m.month()];
                } else {
                    return monthsShortDot$1[m.month()];
                }
            },
            monthsRegex: monthsRegex$4,
            monthsShortRegex: monthsRegex$4,
            monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
            monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
            monthsParse: monthsParse$3,
            longMonthsParse: monthsParse$3,
            shortMonthsParse: monthsParse$3,
            weekdays: 'domingo_lunes_martes_miércoles_jueves_viernes_sábado'.split('_'),
            weekdaysShort: 'dom._lun._mar._mié._jue._vie._sáb.'.split('_'),
            weekdaysMin: 'do_lu_ma_mi_ju_vi_sá'.split('_'),
            weekdaysParseExact: true,
            longDateFormat: {
                LT: 'H:mm',
                LTS: 'H:mm:ss',
                L: 'DD/MM/YYYY',
                LL: 'D [de] MMMM [de] YYYY',
                LLL: 'D [de] MMMM [de] YYYY H:mm',
                LLLL: 'dddd, D [de] MMMM [de] YYYY H:mm',
            },
            calendar: {
                sameDay: function () {
                    return '[hoy a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
                },
                nextDay: function () {
                    return '[mañana a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
                },
                nextWeek: function () {
                    return 'dddd [a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
                },
                lastDay: function () {
                    return '[ayer a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
                },
                lastWeek: function () {
                    return (
                        '[el] dddd [pasado a la' +
                        (this.hours() !== 1 ? 's' : '') +
                        '] LT'
                    );
                },
                sameElse: 'L',
            },
            relativeTime: {
                future: 'en %s',
                past: 'hace %s',
                s: 'unos segundos',
                ss: '%d segundos',
                m: 'un minuto',
                mm: '%d minutos',
                h: 'una hora',
                hh: '%d horas',
                d: 'un día',
                dd: '%d días',
                w: 'una semana',
                ww: '%d semanas',
                M: 'un mes',
                MM: '%d meses',
                y: 'un año',
                yy: '%d años',
            },
            dayOfMonthOrdinalParse: /\d{1,2}º/,
            ordinal: '%dº',
            week: {
                dow: 0, // Sunday is the first day of the week.
                doy: 4, // The week that contains Jan 4th is the first week of the year.
            },
            invalidDate: 'Fecha inválida',
        });

        //! moment.js locale configuration

        var monthsShortDot$2 = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split(
                '_'
            ),
            monthsShort$3 = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_'),
            monthsParse$4 = [
                /^ene/i,
                /^feb/i,
                /^mar/i,
                /^abr/i,
                /^may/i,
                /^jun/i,
                /^jul/i,
                /^ago/i,
                /^sep/i,
                /^oct/i,
                /^nov/i,
                /^dic/i,
            ],
            monthsRegex$5 = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;

        hooks.defineLocale('es-us', {
            months: 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split(
                '_'
            ),
            monthsShort: function (m, format) {
                if (!m) {
                    return monthsShortDot$2;
                } else if (/-MMM-/.test(format)) {
                    return monthsShort$3[m.month()];
                } else {
                    return monthsShortDot$2[m.month()];
                }
            },
            monthsRegex: monthsRegex$5,
            monthsShortRegex: monthsRegex$5,
            monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
            monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
            monthsParse: monthsParse$4,
            longMonthsParse: monthsParse$4,
            shortMonthsParse: monthsParse$4,
            weekdays: 'domingo_lunes_martes_miércoles_jueves_viernes_sábado'.split('_'),
            weekdaysShort: 'dom._lun._mar._mié._jue._vie._sáb.'.split('_'),
            weekdaysMin: 'do_lu_ma_mi_ju_vi_sá'.split('_'),
            weekdaysParseExact: true,
            longDateFormat: {
                LT: 'h:mm A',
                LTS: 'h:mm:ss A',
                L: 'MM/DD/YYYY',
                LL: 'D [de] MMMM [de] YYYY',
                LLL: 'D [de] MMMM [de] YYYY h:mm A',
                LLLL: 'dddd, D [de] MMMM [de] YYYY h:mm A',
            },
            calendar: {
                sameDay: function () {
                    return '[hoy a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
                },
                nextDay: function () {
                    return '[mañana a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
                },
                nextWeek: function () {
                    return 'dddd [a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
                },
                lastDay: function () {
                    return '[ayer a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
                },
                lastWeek: function () {
                    return (
                        '[el] dddd [pasado a la' +
                        (this.hours() !== 1 ? 's' : '') +
                        '] LT'
                    );
                },
                sameElse: 'L',
            },
            relativeTime: {
                future: 'en %s',
                past: 'hace %s',
                s: 'unos segundos',
                ss: '%d segundos',
                m: 'un minuto',
                mm: '%d minutos',
                h: 'una hora',
                hh: '%d horas',
                d: 'un día',
                dd: '%d días',
                w: 'una semana',
                ww: '%d semanas',
                M: 'un mes',
                MM: '%d meses',
                y: 'un año',
                yy: '%d años',
            },
            dayOfMonthOrdinalParse: /\d{1,2}º/,
            ordinal: '%dº',
            week: {
                dow: 0, // Sunday is the first day of the week.
                doy: 6, // The week that contains Jan 6th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        var monthsShortDot$3 = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split(
                '_'
            ),
            monthsShort$4 = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_'),
            monthsParse$5 = [
                /^ene/i,
                /^feb/i,
                /^mar/i,
                /^abr/i,
                /^may/i,
                /^jun/i,
                /^jul/i,
                /^ago/i,
                /^sep/i,
                /^oct/i,
                /^nov/i,
                /^dic/i,
            ],
            monthsRegex$6 = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;

        hooks.defineLocale('es', {
            months: 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split(
                '_'
            ),
            monthsShort: function (m, format) {
                if (!m) {
                    return monthsShortDot$3;
                } else if (/-MMM-/.test(format)) {
                    return monthsShort$4[m.month()];
                } else {
                    return monthsShortDot$3[m.month()];
                }
            },
            monthsRegex: monthsRegex$6,
            monthsShortRegex: monthsRegex$6,
            monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
            monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
            monthsParse: monthsParse$5,
            longMonthsParse: monthsParse$5,
            shortMonthsParse: monthsParse$5,
            weekdays: 'domingo_lunes_martes_miércoles_jueves_viernes_sábado'.split('_'),
            weekdaysShort: 'dom._lun._mar._mié._jue._vie._sáb.'.split('_'),
            weekdaysMin: 'do_lu_ma_mi_ju_vi_sá'.split('_'),
            weekdaysParseExact: true,
            longDateFormat: {
                LT: 'H:mm',
                LTS: 'H:mm:ss',
                L: 'DD/MM/YYYY',
                LL: 'D [de] MMMM [de] YYYY',
                LLL: 'D [de] MMMM [de] YYYY H:mm',
                LLLL: 'dddd, D [de] MMMM [de] YYYY H:mm',
            },
            calendar: {
                sameDay: function () {
                    return '[hoy a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
                },
                nextDay: function () {
                    return '[mañana a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
                },
                nextWeek: function () {
                    return 'dddd [a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
                },
                lastDay: function () {
                    return '[ayer a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
                },
                lastWeek: function () {
                    return (
                        '[el] dddd [pasado a la' +
                        (this.hours() !== 1 ? 's' : '') +
                        '] LT'
                    );
                },
                sameElse: 'L',
            },
            relativeTime: {
                future: 'en %s',
                past: 'hace %s',
                s: 'unos segundos',
                ss: '%d segundos',
                m: 'un minuto',
                mm: '%d minutos',
                h: 'una hora',
                hh: '%d horas',
                d: 'un día',
                dd: '%d días',
                w: 'una semana',
                ww: '%d semanas',
                M: 'un mes',
                MM: '%d meses',
                y: 'un año',
                yy: '%d años',
            },
            dayOfMonthOrdinalParse: /\d{1,2}º/,
            ordinal: '%dº',
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 4, // The week that contains Jan 4th is the first week of the year.
            },
            invalidDate: 'Fecha inválida',
        });

        //! moment.js locale configuration

        function processRelativeTime$3(number, withoutSuffix, key, isFuture) {
            var format = {
                s: ['mõne sekundi', 'mõni sekund', 'paar sekundit'],
                ss: [number + 'sekundi', number + 'sekundit'],
                m: ['ühe minuti', 'üks minut'],
                mm: [number + ' minuti', number + ' minutit'],
                h: ['ühe tunni', 'tund aega', 'üks tund'],
                hh: [number + ' tunni', number + ' tundi'],
                d: ['ühe päeva', 'üks päev'],
                M: ['kuu aja', 'kuu aega', 'üks kuu'],
                MM: [number + ' kuu', number + ' kuud'],
                y: ['ühe aasta', 'aasta', 'üks aasta'],
                yy: [number + ' aasta', number + ' aastat'],
            };
            if (withoutSuffix) {
                return format[key][2] ? format[key][2] : format[key][1];
            }
            return isFuture ? format[key][0] : format[key][1];
        }

        hooks.defineLocale('et', {
            months: 'jaanuar_veebruar_märts_aprill_mai_juuni_juuli_august_september_oktoober_november_detsember'.split(
                '_'
            ),
            monthsShort: 'jaan_veebr_märts_apr_mai_juuni_juuli_aug_sept_okt_nov_dets'.split(
                '_'
            ),
            weekdays: 'pühapäev_esmaspäev_teisipäev_kolmapäev_neljapäev_reede_laupäev'.split(
                '_'
            ),
            weekdaysShort: 'P_E_T_K_N_R_L'.split('_'),
            weekdaysMin: 'P_E_T_K_N_R_L'.split('_'),
            longDateFormat: {
                LT: 'H:mm',
                LTS: 'H:mm:ss',
                L: 'DD.MM.YYYY',
                LL: 'D. MMMM YYYY',
                LLL: 'D. MMMM YYYY H:mm',
                LLLL: 'dddd, D. MMMM YYYY H:mm',
            },
            calendar: {
                sameDay: '[Täna,] LT',
                nextDay: '[Homme,] LT',
                nextWeek: '[Järgmine] dddd LT',
                lastDay: '[Eile,] LT',
                lastWeek: '[Eelmine] dddd LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: '%s pärast',
                past: '%s tagasi',
                s: processRelativeTime$3,
                ss: processRelativeTime$3,
                m: processRelativeTime$3,
                mm: processRelativeTime$3,
                h: processRelativeTime$3,
                hh: processRelativeTime$3,
                d: processRelativeTime$3,
                dd: '%d päeva',
                M: processRelativeTime$3,
                MM: processRelativeTime$3,
                y: processRelativeTime$3,
                yy: processRelativeTime$3,
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: '%d.',
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 4, // The week that contains Jan 4th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        hooks.defineLocale('eu', {
            months: 'urtarrila_otsaila_martxoa_apirila_maiatza_ekaina_uztaila_abuztua_iraila_urria_azaroa_abendua'.split(
                '_'
            ),
            monthsShort: 'urt._ots._mar._api._mai._eka._uzt._abu._ira._urr._aza._abe.'.split(
                '_'
            ),
            monthsParseExact: true,
            weekdays: 'igandea_astelehena_asteartea_asteazkena_osteguna_ostirala_larunbata'.split(
                '_'
            ),
            weekdaysShort: 'ig._al._ar._az._og._ol._lr.'.split('_'),
            weekdaysMin: 'ig_al_ar_az_og_ol_lr'.split('_'),
            weekdaysParseExact: true,
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'YYYY-MM-DD',
                LL: 'YYYY[ko] MMMM[ren] D[a]',
                LLL: 'YYYY[ko] MMMM[ren] D[a] HH:mm',
                LLLL: 'dddd, YYYY[ko] MMMM[ren] D[a] HH:mm',
                l: 'YYYY-M-D',
                ll: 'YYYY[ko] MMM D[a]',
                lll: 'YYYY[ko] MMM D[a] HH:mm',
                llll: 'ddd, YYYY[ko] MMM D[a] HH:mm',
            },
            calendar: {
                sameDay: '[gaur] LT[etan]',
                nextDay: '[bihar] LT[etan]',
                nextWeek: 'dddd LT[etan]',
                lastDay: '[atzo] LT[etan]',
                lastWeek: '[aurreko] dddd LT[etan]',
                sameElse: 'L',
            },
            relativeTime: {
                future: '%s barru',
                past: 'duela %s',
                s: 'segundo batzuk',
                ss: '%d segundo',
                m: 'minutu bat',
                mm: '%d minutu',
                h: 'ordu bat',
                hh: '%d ordu',
                d: 'egun bat',
                dd: '%d egun',
                M: 'hilabete bat',
                MM: '%d hilabete',
                y: 'urte bat',
                yy: '%d urte',
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: '%d.',
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 7, // The week that contains Jan 7th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        var symbolMap$6 = {
                1: '۱',
                2: '۲',
                3: '۳',
                4: '۴',
                5: '۵',
                6: '۶',
                7: '۷',
                8: '۸',
                9: '۹',
                0: '۰',
            },
            numberMap$5 = {
                '۱': '1',
                '۲': '2',
                '۳': '3',
                '۴': '4',
                '۵': '5',
                '۶': '6',
                '۷': '7',
                '۸': '8',
                '۹': '9',
                '۰': '0',
            };

        hooks.defineLocale('fa', {
            months: 'ژانویه_فوریه_مارس_آوریل_مه_ژوئن_ژوئیه_اوت_سپتامبر_اکتبر_نوامبر_دسامبر'.split(
                '_'
            ),
            monthsShort: 'ژانویه_فوریه_مارس_آوریل_مه_ژوئن_ژوئیه_اوت_سپتامبر_اکتبر_نوامبر_دسامبر'.split(
                '_'
            ),
            weekdays: 'یک\u200cشنبه_دوشنبه_سه\u200cشنبه_چهارشنبه_پنج\u200cشنبه_جمعه_شنبه'.split(
                '_'
            ),
            weekdaysShort: 'یک\u200cشنبه_دوشنبه_سه\u200cشنبه_چهارشنبه_پنج\u200cشنبه_جمعه_شنبه'.split(
                '_'
            ),
            weekdaysMin: 'ی_د_س_چ_پ_ج_ش'.split('_'),
            weekdaysParseExact: true,
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'DD/MM/YYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY HH:mm',
                LLLL: 'dddd, D MMMM YYYY HH:mm',
            },
            meridiemParse: /قبل از ظهر|بعد از ظهر/,
            isPM: function (input) {
                return /بعد از ظهر/.test(input);
            },
            meridiem: function (hour, minute, isLower) {
                if (hour < 12) {
                    return 'قبل از ظهر';
                } else {
                    return 'بعد از ظهر';
                }
            },
            calendar: {
                sameDay: '[امروز ساعت] LT',
                nextDay: '[فردا ساعت] LT',
                nextWeek: 'dddd [ساعت] LT',
                lastDay: '[دیروز ساعت] LT',
                lastWeek: 'dddd [پیش] [ساعت] LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: 'در %s',
                past: '%s پیش',
                s: 'چند ثانیه',
                ss: '%d ثانیه',
                m: 'یک دقیقه',
                mm: '%d دقیقه',
                h: 'یک ساعت',
                hh: '%d ساعت',
                d: 'یک روز',
                dd: '%d روز',
                M: 'یک ماه',
                MM: '%d ماه',
                y: 'یک سال',
                yy: '%d سال',
            },
            preparse: function (string) {
                return string
                    .replace(/[۰-۹]/g, function (match) {
                        return numberMap$5[match];
                    })
                    .replace(/،/g, ',');
            },
            postformat: function (string) {
                return string
                    .replace(/\d/g, function (match) {
                        return symbolMap$6[match];
                    })
                    .replace(/,/g, '،');
            },
            dayOfMonthOrdinalParse: /\d{1,2}م/,
            ordinal: '%dم',
            week: {
                dow: 6, // Saturday is the first day of the week.
                doy: 12, // The week that contains Jan 12th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        var numbersPast = 'nolla yksi kaksi kolme neljä viisi kuusi seitsemän kahdeksan yhdeksän'.split(
                ' '
            ),
            numbersFuture = [
                'nolla',
                'yhden',
                'kahden',
                'kolmen',
                'neljän',
                'viiden',
                'kuuden',
                numbersPast[7],
                numbersPast[8],
                numbersPast[9],
            ];
        function translate$2(number, withoutSuffix, key, isFuture) {
            var result = '';
            switch (key) {
                case 's':
                    return isFuture ? 'muutaman sekunnin' : 'muutama sekunti';
                case 'ss':
                    result = isFuture ? 'sekunnin' : 'sekuntia';
                    break;
                case 'm':
                    return isFuture ? 'minuutin' : 'minuutti';
                case 'mm':
                    result = isFuture ? 'minuutin' : 'minuuttia';
                    break;
                case 'h':
                    return isFuture ? 'tunnin' : 'tunti';
                case 'hh':
                    result = isFuture ? 'tunnin' : 'tuntia';
                    break;
                case 'd':
                    return isFuture ? 'päivän' : 'päivä';
                case 'dd':
                    result = isFuture ? 'päivän' : 'päivää';
                    break;
                case 'M':
                    return isFuture ? 'kuukauden' : 'kuukausi';
                case 'MM':
                    result = isFuture ? 'kuukauden' : 'kuukautta';
                    break;
                case 'y':
                    return isFuture ? 'vuoden' : 'vuosi';
                case 'yy':
                    result = isFuture ? 'vuoden' : 'vuotta';
                    break;
            }
            result = verbalNumber(number, isFuture) + ' ' + result;
            return result;
        }
        function verbalNumber(number, isFuture) {
            return number < 10
                ? isFuture
                    ? numbersFuture[number]
                    : numbersPast[number]
                : number;
        }

        hooks.defineLocale('fi', {
            months: 'tammikuu_helmikuu_maaliskuu_huhtikuu_toukokuu_kesäkuu_heinäkuu_elokuu_syyskuu_lokakuu_marraskuu_joulukuu'.split(
                '_'
            ),
            monthsShort: 'tammi_helmi_maalis_huhti_touko_kesä_heinä_elo_syys_loka_marras_joulu'.split(
                '_'
            ),
            weekdays: 'sunnuntai_maanantai_tiistai_keskiviikko_torstai_perjantai_lauantai'.split(
                '_'
            ),
            weekdaysShort: 'su_ma_ti_ke_to_pe_la'.split('_'),
            weekdaysMin: 'su_ma_ti_ke_to_pe_la'.split('_'),
            longDateFormat: {
                LT: 'HH.mm',
                LTS: 'HH.mm.ss',
                L: 'DD.MM.YYYY',
                LL: 'Do MMMM[ta] YYYY',
                LLL: 'Do MMMM[ta] YYYY, [klo] HH.mm',
                LLLL: 'dddd, Do MMMM[ta] YYYY, [klo] HH.mm',
                l: 'D.M.YYYY',
                ll: 'Do MMM YYYY',
                lll: 'Do MMM YYYY, [klo] HH.mm',
                llll: 'ddd, Do MMM YYYY, [klo] HH.mm',
            },
            calendar: {
                sameDay: '[tänään] [klo] LT',
                nextDay: '[huomenna] [klo] LT',
                nextWeek: 'dddd [klo] LT',
                lastDay: '[eilen] [klo] LT',
                lastWeek: '[viime] dddd[na] [klo] LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: '%s päästä',
                past: '%s sitten',
                s: translate$2,
                ss: translate$2,
                m: translate$2,
                mm: translate$2,
                h: translate$2,
                hh: translate$2,
                d: translate$2,
                dd: translate$2,
                M: translate$2,
                MM: translate$2,
                y: translate$2,
                yy: translate$2,
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: '%d.',
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 4, // The week that contains Jan 4th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        hooks.defineLocale('fil', {
            months: 'Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre'.split(
                '_'
            ),
            monthsShort: 'Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis'.split('_'),
            weekdays: 'Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado'.split(
                '_'
            ),
            weekdaysShort: 'Lin_Lun_Mar_Miy_Huw_Biy_Sab'.split('_'),
            weekdaysMin: 'Li_Lu_Ma_Mi_Hu_Bi_Sab'.split('_'),
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'MM/D/YYYY',
                LL: 'MMMM D, YYYY',
                LLL: 'MMMM D, YYYY HH:mm',
                LLLL: 'dddd, MMMM DD, YYYY HH:mm',
            },
            calendar: {
                sameDay: 'LT [ngayong araw]',
                nextDay: '[Bukas ng] LT',
                nextWeek: 'LT [sa susunod na] dddd',
                lastDay: 'LT [kahapon]',
                lastWeek: 'LT [noong nakaraang] dddd',
                sameElse: 'L',
            },
            relativeTime: {
                future: 'sa loob ng %s',
                past: '%s ang nakalipas',
                s: 'ilang segundo',
                ss: '%d segundo',
                m: 'isang minuto',
                mm: '%d minuto',
                h: 'isang oras',
                hh: '%d oras',
                d: 'isang araw',
                dd: '%d araw',
                M: 'isang buwan',
                MM: '%d buwan',
                y: 'isang taon',
                yy: '%d taon',
            },
            dayOfMonthOrdinalParse: /\d{1,2}/,
            ordinal: function (number) {
                return number;
            },
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 4, // The week that contains Jan 4th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        hooks.defineLocale('fo', {
            months: 'januar_februar_mars_apríl_mai_juni_juli_august_september_oktober_november_desember'.split(
                '_'
            ),
            monthsShort: 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
            weekdays: 'sunnudagur_mánadagur_týsdagur_mikudagur_hósdagur_fríggjadagur_leygardagur'.split(
                '_'
            ),
            weekdaysShort: 'sun_mán_týs_mik_hós_frí_ley'.split('_'),
            weekdaysMin: 'su_má_tý_mi_hó_fr_le'.split('_'),
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'DD/MM/YYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY HH:mm',
                LLLL: 'dddd D. MMMM, YYYY HH:mm',
            },
            calendar: {
                sameDay: '[Í dag kl.] LT',
                nextDay: '[Í morgin kl.] LT',
                nextWeek: 'dddd [kl.] LT',
                lastDay: '[Í gjár kl.] LT',
                lastWeek: '[síðstu] dddd [kl] LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: 'um %s',
                past: '%s síðani',
                s: 'fá sekund',
                ss: '%d sekundir',
                m: 'ein minuttur',
                mm: '%d minuttir',
                h: 'ein tími',
                hh: '%d tímar',
                d: 'ein dagur',
                dd: '%d dagar',
                M: 'ein mánaður',
                MM: '%d mánaðir',
                y: 'eitt ár',
                yy: '%d ár',
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: '%d.',
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 4, // The week that contains Jan 4th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        hooks.defineLocale('fr-ca', {
            months: 'janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre'.split(
                '_'
            ),
            monthsShort: 'janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.'.split(
                '_'
            ),
            monthsParseExact: true,
            weekdays: 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
            weekdaysShort: 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
            weekdaysMin: 'di_lu_ma_me_je_ve_sa'.split('_'),
            weekdaysParseExact: true,
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'YYYY-MM-DD',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY HH:mm',
                LLLL: 'dddd D MMMM YYYY HH:mm',
            },
            calendar: {
                sameDay: '[Aujourd’hui à] LT',
                nextDay: '[Demain à] LT',
                nextWeek: 'dddd [à] LT',
                lastDay: '[Hier à] LT',
                lastWeek: 'dddd [dernier à] LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: 'dans %s',
                past: 'il y a %s',
                s: 'quelques secondes',
                ss: '%d secondes',
                m: 'une minute',
                mm: '%d minutes',
                h: 'une heure',
                hh: '%d heures',
                d: 'un jour',
                dd: '%d jours',
                M: 'un mois',
                MM: '%d mois',
                y: 'un an',
                yy: '%d ans',
            },
            dayOfMonthOrdinalParse: /\d{1,2}(er|e)/,
            ordinal: function (number, period) {
                switch (period) {
                    // Words with masculine grammatical gender: mois, trimestre, jour
                    default:
                    case 'M':
                    case 'Q':
                    case 'D':
                    case 'DDD':
                    case 'd':
                        return number + (number === 1 ? 'er' : 'e');

                    // Words with feminine grammatical gender: semaine
                    case 'w':
                    case 'W':
                        return number + (number === 1 ? 're' : 'e');
                }
            },
        });

        //! moment.js locale configuration

        hooks.defineLocale('fr-ch', {
            months: 'janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre'.split(
                '_'
            ),
            monthsShort: 'janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.'.split(
                '_'
            ),
            monthsParseExact: true,
            weekdays: 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
            weekdaysShort: 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
            weekdaysMin: 'di_lu_ma_me_je_ve_sa'.split('_'),
            weekdaysParseExact: true,
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'DD.MM.YYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY HH:mm',
                LLLL: 'dddd D MMMM YYYY HH:mm',
            },
            calendar: {
                sameDay: '[Aujourd’hui à] LT',
                nextDay: '[Demain à] LT',
                nextWeek: 'dddd [à] LT',
                lastDay: '[Hier à] LT',
                lastWeek: 'dddd [dernier à] LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: 'dans %s',
                past: 'il y a %s',
                s: 'quelques secondes',
                ss: '%d secondes',
                m: 'une minute',
                mm: '%d minutes',
                h: 'une heure',
                hh: '%d heures',
                d: 'un jour',
                dd: '%d jours',
                M: 'un mois',
                MM: '%d mois',
                y: 'un an',
                yy: '%d ans',
            },
            dayOfMonthOrdinalParse: /\d{1,2}(er|e)/,
            ordinal: function (number, period) {
                switch (period) {
                    // Words with masculine grammatical gender: mois, trimestre, jour
                    default:
                    case 'M':
                    case 'Q':
                    case 'D':
                    case 'DDD':
                    case 'd':
                        return number + (number === 1 ? 'er' : 'e');

                    // Words with feminine grammatical gender: semaine
                    case 'w':
                    case 'W':
                        return number + (number === 1 ? 're' : 'e');
                }
            },
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 4, // The week that contains Jan 4th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        var monthsStrictRegex$1 = /^(janvier|février|mars|avril|mai|juin|juillet|août|septembre|octobre|novembre|décembre)/i,
            monthsShortStrictRegex$1 = /(janv\.?|févr\.?|mars|avr\.?|mai|juin|juil\.?|août|sept\.?|oct\.?|nov\.?|déc\.?)/i,
            monthsRegex$7 = /(janv\.?|févr\.?|mars|avr\.?|mai|juin|juil\.?|août|sept\.?|oct\.?|nov\.?|déc\.?|janvier|février|mars|avril|mai|juin|juillet|août|septembre|octobre|novembre|décembre)/i,
            monthsParse$6 = [
                /^janv/i,
                /^févr/i,
                /^mars/i,
                /^avr/i,
                /^mai/i,
                /^juin/i,
                /^juil/i,
                /^août/i,
                /^sept/i,
                /^oct/i,
                /^nov/i,
                /^déc/i,
            ];

        hooks.defineLocale('fr', {
            months: 'janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre'.split(
                '_'
            ),
            monthsShort: 'janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.'.split(
                '_'
            ),
            monthsRegex: monthsRegex$7,
            monthsShortRegex: monthsRegex$7,
            monthsStrictRegex: monthsStrictRegex$1,
            monthsShortStrictRegex: monthsShortStrictRegex$1,
            monthsParse: monthsParse$6,
            longMonthsParse: monthsParse$6,
            shortMonthsParse: monthsParse$6,
            weekdays: 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
            weekdaysShort: 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
            weekdaysMin: 'di_lu_ma_me_je_ve_sa'.split('_'),
            weekdaysParseExact: true,
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'DD/MM/YYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY HH:mm',
                LLLL: 'dddd D MMMM YYYY HH:mm',
            },
            calendar: {
                sameDay: '[Aujourd’hui à] LT',
                nextDay: '[Demain à] LT',
                nextWeek: 'dddd [à] LT',
                lastDay: '[Hier à] LT',
                lastWeek: 'dddd [dernier à] LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: 'dans %s',
                past: 'il y a %s',
                s: 'quelques secondes',
                ss: '%d secondes',
                m: 'une minute',
                mm: '%d minutes',
                h: 'une heure',
                hh: '%d heures',
                d: 'un jour',
                dd: '%d jours',
                w: 'une semaine',
                ww: '%d semaines',
                M: 'un mois',
                MM: '%d mois',
                y: 'un an',
                yy: '%d ans',
            },
            dayOfMonthOrdinalParse: /\d{1,2}(er|)/,
            ordinal: function (number, period) {
                switch (period) {
                    // TODO: Return 'e' when day of month > 1. Move this case inside
                    // block for masculine words below.
                    // See https://github.com/moment/moment/issues/3375
                    case 'D':
                        return number + (number === 1 ? 'er' : '');

                    // Words with masculine grammatical gender: mois, trimestre, jour
                    default:
                    case 'M':
                    case 'Q':
                    case 'DDD':
                    case 'd':
                        return number + (number === 1 ? 'er' : 'e');

                    // Words with feminine grammatical gender: semaine
                    case 'w':
                    case 'W':
                        return number + (number === 1 ? 're' : 'e');
                }
            },
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 4, // The week that contains Jan 4th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        var monthsShortWithDots = 'jan._feb._mrt._apr._mai_jun._jul._aug._sep._okt._nov._des.'.split(
                '_'
            ),
            monthsShortWithoutDots = 'jan_feb_mrt_apr_mai_jun_jul_aug_sep_okt_nov_des'.split(
                '_'
            );

        hooks.defineLocale('fy', {
            months: 'jannewaris_febrewaris_maart_april_maaie_juny_july_augustus_septimber_oktober_novimber_desimber'.split(
                '_'
            ),
            monthsShort: function (m, format) {
                if (!m) {
                    return monthsShortWithDots;
                } else if (/-MMM-/.test(format)) {
                    return monthsShortWithoutDots[m.month()];
                } else {
                    return monthsShortWithDots[m.month()];
                }
            },
            monthsParseExact: true,
            weekdays: 'snein_moandei_tiisdei_woansdei_tongersdei_freed_sneon'.split(
                '_'
            ),
            weekdaysShort: 'si._mo._ti._wo._to._fr._so.'.split('_'),
            weekdaysMin: 'Si_Mo_Ti_Wo_To_Fr_So'.split('_'),
            weekdaysParseExact: true,
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'DD-MM-YYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY HH:mm',
                LLLL: 'dddd D MMMM YYYY HH:mm',
            },
            calendar: {
                sameDay: '[hjoed om] LT',
                nextDay: '[moarn om] LT',
                nextWeek: 'dddd [om] LT',
                lastDay: '[juster om] LT',
                lastWeek: '[ôfrûne] dddd [om] LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: 'oer %s',
                past: '%s lyn',
                s: 'in pear sekonden',
                ss: '%d sekonden',
                m: 'ien minút',
                mm: '%d minuten',
                h: 'ien oere',
                hh: '%d oeren',
                d: 'ien dei',
                dd: '%d dagen',
                M: 'ien moanne',
                MM: '%d moannen',
                y: 'ien jier',
                yy: '%d jierren',
            },
            dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
            ordinal: function (number) {
                return (
                    number +
                    (number === 1 || number === 8 || number >= 20 ? 'ste' : 'de')
                );
            },
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 4, // The week that contains Jan 4th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        var months$6 = [
                'Eanáir',
                'Feabhra',
                'Márta',
                'Aibreán',
                'Bealtaine',
                'Meitheamh',
                'Iúil',
                'Lúnasa',
                'Meán Fómhair',
                'Deireadh Fómhair',
                'Samhain',
                'Nollaig',
            ],
            monthsShort$5 = [
                'Ean',
                'Feabh',
                'Márt',
                'Aib',
                'Beal',
                'Meith',
                'Iúil',
                'Lún',
                'M.F.',
                'D.F.',
                'Samh',
                'Noll',
            ],
            weekdays$1 = [
                'Dé Domhnaigh',
                'Dé Luain',
                'Dé Máirt',
                'Dé Céadaoin',
                'Déardaoin',
                'Dé hAoine',
                'Dé Sathairn',
            ],
            weekdaysShort = ['Domh', 'Luan', 'Máirt', 'Céad', 'Déar', 'Aoine', 'Sath'],
            weekdaysMin = ['Do', 'Lu', 'Má', 'Cé', 'Dé', 'A', 'Sa'];

        hooks.defineLocale('ga', {
            months: months$6,
            monthsShort: monthsShort$5,
            monthsParseExact: true,
            weekdays: weekdays$1,
            weekdaysShort: weekdaysShort,
            weekdaysMin: weekdaysMin,
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'DD/MM/YYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY HH:mm',
                LLLL: 'dddd, D MMMM YYYY HH:mm',
            },
            calendar: {
                sameDay: '[Inniu ag] LT',
                nextDay: '[Amárach ag] LT',
                nextWeek: 'dddd [ag] LT',
                lastDay: '[Inné ag] LT',
                lastWeek: 'dddd [seo caite] [ag] LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: 'i %s',
                past: '%s ó shin',
                s: 'cúpla soicind',
                ss: '%d soicind',
                m: 'nóiméad',
                mm: '%d nóiméad',
                h: 'uair an chloig',
                hh: '%d uair an chloig',
                d: 'lá',
                dd: '%d lá',
                M: 'mí',
                MM: '%d míonna',
                y: 'bliain',
                yy: '%d bliain',
            },
            dayOfMonthOrdinalParse: /\d{1,2}(d|na|mh)/,
            ordinal: function (number) {
                var output = number === 1 ? 'd' : number % 10 === 2 ? 'na' : 'mh';
                return number + output;
            },
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 4, // The week that contains Jan 4th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        var months$7 = [
                'Am Faoilleach',
                'An Gearran',
                'Am Màrt',
                'An Giblean',
                'An Cèitean',
                'An t-Ògmhios',
                'An t-Iuchar',
                'An Lùnastal',
                'An t-Sultain',
                'An Dàmhair',
                'An t-Samhain',
                'An Dùbhlachd',
            ],
            monthsShort$6 = [
                'Faoi',
                'Gear',
                'Màrt',
                'Gibl',
                'Cèit',
                'Ògmh',
                'Iuch',
                'Lùn',
                'Sult',
                'Dàmh',
                'Samh',
                'Dùbh',
            ],
            weekdays$2 = [
                'Didòmhnaich',
                'Diluain',
                'Dimàirt',
                'Diciadain',
                'Diardaoin',
                'Dihaoine',
                'Disathairne',
            ],
            weekdaysShort$1 = ['Did', 'Dil', 'Dim', 'Dic', 'Dia', 'Dih', 'Dis'],
            weekdaysMin$1 = ['Dò', 'Lu', 'Mà', 'Ci', 'Ar', 'Ha', 'Sa'];

        hooks.defineLocale('gd', {
            months: months$7,
            monthsShort: monthsShort$6,
            monthsParseExact: true,
            weekdays: weekdays$2,
            weekdaysShort: weekdaysShort$1,
            weekdaysMin: weekdaysMin$1,
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'DD/MM/YYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY HH:mm',
                LLLL: 'dddd, D MMMM YYYY HH:mm',
            },
            calendar: {
                sameDay: '[An-diugh aig] LT',
                nextDay: '[A-màireach aig] LT',
                nextWeek: 'dddd [aig] LT',
                lastDay: '[An-dè aig] LT',
                lastWeek: 'dddd [seo chaidh] [aig] LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: 'ann an %s',
                past: 'bho chionn %s',
                s: 'beagan diogan',
                ss: '%d diogan',
                m: 'mionaid',
                mm: '%d mionaidean',
                h: 'uair',
                hh: '%d uairean',
                d: 'latha',
                dd: '%d latha',
                M: 'mìos',
                MM: '%d mìosan',
                y: 'bliadhna',
                yy: '%d bliadhna',
            },
            dayOfMonthOrdinalParse: /\d{1,2}(d|na|mh)/,
            ordinal: function (number) {
                var output = number === 1 ? 'd' : number % 10 === 2 ? 'na' : 'mh';
                return number + output;
            },
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 4, // The week that contains Jan 4th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        hooks.defineLocale('gl', {
            months: 'xaneiro_febreiro_marzo_abril_maio_xuño_xullo_agosto_setembro_outubro_novembro_decembro'.split(
                '_'
            ),
            monthsShort: 'xan._feb._mar._abr._mai._xuñ._xul._ago._set._out._nov._dec.'.split(
                '_'
            ),
            monthsParseExact: true,
            weekdays: 'domingo_luns_martes_mércores_xoves_venres_sábado'.split('_'),
            weekdaysShort: 'dom._lun._mar._mér._xov._ven._sáb.'.split('_'),
            weekdaysMin: 'do_lu_ma_mé_xo_ve_sá'.split('_'),
            weekdaysParseExact: true,
            longDateFormat: {
                LT: 'H:mm',
                LTS: 'H:mm:ss',
                L: 'DD/MM/YYYY',
                LL: 'D [de] MMMM [de] YYYY',
                LLL: 'D [de] MMMM [de] YYYY H:mm',
                LLLL: 'dddd, D [de] MMMM [de] YYYY H:mm',
            },
            calendar: {
                sameDay: function () {
                    return '[hoxe ' + (this.hours() !== 1 ? 'ás' : 'á') + '] LT';
                },
                nextDay: function () {
                    return '[mañá ' + (this.hours() !== 1 ? 'ás' : 'á') + '] LT';
                },
                nextWeek: function () {
                    return 'dddd [' + (this.hours() !== 1 ? 'ás' : 'a') + '] LT';
                },
                lastDay: function () {
                    return '[onte ' + (this.hours() !== 1 ? 'á' : 'a') + '] LT';
                },
                lastWeek: function () {
                    return (
                        '[o] dddd [pasado ' + (this.hours() !== 1 ? 'ás' : 'a') + '] LT'
                    );
                },
                sameElse: 'L',
            },
            relativeTime: {
                future: function (str) {
                    if (str.indexOf('un') === 0) {
                        return 'n' + str;
                    }
                    return 'en ' + str;
                },
                past: 'hai %s',
                s: 'uns segundos',
                ss: '%d segundos',
                m: 'un minuto',
                mm: '%d minutos',
                h: 'unha hora',
                hh: '%d horas',
                d: 'un día',
                dd: '%d días',
                M: 'un mes',
                MM: '%d meses',
                y: 'un ano',
                yy: '%d anos',
            },
            dayOfMonthOrdinalParse: /\d{1,2}º/,
            ordinal: '%dº',
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 4, // The week that contains Jan 4th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        function processRelativeTime$4(number, withoutSuffix, key, isFuture) {
            var format = {
                s: ['थोडया सॅकंडांनी', 'थोडे सॅकंड'],
                ss: [number + ' सॅकंडांनी', number + ' सॅकंड'],
                m: ['एका मिणटान', 'एक मिनूट'],
                mm: [number + ' मिणटांनी', number + ' मिणटां'],
                h: ['एका वरान', 'एक वर'],
                hh: [number + ' वरांनी', number + ' वरां'],
                d: ['एका दिसान', 'एक दीस'],
                dd: [number + ' दिसांनी', number + ' दीस'],
                M: ['एका म्हयन्यान', 'एक म्हयनो'],
                MM: [number + ' म्हयन्यानी', number + ' म्हयने'],
                y: ['एका वर्सान', 'एक वर्स'],
                yy: [number + ' वर्सांनी', number + ' वर्सां'],
            };
            return isFuture ? format[key][0] : format[key][1];
        }

        hooks.defineLocale('gom-deva', {
            months: {
                standalone: 'जानेवारी_फेब्रुवारी_मार्च_एप्रील_मे_जून_जुलय_ऑगस्ट_सप्टेंबर_ऑक्टोबर_नोव्हेंबर_डिसेंबर'.split(
                    '_'
                ),
                format: 'जानेवारीच्या_फेब्रुवारीच्या_मार्चाच्या_एप्रीलाच्या_मेयाच्या_जूनाच्या_जुलयाच्या_ऑगस्टाच्या_सप्टेंबराच्या_ऑक्टोबराच्या_नोव्हेंबराच्या_डिसेंबराच्या'.split(
                    '_'
                ),
                isFormat: /MMMM(\s)+D[oD]?/,
            },
            monthsShort: 'जाने._फेब्रु._मार्च_एप्री._मे_जून_जुल._ऑग._सप्टें._ऑक्टो._नोव्हें._डिसें.'.split(
                '_'
            ),
            monthsParseExact: true,
            weekdays: 'आयतार_सोमार_मंगळार_बुधवार_बिरेस्तार_सुक्रार_शेनवार'.split('_'),
            weekdaysShort: 'आयत._सोम._मंगळ._बुध._ब्रेस्त._सुक्र._शेन.'.split('_'),
            weekdaysMin: 'आ_सो_मं_बु_ब्रे_सु_शे'.split('_'),
            weekdaysParseExact: true,
            longDateFormat: {
                LT: 'A h:mm [वाजतां]',
                LTS: 'A h:mm:ss [वाजतां]',
                L: 'DD-MM-YYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY A h:mm [वाजतां]',
                LLLL: 'dddd, MMMM Do, YYYY, A h:mm [वाजतां]',
                llll: 'ddd, D MMM YYYY, A h:mm [वाजतां]',
            },
            calendar: {
                sameDay: '[आयज] LT',
                nextDay: '[फाल्यां] LT',
                nextWeek: '[फुडलो] dddd[,] LT',
                lastDay: '[काल] LT',
                lastWeek: '[फाटलो] dddd[,] LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: '%s',
                past: '%s आदीं',
                s: processRelativeTime$4,
                ss: processRelativeTime$4,
                m: processRelativeTime$4,
                mm: processRelativeTime$4,
                h: processRelativeTime$4,
                hh: processRelativeTime$4,
                d: processRelativeTime$4,
                dd: processRelativeTime$4,
                M: processRelativeTime$4,
                MM: processRelativeTime$4,
                y: processRelativeTime$4,
                yy: processRelativeTime$4,
            },
            dayOfMonthOrdinalParse: /\d{1,2}(वेर)/,
            ordinal: function (number, period) {
                switch (period) {
                    // the ordinal 'वेर' only applies to day of the month
                    case 'D':
                        return number + 'वेर';
                    default:
                    case 'M':
                    case 'Q':
                    case 'DDD':
                    case 'd':
                    case 'w':
                    case 'W':
                        return number;
                }
            },
            week: {
                dow: 0, // Sunday is the first day of the week
                doy: 3, // The week that contains Jan 4th is the first week of the year (7 + 0 - 4)
            },
            meridiemParse: /राती|सकाळीं|दनपारां|सांजे/,
            meridiemHour: function (hour, meridiem) {
                if (hour === 12) {
                    hour = 0;
                }
                if (meridiem === 'राती') {
                    return hour < 4 ? hour : hour + 12;
                } else if (meridiem === 'सकाळीं') {
                    return hour;
                } else if (meridiem === 'दनपारां') {
                    return hour > 12 ? hour : hour + 12;
                } else if (meridiem === 'सांजे') {
                    return hour + 12;
                }
            },
            meridiem: function (hour, minute, isLower) {
                if (hour < 4) {
                    return 'राती';
                } else if (hour < 12) {
                    return 'सकाळीं';
                } else if (hour < 16) {
                    return 'दनपारां';
                } else if (hour < 20) {
                    return 'सांजे';
                } else {
                    return 'राती';
                }
            },
        });

        //! moment.js locale configuration

        function processRelativeTime$5(number, withoutSuffix, key, isFuture) {
            var format = {
                s: ['thoddea sekondamni', 'thodde sekond'],
                ss: [number + ' sekondamni', number + ' sekond'],
                m: ['eka mintan', 'ek minut'],
                mm: [number + ' mintamni', number + ' mintam'],
                h: ['eka voran', 'ek vor'],
                hh: [number + ' voramni', number + ' voram'],
                d: ['eka disan', 'ek dis'],
                dd: [number + ' disamni', number + ' dis'],
                M: ['eka mhoinean', 'ek mhoino'],
                MM: [number + ' mhoineamni', number + ' mhoine'],
                y: ['eka vorsan', 'ek voros'],
                yy: [number + ' vorsamni', number + ' vorsam'],
            };
            return isFuture ? format[key][0] : format[key][1];
        }

        hooks.defineLocale('gom-latn', {
            months: {
                standalone: 'Janer_Febrer_Mars_Abril_Mai_Jun_Julai_Agost_Setembr_Otubr_Novembr_Dezembr'.split(
                    '_'
                ),
                format: 'Janerachea_Febrerachea_Marsachea_Abrilachea_Maiachea_Junachea_Julaiachea_Agostachea_Setembrachea_Otubrachea_Novembrachea_Dezembrachea'.split(
                    '_'
                ),
                isFormat: /MMMM(\s)+D[oD]?/,
            },
            monthsShort: 'Jan._Feb._Mars_Abr._Mai_Jun_Jul._Ago._Set._Otu._Nov._Dez.'.split(
                '_'
            ),
            monthsParseExact: true,
            weekdays: "Aitar_Somar_Mongllar_Budhvar_Birestar_Sukrar_Son'var".split('_'),
            weekdaysShort: 'Ait._Som._Mon._Bud._Bre._Suk._Son.'.split('_'),
            weekdaysMin: 'Ai_Sm_Mo_Bu_Br_Su_Sn'.split('_'),
            weekdaysParseExact: true,
            longDateFormat: {
                LT: 'A h:mm [vazta]',
                LTS: 'A h:mm:ss [vazta]',
                L: 'DD-MM-YYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY A h:mm [vazta]',
                LLLL: 'dddd, MMMM Do, YYYY, A h:mm [vazta]',
                llll: 'ddd, D MMM YYYY, A h:mm [vazta]',
            },
            calendar: {
                sameDay: '[Aiz] LT',
                nextDay: '[Faleam] LT',
                nextWeek: '[Fuddlo] dddd[,] LT',
                lastDay: '[Kal] LT',
                lastWeek: '[Fattlo] dddd[,] LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: '%s',
                past: '%s adim',
                s: processRelativeTime$5,
                ss: processRelativeTime$5,
                m: processRelativeTime$5,
                mm: processRelativeTime$5,
                h: processRelativeTime$5,
                hh: processRelativeTime$5,
                d: processRelativeTime$5,
                dd: processRelativeTime$5,
                M: processRelativeTime$5,
                MM: processRelativeTime$5,
                y: processRelativeTime$5,
                yy: processRelativeTime$5,
            },
            dayOfMonthOrdinalParse: /\d{1,2}(er)/,
            ordinal: function (number, period) {
                switch (period) {
                    // the ordinal 'er' only applies to day of the month
                    case 'D':
                        return number + 'er';
                    default:
                    case 'M':
                    case 'Q':
                    case 'DDD':
                    case 'd':
                    case 'w':
                    case 'W':
                        return number;
                }
            },
            week: {
                dow: 0, // Sunday is the first day of the week
                doy: 3, // The week that contains Jan 4th is the first week of the year (7 + 0 - 4)
            },
            meridiemParse: /rati|sokallim|donparam|sanje/,
            meridiemHour: function (hour, meridiem) {
                if (hour === 12) {
                    hour = 0;
                }
                if (meridiem === 'rati') {
                    return hour < 4 ? hour : hour + 12;
                } else if (meridiem === 'sokallim') {
                    return hour;
                } else if (meridiem === 'donparam') {
                    return hour > 12 ? hour : hour + 12;
                } else if (meridiem === 'sanje') {
                    return hour + 12;
                }
            },
            meridiem: function (hour, minute, isLower) {
                if (hour < 4) {
                    return 'rati';
                } else if (hour < 12) {
                    return 'sokallim';
                } else if (hour < 16) {
                    return 'donparam';
                } else if (hour < 20) {
                    return 'sanje';
                } else {
                    return 'rati';
                }
            },
        });

        //! moment.js locale configuration

        var symbolMap$7 = {
                1: '૧',
                2: '૨',
                3: '૩',
                4: '૪',
                5: '૫',
                6: '૬',
                7: '૭',
                8: '૮',
                9: '૯',
                0: '૦',
            },
            numberMap$6 = {
                '૧': '1',
                '૨': '2',
                '૩': '3',
                '૪': '4',
                '૫': '5',
                '૬': '6',
                '૭': '7',
                '૮': '8',
                '૯': '9',
                '૦': '0',
            };

        hooks.defineLocale('gu', {
            months: 'જાન્યુઆરી_ફેબ્રુઆરી_માર્ચ_એપ્રિલ_મે_જૂન_જુલાઈ_ઑગસ્ટ_સપ્ટેમ્બર_ઑક્ટ્બર_નવેમ્બર_ડિસેમ્બર'.split(
                '_'
            ),
            monthsShort: 'જાન્યુ._ફેબ્રુ._માર્ચ_એપ્રિ._મે_જૂન_જુલા._ઑગ._સપ્ટે._ઑક્ટ્._નવે._ડિસે.'.split(
                '_'
            ),
            monthsParseExact: true,
            weekdays: 'રવિવાર_સોમવાર_મંગળવાર_બુધ્વાર_ગુરુવાર_શુક્રવાર_શનિવાર'.split(
                '_'
            ),
            weekdaysShort: 'રવિ_સોમ_મંગળ_બુધ્_ગુરુ_શુક્ર_શનિ'.split('_'),
            weekdaysMin: 'ર_સો_મં_બુ_ગુ_શુ_શ'.split('_'),
            longDateFormat: {
                LT: 'A h:mm વાગ્યે',
                LTS: 'A h:mm:ss વાગ્યે',
                L: 'DD/MM/YYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY, A h:mm વાગ્યે',
                LLLL: 'dddd, D MMMM YYYY, A h:mm વાગ્યે',
            },
            calendar: {
                sameDay: '[આજ] LT',
                nextDay: '[કાલે] LT',
                nextWeek: 'dddd, LT',
                lastDay: '[ગઇકાલે] LT',
                lastWeek: '[પાછલા] dddd, LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: '%s મા',
                past: '%s પહેલા',
                s: 'અમુક પળો',
                ss: '%d સેકંડ',
                m: 'એક મિનિટ',
                mm: '%d મિનિટ',
                h: 'એક કલાક',
                hh: '%d કલાક',
                d: 'એક દિવસ',
                dd: '%d દિવસ',
                M: 'એક મહિનો',
                MM: '%d મહિનો',
                y: 'એક વર્ષ',
                yy: '%d વર્ષ',
            },
            preparse: function (string) {
                return string.replace(/[૧૨૩૪૫૬૭૮૯૦]/g, function (match) {
                    return numberMap$6[match];
                });
            },
            postformat: function (string) {
                return string.replace(/\d/g, function (match) {
                    return symbolMap$7[match];
                });
            },
            // Gujarati notation for meridiems are quite fuzzy in practice. While there exists
            // a rigid notion of a 'Pahar' it is not used as rigidly in modern Gujarati.
            meridiemParse: /રાત|બપોર|સવાર|સાંજ/,
            meridiemHour: function (hour, meridiem) {
                if (hour === 12) {
                    hour = 0;
                }
                if (meridiem === 'રાત') {
                    return hour < 4 ? hour : hour + 12;
                } else if (meridiem === 'સવાર') {
                    return hour;
                } else if (meridiem === 'બપોર') {
                    return hour >= 10 ? hour : hour + 12;
                } else if (meridiem === 'સાંજ') {
                    return hour + 12;
                }
            },
            meridiem: function (hour, minute, isLower) {
                if (hour < 4) {
                    return 'રાત';
                } else if (hour < 10) {
                    return 'સવાર';
                } else if (hour < 17) {
                    return 'બપોર';
                } else if (hour < 20) {
                    return 'સાંજ';
                } else {
                    return 'રાત';
                }
            },
            week: {
                dow: 0, // Sunday is the first day of the week.
                doy: 6, // The week that contains Jan 6th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        hooks.defineLocale('he', {
            months: 'ינואר_פברואר_מרץ_אפריל_מאי_יוני_יולי_אוגוסט_ספטמבר_אוקטובר_נובמבר_דצמבר'.split(
                '_'
            ),
            monthsShort: 'ינו׳_פבר׳_מרץ_אפר׳_מאי_יוני_יולי_אוג׳_ספט׳_אוק׳_נוב׳_דצמ׳'.split(
                '_'
            ),
            weekdays: 'ראשון_שני_שלישי_רביעי_חמישי_שישי_שבת'.split('_'),
            weekdaysShort: 'א׳_ב׳_ג׳_ד׳_ה׳_ו׳_ש׳'.split('_'),
            weekdaysMin: 'א_ב_ג_ד_ה_ו_ש'.split('_'),
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'DD/MM/YYYY',
                LL: 'D [ב]MMMM YYYY',
                LLL: 'D [ב]MMMM YYYY HH:mm',
                LLLL: 'dddd, D [ב]MMMM YYYY HH:mm',
                l: 'D/M/YYYY',
                ll: 'D MMM YYYY',
                lll: 'D MMM YYYY HH:mm',
                llll: 'ddd, D MMM YYYY HH:mm',
            },
            calendar: {
                sameDay: '[היום ב־]LT',
                nextDay: '[מחר ב־]LT',
                nextWeek: 'dddd [בשעה] LT',
                lastDay: '[אתמול ב־]LT',
                lastWeek: '[ביום] dddd [האחרון בשעה] LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: 'בעוד %s',
                past: 'לפני %s',
                s: 'מספר שניות',
                ss: '%d שניות',
                m: 'דקה',
                mm: '%d דקות',
                h: 'שעה',
                hh: function (number) {
                    if (number === 2) {
                        return 'שעתיים';
                    }
                    return number + ' שעות';
                },
                d: 'יום',
                dd: function (number) {
                    if (number === 2) {
                        return 'יומיים';
                    }
                    return number + ' ימים';
                },
                M: 'חודש',
                MM: function (number) {
                    if (number === 2) {
                        return 'חודשיים';
                    }
                    return number + ' חודשים';
                },
                y: 'שנה',
                yy: function (number) {
                    if (number === 2) {
                        return 'שנתיים';
                    } else if (number % 10 === 0 && number !== 10) {
                        return number + ' שנה';
                    }
                    return number + ' שנים';
                },
            },
            meridiemParse: /אחה"צ|לפנה"צ|אחרי הצהריים|לפני הצהריים|לפנות בוקר|בבוקר|בערב/i,
            isPM: function (input) {
                return /^(אחה"צ|אחרי הצהריים|בערב)$/.test(input);
            },
            meridiem: function (hour, minute, isLower) {
                if (hour < 5) {
                    return 'לפנות בוקר';
                } else if (hour < 10) {
                    return 'בבוקר';
                } else if (hour < 12) {
                    return isLower ? 'לפנה"צ' : 'לפני הצהריים';
                } else if (hour < 18) {
                    return isLower ? 'אחה"צ' : 'אחרי הצהריים';
                } else {
                    return 'בערב';
                }
            },
        });

        //! moment.js locale configuration

        var symbolMap$8 = {
                1: '१',
                2: '२',
                3: '३',
                4: '४',
                5: '५',
                6: '६',
                7: '७',
                8: '८',
                9: '९',
                0: '०',
            },
            numberMap$7 = {
                '१': '1',
                '२': '2',
                '३': '3',
                '४': '4',
                '५': '5',
                '६': '6',
                '७': '7',
                '८': '8',
                '९': '9',
                '०': '0',
            },
            monthsParse$7 = [
                /^जन/i,
                /^फ़र|फर/i,
                /^मार्च/i,
                /^अप्रै/i,
                /^मई/i,
                /^जून/i,
                /^जुल/i,
                /^अग/i,
                /^सितं|सित/i,
                /^अक्टू/i,
                /^नव|नवं/i,
                /^दिसं|दिस/i,
            ],
            shortMonthsParse = [
                /^जन/i,
                /^फ़र/i,
                /^मार्च/i,
                /^अप्रै/i,
                /^मई/i,
                /^जून/i,
                /^जुल/i,
                /^अग/i,
                /^सित/i,
                /^अक्टू/i,
                /^नव/i,
                /^दिस/i,
            ];

        hooks.defineLocale('hi', {
            months: {
                format: 'जनवरी_फ़रवरी_मार्च_अप्रैल_मई_जून_जुलाई_अगस्त_सितम्बर_अक्टूबर_नवम्बर_दिसम्बर'.split(
                    '_'
                ),
                standalone: 'जनवरी_फरवरी_मार्च_अप्रैल_मई_जून_जुलाई_अगस्त_सितंबर_अक्टूबर_नवंबर_दिसंबर'.split(
                    '_'
                ),
            },
            monthsShort: 'जन._फ़र._मार्च_अप्रै._मई_जून_जुल._अग._सित._अक्टू._नव._दिस.'.split(
                '_'
            ),
            weekdays: 'रविवार_सोमवार_मंगलवार_बुधवार_गुरूवार_शुक्रवार_शनिवार'.split('_'),
            weekdaysShort: 'रवि_सोम_मंगल_बुध_गुरू_शुक्र_शनि'.split('_'),
            weekdaysMin: 'र_सो_मं_बु_गु_शु_श'.split('_'),
            longDateFormat: {
                LT: 'A h:mm बजे',
                LTS: 'A h:mm:ss बजे',
                L: 'DD/MM/YYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY, A h:mm बजे',
                LLLL: 'dddd, D MMMM YYYY, A h:mm बजे',
            },

            monthsParse: monthsParse$7,
            longMonthsParse: monthsParse$7,
            shortMonthsParse: shortMonthsParse,

            monthsRegex: /^(जनवरी|जन\.?|फ़रवरी|फरवरी|फ़र\.?|मार्च?|अप्रैल|अप्रै\.?|मई?|जून?|जुलाई|जुल\.?|अगस्त|अग\.?|सितम्बर|सितंबर|सित\.?|अक्टूबर|अक्टू\.?|नवम्बर|नवंबर|नव\.?|दिसम्बर|दिसंबर|दिस\.?)/i,

            monthsShortRegex: /^(जनवरी|जन\.?|फ़रवरी|फरवरी|फ़र\.?|मार्च?|अप्रैल|अप्रै\.?|मई?|जून?|जुलाई|जुल\.?|अगस्त|अग\.?|सितम्बर|सितंबर|सित\.?|अक्टूबर|अक्टू\.?|नवम्बर|नवंबर|नव\.?|दिसम्बर|दिसंबर|दिस\.?)/i,

            monthsStrictRegex: /^(जनवरी?|फ़रवरी|फरवरी?|मार्च?|अप्रैल?|मई?|जून?|जुलाई?|अगस्त?|सितम्बर|सितंबर|सित?\.?|अक्टूबर|अक्टू\.?|नवम्बर|नवंबर?|दिसम्बर|दिसंबर?)/i,

            monthsShortStrictRegex: /^(जन\.?|फ़र\.?|मार्च?|अप्रै\.?|मई?|जून?|जुल\.?|अग\.?|सित\.?|अक्टू\.?|नव\.?|दिस\.?)/i,

            calendar: {
                sameDay: '[आज] LT',
                nextDay: '[कल] LT',
                nextWeek: 'dddd, LT',
                lastDay: '[कल] LT',
                lastWeek: '[पिछले] dddd, LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: '%s में',
                past: '%s पहले',
                s: 'कुछ ही क्षण',
                ss: '%d सेकंड',
                m: 'एक मिनट',
                mm: '%d मिनट',
                h: 'एक घंटा',
                hh: '%d घंटे',
                d: 'एक दिन',
                dd: '%d दिन',
                M: 'एक महीने',
                MM: '%d महीने',
                y: 'एक वर्ष',
                yy: '%d वर्ष',
            },
            preparse: function (string) {
                return string.replace(/[१२३४५६७८९०]/g, function (match) {
                    return numberMap$7[match];
                });
            },
            postformat: function (string) {
                return string.replace(/\d/g, function (match) {
                    return symbolMap$8[match];
                });
            },
            // Hindi notation for meridiems are quite fuzzy in practice. While there exists
            // a rigid notion of a 'Pahar' it is not used as rigidly in modern Hindi.
            meridiemParse: /रात|सुबह|दोपहर|शाम/,
            meridiemHour: function (hour, meridiem) {
                if (hour === 12) {
                    hour = 0;
                }
                if (meridiem === 'रात') {
                    return hour < 4 ? hour : hour + 12;
                } else if (meridiem === 'सुबह') {
                    return hour;
                } else if (meridiem === 'दोपहर') {
                    return hour >= 10 ? hour : hour + 12;
                } else if (meridiem === 'शाम') {
                    return hour + 12;
                }
            },
            meridiem: function (hour, minute, isLower) {
                if (hour < 4) {
                    return 'रात';
                } else if (hour < 10) {
                    return 'सुबह';
                } else if (hour < 17) {
                    return 'दोपहर';
                } else if (hour < 20) {
                    return 'शाम';
                } else {
                    return 'रात';
                }
            },
            week: {
                dow: 0, // Sunday is the first day of the week.
                doy: 6, // The week that contains Jan 6th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        function translate$3(number, withoutSuffix, key) {
            var result = number + ' ';
            switch (key) {
                case 'ss':
                    if (number === 1) {
                        result += 'sekunda';
                    } else if (number === 2 || number === 3 || number === 4) {
                        result += 'sekunde';
                    } else {
                        result += 'sekundi';
                    }
                    return result;
                case 'm':
                    return withoutSuffix ? 'jedna minuta' : 'jedne minute';
                case 'mm':
                    if (number === 1) {
                        result += 'minuta';
                    } else if (number === 2 || number === 3 || number === 4) {
                        result += 'minute';
                    } else {
                        result += 'minuta';
                    }
                    return result;
                case 'h':
                    return withoutSuffix ? 'jedan sat' : 'jednog sata';
                case 'hh':
                    if (number === 1) {
                        result += 'sat';
                    } else if (number === 2 || number === 3 || number === 4) {
                        result += 'sata';
                    } else {
                        result += 'sati';
                    }
                    return result;
                case 'dd':
                    if (number === 1) {
                        result += 'dan';
                    } else {
                        result += 'dana';
                    }
                    return result;
                case 'MM':
                    if (number === 1) {
                        result += 'mjesec';
                    } else if (number === 2 || number === 3 || number === 4) {
                        result += 'mjeseca';
                    } else {
                        result += 'mjeseci';
                    }
                    return result;
                case 'yy':
                    if (number === 1) {
                        result += 'godina';
                    } else if (number === 2 || number === 3 || number === 4) {
                        result += 'godine';
                    } else {
                        result += 'godina';
                    }
                    return result;
            }
        }

        hooks.defineLocale('hr', {
            months: {
                format: 'siječnja_veljače_ožujka_travnja_svibnja_lipnja_srpnja_kolovoza_rujna_listopada_studenoga_prosinca'.split(
                    '_'
                ),
                standalone: 'siječanj_veljača_ožujak_travanj_svibanj_lipanj_srpanj_kolovoz_rujan_listopad_studeni_prosinac'.split(
                    '_'
                ),
            },
            monthsShort: 'sij._velj._ožu._tra._svi._lip._srp._kol._ruj._lis._stu._pro.'.split(
                '_'
            ),
            monthsParseExact: true,
            weekdays: 'nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota'.split(
                '_'
            ),
            weekdaysShort: 'ned._pon._uto._sri._čet._pet._sub.'.split('_'),
            weekdaysMin: 'ne_po_ut_sr_če_pe_su'.split('_'),
            weekdaysParseExact: true,
            longDateFormat: {
                LT: 'H:mm',
                LTS: 'H:mm:ss',
                L: 'DD.MM.YYYY',
                LL: 'Do MMMM YYYY',
                LLL: 'Do MMMM YYYY H:mm',
                LLLL: 'dddd, Do MMMM YYYY H:mm',
            },
            calendar: {
                sameDay: '[danas u] LT',
                nextDay: '[sutra u] LT',
                nextWeek: function () {
                    switch (this.day()) {
                        case 0:
                            return '[u] [nedjelju] [u] LT';
                        case 3:
                            return '[u] [srijedu] [u] LT';
                        case 6:
                            return '[u] [subotu] [u] LT';
                        case 1:
                        case 2:
                        case 4:
                        case 5:
                            return '[u] dddd [u] LT';
                    }
                },
                lastDay: '[jučer u] LT',
                lastWeek: function () {
                    switch (this.day()) {
                        case 0:
                            return '[prošlu] [nedjelju] [u] LT';
                        case 3:
                            return '[prošlu] [srijedu] [u] LT';
                        case 6:
                            return '[prošle] [subote] [u] LT';
                        case 1:
                        case 2:
                        case 4:
                        case 5:
                            return '[prošli] dddd [u] LT';
                    }
                },
                sameElse: 'L',
            },
            relativeTime: {
                future: 'za %s',
                past: 'prije %s',
                s: 'par sekundi',
                ss: translate$3,
                m: translate$3,
                mm: translate$3,
                h: translate$3,
                hh: translate$3,
                d: 'dan',
                dd: translate$3,
                M: 'mjesec',
                MM: translate$3,
                y: 'godinu',
                yy: translate$3,
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: '%d.',
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 7, // The week that contains Jan 7th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        var weekEndings = 'vasárnap hétfőn kedden szerdán csütörtökön pénteken szombaton'.split(
            ' '
        );
        function translate$4(number, withoutSuffix, key, isFuture) {
            var num = number;
            switch (key) {
                case 's':
                    return isFuture || withoutSuffix
                        ? 'néhány másodperc'
                        : 'néhány másodperce';
                case 'ss':
                    return num + (isFuture || withoutSuffix)
                        ? ' másodperc'
                        : ' másodperce';
                case 'm':
                    return 'egy' + (isFuture || withoutSuffix ? ' perc' : ' perce');
                case 'mm':
                    return num + (isFuture || withoutSuffix ? ' perc' : ' perce');
                case 'h':
                    return 'egy' + (isFuture || withoutSuffix ? ' óra' : ' órája');
                case 'hh':
                    return num + (isFuture || withoutSuffix ? ' óra' : ' órája');
                case 'd':
                    return 'egy' + (isFuture || withoutSuffix ? ' nap' : ' napja');
                case 'dd':
                    return num + (isFuture || withoutSuffix ? ' nap' : ' napja');
                case 'M':
                    return 'egy' + (isFuture || withoutSuffix ? ' hónap' : ' hónapja');
                case 'MM':
                    return num + (isFuture || withoutSuffix ? ' hónap' : ' hónapja');
                case 'y':
                    return 'egy' + (isFuture || withoutSuffix ? ' év' : ' éve');
                case 'yy':
                    return num + (isFuture || withoutSuffix ? ' év' : ' éve');
            }
            return '';
        }
        function week(isFuture) {
            return (
                (isFuture ? '' : '[múlt] ') +
                '[' +
                weekEndings[this.day()] +
                '] LT[-kor]'
            );
        }

        hooks.defineLocale('hu', {
            months: 'január_február_március_április_május_június_július_augusztus_szeptember_október_november_december'.split(
                '_'
            ),
            monthsShort: 'jan._feb._márc._ápr._máj._jún._júl._aug._szept._okt._nov._dec.'.split(
                '_'
            ),
            monthsParseExact: true,
            weekdays: 'vasárnap_hétfő_kedd_szerda_csütörtök_péntek_szombat'.split('_'),
            weekdaysShort: 'vas_hét_kedd_sze_csüt_pén_szo'.split('_'),
            weekdaysMin: 'v_h_k_sze_cs_p_szo'.split('_'),
            longDateFormat: {
                LT: 'H:mm',
                LTS: 'H:mm:ss',
                L: 'YYYY.MM.DD.',
                LL: 'YYYY. MMMM D.',
                LLL: 'YYYY. MMMM D. H:mm',
                LLLL: 'YYYY. MMMM D., dddd H:mm',
            },
            meridiemParse: /de|du/i,
            isPM: function (input) {
                return input.charAt(1).toLowerCase() === 'u';
            },
            meridiem: function (hours, minutes, isLower) {
                if (hours < 12) {
                    return isLower === true ? 'de' : 'DE';
                } else {
                    return isLower === true ? 'du' : 'DU';
                }
            },
            calendar: {
                sameDay: '[ma] LT[-kor]',
                nextDay: '[holnap] LT[-kor]',
                nextWeek: function () {
                    return week.call(this, true);
                },
                lastDay: '[tegnap] LT[-kor]',
                lastWeek: function () {
                    return week.call(this, false);
                },
                sameElse: 'L',
            },
            relativeTime: {
                future: '%s múlva',
                past: '%s',
                s: translate$4,
                ss: translate$4,
                m: translate$4,
                mm: translate$4,
                h: translate$4,
                hh: translate$4,
                d: translate$4,
                dd: translate$4,
                M: translate$4,
                MM: translate$4,
                y: translate$4,
                yy: translate$4,
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: '%d.',
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 4, // The week that contains Jan 4th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        hooks.defineLocale('hy-am', {
            months: {
                format: 'հունվարի_փետրվարի_մարտի_ապրիլի_մայիսի_հունիսի_հուլիսի_օգոստոսի_սեպտեմբերի_հոկտեմբերի_նոյեմբերի_դեկտեմբերի'.split(
                    '_'
                ),
                standalone: 'հունվար_փետրվար_մարտ_ապրիլ_մայիս_հունիս_հուլիս_օգոստոս_սեպտեմբեր_հոկտեմբեր_նոյեմբեր_դեկտեմբեր'.split(
                    '_'
                ),
            },
            monthsShort: 'հնվ_փտր_մրտ_ապր_մյս_հնս_հլս_օգս_սպտ_հկտ_նմբ_դկտ'.split('_'),
            weekdays: 'կիրակի_երկուշաբթի_երեքշաբթի_չորեքշաբթի_հինգշաբթի_ուրբաթ_շաբաթ'.split(
                '_'
            ),
            weekdaysShort: 'կրկ_երկ_երք_չրք_հնգ_ուրբ_շբթ'.split('_'),
            weekdaysMin: 'կրկ_երկ_երք_չրք_հնգ_ուրբ_շբթ'.split('_'),
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'DD.MM.YYYY',
                LL: 'D MMMM YYYY թ.',
                LLL: 'D MMMM YYYY թ., HH:mm',
                LLLL: 'dddd, D MMMM YYYY թ., HH:mm',
            },
            calendar: {
                sameDay: '[այսօր] LT',
                nextDay: '[վաղը] LT',
                lastDay: '[երեկ] LT',
                nextWeek: function () {
                    return 'dddd [օրը ժամը] LT';
                },
                lastWeek: function () {
                    return '[անցած] dddd [օրը ժամը] LT';
                },
                sameElse: 'L',
            },
            relativeTime: {
                future: '%s հետո',
                past: '%s առաջ',
                s: 'մի քանի վայրկյան',
                ss: '%d վայրկյան',
                m: 'րոպե',
                mm: '%d րոպե',
                h: 'ժամ',
                hh: '%d ժամ',
                d: 'օր',
                dd: '%d օր',
                M: 'ամիս',
                MM: '%d ամիս',
                y: 'տարի',
                yy: '%d տարի',
            },
            meridiemParse: /գիշերվա|առավոտվա|ցերեկվա|երեկոյան/,
            isPM: function (input) {
                return /^(ցերեկվա|երեկոյան)$/.test(input);
            },
            meridiem: function (hour) {
                if (hour < 4) {
                    return 'գիշերվա';
                } else if (hour < 12) {
                    return 'առավոտվա';
                } else if (hour < 17) {
                    return 'ցերեկվա';
                } else {
                    return 'երեկոյան';
                }
            },
            dayOfMonthOrdinalParse: /\d{1,2}|\d{1,2}-(ին|րդ)/,
            ordinal: function (number, period) {
                switch (period) {
                    case 'DDD':
                    case 'w':
                    case 'W':
                    case 'DDDo':
                        if (number === 1) {
                            return number + '-ին';
                        }
                        return number + '-րդ';
                    default:
                        return number;
                }
            },
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 7, // The week that contains Jan 7th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        hooks.defineLocale('id', {
            months: 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_November_Desember'.split(
                '_'
            ),
            monthsShort: 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Agt_Sep_Okt_Nov_Des'.split('_'),
            weekdays: 'Minggu_Senin_Selasa_Rabu_Kamis_Jumat_Sabtu'.split('_'),
            weekdaysShort: 'Min_Sen_Sel_Rab_Kam_Jum_Sab'.split('_'),
            weekdaysMin: 'Mg_Sn_Sl_Rb_Km_Jm_Sb'.split('_'),
            longDateFormat: {
                LT: 'HH.mm',
                LTS: 'HH.mm.ss',
                L: 'DD/MM/YYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY [pukul] HH.mm',
                LLLL: 'dddd, D MMMM YYYY [pukul] HH.mm',
            },
            meridiemParse: /pagi|siang|sore|malam/,
            meridiemHour: function (hour, meridiem) {
                if (hour === 12) {
                    hour = 0;
                }
                if (meridiem === 'pagi') {
                    return hour;
                } else if (meridiem === 'siang') {
                    return hour >= 11 ? hour : hour + 12;
                } else if (meridiem === 'sore' || meridiem === 'malam') {
                    return hour + 12;
                }
            },
            meridiem: function (hours, minutes, isLower) {
                if (hours < 11) {
                    return 'pagi';
                } else if (hours < 15) {
                    return 'siang';
                } else if (hours < 19) {
                    return 'sore';
                } else {
                    return 'malam';
                }
            },
            calendar: {
                sameDay: '[Hari ini pukul] LT',
                nextDay: '[Besok pukul] LT',
                nextWeek: 'dddd [pukul] LT',
                lastDay: '[Kemarin pukul] LT',
                lastWeek: 'dddd [lalu pukul] LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: 'dalam %s',
                past: '%s yang lalu',
                s: 'beberapa detik',
                ss: '%d detik',
                m: 'semenit',
                mm: '%d menit',
                h: 'sejam',
                hh: '%d jam',
                d: 'sehari',
                dd: '%d hari',
                M: 'sebulan',
                MM: '%d bulan',
                y: 'setahun',
                yy: '%d tahun',
            },
            week: {
                dow: 0, // Sunday is the first day of the week.
                doy: 6, // The week that contains Jan 6th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        function plural$2(n) {
            if (n % 100 === 11) {
                return true;
            } else if (n % 10 === 1) {
                return false;
            }
            return true;
        }
        function translate$5(number, withoutSuffix, key, isFuture) {
            var result = number + ' ';
            switch (key) {
                case 's':
                    return withoutSuffix || isFuture
                        ? 'nokkrar sekúndur'
                        : 'nokkrum sekúndum';
                case 'ss':
                    if (plural$2(number)) {
                        return (
                            result +
                            (withoutSuffix || isFuture ? 'sekúndur' : 'sekúndum')
                        );
                    }
                    return result + 'sekúnda';
                case 'm':
                    return withoutSuffix ? 'mínúta' : 'mínútu';
                case 'mm':
                    if (plural$2(number)) {
                        return (
                            result + (withoutSuffix || isFuture ? 'mínútur' : 'mínútum')
                        );
                    } else if (withoutSuffix) {
                        return result + 'mínúta';
                    }
                    return result + 'mínútu';
                case 'hh':
                    if (plural$2(number)) {
                        return (
                            result +
                            (withoutSuffix || isFuture
                                ? 'klukkustundir'
                                : 'klukkustundum')
                        );
                    }
                    return result + 'klukkustund';
                case 'd':
                    if (withoutSuffix) {
                        return 'dagur';
                    }
                    return isFuture ? 'dag' : 'degi';
                case 'dd':
                    if (plural$2(number)) {
                        if (withoutSuffix) {
                            return result + 'dagar';
                        }
                        return result + (isFuture ? 'daga' : 'dögum');
                    } else if (withoutSuffix) {
                        return result + 'dagur';
                    }
                    return result + (isFuture ? 'dag' : 'degi');
                case 'M':
                    if (withoutSuffix) {
                        return 'mánuður';
                    }
                    return isFuture ? 'mánuð' : 'mánuði';
                case 'MM':
                    if (plural$2(number)) {
                        if (withoutSuffix) {
                            return result + 'mánuðir';
                        }
                        return result + (isFuture ? 'mánuði' : 'mánuðum');
                    } else if (withoutSuffix) {
                        return result + 'mánuður';
                    }
                    return result + (isFuture ? 'mánuð' : 'mánuði');
                case 'y':
                    return withoutSuffix || isFuture ? 'ár' : 'ári';
                case 'yy':
                    if (plural$2(number)) {
                        return result + (withoutSuffix || isFuture ? 'ár' : 'árum');
                    }
                    return result + (withoutSuffix || isFuture ? 'ár' : 'ári');
            }
        }

        hooks.defineLocale('is', {
            months: 'janúar_febrúar_mars_apríl_maí_júní_júlí_ágúst_september_október_nóvember_desember'.split(
                '_'
            ),
            monthsShort: 'jan_feb_mar_apr_maí_jún_júl_ágú_sep_okt_nóv_des'.split('_'),
            weekdays: 'sunnudagur_mánudagur_þriðjudagur_miðvikudagur_fimmtudagur_föstudagur_laugardagur'.split(
                '_'
            ),
            weekdaysShort: 'sun_mán_þri_mið_fim_fös_lau'.split('_'),
            weekdaysMin: 'Su_Má_Þr_Mi_Fi_Fö_La'.split('_'),
            longDateFormat: {
                LT: 'H:mm',
                LTS: 'H:mm:ss',
                L: 'DD.MM.YYYY',
                LL: 'D. MMMM YYYY',
                LLL: 'D. MMMM YYYY [kl.] H:mm',
                LLLL: 'dddd, D. MMMM YYYY [kl.] H:mm',
            },
            calendar: {
                sameDay: '[í dag kl.] LT',
                nextDay: '[á morgun kl.] LT',
                nextWeek: 'dddd [kl.] LT',
                lastDay: '[í gær kl.] LT',
                lastWeek: '[síðasta] dddd [kl.] LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: 'eftir %s',
                past: 'fyrir %s síðan',
                s: translate$5,
                ss: translate$5,
                m: translate$5,
                mm: translate$5,
                h: 'klukkustund',
                hh: translate$5,
                d: translate$5,
                dd: translate$5,
                M: translate$5,
                MM: translate$5,
                y: translate$5,
                yy: translate$5,
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: '%d.',
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 4, // The week that contains Jan 4th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        hooks.defineLocale('it-ch', {
            months: 'gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre'.split(
                '_'
            ),
            monthsShort: 'gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic'.split('_'),
            weekdays: 'domenica_lunedì_martedì_mercoledì_giovedì_venerdì_sabato'.split(
                '_'
            ),
            weekdaysShort: 'dom_lun_mar_mer_gio_ven_sab'.split('_'),
            weekdaysMin: 'do_lu_ma_me_gi_ve_sa'.split('_'),
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'DD.MM.YYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY HH:mm',
                LLLL: 'dddd D MMMM YYYY HH:mm',
            },
            calendar: {
                sameDay: '[Oggi alle] LT',
                nextDay: '[Domani alle] LT',
                nextWeek: 'dddd [alle] LT',
                lastDay: '[Ieri alle] LT',
                lastWeek: function () {
                    switch (this.day()) {
                        case 0:
                            return '[la scorsa] dddd [alle] LT';
                        default:
                            return '[lo scorso] dddd [alle] LT';
                    }
                },
                sameElse: 'L',
            },
            relativeTime: {
                future: function (s) {
                    return (/^[0-9].+$/.test(s) ? 'tra' : 'in') + ' ' + s;
                },
                past: '%s fa',
                s: 'alcuni secondi',
                ss: '%d secondi',
                m: 'un minuto',
                mm: '%d minuti',
                h: "un'ora",
                hh: '%d ore',
                d: 'un giorno',
                dd: '%d giorni',
                M: 'un mese',
                MM: '%d mesi',
                y: 'un anno',
                yy: '%d anni',
            },
            dayOfMonthOrdinalParse: /\d{1,2}º/,
            ordinal: '%dº',
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 4, // The week that contains Jan 4th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        hooks.defineLocale('it', {
            months: 'gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre'.split(
                '_'
            ),
            monthsShort: 'gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic'.split('_'),
            weekdays: 'domenica_lunedì_martedì_mercoledì_giovedì_venerdì_sabato'.split(
                '_'
            ),
            weekdaysShort: 'dom_lun_mar_mer_gio_ven_sab'.split('_'),
            weekdaysMin: 'do_lu_ma_me_gi_ve_sa'.split('_'),
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'DD/MM/YYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY HH:mm',
                LLLL: 'dddd D MMMM YYYY HH:mm',
            },
            calendar: {
                sameDay: function () {
                    return (
                        '[Oggi a' +
                        (this.hours() > 1 ? 'lle ' : this.hours() === 0 ? ' ' : "ll'") +
                        ']LT'
                    );
                },
                nextDay: function () {
                    return (
                        '[Domani a' +
                        (this.hours() > 1 ? 'lle ' : this.hours() === 0 ? ' ' : "ll'") +
                        ']LT'
                    );
                },
                nextWeek: function () {
                    return (
                        'dddd [a' +
                        (this.hours() > 1 ? 'lle ' : this.hours() === 0 ? ' ' : "ll'") +
                        ']LT'
                    );
                },
                lastDay: function () {
                    return (
                        '[Ieri a' +
                        (this.hours() > 1 ? 'lle ' : this.hours() === 0 ? ' ' : "ll'") +
                        ']LT'
                    );
                },
                lastWeek: function () {
                    switch (this.day()) {
                        case 0:
                            return (
                                '[La scorsa] dddd [a' +
                                (this.hours() > 1
                                    ? 'lle '
                                    : this.hours() === 0
                                    ? ' '
                                    : "ll'") +
                                ']LT'
                            );
                        default:
                            return (
                                '[Lo scorso] dddd [a' +
                                (this.hours() > 1
                                    ? 'lle '
                                    : this.hours() === 0
                                    ? ' '
                                    : "ll'") +
                                ']LT'
                            );
                    }
                },
                sameElse: 'L',
            },
            relativeTime: {
                future: 'tra %s',
                past: '%s fa',
                s: 'alcuni secondi',
                ss: '%d secondi',
                m: 'un minuto',
                mm: '%d minuti',
                h: "un'ora",
                hh: '%d ore',
                d: 'un giorno',
                dd: '%d giorni',
                w: 'una settimana',
                ww: '%d settimane',
                M: 'un mese',
                MM: '%d mesi',
                y: 'un anno',
                yy: '%d anni',
            },
            dayOfMonthOrdinalParse: /\d{1,2}º/,
            ordinal: '%dº',
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 4, // The week that contains Jan 4th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        hooks.defineLocale('ja', {
            eras: [
                {
                    since: '2019-05-01',
                    offset: 1,
                    name: '令和',
                    narrow: '㋿',
                    abbr: 'R',
                },
                {
                    since: '1989-01-08',
                    until: '2019-04-30',
                    offset: 1,
                    name: '平成',
                    narrow: '㍻',
                    abbr: 'H',
                },
                {
                    since: '1926-12-25',
                    until: '1989-01-07',
                    offset: 1,
                    name: '昭和',
                    narrow: '㍼',
                    abbr: 'S',
                },
                {
                    since: '1912-07-30',
                    until: '1926-12-24',
                    offset: 1,
                    name: '大正',
                    narrow: '㍽',
                    abbr: 'T',
                },
                {
                    since: '1873-01-01',
                    until: '1912-07-29',
                    offset: 6,
                    name: '明治',
                    narrow: '㍾',
                    abbr: 'M',
                },
                {
                    since: '0001-01-01',
                    until: '1873-12-31',
                    offset: 1,
                    name: '西暦',
                    narrow: 'AD',
                    abbr: 'AD',
                },
                {
                    since: '0000-12-31',
                    until: -Infinity,
                    offset: 1,
                    name: '紀元前',
                    narrow: 'BC',
                    abbr: 'BC',
                },
            ],
            eraYearOrdinalRegex: /(元|\d+)年/,
            eraYearOrdinalParse: function (input, match) {
                return match[1] === '元' ? 1 : parseInt(match[1] || input, 10);
            },
            months: '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
            monthsShort: '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split(
                '_'
            ),
            weekdays: '日曜日_月曜日_火曜日_水曜日_木曜日_金曜日_土曜日'.split('_'),
            weekdaysShort: '日_月_火_水_木_金_土'.split('_'),
            weekdaysMin: '日_月_火_水_木_金_土'.split('_'),
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'YYYY/MM/DD',
                LL: 'YYYY年M月D日',
                LLL: 'YYYY年M月D日 HH:mm',
                LLLL: 'YYYY年M月D日 dddd HH:mm',
                l: 'YYYY/MM/DD',
                ll: 'YYYY年M月D日',
                lll: 'YYYY年M月D日 HH:mm',
                llll: 'YYYY年M月D日(ddd) HH:mm',
            },
            meridiemParse: /午前|午後/i,
            isPM: function (input) {
                return input === '午後';
            },
            meridiem: function (hour, minute, isLower) {
                if (hour < 12) {
                    return '午前';
                } else {
                    return '午後';
                }
            },
            calendar: {
                sameDay: '[今日] LT',
                nextDay: '[明日] LT',
                nextWeek: function (now) {
                    if (now.week() !== this.week()) {
                        return '[来週]dddd LT';
                    } else {
                        return 'dddd LT';
                    }
                },
                lastDay: '[昨日] LT',
                lastWeek: function (now) {
                    if (this.week() !== now.week()) {
                        return '[先週]dddd LT';
                    } else {
                        return 'dddd LT';
                    }
                },
                sameElse: 'L',
            },
            dayOfMonthOrdinalParse: /\d{1,2}日/,
            ordinal: function (number, period) {
                switch (period) {
                    case 'y':
                        return number === 1 ? '元年' : number + '年';
                    case 'd':
                    case 'D':
                    case 'DDD':
                        return number + '日';
                    default:
                        return number;
                }
            },
            relativeTime: {
                future: '%s後',
                past: '%s前',
                s: '数秒',
                ss: '%d秒',
                m: '1分',
                mm: '%d分',
                h: '1時間',
                hh: '%d時間',
                d: '1日',
                dd: '%d日',
                M: '1ヶ月',
                MM: '%dヶ月',
                y: '1年',
                yy: '%d年',
            },
        });

        //! moment.js locale configuration

        hooks.defineLocale('jv', {
            months: 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_Nopember_Desember'.split(
                '_'
            ),
            monthsShort: 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nop_Des'.split('_'),
            weekdays: 'Minggu_Senen_Seloso_Rebu_Kemis_Jemuwah_Septu'.split('_'),
            weekdaysShort: 'Min_Sen_Sel_Reb_Kem_Jem_Sep'.split('_'),
            weekdaysMin: 'Mg_Sn_Sl_Rb_Km_Jm_Sp'.split('_'),
            longDateFormat: {
                LT: 'HH.mm',
                LTS: 'HH.mm.ss',
                L: 'DD/MM/YYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY [pukul] HH.mm',
                LLLL: 'dddd, D MMMM YYYY [pukul] HH.mm',
            },
            meridiemParse: /enjing|siyang|sonten|ndalu/,
            meridiemHour: function (hour, meridiem) {
                if (hour === 12) {
                    hour = 0;
                }
                if (meridiem === 'enjing') {
                    return hour;
                } else if (meridiem === 'siyang') {
                    return hour >= 11 ? hour : hour + 12;
                } else if (meridiem === 'sonten' || meridiem === 'ndalu') {
                    return hour + 12;
                }
            },
            meridiem: function (hours, minutes, isLower) {
                if (hours < 11) {
                    return 'enjing';
                } else if (hours < 15) {
                    return 'siyang';
                } else if (hours < 19) {
                    return 'sonten';
                } else {
                    return 'ndalu';
                }
            },
            calendar: {
                sameDay: '[Dinten puniko pukul] LT',
                nextDay: '[Mbenjang pukul] LT',
                nextWeek: 'dddd [pukul] LT',
                lastDay: '[Kala wingi pukul] LT',
                lastWeek: 'dddd [kepengker pukul] LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: 'wonten ing %s',
                past: '%s ingkang kepengker',
                s: 'sawetawis detik',
                ss: '%d detik',
                m: 'setunggal menit',
                mm: '%d menit',
                h: 'setunggal jam',
                hh: '%d jam',
                d: 'sedinten',
                dd: '%d dinten',
                M: 'sewulan',
                MM: '%d wulan',
                y: 'setaun',
                yy: '%d taun',
            },
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 7, // The week that contains Jan 7th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        hooks.defineLocale('ka', {
            months: 'იანვარი_თებერვალი_მარტი_აპრილი_მაისი_ივნისი_ივლისი_აგვისტო_სექტემბერი_ოქტომბერი_ნოემბერი_დეკემბერი'.split(
                '_'
            ),
            monthsShort: 'იან_თებ_მარ_აპრ_მაი_ივნ_ივლ_აგვ_სექ_ოქტ_ნოე_დეკ'.split('_'),
            weekdays: {
                standalone: 'კვირა_ორშაბათი_სამშაბათი_ოთხშაბათი_ხუთშაბათი_პარასკევი_შაბათი'.split(
                    '_'
                ),
                format: 'კვირას_ორშაბათს_სამშაბათს_ოთხშაბათს_ხუთშაბათს_პარასკევს_შაბათს'.split(
                    '_'
                ),
                isFormat: /(წინა|შემდეგ)/,
            },
            weekdaysShort: 'კვი_ორშ_სამ_ოთხ_ხუთ_პარ_შაბ'.split('_'),
            weekdaysMin: 'კვ_ორ_სა_ოთ_ხუ_პა_შა'.split('_'),
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'DD/MM/YYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY HH:mm',
                LLLL: 'dddd, D MMMM YYYY HH:mm',
            },
            calendar: {
                sameDay: '[დღეს] LT[-ზე]',
                nextDay: '[ხვალ] LT[-ზე]',
                lastDay: '[გუშინ] LT[-ზე]',
                nextWeek: '[შემდეგ] dddd LT[-ზე]',
                lastWeek: '[წინა] dddd LT-ზე',
                sameElse: 'L',
            },
            relativeTime: {
                future: function (s) {
                    return s.replace(/(წამ|წუთ|საათ|წელ|დღ|თვ)(ი|ე)/, function (
                        $0,
                        $1,
                        $2
                    ) {
                        return $2 === 'ი' ? $1 + 'ში' : $1 + $2 + 'ში';
                    });
                },
                past: function (s) {
                    if (/(წამი|წუთი|საათი|დღე|თვე)/.test(s)) {
                        return s.replace(/(ი|ე)$/, 'ის წინ');
                    }
                    if (/წელი/.test(s)) {
                        return s.replace(/წელი$/, 'წლის წინ');
                    }
                    return s;
                },
                s: 'რამდენიმე წამი',
                ss: '%d წამი',
                m: 'წუთი',
                mm: '%d წუთი',
                h: 'საათი',
                hh: '%d საათი',
                d: 'დღე',
                dd: '%d დღე',
                M: 'თვე',
                MM: '%d თვე',
                y: 'წელი',
                yy: '%d წელი',
            },
            dayOfMonthOrdinalParse: /0|1-ლი|მე-\d{1,2}|\d{1,2}-ე/,
            ordinal: function (number) {
                if (number === 0) {
                    return number;
                }
                if (number === 1) {
                    return number + '-ლი';
                }
                if (
                    number < 20 ||
                    (number <= 100 && number % 20 === 0) ||
                    number % 100 === 0
                ) {
                    return 'მე-' + number;
                }
                return number + '-ე';
            },
            week: {
                dow: 1,
                doy: 7,
            },
        });

        //! moment.js locale configuration

        var suffixes$1 = {
            0: '-ші',
            1: '-ші',
            2: '-ші',
            3: '-ші',
            4: '-ші',
            5: '-ші',
            6: '-шы',
            7: '-ші',
            8: '-ші',
            9: '-шы',
            10: '-шы',
            20: '-шы',
            30: '-шы',
            40: '-шы',
            50: '-ші',
            60: '-шы',
            70: '-ші',
            80: '-ші',
            90: '-шы',
            100: '-ші',
        };

        hooks.defineLocale('kk', {
            months: 'қаңтар_ақпан_наурыз_сәуір_мамыр_маусым_шілде_тамыз_қыркүйек_қазан_қараша_желтоқсан'.split(
                '_'
            ),
            monthsShort: 'қаң_ақп_нау_сәу_мам_мау_шіл_там_қыр_қаз_қар_жел'.split('_'),
            weekdays: 'жексенбі_дүйсенбі_сейсенбі_сәрсенбі_бейсенбі_жұма_сенбі'.split(
                '_'
            ),
            weekdaysShort: 'жек_дүй_сей_сәр_бей_жұм_сен'.split('_'),
            weekdaysMin: 'жк_дй_сй_ср_бй_жм_сн'.split('_'),
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'DD.MM.YYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY HH:mm',
                LLLL: 'dddd, D MMMM YYYY HH:mm',
            },
            calendar: {
                sameDay: '[Бүгін сағат] LT',
                nextDay: '[Ертең сағат] LT',
                nextWeek: 'dddd [сағат] LT',
                lastDay: '[Кеше сағат] LT',
                lastWeek: '[Өткен аптаның] dddd [сағат] LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: '%s ішінде',
                past: '%s бұрын',
                s: 'бірнеше секунд',
                ss: '%d секунд',
                m: 'бір минут',
                mm: '%d минут',
                h: 'бір сағат',
                hh: '%d сағат',
                d: 'бір күн',
                dd: '%d күн',
                M: 'бір ай',
                MM: '%d ай',
                y: 'бір жыл',
                yy: '%d жыл',
            },
            dayOfMonthOrdinalParse: /\d{1,2}-(ші|шы)/,
            ordinal: function (number) {
                var a = number % 10,
                    b = number >= 100 ? 100 : null;
                return number + (suffixes$1[number] || suffixes$1[a] || suffixes$1[b]);
            },
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 7, // The week that contains Jan 7th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        var symbolMap$9 = {
                1: '១',
                2: '២',
                3: '៣',
                4: '៤',
                5: '៥',
                6: '៦',
                7: '៧',
                8: '៨',
                9: '៩',
                0: '០',
            },
            numberMap$8 = {
                '១': '1',
                '២': '2',
                '៣': '3',
                '៤': '4',
                '៥': '5',
                '៦': '6',
                '៧': '7',
                '៨': '8',
                '៩': '9',
                '០': '0',
            };

        hooks.defineLocale('km', {
            months: 'មករា_កុម្ភៈ_មីនា_មេសា_ឧសភា_មិថុនា_កក្កដា_សីហា_កញ្ញា_តុលា_វិច្ឆិកា_ធ្នូ'.split(
                '_'
            ),
            monthsShort: 'មករា_កុម្ភៈ_មីនា_មេសា_ឧសភា_មិថុនា_កក្កដា_សីហា_កញ្ញា_តុលា_វិច្ឆិកា_ធ្នូ'.split(
                '_'
            ),
            weekdays: 'អាទិត្យ_ច័ន្ទ_អង្គារ_ពុធ_ព្រហស្បតិ៍_សុក្រ_សៅរ៍'.split('_'),
            weekdaysShort: 'អា_ច_អ_ព_ព្រ_សុ_ស'.split('_'),
            weekdaysMin: 'អា_ច_អ_ព_ព្រ_សុ_ស'.split('_'),
            weekdaysParseExact: true,
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'DD/MM/YYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY HH:mm',
                LLLL: 'dddd, D MMMM YYYY HH:mm',
            },
            meridiemParse: /ព្រឹក|ល្ងាច/,
            isPM: function (input) {
                return input === 'ល្ងាច';
            },
            meridiem: function (hour, minute, isLower) {
                if (hour < 12) {
                    return 'ព្រឹក';
                } else {
                    return 'ល្ងាច';
                }
            },
            calendar: {
                sameDay: '[ថ្ងៃនេះ ម៉ោង] LT',
                nextDay: '[ស្អែក ម៉ោង] LT',
                nextWeek: 'dddd [ម៉ោង] LT',
                lastDay: '[ម្សិលមិញ ម៉ោង] LT',
                lastWeek: 'dddd [សប្តាហ៍មុន] [ម៉ោង] LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: '%sទៀត',
                past: '%sមុន',
                s: 'ប៉ុន្មានវិនាទី',
                ss: '%d វិនាទី',
                m: 'មួយនាទី',
                mm: '%d នាទី',
                h: 'មួយម៉ោង',
                hh: '%d ម៉ោង',
                d: 'មួយថ្ងៃ',
                dd: '%d ថ្ងៃ',
                M: 'មួយខែ',
                MM: '%d ខែ',
                y: 'មួយឆ្នាំ',
                yy: '%d ឆ្នាំ',
            },
            dayOfMonthOrdinalParse: /ទី\d{1,2}/,
            ordinal: 'ទី%d',
            preparse: function (string) {
                return string.replace(/[១២៣៤៥៦៧៨៩០]/g, function (match) {
                    return numberMap$8[match];
                });
            },
            postformat: function (string) {
                return string.replace(/\d/g, function (match) {
                    return symbolMap$9[match];
                });
            },
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 4, // The week that contains Jan 4th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        var symbolMap$a = {
                1: '೧',
                2: '೨',
                3: '೩',
                4: '೪',
                5: '೫',
                6: '೬',
                7: '೭',
                8: '೮',
                9: '೯',
                0: '೦',
            },
            numberMap$9 = {
                '೧': '1',
                '೨': '2',
                '೩': '3',
                '೪': '4',
                '೫': '5',
                '೬': '6',
                '೭': '7',
                '೮': '8',
                '೯': '9',
                '೦': '0',
            };

        hooks.defineLocale('kn', {
            months: 'ಜನವರಿ_ಫೆಬ್ರವರಿ_ಮಾರ್ಚ್_ಏಪ್ರಿಲ್_ಮೇ_ಜೂನ್_ಜುಲೈ_ಆಗಸ್ಟ್_ಸೆಪ್ಟೆಂಬರ್_ಅಕ್ಟೋಬರ್_ನವೆಂಬರ್_ಡಿಸೆಂಬರ್'.split(
                '_'
            ),
            monthsShort: 'ಜನ_ಫೆಬ್ರ_ಮಾರ್ಚ್_ಏಪ್ರಿಲ್_ಮೇ_ಜೂನ್_ಜುಲೈ_ಆಗಸ್ಟ್_ಸೆಪ್ಟೆಂ_ಅಕ್ಟೋ_ನವೆಂ_ಡಿಸೆಂ'.split(
                '_'
            ),
            monthsParseExact: true,
            weekdays: 'ಭಾನುವಾರ_ಸೋಮವಾರ_ಮಂಗಳವಾರ_ಬುಧವಾರ_ಗುರುವಾರ_ಶುಕ್ರವಾರ_ಶನಿವಾರ'.split(
                '_'
            ),
            weekdaysShort: 'ಭಾನು_ಸೋಮ_ಮಂಗಳ_ಬುಧ_ಗುರು_ಶುಕ್ರ_ಶನಿ'.split('_'),
            weekdaysMin: 'ಭಾ_ಸೋ_ಮಂ_ಬು_ಗು_ಶು_ಶ'.split('_'),
            longDateFormat: {
                LT: 'A h:mm',
                LTS: 'A h:mm:ss',
                L: 'DD/MM/YYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY, A h:mm',
                LLLL: 'dddd, D MMMM YYYY, A h:mm',
            },
            calendar: {
                sameDay: '[ಇಂದು] LT',
                nextDay: '[ನಾಳೆ] LT',
                nextWeek: 'dddd, LT',
                lastDay: '[ನಿನ್ನೆ] LT',
                lastWeek: '[ಕೊನೆಯ] dddd, LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: '%s ನಂತರ',
                past: '%s ಹಿಂದೆ',
                s: 'ಕೆಲವು ಕ್ಷಣಗಳು',
                ss: '%d ಸೆಕೆಂಡುಗಳು',
                m: 'ಒಂದು ನಿಮಿಷ',
                mm: '%d ನಿಮಿಷ',
                h: 'ಒಂದು ಗಂಟೆ',
                hh: '%d ಗಂಟೆ',
                d: 'ಒಂದು ದಿನ',
                dd: '%d ದಿನ',
                M: 'ಒಂದು ತಿಂಗಳು',
                MM: '%d ತಿಂಗಳು',
                y: 'ಒಂದು ವರ್ಷ',
                yy: '%d ವರ್ಷ',
            },
            preparse: function (string) {
                return string.replace(/[೧೨೩೪೫೬೭೮೯೦]/g, function (match) {
                    return numberMap$9[match];
                });
            },
            postformat: function (string) {
                return string.replace(/\d/g, function (match) {
                    return symbolMap$a[match];
                });
            },
            meridiemParse: /ರಾತ್ರಿ|ಬೆಳಿಗ್ಗೆ|ಮಧ್ಯಾಹ್ನ|ಸಂಜೆ/,
            meridiemHour: function (hour, meridiem) {
                if (hour === 12) {
                    hour = 0;
                }
                if (meridiem === 'ರಾತ್ರಿ') {
                    return hour < 4 ? hour : hour + 12;
                } else if (meridiem === 'ಬೆಳಿಗ್ಗೆ') {
                    return hour;
                } else if (meridiem === 'ಮಧ್ಯಾಹ್ನ') {
                    return hour >= 10 ? hour : hour + 12;
                } else if (meridiem === 'ಸಂಜೆ') {
                    return hour + 12;
                }
            },
            meridiem: function (hour, minute, isLower) {
                if (hour < 4) {
                    return 'ರಾತ್ರಿ';
                } else if (hour < 10) {
                    return 'ಬೆಳಿಗ್ಗೆ';
                } else if (hour < 17) {
                    return 'ಮಧ್ಯಾಹ್ನ';
                } else if (hour < 20) {
                    return 'ಸಂಜೆ';
                } else {
                    return 'ರಾತ್ರಿ';
                }
            },
            dayOfMonthOrdinalParse: /\d{1,2}(ನೇ)/,
            ordinal: function (number) {
                return number + 'ನೇ';
            },
            week: {
                dow: 0, // Sunday is the first day of the week.
                doy: 6, // The week that contains Jan 6th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        hooks.defineLocale('ko', {
            months: '1월_2월_3월_4월_5월_6월_7월_8월_9월_10월_11월_12월'.split('_'),
            monthsShort: '1월_2월_3월_4월_5월_6월_7월_8월_9월_10월_11월_12월'.split(
                '_'
            ),
            weekdays: '일요일_월요일_화요일_수요일_목요일_금요일_토요일'.split('_'),
            weekdaysShort: '일_월_화_수_목_금_토'.split('_'),
            weekdaysMin: '일_월_화_수_목_금_토'.split('_'),
            longDateFormat: {
                LT: 'A h:mm',
                LTS: 'A h:mm:ss',
                L: 'YYYY.MM.DD.',
                LL: 'YYYY년 MMMM D일',
                LLL: 'YYYY년 MMMM D일 A h:mm',
                LLLL: 'YYYY년 MMMM D일 dddd A h:mm',
                l: 'YYYY.MM.DD.',
                ll: 'YYYY년 MMMM D일',
                lll: 'YYYY년 MMMM D일 A h:mm',
                llll: 'YYYY년 MMMM D일 dddd A h:mm',
            },
            calendar: {
                sameDay: '오늘 LT',
                nextDay: '내일 LT',
                nextWeek: 'dddd LT',
                lastDay: '어제 LT',
                lastWeek: '지난주 dddd LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: '%s 후',
                past: '%s 전',
                s: '몇 초',
                ss: '%d초',
                m: '1분',
                mm: '%d분',
                h: '한 시간',
                hh: '%d시간',
                d: '하루',
                dd: '%d일',
                M: '한 달',
                MM: '%d달',
                y: '일 년',
                yy: '%d년',
            },
            dayOfMonthOrdinalParse: /\d{1,2}(일|월|주)/,
            ordinal: function (number, period) {
                switch (period) {
                    case 'd':
                    case 'D':
                    case 'DDD':
                        return number + '일';
                    case 'M':
                        return number + '월';
                    case 'w':
                    case 'W':
                        return number + '주';
                    default:
                        return number;
                }
            },
            meridiemParse: /오전|오후/,
            isPM: function (token) {
                return token === '오후';
            },
            meridiem: function (hour, minute, isUpper) {
                return hour < 12 ? '오전' : '오후';
            },
        });

        //! moment.js locale configuration

        var symbolMap$b = {
                1: '١',
                2: '٢',
                3: '٣',
                4: '٤',
                5: '٥',
                6: '٦',
                7: '٧',
                8: '٨',
                9: '٩',
                0: '٠',
            },
            numberMap$a = {
                '١': '1',
                '٢': '2',
                '٣': '3',
                '٤': '4',
                '٥': '5',
                '٦': '6',
                '٧': '7',
                '٨': '8',
                '٩': '9',
                '٠': '0',
            },
            months$8 = [
                'کانونی دووەم',
                'شوبات',
                'ئازار',
                'نیسان',
                'ئایار',
                'حوزەیران',
                'تەمموز',
                'ئاب',
                'ئەیلوول',
                'تشرینی یەكەم',
                'تشرینی دووەم',
                'كانونی یەکەم',
            ];

        hooks.defineLocale('ku', {
            months: months$8,
            monthsShort: months$8,
            weekdays: 'یه‌كشه‌ممه‌_دووشه‌ممه‌_سێشه‌ممه‌_چوارشه‌ممه‌_پێنجشه‌ممه‌_هه‌ینی_شه‌ممه‌'.split(
                '_'
            ),
            weekdaysShort: 'یه‌كشه‌م_دووشه‌م_سێشه‌م_چوارشه‌م_پێنجشه‌م_هه‌ینی_شه‌ممه‌'.split(
                '_'
            ),
            weekdaysMin: 'ی_د_س_چ_پ_ه_ش'.split('_'),
            weekdaysParseExact: true,
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'DD/MM/YYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY HH:mm',
                LLLL: 'dddd, D MMMM YYYY HH:mm',
            },
            meridiemParse: /ئێواره‌|به‌یانی/,
            isPM: function (input) {
                return /ئێواره‌/.test(input);
            },
            meridiem: function (hour, minute, isLower) {
                if (hour < 12) {
                    return 'به‌یانی';
                } else {
                    return 'ئێواره‌';
                }
            },
            calendar: {
                sameDay: '[ئه‌مرۆ كاتژمێر] LT',
                nextDay: '[به‌یانی كاتژمێر] LT',
                nextWeek: 'dddd [كاتژمێر] LT',
                lastDay: '[دوێنێ كاتژمێر] LT',
                lastWeek: 'dddd [كاتژمێر] LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: 'له‌ %s',
                past: '%s',
                s: 'چه‌ند چركه‌یه‌ك',
                ss: 'چركه‌ %d',
                m: 'یه‌ك خوله‌ك',
                mm: '%d خوله‌ك',
                h: 'یه‌ك كاتژمێر',
                hh: '%d كاتژمێر',
                d: 'یه‌ك ڕۆژ',
                dd: '%d ڕۆژ',
                M: 'یه‌ك مانگ',
                MM: '%d مانگ',
                y: 'یه‌ك ساڵ',
                yy: '%d ساڵ',
            },
            preparse: function (string) {
                return string
                    .replace(/[١٢٣٤٥٦٧٨٩٠]/g, function (match) {
                        return numberMap$a[match];
                    })
                    .replace(/،/g, ',');
            },
            postformat: function (string) {
                return string
                    .replace(/\d/g, function (match) {
                        return symbolMap$b[match];
                    })
                    .replace(/,/g, '،');
            },
            week: {
                dow: 6, // Saturday is the first day of the week.
                doy: 12, // The week that contains Jan 12th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        var suffixes$2 = {
            0: '-чү',
            1: '-чи',
            2: '-чи',
            3: '-чү',
            4: '-чү',
            5: '-чи',
            6: '-чы',
            7: '-чи',
            8: '-чи',
            9: '-чу',
            10: '-чу',
            20: '-чы',
            30: '-чу',
            40: '-чы',
            50: '-чү',
            60: '-чы',
            70: '-чи',
            80: '-чи',
            90: '-чу',
            100: '-чү',
        };

        hooks.defineLocale('ky', {
            months: 'январь_февраль_март_апрель_май_июнь_июль_август_сентябрь_октябрь_ноябрь_декабрь'.split(
                '_'
            ),
            monthsShort: 'янв_фев_март_апр_май_июнь_июль_авг_сен_окт_ноя_дек'.split(
                '_'
            ),
            weekdays: 'Жекшемби_Дүйшөмбү_Шейшемби_Шаршемби_Бейшемби_Жума_Ишемби'.split(
                '_'
            ),
            weekdaysShort: 'Жек_Дүй_Шей_Шар_Бей_Жум_Ише'.split('_'),
            weekdaysMin: 'Жк_Дй_Шй_Шр_Бй_Жм_Иш'.split('_'),
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'DD.MM.YYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY HH:mm',
                LLLL: 'dddd, D MMMM YYYY HH:mm',
            },
            calendar: {
                sameDay: '[Бүгүн саат] LT',
                nextDay: '[Эртең саат] LT',
                nextWeek: 'dddd [саат] LT',
                lastDay: '[Кечээ саат] LT',
                lastWeek: '[Өткөн аптанын] dddd [күнү] [саат] LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: '%s ичинде',
                past: '%s мурун',
                s: 'бирнече секунд',
                ss: '%d секунд',
                m: 'бир мүнөт',
                mm: '%d мүнөт',
                h: 'бир саат',
                hh: '%d саат',
                d: 'бир күн',
                dd: '%d күн',
                M: 'бир ай',
                MM: '%d ай',
                y: 'бир жыл',
                yy: '%d жыл',
            },
            dayOfMonthOrdinalParse: /\d{1,2}-(чи|чы|чү|чу)/,
            ordinal: function (number) {
                var a = number % 10,
                    b = number >= 100 ? 100 : null;
                return number + (suffixes$2[number] || suffixes$2[a] || suffixes$2[b]);
            },
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 7, // The week that contains Jan 7th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        function processRelativeTime$6(number, withoutSuffix, key, isFuture) {
            var format = {
                m: ['eng Minutt', 'enger Minutt'],
                h: ['eng Stonn', 'enger Stonn'],
                d: ['een Dag', 'engem Dag'],
                M: ['ee Mount', 'engem Mount'],
                y: ['ee Joer', 'engem Joer'],
            };
            return withoutSuffix ? format[key][0] : format[key][1];
        }
        function processFutureTime(string) {
            var number = string.substr(0, string.indexOf(' '));
            if (eifelerRegelAppliesToNumber(number)) {
                return 'a ' + string;
            }
            return 'an ' + string;
        }
        function processPastTime(string) {
            var number = string.substr(0, string.indexOf(' '));
            if (eifelerRegelAppliesToNumber(number)) {
                return 'viru ' + string;
            }
            return 'virun ' + string;
        }
        /**
         * Returns true if the word before the given number loses the '-n' ending.
         * e.g. 'an 10 Deeg' but 'a 5 Deeg'
         *
         * @param number {integer}
         * @returns {boolean}
         */
        function eifelerRegelAppliesToNumber(number) {
            number = parseInt(number, 10);
            if (isNaN(number)) {
                return false;
            }
            if (number < 0) {
                // Negative Number --> always true
                return true;
            } else if (number < 10) {
                // Only 1 digit
                if (4 <= number && number <= 7) {
                    return true;
                }
                return false;
            } else if (number < 100) {
                // 2 digits
                var lastDigit = number % 10,
                    firstDigit = number / 10;
                if (lastDigit === 0) {
                    return eifelerRegelAppliesToNumber(firstDigit);
                }
                return eifelerRegelAppliesToNumber(lastDigit);
            } else if (number < 10000) {
                // 3 or 4 digits --> recursively check first digit
                while (number >= 10) {
                    number = number / 10;
                }
                return eifelerRegelAppliesToNumber(number);
            } else {
                // Anything larger than 4 digits: recursively check first n-3 digits
                number = number / 1000;
                return eifelerRegelAppliesToNumber(number);
            }
        }

        hooks.defineLocale('lb', {
            months: 'Januar_Februar_Mäerz_Abrëll_Mee_Juni_Juli_August_September_Oktober_November_Dezember'.split(
                '_'
            ),
            monthsShort: 'Jan._Febr._Mrz._Abr._Mee_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split(
                '_'
            ),
            monthsParseExact: true,
            weekdays: 'Sonndeg_Méindeg_Dënschdeg_Mëttwoch_Donneschdeg_Freideg_Samschdeg'.split(
                '_'
            ),
            weekdaysShort: 'So._Mé._Dë._Më._Do._Fr._Sa.'.split('_'),
            weekdaysMin: 'So_Mé_Dë_Më_Do_Fr_Sa'.split('_'),
            weekdaysParseExact: true,
            longDateFormat: {
                LT: 'H:mm [Auer]',
                LTS: 'H:mm:ss [Auer]',
                L: 'DD.MM.YYYY',
                LL: 'D. MMMM YYYY',
                LLL: 'D. MMMM YYYY H:mm [Auer]',
                LLLL: 'dddd, D. MMMM YYYY H:mm [Auer]',
            },
            calendar: {
                sameDay: '[Haut um] LT',
                sameElse: 'L',
                nextDay: '[Muer um] LT',
                nextWeek: 'dddd [um] LT',
                lastDay: '[Gëschter um] LT',
                lastWeek: function () {
                    // Different date string for 'Dënschdeg' (Tuesday) and 'Donneschdeg' (Thursday) due to phonological rule
                    switch (this.day()) {
                        case 2:
                        case 4:
                            return '[Leschten] dddd [um] LT';
                        default:
                            return '[Leschte] dddd [um] LT';
                    }
                },
            },
            relativeTime: {
                future: processFutureTime,
                past: processPastTime,
                s: 'e puer Sekonnen',
                ss: '%d Sekonnen',
                m: processRelativeTime$6,
                mm: '%d Minutten',
                h: processRelativeTime$6,
                hh: '%d Stonnen',
                d: processRelativeTime$6,
                dd: '%d Deeg',
                M: processRelativeTime$6,
                MM: '%d Méint',
                y: processRelativeTime$6,
                yy: '%d Joer',
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: '%d.',
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 4, // The week that contains Jan 4th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        hooks.defineLocale('lo', {
            months: 'ມັງກອນ_ກຸມພາ_ມີນາ_ເມສາ_ພຶດສະພາ_ມິຖຸນາ_ກໍລະກົດ_ສິງຫາ_ກັນຍາ_ຕຸລາ_ພະຈິກ_ທັນວາ'.split(
                '_'
            ),
            monthsShort: 'ມັງກອນ_ກຸມພາ_ມີນາ_ເມສາ_ພຶດສະພາ_ມິຖຸນາ_ກໍລະກົດ_ສິງຫາ_ກັນຍາ_ຕຸລາ_ພະຈິກ_ທັນວາ'.split(
                '_'
            ),
            weekdays: 'ອາທິດ_ຈັນ_ອັງຄານ_ພຸດ_ພະຫັດ_ສຸກ_ເສົາ'.split('_'),
            weekdaysShort: 'ທິດ_ຈັນ_ອັງຄານ_ພຸດ_ພະຫັດ_ສຸກ_ເສົາ'.split('_'),
            weekdaysMin: 'ທ_ຈ_ອຄ_ພ_ພຫ_ສກ_ສ'.split('_'),
            weekdaysParseExact: true,
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'DD/MM/YYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY HH:mm',
                LLLL: 'ວັນdddd D MMMM YYYY HH:mm',
            },
            meridiemParse: /ຕອນເຊົ້າ|ຕອນແລງ/,
            isPM: function (input) {
                return input === 'ຕອນແລງ';
            },
            meridiem: function (hour, minute, isLower) {
                if (hour < 12) {
                    return 'ຕອນເຊົ້າ';
                } else {
                    return 'ຕອນແລງ';
                }
            },
            calendar: {
                sameDay: '[ມື້ນີ້ເວລາ] LT',
                nextDay: '[ມື້ອື່ນເວລາ] LT',
                nextWeek: '[ວັນ]dddd[ໜ້າເວລາ] LT',
                lastDay: '[ມື້ວານນີ້ເວລາ] LT',
                lastWeek: '[ວັນ]dddd[ແລ້ວນີ້ເວລາ] LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: 'ອີກ %s',
                past: '%sຜ່ານມາ',
                s: 'ບໍ່ເທົ່າໃດວິນາທີ',
                ss: '%d ວິນາທີ',
                m: '1 ນາທີ',
                mm: '%d ນາທີ',
                h: '1 ຊົ່ວໂມງ',
                hh: '%d ຊົ່ວໂມງ',
                d: '1 ມື້',
                dd: '%d ມື້',
                M: '1 ເດືອນ',
                MM: '%d ເດືອນ',
                y: '1 ປີ',
                yy: '%d ປີ',
            },
            dayOfMonthOrdinalParse: /(ທີ່)\d{1,2}/,
            ordinal: function (number) {
                return 'ທີ່' + number;
            },
        });

        //! moment.js locale configuration

        var units = {
            ss: 'sekundė_sekundžių_sekundes',
            m: 'minutė_minutės_minutę',
            mm: 'minutės_minučių_minutes',
            h: 'valanda_valandos_valandą',
            hh: 'valandos_valandų_valandas',
            d: 'diena_dienos_dieną',
            dd: 'dienos_dienų_dienas',
            M: 'mėnuo_mėnesio_mėnesį',
            MM: 'mėnesiai_mėnesių_mėnesius',
            y: 'metai_metų_metus',
            yy: 'metai_metų_metus',
        };
        function translateSeconds(number, withoutSuffix, key, isFuture) {
            if (withoutSuffix) {
                return 'kelios sekundės';
            } else {
                return isFuture ? 'kelių sekundžių' : 'kelias sekundes';
            }
        }
        function translateSingular(number, withoutSuffix, key, isFuture) {
            return withoutSuffix
                ? forms(key)[0]
                : isFuture
                ? forms(key)[1]
                : forms(key)[2];
        }
        function special(number) {
            return number % 10 === 0 || (number > 10 && number < 20);
        }
        function forms(key) {
            return units[key].split('_');
        }
        function translate$6(number, withoutSuffix, key, isFuture) {
            var result = number + ' ';
            if (number === 1) {
                return (
                    result + translateSingular(number, withoutSuffix, key[0], isFuture)
                );
            } else if (withoutSuffix) {
                return result + (special(number) ? forms(key)[1] : forms(key)[0]);
            } else {
                if (isFuture) {
                    return result + forms(key)[1];
                } else {
                    return result + (special(number) ? forms(key)[1] : forms(key)[2]);
                }
            }
        }
        hooks.defineLocale('lt', {
            months: {
                format: 'sausio_vasario_kovo_balandžio_gegužės_birželio_liepos_rugpjūčio_rugsėjo_spalio_lapkričio_gruodžio'.split(
                    '_'
                ),
                standalone: 'sausis_vasaris_kovas_balandis_gegužė_birželis_liepa_rugpjūtis_rugsėjis_spalis_lapkritis_gruodis'.split(
                    '_'
                ),
                isFormat: /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?|MMMM?(\[[^\[\]]*\]|\s)+D[oD]?/,
            },
            monthsShort: 'sau_vas_kov_bal_geg_bir_lie_rgp_rgs_spa_lap_grd'.split('_'),
            weekdays: {
                format: 'sekmadienį_pirmadienį_antradienį_trečiadienį_ketvirtadienį_penktadienį_šeštadienį'.split(
                    '_'
                ),
                standalone: 'sekmadienis_pirmadienis_antradienis_trečiadienis_ketvirtadienis_penktadienis_šeštadienis'.split(
                    '_'
                ),
                isFormat: /dddd HH:mm/,
            },
            weekdaysShort: 'Sek_Pir_Ant_Tre_Ket_Pen_Šeš'.split('_'),
            weekdaysMin: 'S_P_A_T_K_Pn_Š'.split('_'),
            weekdaysParseExact: true,
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'YYYY-MM-DD',
                LL: 'YYYY [m.] MMMM D [d.]',
                LLL: 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
                LLLL: 'YYYY [m.] MMMM D [d.], dddd, HH:mm [val.]',
                l: 'YYYY-MM-DD',
                ll: 'YYYY [m.] MMMM D [d.]',
                lll: 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
                llll: 'YYYY [m.] MMMM D [d.], ddd, HH:mm [val.]',
            },
            calendar: {
                sameDay: '[Šiandien] LT',
                nextDay: '[Rytoj] LT',
                nextWeek: 'dddd LT',
                lastDay: '[Vakar] LT',
                lastWeek: '[Praėjusį] dddd LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: 'po %s',
                past: 'prieš %s',
                s: translateSeconds,
                ss: translate$6,
                m: translateSingular,
                mm: translate$6,
                h: translateSingular,
                hh: translate$6,
                d: translateSingular,
                dd: translate$6,
                M: translateSingular,
                MM: translate$6,
                y: translateSingular,
                yy: translate$6,
            },
            dayOfMonthOrdinalParse: /\d{1,2}-oji/,
            ordinal: function (number) {
                return number + '-oji';
            },
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 4, // The week that contains Jan 4th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        var units$1 = {
            ss: 'sekundes_sekundēm_sekunde_sekundes'.split('_'),
            m: 'minūtes_minūtēm_minūte_minūtes'.split('_'),
            mm: 'minūtes_minūtēm_minūte_minūtes'.split('_'),
            h: 'stundas_stundām_stunda_stundas'.split('_'),
            hh: 'stundas_stundām_stunda_stundas'.split('_'),
            d: 'dienas_dienām_diena_dienas'.split('_'),
            dd: 'dienas_dienām_diena_dienas'.split('_'),
            M: 'mēneša_mēnešiem_mēnesis_mēneši'.split('_'),
            MM: 'mēneša_mēnešiem_mēnesis_mēneši'.split('_'),
            y: 'gada_gadiem_gads_gadi'.split('_'),
            yy: 'gada_gadiem_gads_gadi'.split('_'),
        };
        /**
         * @param withoutSuffix boolean true = a length of time; false = before/after a period of time.
         */
        function format$1(forms, number, withoutSuffix) {
            if (withoutSuffix) {
                // E.g. "21 minūte", "3 minūtes".
                return number % 10 === 1 && number % 100 !== 11 ? forms[2] : forms[3];
            } else {
                // E.g. "21 minūtes" as in "pēc 21 minūtes".
                // E.g. "3 minūtēm" as in "pēc 3 minūtēm".
                return number % 10 === 1 && number % 100 !== 11 ? forms[0] : forms[1];
            }
        }
        function relativeTimeWithPlural$1(number, withoutSuffix, key) {
            return number + ' ' + format$1(units$1[key], number, withoutSuffix);
        }
        function relativeTimeWithSingular(number, withoutSuffix, key) {
            return format$1(units$1[key], number, withoutSuffix);
        }
        function relativeSeconds(number, withoutSuffix) {
            return withoutSuffix ? 'dažas sekundes' : 'dažām sekundēm';
        }

        hooks.defineLocale('lv', {
            months: 'janvāris_februāris_marts_aprīlis_maijs_jūnijs_jūlijs_augusts_septembris_oktobris_novembris_decembris'.split(
                '_'
            ),
            monthsShort: 'jan_feb_mar_apr_mai_jūn_jūl_aug_sep_okt_nov_dec'.split('_'),
            weekdays: 'svētdiena_pirmdiena_otrdiena_trešdiena_ceturtdiena_piektdiena_sestdiena'.split(
                '_'
            ),
            weekdaysShort: 'Sv_P_O_T_C_Pk_S'.split('_'),
            weekdaysMin: 'Sv_P_O_T_C_Pk_S'.split('_'),
            weekdaysParseExact: true,
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'DD.MM.YYYY.',
                LL: 'YYYY. [gada] D. MMMM',
                LLL: 'YYYY. [gada] D. MMMM, HH:mm',
                LLLL: 'YYYY. [gada] D. MMMM, dddd, HH:mm',
            },
            calendar: {
                sameDay: '[Šodien pulksten] LT',
                nextDay: '[Rīt pulksten] LT',
                nextWeek: 'dddd [pulksten] LT',
                lastDay: '[Vakar pulksten] LT',
                lastWeek: '[Pagājušā] dddd [pulksten] LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: 'pēc %s',
                past: 'pirms %s',
                s: relativeSeconds,
                ss: relativeTimeWithPlural$1,
                m: relativeTimeWithSingular,
                mm: relativeTimeWithPlural$1,
                h: relativeTimeWithSingular,
                hh: relativeTimeWithPlural$1,
                d: relativeTimeWithSingular,
                dd: relativeTimeWithPlural$1,
                M: relativeTimeWithSingular,
                MM: relativeTimeWithPlural$1,
                y: relativeTimeWithSingular,
                yy: relativeTimeWithPlural$1,
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: '%d.',
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 4, // The week that contains Jan 4th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        var translator = {
            words: {
                //Different grammatical cases
                ss: ['sekund', 'sekunda', 'sekundi'],
                m: ['jedan minut', 'jednog minuta'],
                mm: ['minut', 'minuta', 'minuta'],
                h: ['jedan sat', 'jednog sata'],
                hh: ['sat', 'sata', 'sati'],
                dd: ['dan', 'dana', 'dana'],
                MM: ['mjesec', 'mjeseca', 'mjeseci'],
                yy: ['godina', 'godine', 'godina'],
            },
            correctGrammaticalCase: function (number, wordKey) {
                return number === 1
                    ? wordKey[0]
                    : number >= 2 && number <= 4
                    ? wordKey[1]
                    : wordKey[2];
            },
            translate: function (number, withoutSuffix, key) {
                var wordKey = translator.words[key];
                if (key.length === 1) {
                    return withoutSuffix ? wordKey[0] : wordKey[1];
                } else {
                    return (
                        number +
                        ' ' +
                        translator.correctGrammaticalCase(number, wordKey)
                    );
                }
            },
        };

        hooks.defineLocale('me', {
            months: 'januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar'.split(
                '_'
            ),
            monthsShort: 'jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.'.split(
                '_'
            ),
            monthsParseExact: true,
            weekdays: 'nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota'.split(
                '_'
            ),
            weekdaysShort: 'ned._pon._uto._sri._čet._pet._sub.'.split('_'),
            weekdaysMin: 'ne_po_ut_sr_če_pe_su'.split('_'),
            weekdaysParseExact: true,
            longDateFormat: {
                LT: 'H:mm',
                LTS: 'H:mm:ss',
                L: 'DD.MM.YYYY',
                LL: 'D. MMMM YYYY',
                LLL: 'D. MMMM YYYY H:mm',
                LLLL: 'dddd, D. MMMM YYYY H:mm',
            },
            calendar: {
                sameDay: '[danas u] LT',
                nextDay: '[sjutra u] LT',

                nextWeek: function () {
                    switch (this.day()) {
                        case 0:
                            return '[u] [nedjelju] [u] LT';
                        case 3:
                            return '[u] [srijedu] [u] LT';
                        case 6:
                            return '[u] [subotu] [u] LT';
                        case 1:
                        case 2:
                        case 4:
                        case 5:
                            return '[u] dddd [u] LT';
                    }
                },
                lastDay: '[juče u] LT',
                lastWeek: function () {
                    var lastWeekDays = [
                        '[prošle] [nedjelje] [u] LT',
                        '[prošlog] [ponedjeljka] [u] LT',
                        '[prošlog] [utorka] [u] LT',
                        '[prošle] [srijede] [u] LT',
                        '[prošlog] [četvrtka] [u] LT',
                        '[prošlog] [petka] [u] LT',
                        '[prošle] [subote] [u] LT',
                    ];
                    return lastWeekDays[this.day()];
                },
                sameElse: 'L',
            },
            relativeTime: {
                future: 'za %s',
                past: 'prije %s',
                s: 'nekoliko sekundi',
                ss: translator.translate,
                m: translator.translate,
                mm: translator.translate,
                h: translator.translate,
                hh: translator.translate,
                d: 'dan',
                dd: translator.translate,
                M: 'mjesec',
                MM: translator.translate,
                y: 'godinu',
                yy: translator.translate,
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: '%d.',
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 7, // The week that contains Jan 7th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        hooks.defineLocale('mi', {
            months: 'Kohi-tāte_Hui-tanguru_Poutū-te-rangi_Paenga-whāwhā_Haratua_Pipiri_Hōngoingoi_Here-turi-kōkā_Mahuru_Whiringa-ā-nuku_Whiringa-ā-rangi_Hakihea'.split(
                '_'
            ),
            monthsShort: 'Kohi_Hui_Pou_Pae_Hara_Pipi_Hōngoi_Here_Mahu_Whi-nu_Whi-ra_Haki'.split(
                '_'
            ),
            monthsRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
            monthsStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
            monthsShortRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
            monthsShortStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,2}/i,
            weekdays: 'Rātapu_Mane_Tūrei_Wenerei_Tāite_Paraire_Hātarei'.split('_'),
            weekdaysShort: 'Ta_Ma_Tū_We_Tāi_Pa_Hā'.split('_'),
            weekdaysMin: 'Ta_Ma_Tū_We_Tāi_Pa_Hā'.split('_'),
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'DD/MM/YYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY [i] HH:mm',
                LLLL: 'dddd, D MMMM YYYY [i] HH:mm',
            },
            calendar: {
                sameDay: '[i teie mahana, i] LT',
                nextDay: '[apopo i] LT',
                nextWeek: 'dddd [i] LT',
                lastDay: '[inanahi i] LT',
                lastWeek: 'dddd [whakamutunga i] LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: 'i roto i %s',
                past: '%s i mua',
                s: 'te hēkona ruarua',
                ss: '%d hēkona',
                m: 'he meneti',
                mm: '%d meneti',
                h: 'te haora',
                hh: '%d haora',
                d: 'he ra',
                dd: '%d ra',
                M: 'he marama',
                MM: '%d marama',
                y: 'he tau',
                yy: '%d tau',
            },
            dayOfMonthOrdinalParse: /\d{1,2}º/,
            ordinal: '%dº',
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 4, // The week that contains Jan 4th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        hooks.defineLocale('mk', {
            months: 'јануари_февруари_март_април_мај_јуни_јули_август_септември_октомври_ноември_декември'.split(
                '_'
            ),
            monthsShort: 'јан_фев_мар_апр_мај_јун_јул_авг_сеп_окт_ное_дек'.split('_'),
            weekdays: 'недела_понеделник_вторник_среда_четврток_петок_сабота'.split(
                '_'
            ),
            weekdaysShort: 'нед_пон_вто_сре_чет_пет_саб'.split('_'),
            weekdaysMin: 'нe_пo_вт_ср_че_пе_сa'.split('_'),
            longDateFormat: {
                LT: 'H:mm',
                LTS: 'H:mm:ss',
                L: 'D.MM.YYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY H:mm',
                LLLL: 'dddd, D MMMM YYYY H:mm',
            },
            calendar: {
                sameDay: '[Денес во] LT',
                nextDay: '[Утре во] LT',
                nextWeek: '[Во] dddd [во] LT',
                lastDay: '[Вчера во] LT',
                lastWeek: function () {
                    switch (this.day()) {
                        case 0:
                        case 3:
                        case 6:
                            return '[Изминатата] dddd [во] LT';
                        case 1:
                        case 2:
                        case 4:
                        case 5:
                            return '[Изминатиот] dddd [во] LT';
                    }
                },
                sameElse: 'L',
            },
            relativeTime: {
                future: 'за %s',
                past: 'пред %s',
                s: 'неколку секунди',
                ss: '%d секунди',
                m: 'една минута',
                mm: '%d минути',
                h: 'еден час',
                hh: '%d часа',
                d: 'еден ден',
                dd: '%d дена',
                M: 'еден месец',
                MM: '%d месеци',
                y: 'една година',
                yy: '%d години',
            },
            dayOfMonthOrdinalParse: /\d{1,2}-(ев|ен|ти|ви|ри|ми)/,
            ordinal: function (number) {
                var lastDigit = number % 10,
                    last2Digits = number % 100;
                if (number === 0) {
                    return number + '-ев';
                } else if (last2Digits === 0) {
                    return number + '-ен';
                } else if (last2Digits > 10 && last2Digits < 20) {
                    return number + '-ти';
                } else if (lastDigit === 1) {
                    return number + '-ви';
                } else if (lastDigit === 2) {
                    return number + '-ри';
                } else if (lastDigit === 7 || lastDigit === 8) {
                    return number + '-ми';
                } else {
                    return number + '-ти';
                }
            },
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 7, // The week that contains Jan 7th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        hooks.defineLocale('ml', {
            months: 'ജനുവരി_ഫെബ്രുവരി_മാർച്ച്_ഏപ്രിൽ_മേയ്_ജൂൺ_ജൂലൈ_ഓഗസ്റ്റ്_സെപ്റ്റംബർ_ഒക്ടോബർ_നവംബർ_ഡിസംബർ'.split(
                '_'
            ),
            monthsShort: 'ജനു._ഫെബ്രു._മാർ._ഏപ്രി._മേയ്_ജൂൺ_ജൂലൈ._ഓഗ._സെപ്റ്റ._ഒക്ടോ._നവം._ഡിസം.'.split(
                '_'
            ),
            monthsParseExact: true,
            weekdays: 'ഞായറാഴ്ച_തിങ്കളാഴ്ച_ചൊവ്വാഴ്ച_ബുധനാഴ്ച_വ്യാഴാഴ്ച_വെള്ളിയാഴ്ച_ശനിയാഴ്ച'.split(
                '_'
            ),
            weekdaysShort: 'ഞായർ_തിങ്കൾ_ചൊവ്വ_ബുധൻ_വ്യാഴം_വെള്ളി_ശനി'.split('_'),
            weekdaysMin: 'ഞാ_തി_ചൊ_ബു_വ്യാ_വെ_ശ'.split('_'),
            longDateFormat: {
                LT: 'A h:mm -നു',
                LTS: 'A h:mm:ss -നു',
                L: 'DD/MM/YYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY, A h:mm -നു',
                LLLL: 'dddd, D MMMM YYYY, A h:mm -നു',
            },
            calendar: {
                sameDay: '[ഇന്ന്] LT',
                nextDay: '[നാളെ] LT',
                nextWeek: 'dddd, LT',
                lastDay: '[ഇന്നലെ] LT',
                lastWeek: '[കഴിഞ്ഞ] dddd, LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: '%s കഴിഞ്ഞ്',
                past: '%s മുൻപ്',
                s: 'അൽപ നിമിഷങ്ങൾ',
                ss: '%d സെക്കൻഡ്',
                m: 'ഒരു മിനിറ്റ്',
                mm: '%d മിനിറ്റ്',
                h: 'ഒരു മണിക്കൂർ',
                hh: '%d മണിക്കൂർ',
                d: 'ഒരു ദിവസം',
                dd: '%d ദിവസം',
                M: 'ഒരു മാസം',
                MM: '%d മാസം',
                y: 'ഒരു വർഷം',
                yy: '%d വർഷം',
            },
            meridiemParse: /രാത്രി|രാവിലെ|ഉച്ച കഴിഞ്ഞ്|വൈകുന്നേരം|രാത്രി/i,
            meridiemHour: function (hour, meridiem) {
                if (hour === 12) {
                    hour = 0;
                }
                if (
                    (meridiem === 'രാത്രി' && hour >= 4) ||
                    meridiem === 'ഉച്ച കഴിഞ്ഞ്' ||
                    meridiem === 'വൈകുന്നേരം'
                ) {
                    return hour + 12;
                } else {
                    return hour;
                }
            },
            meridiem: function (hour, minute, isLower) {
                if (hour < 4) {
                    return 'രാത്രി';
                } else if (hour < 12) {
                    return 'രാവിലെ';
                } else if (hour < 17) {
                    return 'ഉച്ച കഴിഞ്ഞ്';
                } else if (hour < 20) {
                    return 'വൈകുന്നേരം';
                } else {
                    return 'രാത്രി';
                }
            },
        });

        //! moment.js locale configuration

        function translate$7(number, withoutSuffix, key, isFuture) {
            switch (key) {
                case 's':
                    return withoutSuffix ? 'хэдхэн секунд' : 'хэдхэн секундын';
                case 'ss':
                    return number + (withoutSuffix ? ' секунд' : ' секундын');
                case 'm':
                case 'mm':
                    return number + (withoutSuffix ? ' минут' : ' минутын');
                case 'h':
                case 'hh':
                    return number + (withoutSuffix ? ' цаг' : ' цагийн');
                case 'd':
                case 'dd':
                    return number + (withoutSuffix ? ' өдөр' : ' өдрийн');
                case 'M':
                case 'MM':
                    return number + (withoutSuffix ? ' сар' : ' сарын');
                case 'y':
                case 'yy':
                    return number + (withoutSuffix ? ' жил' : ' жилийн');
                default:
                    return number;
            }
        }

        hooks.defineLocale('mn', {
            months: 'Нэгдүгээр сар_Хоёрдугаар сар_Гуравдугаар сар_Дөрөвдүгээр сар_Тавдугаар сар_Зургадугаар сар_Долдугаар сар_Наймдугаар сар_Есдүгээр сар_Аравдугаар сар_Арван нэгдүгээр сар_Арван хоёрдугаар сар'.split(
                '_'
            ),
            monthsShort: '1 сар_2 сар_3 сар_4 сар_5 сар_6 сар_7 сар_8 сар_9 сар_10 сар_11 сар_12 сар'.split(
                '_'
            ),
            monthsParseExact: true,
            weekdays: 'Ням_Даваа_Мягмар_Лхагва_Пүрэв_Баасан_Бямба'.split('_'),
            weekdaysShort: 'Ням_Дав_Мяг_Лха_Пүр_Баа_Бям'.split('_'),
            weekdaysMin: 'Ня_Да_Мя_Лх_Пү_Ба_Бя'.split('_'),
            weekdaysParseExact: true,
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'YYYY-MM-DD',
                LL: 'YYYY оны MMMMын D',
                LLL: 'YYYY оны MMMMын D HH:mm',
                LLLL: 'dddd, YYYY оны MMMMын D HH:mm',
            },
            meridiemParse: /ҮӨ|ҮХ/i,
            isPM: function (input) {
                return input === 'ҮХ';
            },
            meridiem: function (hour, minute, isLower) {
                if (hour < 12) {
                    return 'ҮӨ';
                } else {
                    return 'ҮХ';
                }
            },
            calendar: {
                sameDay: '[Өнөөдөр] LT',
                nextDay: '[Маргааш] LT',
                nextWeek: '[Ирэх] dddd LT',
                lastDay: '[Өчигдөр] LT',
                lastWeek: '[Өнгөрсөн] dddd LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: '%s дараа',
                past: '%s өмнө',
                s: translate$7,
                ss: translate$7,
                m: translate$7,
                mm: translate$7,
                h: translate$7,
                hh: translate$7,
                d: translate$7,
                dd: translate$7,
                M: translate$7,
                MM: translate$7,
                y: translate$7,
                yy: translate$7,
            },
            dayOfMonthOrdinalParse: /\d{1,2} өдөр/,
            ordinal: function (number, period) {
                switch (period) {
                    case 'd':
                    case 'D':
                    case 'DDD':
                        return number + ' өдөр';
                    default:
                        return number;
                }
            },
        });

        //! moment.js locale configuration

        var symbolMap$c = {
                1: '१',
                2: '२',
                3: '३',
                4: '४',
                5: '५',
                6: '६',
                7: '७',
                8: '८',
                9: '९',
                0: '०',
            },
            numberMap$b = {
                '१': '1',
                '२': '2',
                '३': '3',
                '४': '4',
                '५': '5',
                '६': '6',
                '७': '7',
                '८': '8',
                '९': '9',
                '०': '0',
            };

        function relativeTimeMr(number, withoutSuffix, string, isFuture) {
            var output = '';
            if (withoutSuffix) {
                switch (string) {
                    case 's':
                        output = 'काही सेकंद';
                        break;
                    case 'ss':
                        output = '%d सेकंद';
                        break;
                    case 'm':
                        output = 'एक मिनिट';
                        break;
                    case 'mm':
                        output = '%d मिनिटे';
                        break;
                    case 'h':
                        output = 'एक तास';
                        break;
                    case 'hh':
                        output = '%d तास';
                        break;
                    case 'd':
                        output = 'एक दिवस';
                        break;
                    case 'dd':
                        output = '%d दिवस';
                        break;
                    case 'M':
                        output = 'एक महिना';
                        break;
                    case 'MM':
                        output = '%d महिने';
                        break;
                    case 'y':
                        output = 'एक वर्ष';
                        break;
                    case 'yy':
                        output = '%d वर्षे';
                        break;
                }
            } else {
                switch (string) {
                    case 's':
                        output = 'काही सेकंदां';
                        break;
                    case 'ss':
                        output = '%d सेकंदां';
                        break;
                    case 'm':
                        output = 'एका मिनिटा';
                        break;
                    case 'mm':
                        output = '%d मिनिटां';
                        break;
                    case 'h':
                        output = 'एका तासा';
                        break;
                    case 'hh':
                        output = '%d तासां';
                        break;
                    case 'd':
                        output = 'एका दिवसा';
                        break;
                    case 'dd':
                        output = '%d दिवसां';
                        break;
                    case 'M':
                        output = 'एका महिन्या';
                        break;
                    case 'MM':
                        output = '%d महिन्यां';
                        break;
                    case 'y':
                        output = 'एका वर्षा';
                        break;
                    case 'yy':
                        output = '%d वर्षां';
                        break;
                }
            }
            return output.replace(/%d/i, number);
        }

        hooks.defineLocale('mr', {
            months: 'जानेवारी_फेब्रुवारी_मार्च_एप्रिल_मे_जून_जुलै_ऑगस्ट_सप्टेंबर_ऑक्टोबर_नोव्हेंबर_डिसेंबर'.split(
                '_'
            ),
            monthsShort: 'जाने._फेब्रु._मार्च._एप्रि._मे._जून._जुलै._ऑग._सप्टें._ऑक्टो._नोव्हें._डिसें.'.split(
                '_'
            ),
            monthsParseExact: true,
            weekdays: 'रविवार_सोमवार_मंगळवार_बुधवार_गुरूवार_शुक्रवार_शनिवार'.split('_'),
            weekdaysShort: 'रवि_सोम_मंगळ_बुध_गुरू_शुक्र_शनि'.split('_'),
            weekdaysMin: 'र_सो_मं_बु_गु_शु_श'.split('_'),
            longDateFormat: {
                LT: 'A h:mm वाजता',
                LTS: 'A h:mm:ss वाजता',
                L: 'DD/MM/YYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY, A h:mm वाजता',
                LLLL: 'dddd, D MMMM YYYY, A h:mm वाजता',
            },
            calendar: {
                sameDay: '[आज] LT',
                nextDay: '[उद्या] LT',
                nextWeek: 'dddd, LT',
                lastDay: '[काल] LT',
                lastWeek: '[मागील] dddd, LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: '%sमध्ये',
                past: '%sपूर्वी',
                s: relativeTimeMr,
                ss: relativeTimeMr,
                m: relativeTimeMr,
                mm: relativeTimeMr,
                h: relativeTimeMr,
                hh: relativeTimeMr,
                d: relativeTimeMr,
                dd: relativeTimeMr,
                M: relativeTimeMr,
                MM: relativeTimeMr,
                y: relativeTimeMr,
                yy: relativeTimeMr,
            },
            preparse: function (string) {
                return string.replace(/[१२३४५६७८९०]/g, function (match) {
                    return numberMap$b[match];
                });
            },
            postformat: function (string) {
                return string.replace(/\d/g, function (match) {
                    return symbolMap$c[match];
                });
            },
            meridiemParse: /पहाटे|सकाळी|दुपारी|सायंकाळी|रात्री/,
            meridiemHour: function (hour, meridiem) {
                if (hour === 12) {
                    hour = 0;
                }
                if (meridiem === 'पहाटे' || meridiem === 'सकाळी') {
                    return hour;
                } else if (
                    meridiem === 'दुपारी' ||
                    meridiem === 'सायंकाळी' ||
                    meridiem === 'रात्री'
                ) {
                    return hour >= 12 ? hour : hour + 12;
                }
            },
            meridiem: function (hour, minute, isLower) {
                if (hour >= 0 && hour < 6) {
                    return 'पहाटे';
                } else if (hour < 12) {
                    return 'सकाळी';
                } else if (hour < 17) {
                    return 'दुपारी';
                } else if (hour < 20) {
                    return 'सायंकाळी';
                } else {
                    return 'रात्री';
                }
            },
            week: {
                dow: 0, // Sunday is the first day of the week.
                doy: 6, // The week that contains Jan 6th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        hooks.defineLocale('ms-my', {
            months: 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split(
                '_'
            ),
            monthsShort: 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
            weekdays: 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
            weekdaysShort: 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
            weekdaysMin: 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
            longDateFormat: {
                LT: 'HH.mm',
                LTS: 'HH.mm.ss',
                L: 'DD/MM/YYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY [pukul] HH.mm',
                LLLL: 'dddd, D MMMM YYYY [pukul] HH.mm',
            },
            meridiemParse: /pagi|tengahari|petang|malam/,
            meridiemHour: function (hour, meridiem) {
                if (hour === 12) {
                    hour = 0;
                }
                if (meridiem === 'pagi') {
                    return hour;
                } else if (meridiem === 'tengahari') {
                    return hour >= 11 ? hour : hour + 12;
                } else if (meridiem === 'petang' || meridiem === 'malam') {
                    return hour + 12;
                }
            },
            meridiem: function (hours, minutes, isLower) {
                if (hours < 11) {
                    return 'pagi';
                } else if (hours < 15) {
                    return 'tengahari';
                } else if (hours < 19) {
                    return 'petang';
                } else {
                    return 'malam';
                }
            },
            calendar: {
                sameDay: '[Hari ini pukul] LT',
                nextDay: '[Esok pukul] LT',
                nextWeek: 'dddd [pukul] LT',
                lastDay: '[Kelmarin pukul] LT',
                lastWeek: 'dddd [lepas pukul] LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: 'dalam %s',
                past: '%s yang lepas',
                s: 'beberapa saat',
                ss: '%d saat',
                m: 'seminit',
                mm: '%d minit',
                h: 'sejam',
                hh: '%d jam',
                d: 'sehari',
                dd: '%d hari',
                M: 'sebulan',
                MM: '%d bulan',
                y: 'setahun',
                yy: '%d tahun',
            },
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 7, // The week that contains Jan 7th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        hooks.defineLocale('ms', {
            months: 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split(
                '_'
            ),
            monthsShort: 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
            weekdays: 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
            weekdaysShort: 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
            weekdaysMin: 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
            longDateFormat: {
                LT: 'HH.mm',
                LTS: 'HH.mm.ss',
                L: 'DD/MM/YYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY [pukul] HH.mm',
                LLLL: 'dddd, D MMMM YYYY [pukul] HH.mm',
            },
            meridiemParse: /pagi|tengahari|petang|malam/,
            meridiemHour: function (hour, meridiem) {
                if (hour === 12) {
                    hour = 0;
                }
                if (meridiem === 'pagi') {
                    return hour;
                } else if (meridiem === 'tengahari') {
                    return hour >= 11 ? hour : hour + 12;
                } else if (meridiem === 'petang' || meridiem === 'malam') {
                    return hour + 12;
                }
            },
            meridiem: function (hours, minutes, isLower) {
                if (hours < 11) {
                    return 'pagi';
                } else if (hours < 15) {
                    return 'tengahari';
                } else if (hours < 19) {
                    return 'petang';
                } else {
                    return 'malam';
                }
            },
            calendar: {
                sameDay: '[Hari ini pukul] LT',
                nextDay: '[Esok pukul] LT',
                nextWeek: 'dddd [pukul] LT',
                lastDay: '[Kelmarin pukul] LT',
                lastWeek: 'dddd [lepas pukul] LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: 'dalam %s',
                past: '%s yang lepas',
                s: 'beberapa saat',
                ss: '%d saat',
                m: 'seminit',
                mm: '%d minit',
                h: 'sejam',
                hh: '%d jam',
                d: 'sehari',
                dd: '%d hari',
                M: 'sebulan',
                MM: '%d bulan',
                y: 'setahun',
                yy: '%d tahun',
            },
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 7, // The week that contains Jan 7th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        hooks.defineLocale('mt', {
            months: 'Jannar_Frar_Marzu_April_Mejju_Ġunju_Lulju_Awwissu_Settembru_Ottubru_Novembru_Diċembru'.split(
                '_'
            ),
            monthsShort: 'Jan_Fra_Mar_Apr_Mej_Ġun_Lul_Aww_Set_Ott_Nov_Diċ'.split('_'),
            weekdays: 'Il-Ħadd_It-Tnejn_It-Tlieta_L-Erbgħa_Il-Ħamis_Il-Ġimgħa_Is-Sibt'.split(
                '_'
            ),
            weekdaysShort: 'Ħad_Tne_Tli_Erb_Ħam_Ġim_Sib'.split('_'),
            weekdaysMin: 'Ħa_Tn_Tl_Er_Ħa_Ġi_Si'.split('_'),
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'DD/MM/YYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY HH:mm',
                LLLL: 'dddd, D MMMM YYYY HH:mm',
            },
            calendar: {
                sameDay: '[Illum fil-]LT',
                nextDay: '[Għada fil-]LT',
                nextWeek: 'dddd [fil-]LT',
                lastDay: '[Il-bieraħ fil-]LT',
                lastWeek: 'dddd [li għadda] [fil-]LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: 'f’ %s',
                past: '%s ilu',
                s: 'ftit sekondi',
                ss: '%d sekondi',
                m: 'minuta',
                mm: '%d minuti',
                h: 'siegħa',
                hh: '%d siegħat',
                d: 'ġurnata',
                dd: '%d ġranet',
                M: 'xahar',
                MM: '%d xhur',
                y: 'sena',
                yy: '%d sni',
            },
            dayOfMonthOrdinalParse: /\d{1,2}º/,
            ordinal: '%dº',
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 4, // The week that contains Jan 4th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        var symbolMap$d = {
                1: '၁',
                2: '၂',
                3: '၃',
                4: '၄',
                5: '၅',
                6: '၆',
                7: '၇',
                8: '၈',
                9: '၉',
                0: '၀',
            },
            numberMap$c = {
                '၁': '1',
                '၂': '2',
                '၃': '3',
                '၄': '4',
                '၅': '5',
                '၆': '6',
                '၇': '7',
                '၈': '8',
                '၉': '9',
                '၀': '0',
            };

        hooks.defineLocale('my', {
            months: 'ဇန်နဝါရီ_ဖေဖော်ဝါရီ_မတ်_ဧပြီ_မေ_ဇွန်_ဇူလိုင်_သြဂုတ်_စက်တင်ဘာ_အောက်တိုဘာ_နိုဝင်ဘာ_ဒီဇင်ဘာ'.split(
                '_'
            ),
            monthsShort: 'ဇန်_ဖေ_မတ်_ပြီ_မေ_ဇွန်_လိုင်_သြ_စက်_အောက်_နို_ဒီ'.split('_'),
            weekdays: 'တနင်္ဂနွေ_တနင်္လာ_အင်္ဂါ_ဗုဒ္ဓဟူး_ကြာသပတေး_သောကြာ_စနေ'.split(
                '_'
            ),
            weekdaysShort: 'နွေ_လာ_ဂါ_ဟူး_ကြာ_သော_နေ'.split('_'),
            weekdaysMin: 'နွေ_လာ_ဂါ_ဟူး_ကြာ_သော_နေ'.split('_'),

            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'DD/MM/YYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY HH:mm',
                LLLL: 'dddd D MMMM YYYY HH:mm',
            },
            calendar: {
                sameDay: '[ယနေ.] LT [မှာ]',
                nextDay: '[မနက်ဖြန်] LT [မှာ]',
                nextWeek: 'dddd LT [မှာ]',
                lastDay: '[မနေ.က] LT [မှာ]',
                lastWeek: '[ပြီးခဲ့သော] dddd LT [မှာ]',
                sameElse: 'L',
            },
            relativeTime: {
                future: 'လာမည့် %s မှာ',
                past: 'လွန်ခဲ့သော %s က',
                s: 'စက္ကန်.အနည်းငယ်',
                ss: '%d စက္ကန့်',
                m: 'တစ်မိနစ်',
                mm: '%d မိနစ်',
                h: 'တစ်နာရီ',
                hh: '%d နာရီ',
                d: 'တစ်ရက်',
                dd: '%d ရက်',
                M: 'တစ်လ',
                MM: '%d လ',
                y: 'တစ်နှစ်',
                yy: '%d နှစ်',
            },
            preparse: function (string) {
                return string.replace(/[၁၂၃၄၅၆၇၈၉၀]/g, function (match) {
                    return numberMap$c[match];
                });
            },
            postformat: function (string) {
                return string.replace(/\d/g, function (match) {
                    return symbolMap$d[match];
                });
            },
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 4, // The week that contains Jan 4th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        hooks.defineLocale('nb', {
            months: 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split(
                '_'
            ),
            monthsShort: 'jan._feb._mars_apr._mai_juni_juli_aug._sep._okt._nov._des.'.split(
                '_'
            ),
            monthsParseExact: true,
            weekdays: 'søndag_mandag_tirsdag_onsdag_torsdag_fredag_lørdag'.split('_'),
            weekdaysShort: 'sø._ma._ti._on._to._fr._lø.'.split('_'),
            weekdaysMin: 'sø_ma_ti_on_to_fr_lø'.split('_'),
            weekdaysParseExact: true,
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'DD.MM.YYYY',
                LL: 'D. MMMM YYYY',
                LLL: 'D. MMMM YYYY [kl.] HH:mm',
                LLLL: 'dddd D. MMMM YYYY [kl.] HH:mm',
            },
            calendar: {
                sameDay: '[i dag kl.] LT',
                nextDay: '[i morgen kl.] LT',
                nextWeek: 'dddd [kl.] LT',
                lastDay: '[i går kl.] LT',
                lastWeek: '[forrige] dddd [kl.] LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: 'om %s',
                past: '%s siden',
                s: 'noen sekunder',
                ss: '%d sekunder',
                m: 'ett minutt',
                mm: '%d minutter',
                h: 'en time',
                hh: '%d timer',
                d: 'en dag',
                dd: '%d dager',
                w: 'en uke',
                ww: '%d uker',
                M: 'en måned',
                MM: '%d måneder',
                y: 'ett år',
                yy: '%d år',
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: '%d.',
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 4, // The week that contains Jan 4th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        var symbolMap$e = {
                1: '१',
                2: '२',
                3: '३',
                4: '४',
                5: '५',
                6: '६',
                7: '७',
                8: '८',
                9: '९',
                0: '०',
            },
            numberMap$d = {
                '१': '1',
                '२': '2',
                '३': '3',
                '४': '4',
                '५': '5',
                '६': '6',
                '७': '7',
                '८': '8',
                '९': '9',
                '०': '0',
            };

        hooks.defineLocale('ne', {
            months: 'जनवरी_फेब्रुवरी_मार्च_अप्रिल_मई_जुन_जुलाई_अगष्ट_सेप्टेम्बर_अक्टोबर_नोभेम्बर_डिसेम्बर'.split(
                '_'
            ),
            monthsShort: 'जन._फेब्रु._मार्च_अप्रि._मई_जुन_जुलाई._अग._सेप्ट._अक्टो._नोभे._डिसे.'.split(
                '_'
            ),
            monthsParseExact: true,
            weekdays: 'आइतबार_सोमबार_मङ्गलबार_बुधबार_बिहिबार_शुक्रबार_शनिबार'.split(
                '_'
            ),
            weekdaysShort: 'आइत._सोम._मङ्गल._बुध._बिहि._शुक्र._शनि.'.split('_'),
            weekdaysMin: 'आ._सो._मं._बु._बि._शु._श.'.split('_'),
            weekdaysParseExact: true,
            longDateFormat: {
                LT: 'Aको h:mm बजे',
                LTS: 'Aको h:mm:ss बजे',
                L: 'DD/MM/YYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY, Aको h:mm बजे',
                LLLL: 'dddd, D MMMM YYYY, Aको h:mm बजे',
            },
            preparse: function (string) {
                return string.replace(/[१२३४५६७८९०]/g, function (match) {
                    return numberMap$d[match];
                });
            },
            postformat: function (string) {
                return string.replace(/\d/g, function (match) {
                    return symbolMap$e[match];
                });
            },
            meridiemParse: /राति|बिहान|दिउँसो|साँझ/,
            meridiemHour: function (hour, meridiem) {
                if (hour === 12) {
                    hour = 0;
                }
                if (meridiem === 'राति') {
                    return hour < 4 ? hour : hour + 12;
                } else if (meridiem === 'बिहान') {
                    return hour;
                } else if (meridiem === 'दिउँसो') {
                    return hour >= 10 ? hour : hour + 12;
                } else if (meridiem === 'साँझ') {
                    return hour + 12;
                }
            },
            meridiem: function (hour, minute, isLower) {
                if (hour < 3) {
                    return 'राति';
                } else if (hour < 12) {
                    return 'बिहान';
                } else if (hour < 16) {
                    return 'दिउँसो';
                } else if (hour < 20) {
                    return 'साँझ';
                } else {
                    return 'राति';
                }
            },
            calendar: {
                sameDay: '[आज] LT',
                nextDay: '[भोलि] LT',
                nextWeek: '[आउँदो] dddd[,] LT',
                lastDay: '[हिजो] LT',
                lastWeek: '[गएको] dddd[,] LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: '%sमा',
                past: '%s अगाडि',
                s: 'केही क्षण',
                ss: '%d सेकेण्ड',
                m: 'एक मिनेट',
                mm: '%d मिनेट',
                h: 'एक घण्टा',
                hh: '%d घण्टा',
                d: 'एक दिन',
                dd: '%d दिन',
                M: 'एक महिना',
                MM: '%d महिना',
                y: 'एक बर्ष',
                yy: '%d बर्ष',
            },
            week: {
                dow: 0, // Sunday is the first day of the week.
                doy: 6, // The week that contains Jan 6th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        var monthsShortWithDots$1 = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split(
                '_'
            ),
            monthsShortWithoutDots$1 = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split(
                '_'
            ),
            monthsParse$8 = [
                /^jan/i,
                /^feb/i,
                /^maart|mrt.?$/i,
                /^apr/i,
                /^mei$/i,
                /^jun[i.]?$/i,
                /^jul[i.]?$/i,
                /^aug/i,
                /^sep/i,
                /^okt/i,
                /^nov/i,
                /^dec/i,
            ],
            monthsRegex$8 = /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;

        hooks.defineLocale('nl-be', {
            months: 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split(
                '_'
            ),
            monthsShort: function (m, format) {
                if (!m) {
                    return monthsShortWithDots$1;
                } else if (/-MMM-/.test(format)) {
                    return monthsShortWithoutDots$1[m.month()];
                } else {
                    return monthsShortWithDots$1[m.month()];
                }
            },

            monthsRegex: monthsRegex$8,
            monthsShortRegex: monthsRegex$8,
            monthsStrictRegex: /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december)/i,
            monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,

            monthsParse: monthsParse$8,
            longMonthsParse: monthsParse$8,
            shortMonthsParse: monthsParse$8,

            weekdays: 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split(
                '_'
            ),
            weekdaysShort: 'zo._ma._di._wo._do._vr._za.'.split('_'),
            weekdaysMin: 'zo_ma_di_wo_do_vr_za'.split('_'),
            weekdaysParseExact: true,
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'DD/MM/YYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY HH:mm',
                LLLL: 'dddd D MMMM YYYY HH:mm',
            },
            calendar: {
                sameDay: '[vandaag om] LT',
                nextDay: '[morgen om] LT',
                nextWeek: 'dddd [om] LT',
                lastDay: '[gisteren om] LT',
                lastWeek: '[afgelopen] dddd [om] LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: 'over %s',
                past: '%s geleden',
                s: 'een paar seconden',
                ss: '%d seconden',
                m: 'één minuut',
                mm: '%d minuten',
                h: 'één uur',
                hh: '%d uur',
                d: 'één dag',
                dd: '%d dagen',
                M: 'één maand',
                MM: '%d maanden',
                y: 'één jaar',
                yy: '%d jaar',
            },
            dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
            ordinal: function (number) {
                return (
                    number +
                    (number === 1 || number === 8 || number >= 20 ? 'ste' : 'de')
                );
            },
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 4, // The week that contains Jan 4th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        var monthsShortWithDots$2 = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split(
                '_'
            ),
            monthsShortWithoutDots$2 = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split(
                '_'
            ),
            monthsParse$9 = [
                /^jan/i,
                /^feb/i,
                /^maart|mrt.?$/i,
                /^apr/i,
                /^mei$/i,
                /^jun[i.]?$/i,
                /^jul[i.]?$/i,
                /^aug/i,
                /^sep/i,
                /^okt/i,
                /^nov/i,
                /^dec/i,
            ],
            monthsRegex$9 = /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;

        hooks.defineLocale('nl', {
            months: 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split(
                '_'
            ),
            monthsShort: function (m, format) {
                if (!m) {
                    return monthsShortWithDots$2;
                } else if (/-MMM-/.test(format)) {
                    return monthsShortWithoutDots$2[m.month()];
                } else {
                    return monthsShortWithDots$2[m.month()];
                }
            },

            monthsRegex: monthsRegex$9,
            monthsShortRegex: monthsRegex$9,
            monthsStrictRegex: /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december)/i,
            monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,

            monthsParse: monthsParse$9,
            longMonthsParse: monthsParse$9,
            shortMonthsParse: monthsParse$9,

            weekdays: 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split(
                '_'
            ),
            weekdaysShort: 'zo._ma._di._wo._do._vr._za.'.split('_'),
            weekdaysMin: 'zo_ma_di_wo_do_vr_za'.split('_'),
            weekdaysParseExact: true,
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'DD-MM-YYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY HH:mm',
                LLLL: 'dddd D MMMM YYYY HH:mm',
            },
            calendar: {
                sameDay: '[vandaag om] LT',
                nextDay: '[morgen om] LT',
                nextWeek: 'dddd [om] LT',
                lastDay: '[gisteren om] LT',
                lastWeek: '[afgelopen] dddd [om] LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: 'over %s',
                past: '%s geleden',
                s: 'een paar seconden',
                ss: '%d seconden',
                m: 'één minuut',
                mm: '%d minuten',
                h: 'één uur',
                hh: '%d uur',
                d: 'één dag',
                dd: '%d dagen',
                w: 'één week',
                ww: '%d weken',
                M: 'één maand',
                MM: '%d maanden',
                y: 'één jaar',
                yy: '%d jaar',
            },
            dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
            ordinal: function (number) {
                return (
                    number +
                    (number === 1 || number === 8 || number >= 20 ? 'ste' : 'de')
                );
            },
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 4, // The week that contains Jan 4th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        hooks.defineLocale('nn', {
            months: 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split(
                '_'
            ),
            monthsShort: 'jan._feb._mars_apr._mai_juni_juli_aug._sep._okt._nov._des.'.split(
                '_'
            ),
            monthsParseExact: true,
            weekdays: 'sundag_måndag_tysdag_onsdag_torsdag_fredag_laurdag'.split('_'),
            weekdaysShort: 'su._må._ty._on._to._fr._lau.'.split('_'),
            weekdaysMin: 'su_må_ty_on_to_fr_la'.split('_'),
            weekdaysParseExact: true,
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'DD.MM.YYYY',
                LL: 'D. MMMM YYYY',
                LLL: 'D. MMMM YYYY [kl.] H:mm',
                LLLL: 'dddd D. MMMM YYYY [kl.] HH:mm',
            },
            calendar: {
                sameDay: '[I dag klokka] LT',
                nextDay: '[I morgon klokka] LT',
                nextWeek: 'dddd [klokka] LT',
                lastDay: '[I går klokka] LT',
                lastWeek: '[Føregåande] dddd [klokka] LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: 'om %s',
                past: '%s sidan',
                s: 'nokre sekund',
                ss: '%d sekund',
                m: 'eit minutt',
                mm: '%d minutt',
                h: 'ein time',
                hh: '%d timar',
                d: 'ein dag',
                dd: '%d dagar',
                w: 'ei veke',
                ww: '%d veker',
                M: 'ein månad',
                MM: '%d månader',
                y: 'eit år',
                yy: '%d år',
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: '%d.',
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 4, // The week that contains Jan 4th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        hooks.defineLocale('oc-lnc', {
            months: {
                standalone: 'genièr_febrièr_març_abril_mai_junh_julhet_agost_setembre_octòbre_novembre_decembre'.split(
                    '_'
                ),
                format: "de genièr_de febrièr_de març_d'abril_de mai_de junh_de julhet_d'agost_de setembre_d'octòbre_de novembre_de decembre".split(
                    '_'
                ),
                isFormat: /D[oD]?(\s)+MMMM/,
            },
            monthsShort: 'gen._febr._març_abr._mai_junh_julh._ago._set._oct._nov._dec.'.split(
                '_'
            ),
            monthsParseExact: true,
            weekdays: 'dimenge_diluns_dimars_dimècres_dijòus_divendres_dissabte'.split(
                '_'
            ),
            weekdaysShort: 'dg._dl._dm._dc._dj._dv._ds.'.split('_'),
            weekdaysMin: 'dg_dl_dm_dc_dj_dv_ds'.split('_'),
            weekdaysParseExact: true,
            longDateFormat: {
                LT: 'H:mm',
                LTS: 'H:mm:ss',
                L: 'DD/MM/YYYY',
                LL: 'D MMMM [de] YYYY',
                ll: 'D MMM YYYY',
                LLL: 'D MMMM [de] YYYY [a] H:mm',
                lll: 'D MMM YYYY, H:mm',
                LLLL: 'dddd D MMMM [de] YYYY [a] H:mm',
                llll: 'ddd D MMM YYYY, H:mm',
            },
            calendar: {
                sameDay: '[uèi a] LT',
                nextDay: '[deman a] LT',
                nextWeek: 'dddd [a] LT',
                lastDay: '[ièr a] LT',
                lastWeek: 'dddd [passat a] LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: "d'aquí %s",
                past: 'fa %s',
                s: 'unas segondas',
                ss: '%d segondas',
                m: 'una minuta',
                mm: '%d minutas',
                h: 'una ora',
                hh: '%d oras',
                d: 'un jorn',
                dd: '%d jorns',
                M: 'un mes',
                MM: '%d meses',
                y: 'un an',
                yy: '%d ans',
            },
            dayOfMonthOrdinalParse: /\d{1,2}(r|n|t|è|a)/,
            ordinal: function (number, period) {
                var output =
                    number === 1
                        ? 'r'
                        : number === 2
                        ? 'n'
                        : number === 3
                        ? 'r'
                        : number === 4
                        ? 't'
                        : 'è';
                if (period === 'w' || period === 'W') {
                    output = 'a';
                }
                return number + output;
            },
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 4,
            },
        });

        //! moment.js locale configuration

        var symbolMap$f = {
                1: '੧',
                2: '੨',
                3: '੩',
                4: '੪',
                5: '੫',
                6: '੬',
                7: '੭',
                8: '੮',
                9: '੯',
                0: '੦',
            },
            numberMap$e = {
                '੧': '1',
                '੨': '2',
                '੩': '3',
                '੪': '4',
                '੫': '5',
                '੬': '6',
                '੭': '7',
                '੮': '8',
                '੯': '9',
                '੦': '0',
            };

        hooks.defineLocale('pa-in', {
            // There are months name as per Nanakshahi Calendar but they are not used as rigidly in modern Punjabi.
            months: 'ਜਨਵਰੀ_ਫ਼ਰਵਰੀ_ਮਾਰਚ_ਅਪ੍ਰੈਲ_ਮਈ_ਜੂਨ_ਜੁਲਾਈ_ਅਗਸਤ_ਸਤੰਬਰ_ਅਕਤੂਬਰ_ਨਵੰਬਰ_ਦਸੰਬਰ'.split(
                '_'
            ),
            monthsShort: 'ਜਨਵਰੀ_ਫ਼ਰਵਰੀ_ਮਾਰਚ_ਅਪ੍ਰੈਲ_ਮਈ_ਜੂਨ_ਜੁਲਾਈ_ਅਗਸਤ_ਸਤੰਬਰ_ਅਕਤੂਬਰ_ਨਵੰਬਰ_ਦਸੰਬਰ'.split(
                '_'
            ),
            weekdays: 'ਐਤਵਾਰ_ਸੋਮਵਾਰ_ਮੰਗਲਵਾਰ_ਬੁਧਵਾਰ_ਵੀਰਵਾਰ_ਸ਼ੁੱਕਰਵਾਰ_ਸ਼ਨੀਚਰਵਾਰ'.split(
                '_'
            ),
            weekdaysShort: 'ਐਤ_ਸੋਮ_ਮੰਗਲ_ਬੁਧ_ਵੀਰ_ਸ਼ੁਕਰ_ਸ਼ਨੀ'.split('_'),
            weekdaysMin: 'ਐਤ_ਸੋਮ_ਮੰਗਲ_ਬੁਧ_ਵੀਰ_ਸ਼ੁਕਰ_ਸ਼ਨੀ'.split('_'),
            longDateFormat: {
                LT: 'A h:mm ਵਜੇ',
                LTS: 'A h:mm:ss ਵਜੇ',
                L: 'DD/MM/YYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY, A h:mm ਵਜੇ',
                LLLL: 'dddd, D MMMM YYYY, A h:mm ਵਜੇ',
            },
            calendar: {
                sameDay: '[ਅਜ] LT',
                nextDay: '[ਕਲ] LT',
                nextWeek: '[ਅਗਲਾ] dddd, LT',
                lastDay: '[ਕਲ] LT',
                lastWeek: '[ਪਿਛਲੇ] dddd, LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: '%s ਵਿੱਚ',
                past: '%s ਪਿਛਲੇ',
                s: 'ਕੁਝ ਸਕਿੰਟ',
                ss: '%d ਸਕਿੰਟ',
                m: 'ਇਕ ਮਿੰਟ',
                mm: '%d ਮਿੰਟ',
                h: 'ਇੱਕ ਘੰਟਾ',
                hh: '%d ਘੰਟੇ',
                d: 'ਇੱਕ ਦਿਨ',
                dd: '%d ਦਿਨ',
                M: 'ਇੱਕ ਮਹੀਨਾ',
                MM: '%d ਮਹੀਨੇ',
                y: 'ਇੱਕ ਸਾਲ',
                yy: '%d ਸਾਲ',
            },
            preparse: function (string) {
                return string.replace(/[੧੨੩੪੫੬੭੮੯੦]/g, function (match) {
                    return numberMap$e[match];
                });
            },
            postformat: function (string) {
                return string.replace(/\d/g, function (match) {
                    return symbolMap$f[match];
                });
            },
            // Punjabi notation for meridiems are quite fuzzy in practice. While there exists
            // a rigid notion of a 'Pahar' it is not used as rigidly in modern Punjabi.
            meridiemParse: /ਰਾਤ|ਸਵੇਰ|ਦੁਪਹਿਰ|ਸ਼ਾਮ/,
            meridiemHour: function (hour, meridiem) {
                if (hour === 12) {
                    hour = 0;
                }
                if (meridiem === 'ਰਾਤ') {
                    return hour < 4 ? hour : hour + 12;
                } else if (meridiem === 'ਸਵੇਰ') {
                    return hour;
                } else if (meridiem === 'ਦੁਪਹਿਰ') {
                    return hour >= 10 ? hour : hour + 12;
                } else if (meridiem === 'ਸ਼ਾਮ') {
                    return hour + 12;
                }
            },
            meridiem: function (hour, minute, isLower) {
                if (hour < 4) {
                    return 'ਰਾਤ';
                } else if (hour < 10) {
                    return 'ਸਵੇਰ';
                } else if (hour < 17) {
                    return 'ਦੁਪਹਿਰ';
                } else if (hour < 20) {
                    return 'ਸ਼ਾਮ';
                } else {
                    return 'ਰਾਤ';
                }
            },
            week: {
                dow: 0, // Sunday is the first day of the week.
                doy: 6, // The week that contains Jan 6th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        var monthsNominative = 'styczeń_luty_marzec_kwiecień_maj_czerwiec_lipiec_sierpień_wrzesień_październik_listopad_grudzień'.split(
                '_'
            ),
            monthsSubjective = 'stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_września_października_listopada_grudnia'.split(
                '_'
            ),
            monthsParse$a = [
                /^sty/i,
                /^lut/i,
                /^mar/i,
                /^kwi/i,
                /^maj/i,
                /^cze/i,
                /^lip/i,
                /^sie/i,
                /^wrz/i,
                /^paź/i,
                /^lis/i,
                /^gru/i,
            ];
        function plural$3(n) {
            return n % 10 < 5 && n % 10 > 1 && ~~(n / 10) % 10 !== 1;
        }
        function translate$8(number, withoutSuffix, key) {
            var result = number + ' ';
            switch (key) {
                case 'ss':
                    return result + (plural$3(number) ? 'sekundy' : 'sekund');
                case 'm':
                    return withoutSuffix ? 'minuta' : 'minutę';
                case 'mm':
                    return result + (plural$3(number) ? 'minuty' : 'minut');
                case 'h':
                    return withoutSuffix ? 'godzina' : 'godzinę';
                case 'hh':
                    return result + (plural$3(number) ? 'godziny' : 'godzin');
                case 'ww':
                    return result + (plural$3(number) ? 'tygodnie' : 'tygodni');
                case 'MM':
                    return result + (plural$3(number) ? 'miesiące' : 'miesięcy');
                case 'yy':
                    return result + (plural$3(number) ? 'lata' : 'lat');
            }
        }

        hooks.defineLocale('pl', {
            months: function (momentToFormat, format) {
                if (!momentToFormat) {
                    return monthsNominative;
                } else if (/D MMMM/.test(format)) {
                    return monthsSubjective[momentToFormat.month()];
                } else {
                    return monthsNominative[momentToFormat.month()];
                }
            },
            monthsShort: 'sty_lut_mar_kwi_maj_cze_lip_sie_wrz_paź_lis_gru'.split('_'),
            monthsParse: monthsParse$a,
            longMonthsParse: monthsParse$a,
            shortMonthsParse: monthsParse$a,
            weekdays: 'niedziela_poniedziałek_wtorek_środa_czwartek_piątek_sobota'.split(
                '_'
            ),
            weekdaysShort: 'ndz_pon_wt_śr_czw_pt_sob'.split('_'),
            weekdaysMin: 'Nd_Pn_Wt_Śr_Cz_Pt_So'.split('_'),
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'DD.MM.YYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY HH:mm',
                LLLL: 'dddd, D MMMM YYYY HH:mm',
            },
            calendar: {
                sameDay: '[Dziś o] LT',
                nextDay: '[Jutro o] LT',
                nextWeek: function () {
                    switch (this.day()) {
                        case 0:
                            return '[W niedzielę o] LT';

                        case 2:
                            return '[We wtorek o] LT';

                        case 3:
                            return '[W środę o] LT';

                        case 6:
                            return '[W sobotę o] LT';

                        default:
                            return '[W] dddd [o] LT';
                    }
                },
                lastDay: '[Wczoraj o] LT',
                lastWeek: function () {
                    switch (this.day()) {
                        case 0:
                            return '[W zeszłą niedzielę o] LT';
                        case 3:
                            return '[W zeszłą środę o] LT';
                        case 6:
                            return '[W zeszłą sobotę o] LT';
                        default:
                            return '[W zeszły] dddd [o] LT';
                    }
                },
                sameElse: 'L',
            },
            relativeTime: {
                future: 'za %s',
                past: '%s temu',
                s: 'kilka sekund',
                ss: translate$8,
                m: translate$8,
                mm: translate$8,
                h: translate$8,
                hh: translate$8,
                d: '1 dzień',
                dd: '%d dni',
                w: 'tydzień',
                ww: translate$8,
                M: 'miesiąc',
                MM: translate$8,
                y: 'rok',
                yy: translate$8,
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: '%d.',
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 4, // The week that contains Jan 4th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        hooks.defineLocale('pt-br', {
            months: 'janeiro_fevereiro_março_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro'.split(
                '_'
            ),
            monthsShort: 'jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez'.split('_'),
            weekdays: 'domingo_segunda-feira_terça-feira_quarta-feira_quinta-feira_sexta-feira_sábado'.split(
                '_'
            ),
            weekdaysShort: 'dom_seg_ter_qua_qui_sex_sáb'.split('_'),
            weekdaysMin: 'do_2ª_3ª_4ª_5ª_6ª_sá'.split('_'),
            weekdaysParseExact: true,
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'DD/MM/YYYY',
                LL: 'D [de] MMMM [de] YYYY',
                LLL: 'D [de] MMMM [de] YYYY [às] HH:mm',
                LLLL: 'dddd, D [de] MMMM [de] YYYY [às] HH:mm',
            },
            calendar: {
                sameDay: '[Hoje às] LT',
                nextDay: '[Amanhã às] LT',
                nextWeek: 'dddd [às] LT',
                lastDay: '[Ontem às] LT',
                lastWeek: function () {
                    return this.day() === 0 || this.day() === 6
                        ? '[Último] dddd [às] LT' // Saturday + Sunday
                        : '[Última] dddd [às] LT'; // Monday - Friday
                },
                sameElse: 'L',
            },
            relativeTime: {
                future: 'em %s',
                past: 'há %s',
                s: 'poucos segundos',
                ss: '%d segundos',
                m: 'um minuto',
                mm: '%d minutos',
                h: 'uma hora',
                hh: '%d horas',
                d: 'um dia',
                dd: '%d dias',
                M: 'um mês',
                MM: '%d meses',
                y: 'um ano',
                yy: '%d anos',
            },
            dayOfMonthOrdinalParse: /\d{1,2}º/,
            ordinal: '%dº',
            invalidDate: 'Data inválida',
        });

        //! moment.js locale configuration

        hooks.defineLocale('pt', {
            months: 'janeiro_fevereiro_março_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro'.split(
                '_'
            ),
            monthsShort: 'jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez'.split('_'),
            weekdays: 'Domingo_Segunda-feira_Terça-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sábado'.split(
                '_'
            ),
            weekdaysShort: 'Dom_Seg_Ter_Qua_Qui_Sex_Sáb'.split('_'),
            weekdaysMin: 'Do_2ª_3ª_4ª_5ª_6ª_Sá'.split('_'),
            weekdaysParseExact: true,
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'DD/MM/YYYY',
                LL: 'D [de] MMMM [de] YYYY',
                LLL: 'D [de] MMMM [de] YYYY HH:mm',
                LLLL: 'dddd, D [de] MMMM [de] YYYY HH:mm',
            },
            calendar: {
                sameDay: '[Hoje às] LT',
                nextDay: '[Amanhã às] LT',
                nextWeek: 'dddd [às] LT',
                lastDay: '[Ontem às] LT',
                lastWeek: function () {
                    return this.day() === 0 || this.day() === 6
                        ? '[Último] dddd [às] LT' // Saturday + Sunday
                        : '[Última] dddd [às] LT'; // Monday - Friday
                },
                sameElse: 'L',
            },
            relativeTime: {
                future: 'em %s',
                past: 'há %s',
                s: 'segundos',
                ss: '%d segundos',
                m: 'um minuto',
                mm: '%d minutos',
                h: 'uma hora',
                hh: '%d horas',
                d: 'um dia',
                dd: '%d dias',
                w: 'uma semana',
                ww: '%d semanas',
                M: 'um mês',
                MM: '%d meses',
                y: 'um ano',
                yy: '%d anos',
            },
            dayOfMonthOrdinalParse: /\d{1,2}º/,
            ordinal: '%dº',
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 4, // The week that contains Jan 4th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        function relativeTimeWithPlural$2(number, withoutSuffix, key) {
            var format = {
                    ss: 'secunde',
                    mm: 'minute',
                    hh: 'ore',
                    dd: 'zile',
                    ww: 'săptămâni',
                    MM: 'luni',
                    yy: 'ani',
                },
                separator = ' ';
            if (number % 100 >= 20 || (number >= 100 && number % 100 === 0)) {
                separator = ' de ';
            }
            return number + separator + format[key];
        }

        hooks.defineLocale('ro', {
            months: 'ianuarie_februarie_martie_aprilie_mai_iunie_iulie_august_septembrie_octombrie_noiembrie_decembrie'.split(
                '_'
            ),
            monthsShort: 'ian._feb._mart._apr._mai_iun._iul._aug._sept._oct._nov._dec.'.split(
                '_'
            ),
            monthsParseExact: true,
            weekdays: 'duminică_luni_marți_miercuri_joi_vineri_sâmbătă'.split('_'),
            weekdaysShort: 'Dum_Lun_Mar_Mie_Joi_Vin_Sâm'.split('_'),
            weekdaysMin: 'Du_Lu_Ma_Mi_Jo_Vi_Sâ'.split('_'),
            longDateFormat: {
                LT: 'H:mm',
                LTS: 'H:mm:ss',
                L: 'DD.MM.YYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY H:mm',
                LLLL: 'dddd, D MMMM YYYY H:mm',
            },
            calendar: {
                sameDay: '[azi la] LT',
                nextDay: '[mâine la] LT',
                nextWeek: 'dddd [la] LT',
                lastDay: '[ieri la] LT',
                lastWeek: '[fosta] dddd [la] LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: 'peste %s',
                past: '%s în urmă',
                s: 'câteva secunde',
                ss: relativeTimeWithPlural$2,
                m: 'un minut',
                mm: relativeTimeWithPlural$2,
                h: 'o oră',
                hh: relativeTimeWithPlural$2,
                d: 'o zi',
                dd: relativeTimeWithPlural$2,
                w: 'o săptămână',
                ww: relativeTimeWithPlural$2,
                M: 'o lună',
                MM: relativeTimeWithPlural$2,
                y: 'un an',
                yy: relativeTimeWithPlural$2,
            },
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 7, // The week that contains Jan 7th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        function plural$4(word, num) {
            var forms = word.split('_');
            return num % 10 === 1 && num % 100 !== 11
                ? forms[0]
                : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20)
                ? forms[1]
                : forms[2];
        }
        function relativeTimeWithPlural$3(number, withoutSuffix, key) {
            var format = {
                ss: withoutSuffix ? 'секунда_секунды_секунд' : 'секунду_секунды_секунд',
                mm: withoutSuffix ? 'минута_минуты_минут' : 'минуту_минуты_минут',
                hh: 'час_часа_часов',
                dd: 'день_дня_дней',
                ww: 'неделя_недели_недель',
                MM: 'месяц_месяца_месяцев',
                yy: 'год_года_лет',
            };
            if (key === 'm') {
                return withoutSuffix ? 'минута' : 'минуту';
            } else {
                return number + ' ' + plural$4(format[key], +number);
            }
        }
        var monthsParse$b = [
            /^янв/i,
            /^фев/i,
            /^мар/i,
            /^апр/i,
            /^ма[йя]/i,
            /^июн/i,
            /^июл/i,
            /^авг/i,
            /^сен/i,
            /^окт/i,
            /^ноя/i,
            /^дек/i,
        ];

        // http://new.gramota.ru/spravka/rules/139-prop : § 103
        // Сокращения месяцев: http://new.gramota.ru/spravka/buro/search-answer?s=242637
        // CLDR data:          http://www.unicode.org/cldr/charts/28/summary/ru.html#1753
        hooks.defineLocale('ru', {
            months: {
                format: 'января_февраля_марта_апреля_мая_июня_июля_августа_сентября_октября_ноября_декабря'.split(
                    '_'
                ),
                standalone: 'январь_февраль_март_апрель_май_июнь_июль_август_сентябрь_октябрь_ноябрь_декабрь'.split(
                    '_'
                ),
            },
            monthsShort: {
                // по CLDR именно "июл." и "июн.", но какой смысл менять букву на точку?
                format: 'янв._февр._мар._апр._мая_июня_июля_авг._сент._окт._нояб._дек.'.split(
                    '_'
                ),
                standalone: 'янв._февр._март_апр._май_июнь_июль_авг._сент._окт._нояб._дек.'.split(
                    '_'
                ),
            },
            weekdays: {
                standalone: 'воскресенье_понедельник_вторник_среда_четверг_пятница_суббота'.split(
                    '_'
                ),
                format: 'воскресенье_понедельник_вторник_среду_четверг_пятницу_субботу'.split(
                    '_'
                ),
                isFormat: /\[ ?[Вв] ?(?:прошлую|следующую|эту)? ?] ?dddd/,
            },
            weekdaysShort: 'вс_пн_вт_ср_чт_пт_сб'.split('_'),
            weekdaysMin: 'вс_пн_вт_ср_чт_пт_сб'.split('_'),
            monthsParse: monthsParse$b,
            longMonthsParse: monthsParse$b,
            shortMonthsParse: monthsParse$b,

            // полные названия с падежами, по три буквы, для некоторых, по 4 буквы, сокращения с точкой и без точки
            monthsRegex: /^(январ[ья]|янв\.?|феврал[ья]|февр?\.?|марта?|мар\.?|апрел[ья]|апр\.?|ма[йя]|июн[ья]|июн\.?|июл[ья]|июл\.?|августа?|авг\.?|сентябр[ья]|сент?\.?|октябр[ья]|окт\.?|ноябр[ья]|нояб?\.?|декабр[ья]|дек\.?)/i,

            // копия предыдущего
            monthsShortRegex: /^(январ[ья]|янв\.?|феврал[ья]|февр?\.?|марта?|мар\.?|апрел[ья]|апр\.?|ма[йя]|июн[ья]|июн\.?|июл[ья]|июл\.?|августа?|авг\.?|сентябр[ья]|сент?\.?|октябр[ья]|окт\.?|ноябр[ья]|нояб?\.?|декабр[ья]|дек\.?)/i,

            // полные названия с падежами
            monthsStrictRegex: /^(январ[яь]|феврал[яь]|марта?|апрел[яь]|ма[яй]|июн[яь]|июл[яь]|августа?|сентябр[яь]|октябр[яь]|ноябр[яь]|декабр[яь])/i,

            // Выражение, которое соответствует только сокращённым формам
            monthsShortStrictRegex: /^(янв\.|февр?\.|мар[т.]|апр\.|ма[яй]|июн[ья.]|июл[ья.]|авг\.|сент?\.|окт\.|нояб?\.|дек\.)/i,
            longDateFormat: {
                LT: 'H:mm',
                LTS: 'H:mm:ss',
                L: 'DD.MM.YYYY',
                LL: 'D MMMM YYYY г.',
                LLL: 'D MMMM YYYY г., H:mm',
                LLLL: 'dddd, D MMMM YYYY г., H:mm',
            },
            calendar: {
                sameDay: '[Сегодня, в] LT',
                nextDay: '[Завтра, в] LT',
                lastDay: '[Вчера, в] LT',
                nextWeek: function (now) {
                    if (now.week() !== this.week()) {
                        switch (this.day()) {
                            case 0:
                                return '[В следующее] dddd, [в] LT';
                            case 1:
                            case 2:
                            case 4:
                                return '[В следующий] dddd, [в] LT';
                            case 3:
                            case 5:
                            case 6:
                                return '[В следующую] dddd, [в] LT';
                        }
                    } else {
                        if (this.day() === 2) {
                            return '[Во] dddd, [в] LT';
                        } else {
                            return '[В] dddd, [в] LT';
                        }
                    }
                },
                lastWeek: function (now) {
                    if (now.week() !== this.week()) {
                        switch (this.day()) {
                            case 0:
                                return '[В прошлое] dddd, [в] LT';
                            case 1:
                            case 2:
                            case 4:
                                return '[В прошлый] dddd, [в] LT';
                            case 3:
                            case 5:
                            case 6:
                                return '[В прошлую] dddd, [в] LT';
                        }
                    } else {
                        if (this.day() === 2) {
                            return '[Во] dddd, [в] LT';
                        } else {
                            return '[В] dddd, [в] LT';
                        }
                    }
                },
                sameElse: 'L',
            },
            relativeTime: {
                future: 'через %s',
                past: '%s назад',
                s: 'несколько секунд',
                ss: relativeTimeWithPlural$3,
                m: relativeTimeWithPlural$3,
                mm: relativeTimeWithPlural$3,
                h: 'час',
                hh: relativeTimeWithPlural$3,
                d: 'день',
                dd: relativeTimeWithPlural$3,
                w: 'неделя',
                ww: relativeTimeWithPlural$3,
                M: 'месяц',
                MM: relativeTimeWithPlural$3,
                y: 'год',
                yy: relativeTimeWithPlural$3,
            },
            meridiemParse: /ночи|утра|дня|вечера/i,
            isPM: function (input) {
                return /^(дня|вечера)$/.test(input);
            },
            meridiem: function (hour, minute, isLower) {
                if (hour < 4) {
                    return 'ночи';
                } else if (hour < 12) {
                    return 'утра';
                } else if (hour < 17) {
                    return 'дня';
                } else {
                    return 'вечера';
                }
            },
            dayOfMonthOrdinalParse: /\d{1,2}-(й|го|я)/,
            ordinal: function (number, period) {
                switch (period) {
                    case 'M':
                    case 'd':
                    case 'DDD':
                        return number + '-й';
                    case 'D':
                        return number + '-го';
                    case 'w':
                    case 'W':
                        return number + '-я';
                    default:
                        return number;
                }
            },
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 4, // The week that contains Jan 4th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        var months$9 = [
                'جنوري',
                'فيبروري',
                'مارچ',
                'اپريل',
                'مئي',
                'جون',
                'جولاءِ',
                'آگسٽ',
                'سيپٽمبر',
                'آڪٽوبر',
                'نومبر',
                'ڊسمبر',
            ],
            days$1 = ['آچر', 'سومر', 'اڱارو', 'اربع', 'خميس', 'جمع', 'ڇنڇر'];

        hooks.defineLocale('sd', {
            months: months$9,
            monthsShort: months$9,
            weekdays: days$1,
            weekdaysShort: days$1,
            weekdaysMin: days$1,
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'DD/MM/YYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY HH:mm',
                LLLL: 'dddd، D MMMM YYYY HH:mm',
            },
            meridiemParse: /صبح|شام/,
            isPM: function (input) {
                return 'شام' === input;
            },
            meridiem: function (hour, minute, isLower) {
                if (hour < 12) {
                    return 'صبح';
                }
                return 'شام';
            },
            calendar: {
                sameDay: '[اڄ] LT',
                nextDay: '[سڀاڻي] LT',
                nextWeek: 'dddd [اڳين هفتي تي] LT',
                lastDay: '[ڪالهه] LT',
                lastWeek: '[گزريل هفتي] dddd [تي] LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: '%s پوء',
                past: '%s اڳ',
                s: 'چند سيڪنڊ',
                ss: '%d سيڪنڊ',
                m: 'هڪ منٽ',
                mm: '%d منٽ',
                h: 'هڪ ڪلاڪ',
                hh: '%d ڪلاڪ',
                d: 'هڪ ڏينهن',
                dd: '%d ڏينهن',
                M: 'هڪ مهينو',
                MM: '%d مهينا',
                y: 'هڪ سال',
                yy: '%d سال',
            },
            preparse: function (string) {
                return string.replace(/،/g, ',');
            },
            postformat: function (string) {
                return string.replace(/,/g, '،');
            },
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 4, // The week that contains Jan 4th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        hooks.defineLocale('se', {
            months: 'ođđajagemánnu_guovvamánnu_njukčamánnu_cuoŋománnu_miessemánnu_geassemánnu_suoidnemánnu_borgemánnu_čakčamánnu_golggotmánnu_skábmamánnu_juovlamánnu'.split(
                '_'
            ),
            monthsShort: 'ođđj_guov_njuk_cuo_mies_geas_suoi_borg_čakč_golg_skáb_juov'.split(
                '_'
            ),
            weekdays: 'sotnabeaivi_vuossárga_maŋŋebárga_gaskavahkku_duorastat_bearjadat_lávvardat'.split(
                '_'
            ),
            weekdaysShort: 'sotn_vuos_maŋ_gask_duor_bear_láv'.split('_'),
            weekdaysMin: 's_v_m_g_d_b_L'.split('_'),
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'DD.MM.YYYY',
                LL: 'MMMM D. [b.] YYYY',
                LLL: 'MMMM D. [b.] YYYY [ti.] HH:mm',
                LLLL: 'dddd, MMMM D. [b.] YYYY [ti.] HH:mm',
            },
            calendar: {
                sameDay: '[otne ti] LT',
                nextDay: '[ihttin ti] LT',
                nextWeek: 'dddd [ti] LT',
                lastDay: '[ikte ti] LT',
                lastWeek: '[ovddit] dddd [ti] LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: '%s geažes',
                past: 'maŋit %s',
                s: 'moadde sekunddat',
                ss: '%d sekunddat',
                m: 'okta minuhta',
                mm: '%d minuhtat',
                h: 'okta diimmu',
                hh: '%d diimmut',
                d: 'okta beaivi',
                dd: '%d beaivvit',
                M: 'okta mánnu',
                MM: '%d mánut',
                y: 'okta jahki',
                yy: '%d jagit',
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: '%d.',
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 4, // The week that contains Jan 4th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        /*jshint -W100*/
        hooks.defineLocale('si', {
            months: 'ජනවාරි_පෙබරවාරි_මාර්තු_අප්‍රේල්_මැයි_ජූනි_ජූලි_අගෝස්තු_සැප්තැම්බර්_ඔක්තෝබර්_නොවැම්බර්_දෙසැම්බර්'.split(
                '_'
            ),
            monthsShort: 'ජන_පෙබ_මාර්_අප්_මැයි_ජූනි_ජූලි_අගෝ_සැප්_ඔක්_නොවැ_දෙසැ'.split(
                '_'
            ),
            weekdays: 'ඉරිදා_සඳුදා_අඟහරුවාදා_බදාදා_බ්‍රහස්පතින්දා_සිකුරාදා_සෙනසුරාදා'.split(
                '_'
            ),
            weekdaysShort: 'ඉරි_සඳු_අඟ_බදා_බ්‍රහ_සිකු_සෙන'.split('_'),
            weekdaysMin: 'ඉ_ස_අ_බ_බ්‍ර_සි_සෙ'.split('_'),
            weekdaysParseExact: true,
            longDateFormat: {
                LT: 'a h:mm',
                LTS: 'a h:mm:ss',
                L: 'YYYY/MM/DD',
                LL: 'YYYY MMMM D',
                LLL: 'YYYY MMMM D, a h:mm',
                LLLL: 'YYYY MMMM D [වැනි] dddd, a h:mm:ss',
            },
            calendar: {
                sameDay: '[අද] LT[ට]',
                nextDay: '[හෙට] LT[ට]',
                nextWeek: 'dddd LT[ට]',
                lastDay: '[ඊයේ] LT[ට]',
                lastWeek: '[පසුගිය] dddd LT[ට]',
                sameElse: 'L',
            },
            relativeTime: {
                future: '%sකින්',
                past: '%sකට පෙර',
                s: 'තත්පර කිහිපය',
                ss: 'තත්පර %d',
                m: 'මිනිත්තුව',
                mm: 'මිනිත්තු %d',
                h: 'පැය',
                hh: 'පැය %d',
                d: 'දිනය',
                dd: 'දින %d',
                M: 'මාසය',
                MM: 'මාස %d',
                y: 'වසර',
                yy: 'වසර %d',
            },
            dayOfMonthOrdinalParse: /\d{1,2} වැනි/,
            ordinal: function (number) {
                return number + ' වැනි';
            },
            meridiemParse: /පෙර වරු|පස් වරු|පෙ.ව|ප.ව./,
            isPM: function (input) {
                return input === 'ප.ව.' || input === 'පස් වරු';
            },
            meridiem: function (hours, minutes, isLower) {
                if (hours > 11) {
                    return isLower ? 'ප.ව.' : 'පස් වරු';
                } else {
                    return isLower ? 'පෙ.ව.' : 'පෙර වරු';
                }
            },
        });

        //! moment.js locale configuration

        var months$a = 'január_február_marec_apríl_máj_jún_júl_august_september_október_november_december'.split(
                '_'
            ),
            monthsShort$7 = 'jan_feb_mar_apr_máj_jún_júl_aug_sep_okt_nov_dec'.split('_');
        function plural$5(n) {
            return n > 1 && n < 5;
        }
        function translate$9(number, withoutSuffix, key, isFuture) {
            var result = number + ' ';
            switch (key) {
                case 's': // a few seconds / in a few seconds / a few seconds ago
                    return withoutSuffix || isFuture ? 'pár sekúnd' : 'pár sekundami';
                case 'ss': // 9 seconds / in 9 seconds / 9 seconds ago
                    if (withoutSuffix || isFuture) {
                        return result + (plural$5(number) ? 'sekundy' : 'sekúnd');
                    } else {
                        return result + 'sekundami';
                    }
                case 'm': // a minute / in a minute / a minute ago
                    return withoutSuffix ? 'minúta' : isFuture ? 'minútu' : 'minútou';
                case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago
                    if (withoutSuffix || isFuture) {
                        return result + (plural$5(number) ? 'minúty' : 'minút');
                    } else {
                        return result + 'minútami';
                    }
                case 'h': // an hour / in an hour / an hour ago
                    return withoutSuffix ? 'hodina' : isFuture ? 'hodinu' : 'hodinou';
                case 'hh': // 9 hours / in 9 hours / 9 hours ago
                    if (withoutSuffix || isFuture) {
                        return result + (plural$5(number) ? 'hodiny' : 'hodín');
                    } else {
                        return result + 'hodinami';
                    }
                case 'd': // a day / in a day / a day ago
                    return withoutSuffix || isFuture ? 'deň' : 'dňom';
                case 'dd': // 9 days / in 9 days / 9 days ago
                    if (withoutSuffix || isFuture) {
                        return result + (plural$5(number) ? 'dni' : 'dní');
                    } else {
                        return result + 'dňami';
                    }
                case 'M': // a month / in a month / a month ago
                    return withoutSuffix || isFuture ? 'mesiac' : 'mesiacom';
                case 'MM': // 9 months / in 9 months / 9 months ago
                    if (withoutSuffix || isFuture) {
                        return result + (plural$5(number) ? 'mesiace' : 'mesiacov');
                    } else {
                        return result + 'mesiacmi';
                    }
                case 'y': // a year / in a year / a year ago
                    return withoutSuffix || isFuture ? 'rok' : 'rokom';
                case 'yy': // 9 years / in 9 years / 9 years ago
                    if (withoutSuffix || isFuture) {
                        return result + (plural$5(number) ? 'roky' : 'rokov');
                    } else {
                        return result + 'rokmi';
                    }
            }
        }

        hooks.defineLocale('sk', {
            months: months$a,
            monthsShort: monthsShort$7,
            weekdays: 'nedeľa_pondelok_utorok_streda_štvrtok_piatok_sobota'.split('_'),
            weekdaysShort: 'ne_po_ut_st_št_pi_so'.split('_'),
            weekdaysMin: 'ne_po_ut_st_št_pi_so'.split('_'),
            longDateFormat: {
                LT: 'H:mm',
                LTS: 'H:mm:ss',
                L: 'DD.MM.YYYY',
                LL: 'D. MMMM YYYY',
                LLL: 'D. MMMM YYYY H:mm',
                LLLL: 'dddd D. MMMM YYYY H:mm',
            },
            calendar: {
                sameDay: '[dnes o] LT',
                nextDay: '[zajtra o] LT',
                nextWeek: function () {
                    switch (this.day()) {
                        case 0:
                            return '[v nedeľu o] LT';
                        case 1:
                        case 2:
                            return '[v] dddd [o] LT';
                        case 3:
                            return '[v stredu o] LT';
                        case 4:
                            return '[vo štvrtok o] LT';
                        case 5:
                            return '[v piatok o] LT';
                        case 6:
                            return '[v sobotu o] LT';
                    }
                },
                lastDay: '[včera o] LT',
                lastWeek: function () {
                    switch (this.day()) {
                        case 0:
                            return '[minulú nedeľu o] LT';
                        case 1:
                        case 2:
                            return '[minulý] dddd [o] LT';
                        case 3:
                            return '[minulú stredu o] LT';
                        case 4:
                        case 5:
                            return '[minulý] dddd [o] LT';
                        case 6:
                            return '[minulú sobotu o] LT';
                    }
                },
                sameElse: 'L',
            },
            relativeTime: {
                future: 'za %s',
                past: 'pred %s',
                s: translate$9,
                ss: translate$9,
                m: translate$9,
                mm: translate$9,
                h: translate$9,
                hh: translate$9,
                d: translate$9,
                dd: translate$9,
                M: translate$9,
                MM: translate$9,
                y: translate$9,
                yy: translate$9,
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: '%d.',
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 4, // The week that contains Jan 4th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        function processRelativeTime$7(number, withoutSuffix, key, isFuture) {
            var result = number + ' ';
            switch (key) {
                case 's':
                    return withoutSuffix || isFuture
                        ? 'nekaj sekund'
                        : 'nekaj sekundami';
                case 'ss':
                    if (number === 1) {
                        result += withoutSuffix ? 'sekundo' : 'sekundi';
                    } else if (number === 2) {
                        result += withoutSuffix || isFuture ? 'sekundi' : 'sekundah';
                    } else if (number < 5) {
                        result += withoutSuffix || isFuture ? 'sekunde' : 'sekundah';
                    } else {
                        result += 'sekund';
                    }
                    return result;
                case 'm':
                    return withoutSuffix ? 'ena minuta' : 'eno minuto';
                case 'mm':
                    if (number === 1) {
                        result += withoutSuffix ? 'minuta' : 'minuto';
                    } else if (number === 2) {
                        result += withoutSuffix || isFuture ? 'minuti' : 'minutama';
                    } else if (number < 5) {
                        result += withoutSuffix || isFuture ? 'minute' : 'minutami';
                    } else {
                        result += withoutSuffix || isFuture ? 'minut' : 'minutami';
                    }
                    return result;
                case 'h':
                    return withoutSuffix ? 'ena ura' : 'eno uro';
                case 'hh':
                    if (number === 1) {
                        result += withoutSuffix ? 'ura' : 'uro';
                    } else if (number === 2) {
                        result += withoutSuffix || isFuture ? 'uri' : 'urama';
                    } else if (number < 5) {
                        result += withoutSuffix || isFuture ? 'ure' : 'urami';
                    } else {
                        result += withoutSuffix || isFuture ? 'ur' : 'urami';
                    }
                    return result;
                case 'd':
                    return withoutSuffix || isFuture ? 'en dan' : 'enim dnem';
                case 'dd':
                    if (number === 1) {
                        result += withoutSuffix || isFuture ? 'dan' : 'dnem';
                    } else if (number === 2) {
                        result += withoutSuffix || isFuture ? 'dni' : 'dnevoma';
                    } else {
                        result += withoutSuffix || isFuture ? 'dni' : 'dnevi';
                    }
                    return result;
                case 'M':
                    return withoutSuffix || isFuture ? 'en mesec' : 'enim mesecem';
                case 'MM':
                    if (number === 1) {
                        result += withoutSuffix || isFuture ? 'mesec' : 'mesecem';
                    } else if (number === 2) {
                        result += withoutSuffix || isFuture ? 'meseca' : 'mesecema';
                    } else if (number < 5) {
                        result += withoutSuffix || isFuture ? 'mesece' : 'meseci';
                    } else {
                        result += withoutSuffix || isFuture ? 'mesecev' : 'meseci';
                    }
                    return result;
                case 'y':
                    return withoutSuffix || isFuture ? 'eno leto' : 'enim letom';
                case 'yy':
                    if (number === 1) {
                        result += withoutSuffix || isFuture ? 'leto' : 'letom';
                    } else if (number === 2) {
                        result += withoutSuffix || isFuture ? 'leti' : 'letoma';
                    } else if (number < 5) {
                        result += withoutSuffix || isFuture ? 'leta' : 'leti';
                    } else {
                        result += withoutSuffix || isFuture ? 'let' : 'leti';
                    }
                    return result;
            }
        }

        hooks.defineLocale('sl', {
            months: 'januar_februar_marec_april_maj_junij_julij_avgust_september_oktober_november_december'.split(
                '_'
            ),
            monthsShort: 'jan._feb._mar._apr._maj._jun._jul._avg._sep._okt._nov._dec.'.split(
                '_'
            ),
            monthsParseExact: true,
            weekdays: 'nedelja_ponedeljek_torek_sreda_četrtek_petek_sobota'.split('_'),
            weekdaysShort: 'ned._pon._tor._sre._čet._pet._sob.'.split('_'),
            weekdaysMin: 'ne_po_to_sr_če_pe_so'.split('_'),
            weekdaysParseExact: true,
            longDateFormat: {
                LT: 'H:mm',
                LTS: 'H:mm:ss',
                L: 'DD. MM. YYYY',
                LL: 'D. MMMM YYYY',
                LLL: 'D. MMMM YYYY H:mm',
                LLLL: 'dddd, D. MMMM YYYY H:mm',
            },
            calendar: {
                sameDay: '[danes ob] LT',
                nextDay: '[jutri ob] LT',

                nextWeek: function () {
                    switch (this.day()) {
                        case 0:
                            return '[v] [nedeljo] [ob] LT';
                        case 3:
                            return '[v] [sredo] [ob] LT';
                        case 6:
                            return '[v] [soboto] [ob] LT';
                        case 1:
                        case 2:
                        case 4:
                        case 5:
                            return '[v] dddd [ob] LT';
                    }
                },
                lastDay: '[včeraj ob] LT',
                lastWeek: function () {
                    switch (this.day()) {
                        case 0:
                            return '[prejšnjo] [nedeljo] [ob] LT';
                        case 3:
                            return '[prejšnjo] [sredo] [ob] LT';
                        case 6:
                            return '[prejšnjo] [soboto] [ob] LT';
                        case 1:
                        case 2:
                        case 4:
                        case 5:
                            return '[prejšnji] dddd [ob] LT';
                    }
                },
                sameElse: 'L',
            },
            relativeTime: {
                future: 'čez %s',
                past: 'pred %s',
                s: processRelativeTime$7,
                ss: processRelativeTime$7,
                m: processRelativeTime$7,
                mm: processRelativeTime$7,
                h: processRelativeTime$7,
                hh: processRelativeTime$7,
                d: processRelativeTime$7,
                dd: processRelativeTime$7,
                M: processRelativeTime$7,
                MM: processRelativeTime$7,
                y: processRelativeTime$7,
                yy: processRelativeTime$7,
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: '%d.',
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 7, // The week that contains Jan 7th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        hooks.defineLocale('sq', {
            months: 'Janar_Shkurt_Mars_Prill_Maj_Qershor_Korrik_Gusht_Shtator_Tetor_Nëntor_Dhjetor'.split(
                '_'
            ),
            monthsShort: 'Jan_Shk_Mar_Pri_Maj_Qer_Kor_Gus_Sht_Tet_Nën_Dhj'.split('_'),
            weekdays: 'E Diel_E Hënë_E Martë_E Mërkurë_E Enjte_E Premte_E Shtunë'.split(
                '_'
            ),
            weekdaysShort: 'Die_Hën_Mar_Mër_Enj_Pre_Sht'.split('_'),
            weekdaysMin: 'D_H_Ma_Më_E_P_Sh'.split('_'),
            weekdaysParseExact: true,
            meridiemParse: /PD|MD/,
            isPM: function (input) {
                return input.charAt(0) === 'M';
            },
            meridiem: function (hours, minutes, isLower) {
                return hours < 12 ? 'PD' : 'MD';
            },
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'DD/MM/YYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY HH:mm',
                LLLL: 'dddd, D MMMM YYYY HH:mm',
            },
            calendar: {
                sameDay: '[Sot në] LT',
                nextDay: '[Nesër në] LT',
                nextWeek: 'dddd [në] LT',
                lastDay: '[Dje në] LT',
                lastWeek: 'dddd [e kaluar në] LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: 'në %s',
                past: '%s më parë',
                s: 'disa sekonda',
                ss: '%d sekonda',
                m: 'një minutë',
                mm: '%d minuta',
                h: 'një orë',
                hh: '%d orë',
                d: 'një ditë',
                dd: '%d ditë',
                M: 'një muaj',
                MM: '%d muaj',
                y: 'një vit',
                yy: '%d vite',
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: '%d.',
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 4, // The week that contains Jan 4th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        var translator$1 = {
            words: {
                //Different grammatical cases
                ss: ['секунда', 'секунде', 'секунди'],
                m: ['један минут', 'једне минуте'],
                mm: ['минут', 'минуте', 'минута'],
                h: ['један сат', 'једног сата'],
                hh: ['сат', 'сата', 'сати'],
                dd: ['дан', 'дана', 'дана'],
                MM: ['месец', 'месеца', 'месеци'],
                yy: ['година', 'године', 'година'],
            },
            correctGrammaticalCase: function (number, wordKey) {
                return number === 1
                    ? wordKey[0]
                    : number >= 2 && number <= 4
                    ? wordKey[1]
                    : wordKey[2];
            },
            translate: function (number, withoutSuffix, key) {
                var wordKey = translator$1.words[key];
                if (key.length === 1) {
                    return withoutSuffix ? wordKey[0] : wordKey[1];
                } else {
                    return (
                        number +
                        ' ' +
                        translator$1.correctGrammaticalCase(number, wordKey)
                    );
                }
            },
        };

        hooks.defineLocale('sr-cyrl', {
            months: 'јануар_фебруар_март_април_мај_јун_јул_август_септембар_октобар_новембар_децембар'.split(
                '_'
            ),
            monthsShort: 'јан._феб._мар._апр._мај_јун_јул_авг._сеп._окт._нов._дец.'.split(
                '_'
            ),
            monthsParseExact: true,
            weekdays: 'недеља_понедељак_уторак_среда_четвртак_петак_субота'.split('_'),
            weekdaysShort: 'нед._пон._уто._сре._чет._пет._суб.'.split('_'),
            weekdaysMin: 'не_по_ут_ср_че_пе_су'.split('_'),
            weekdaysParseExact: true,
            longDateFormat: {
                LT: 'H:mm',
                LTS: 'H:mm:ss',
                L: 'D. M. YYYY.',
                LL: 'D. MMMM YYYY.',
                LLL: 'D. MMMM YYYY. H:mm',
                LLLL: 'dddd, D. MMMM YYYY. H:mm',
            },
            calendar: {
                sameDay: '[данас у] LT',
                nextDay: '[сутра у] LT',
                nextWeek: function () {
                    switch (this.day()) {
                        case 0:
                            return '[у] [недељу] [у] LT';
                        case 3:
                            return '[у] [среду] [у] LT';
                        case 6:
                            return '[у] [суботу] [у] LT';
                        case 1:
                        case 2:
                        case 4:
                        case 5:
                            return '[у] dddd [у] LT';
                    }
                },
                lastDay: '[јуче у] LT',
                lastWeek: function () {
                    var lastWeekDays = [
                        '[прошле] [недеље] [у] LT',
                        '[прошлог] [понедељка] [у] LT',
                        '[прошлог] [уторка] [у] LT',
                        '[прошле] [среде] [у] LT',
                        '[прошлог] [четвртка] [у] LT',
                        '[прошлог] [петка] [у] LT',
                        '[прошле] [суботе] [у] LT',
                    ];
                    return lastWeekDays[this.day()];
                },
                sameElse: 'L',
            },
            relativeTime: {
                future: 'за %s',
                past: 'пре %s',
                s: 'неколико секунди',
                ss: translator$1.translate,
                m: translator$1.translate,
                mm: translator$1.translate,
                h: translator$1.translate,
                hh: translator$1.translate,
                d: 'дан',
                dd: translator$1.translate,
                M: 'месец',
                MM: translator$1.translate,
                y: 'годину',
                yy: translator$1.translate,
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: '%d.',
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 7, // The week that contains Jan 1st is the first week of the year.
            },
        });

        //! moment.js locale configuration

        var translator$2 = {
            words: {
                //Different grammatical cases
                ss: ['sekunda', 'sekunde', 'sekundi'],
                m: ['jedan minut', 'jedne minute'],
                mm: ['minut', 'minute', 'minuta'],
                h: ['jedan sat', 'jednog sata'],
                hh: ['sat', 'sata', 'sati'],
                dd: ['dan', 'dana', 'dana'],
                MM: ['mesec', 'meseca', 'meseci'],
                yy: ['godina', 'godine', 'godina'],
            },
            correctGrammaticalCase: function (number, wordKey) {
                return number === 1
                    ? wordKey[0]
                    : number >= 2 && number <= 4
                    ? wordKey[1]
                    : wordKey[2];
            },
            translate: function (number, withoutSuffix, key) {
                var wordKey = translator$2.words[key];
                if (key.length === 1) {
                    return withoutSuffix ? wordKey[0] : wordKey[1];
                } else {
                    return (
                        number +
                        ' ' +
                        translator$2.correctGrammaticalCase(number, wordKey)
                    );
                }
            },
        };

        hooks.defineLocale('sr', {
            months: 'januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar'.split(
                '_'
            ),
            monthsShort: 'jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.'.split(
                '_'
            ),
            monthsParseExact: true,
            weekdays: 'nedelja_ponedeljak_utorak_sreda_četvrtak_petak_subota'.split(
                '_'
            ),
            weekdaysShort: 'ned._pon._uto._sre._čet._pet._sub.'.split('_'),
            weekdaysMin: 'ne_po_ut_sr_če_pe_su'.split('_'),
            weekdaysParseExact: true,
            longDateFormat: {
                LT: 'H:mm',
                LTS: 'H:mm:ss',
                L: 'D. M. YYYY.',
                LL: 'D. MMMM YYYY.',
                LLL: 'D. MMMM YYYY. H:mm',
                LLLL: 'dddd, D. MMMM YYYY. H:mm',
            },
            calendar: {
                sameDay: '[danas u] LT',
                nextDay: '[sutra u] LT',
                nextWeek: function () {
                    switch (this.day()) {
                        case 0:
                            return '[u] [nedelju] [u] LT';
                        case 3:
                            return '[u] [sredu] [u] LT';
                        case 6:
                            return '[u] [subotu] [u] LT';
                        case 1:
                        case 2:
                        case 4:
                        case 5:
                            return '[u] dddd [u] LT';
                    }
                },
                lastDay: '[juče u] LT',
                lastWeek: function () {
                    var lastWeekDays = [
                        '[prošle] [nedelje] [u] LT',
                        '[prošlog] [ponedeljka] [u] LT',
                        '[prošlog] [utorka] [u] LT',
                        '[prošle] [srede] [u] LT',
                        '[prošlog] [četvrtka] [u] LT',
                        '[prošlog] [petka] [u] LT',
                        '[prošle] [subote] [u] LT',
                    ];
                    return lastWeekDays[this.day()];
                },
                sameElse: 'L',
            },
            relativeTime: {
                future: 'za %s',
                past: 'pre %s',
                s: 'nekoliko sekundi',
                ss: translator$2.translate,
                m: translator$2.translate,
                mm: translator$2.translate,
                h: translator$2.translate,
                hh: translator$2.translate,
                d: 'dan',
                dd: translator$2.translate,
                M: 'mesec',
                MM: translator$2.translate,
                y: 'godinu',
                yy: translator$2.translate,
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: '%d.',
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 7, // The week that contains Jan 7th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        hooks.defineLocale('ss', {
            months: "Bhimbidvwane_Indlovana_Indlov'lenkhulu_Mabasa_Inkhwekhweti_Inhlaba_Kholwane_Ingci_Inyoni_Imphala_Lweti_Ingongoni".split(
                '_'
            ),
            monthsShort: 'Bhi_Ina_Inu_Mab_Ink_Inh_Kho_Igc_Iny_Imp_Lwe_Igo'.split('_'),
            weekdays: 'Lisontfo_Umsombuluko_Lesibili_Lesitsatfu_Lesine_Lesihlanu_Umgcibelo'.split(
                '_'
            ),
            weekdaysShort: 'Lis_Umb_Lsb_Les_Lsi_Lsh_Umg'.split('_'),
            weekdaysMin: 'Li_Us_Lb_Lt_Ls_Lh_Ug'.split('_'),
            weekdaysParseExact: true,
            longDateFormat: {
                LT: 'h:mm A',
                LTS: 'h:mm:ss A',
                L: 'DD/MM/YYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY h:mm A',
                LLLL: 'dddd, D MMMM YYYY h:mm A',
            },
            calendar: {
                sameDay: '[Namuhla nga] LT',
                nextDay: '[Kusasa nga] LT',
                nextWeek: 'dddd [nga] LT',
                lastDay: '[Itolo nga] LT',
                lastWeek: 'dddd [leliphelile] [nga] LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: 'nga %s',
                past: 'wenteka nga %s',
                s: 'emizuzwana lomcane',
                ss: '%d mzuzwana',
                m: 'umzuzu',
                mm: '%d emizuzu',
                h: 'lihora',
                hh: '%d emahora',
                d: 'lilanga',
                dd: '%d emalanga',
                M: 'inyanga',
                MM: '%d tinyanga',
                y: 'umnyaka',
                yy: '%d iminyaka',
            },
            meridiemParse: /ekuseni|emini|entsambama|ebusuku/,
            meridiem: function (hours, minutes, isLower) {
                if (hours < 11) {
                    return 'ekuseni';
                } else if (hours < 15) {
                    return 'emini';
                } else if (hours < 19) {
                    return 'entsambama';
                } else {
                    return 'ebusuku';
                }
            },
            meridiemHour: function (hour, meridiem) {
                if (hour === 12) {
                    hour = 0;
                }
                if (meridiem === 'ekuseni') {
                    return hour;
                } else if (meridiem === 'emini') {
                    return hour >= 11 ? hour : hour + 12;
                } else if (meridiem === 'entsambama' || meridiem === 'ebusuku') {
                    if (hour === 0) {
                        return 0;
                    }
                    return hour + 12;
                }
            },
            dayOfMonthOrdinalParse: /\d{1,2}/,
            ordinal: '%d',
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 4, // The week that contains Jan 4th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        hooks.defineLocale('sv', {
            months: 'januari_februari_mars_april_maj_juni_juli_augusti_september_oktober_november_december'.split(
                '_'
            ),
            monthsShort: 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
            weekdays: 'söndag_måndag_tisdag_onsdag_torsdag_fredag_lördag'.split('_'),
            weekdaysShort: 'sön_mån_tis_ons_tor_fre_lör'.split('_'),
            weekdaysMin: 'sö_må_ti_on_to_fr_lö'.split('_'),
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'YYYY-MM-DD',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY [kl.] HH:mm',
                LLLL: 'dddd D MMMM YYYY [kl.] HH:mm',
                lll: 'D MMM YYYY HH:mm',
                llll: 'ddd D MMM YYYY HH:mm',
            },
            calendar: {
                sameDay: '[Idag] LT',
                nextDay: '[Imorgon] LT',
                lastDay: '[Igår] LT',
                nextWeek: '[På] dddd LT',
                lastWeek: '[I] dddd[s] LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: 'om %s',
                past: 'för %s sedan',
                s: 'några sekunder',
                ss: '%d sekunder',
                m: 'en minut',
                mm: '%d minuter',
                h: 'en timme',
                hh: '%d timmar',
                d: 'en dag',
                dd: '%d dagar',
                M: 'en månad',
                MM: '%d månader',
                y: 'ett år',
                yy: '%d år',
            },
            dayOfMonthOrdinalParse: /\d{1,2}(\:e|\:a)/,
            ordinal: function (number) {
                var b = number % 10,
                    output =
                        ~~((number % 100) / 10) === 1
                            ? ':e'
                            : b === 1
                            ? ':a'
                            : b === 2
                            ? ':a'
                            : b === 3
                            ? ':e'
                            : ':e';
                return number + output;
            },
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 4, // The week that contains Jan 4th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        hooks.defineLocale('sw', {
            months: 'Januari_Februari_Machi_Aprili_Mei_Juni_Julai_Agosti_Septemba_Oktoba_Novemba_Desemba'.split(
                '_'
            ),
            monthsShort: 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ago_Sep_Okt_Nov_Des'.split('_'),
            weekdays: 'Jumapili_Jumatatu_Jumanne_Jumatano_Alhamisi_Ijumaa_Jumamosi'.split(
                '_'
            ),
            weekdaysShort: 'Jpl_Jtat_Jnne_Jtan_Alh_Ijm_Jmos'.split('_'),
            weekdaysMin: 'J2_J3_J4_J5_Al_Ij_J1'.split('_'),
            weekdaysParseExact: true,
            longDateFormat: {
                LT: 'hh:mm A',
                LTS: 'HH:mm:ss',
                L: 'DD.MM.YYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY HH:mm',
                LLLL: 'dddd, D MMMM YYYY HH:mm',
            },
            calendar: {
                sameDay: '[leo saa] LT',
                nextDay: '[kesho saa] LT',
                nextWeek: '[wiki ijayo] dddd [saat] LT',
                lastDay: '[jana] LT',
                lastWeek: '[wiki iliyopita] dddd [saat] LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: '%s baadaye',
                past: 'tokea %s',
                s: 'hivi punde',
                ss: 'sekunde %d',
                m: 'dakika moja',
                mm: 'dakika %d',
                h: 'saa limoja',
                hh: 'masaa %d',
                d: 'siku moja',
                dd: 'siku %d',
                M: 'mwezi mmoja',
                MM: 'miezi %d',
                y: 'mwaka mmoja',
                yy: 'miaka %d',
            },
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 7, // The week that contains Jan 7th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        var symbolMap$g = {
                1: '௧',
                2: '௨',
                3: '௩',
                4: '௪',
                5: '௫',
                6: '௬',
                7: '௭',
                8: '௮',
                9: '௯',
                0: '௦',
            },
            numberMap$f = {
                '௧': '1',
                '௨': '2',
                '௩': '3',
                '௪': '4',
                '௫': '5',
                '௬': '6',
                '௭': '7',
                '௮': '8',
                '௯': '9',
                '௦': '0',
            };

        hooks.defineLocale('ta', {
            months: 'ஜனவரி_பிப்ரவரி_மார்ச்_ஏப்ரல்_மே_ஜூன்_ஜூலை_ஆகஸ்ட்_செப்டெம்பர்_அக்டோபர்_நவம்பர்_டிசம்பர்'.split(
                '_'
            ),
            monthsShort: 'ஜனவரி_பிப்ரவரி_மார்ச்_ஏப்ரல்_மே_ஜூன்_ஜூலை_ஆகஸ்ட்_செப்டெம்பர்_அக்டோபர்_நவம்பர்_டிசம்பர்'.split(
                '_'
            ),
            weekdays: 'ஞாயிற்றுக்கிழமை_திங்கட்கிழமை_செவ்வாய்கிழமை_புதன்கிழமை_வியாழக்கிழமை_வெள்ளிக்கிழமை_சனிக்கிழமை'.split(
                '_'
            ),
            weekdaysShort: 'ஞாயிறு_திங்கள்_செவ்வாய்_புதன்_வியாழன்_வெள்ளி_சனி'.split(
                '_'
            ),
            weekdaysMin: 'ஞா_தி_செ_பு_வி_வெ_ச'.split('_'),
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'DD/MM/YYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY, HH:mm',
                LLLL: 'dddd, D MMMM YYYY, HH:mm',
            },
            calendar: {
                sameDay: '[இன்று] LT',
                nextDay: '[நாளை] LT',
                nextWeek: 'dddd, LT',
                lastDay: '[நேற்று] LT',
                lastWeek: '[கடந்த வாரம்] dddd, LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: '%s இல்',
                past: '%s முன்',
                s: 'ஒரு சில விநாடிகள்',
                ss: '%d விநாடிகள்',
                m: 'ஒரு நிமிடம்',
                mm: '%d நிமிடங்கள்',
                h: 'ஒரு மணி நேரம்',
                hh: '%d மணி நேரம்',
                d: 'ஒரு நாள்',
                dd: '%d நாட்கள்',
                M: 'ஒரு மாதம்',
                MM: '%d மாதங்கள்',
                y: 'ஒரு வருடம்',
                yy: '%d ஆண்டுகள்',
            },
            dayOfMonthOrdinalParse: /\d{1,2}வது/,
            ordinal: function (number) {
                return number + 'வது';
            },
            preparse: function (string) {
                return string.replace(/[௧௨௩௪௫௬௭௮௯௦]/g, function (match) {
                    return numberMap$f[match];
                });
            },
            postformat: function (string) {
                return string.replace(/\d/g, function (match) {
                    return symbolMap$g[match];
                });
            },
            // refer http://ta.wikipedia.org/s/1er1
            meridiemParse: /யாமம்|வைகறை|காலை|நண்பகல்|எற்பாடு|மாலை/,
            meridiem: function (hour, minute, isLower) {
                if (hour < 2) {
                    return ' யாமம்';
                } else if (hour < 6) {
                    return ' வைகறை'; // வைகறை
                } else if (hour < 10) {
                    return ' காலை'; // காலை
                } else if (hour < 14) {
                    return ' நண்பகல்'; // நண்பகல்
                } else if (hour < 18) {
                    return ' எற்பாடு'; // எற்பாடு
                } else if (hour < 22) {
                    return ' மாலை'; // மாலை
                } else {
                    return ' யாமம்';
                }
            },
            meridiemHour: function (hour, meridiem) {
                if (hour === 12) {
                    hour = 0;
                }
                if (meridiem === 'யாமம்') {
                    return hour < 2 ? hour : hour + 12;
                } else if (meridiem === 'வைகறை' || meridiem === 'காலை') {
                    return hour;
                } else if (meridiem === 'நண்பகல்') {
                    return hour >= 10 ? hour : hour + 12;
                } else {
                    return hour + 12;
                }
            },
            week: {
                dow: 0, // Sunday is the first day of the week.
                doy: 6, // The week that contains Jan 6th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        hooks.defineLocale('te', {
            months: 'జనవరి_ఫిబ్రవరి_మార్చి_ఏప్రిల్_మే_జూన్_జులై_ఆగస్టు_సెప్టెంబర్_అక్టోబర్_నవంబర్_డిసెంబర్'.split(
                '_'
            ),
            monthsShort: 'జన._ఫిబ్ర._మార్చి_ఏప్రి._మే_జూన్_జులై_ఆగ._సెప్._అక్టో._నవ._డిసె.'.split(
                '_'
            ),
            monthsParseExact: true,
            weekdays: 'ఆదివారం_సోమవారం_మంగళవారం_బుధవారం_గురువారం_శుక్రవారం_శనివారం'.split(
                '_'
            ),
            weekdaysShort: 'ఆది_సోమ_మంగళ_బుధ_గురు_శుక్ర_శని'.split('_'),
            weekdaysMin: 'ఆ_సో_మం_బు_గు_శు_శ'.split('_'),
            longDateFormat: {
                LT: 'A h:mm',
                LTS: 'A h:mm:ss',
                L: 'DD/MM/YYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY, A h:mm',
                LLLL: 'dddd, D MMMM YYYY, A h:mm',
            },
            calendar: {
                sameDay: '[నేడు] LT',
                nextDay: '[రేపు] LT',
                nextWeek: 'dddd, LT',
                lastDay: '[నిన్న] LT',
                lastWeek: '[గత] dddd, LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: '%s లో',
                past: '%s క్రితం',
                s: 'కొన్ని క్షణాలు',
                ss: '%d సెకన్లు',
                m: 'ఒక నిమిషం',
                mm: '%d నిమిషాలు',
                h: 'ఒక గంట',
                hh: '%d గంటలు',
                d: 'ఒక రోజు',
                dd: '%d రోజులు',
                M: 'ఒక నెల',
                MM: '%d నెలలు',
                y: 'ఒక సంవత్సరం',
                yy: '%d సంవత్సరాలు',
            },
            dayOfMonthOrdinalParse: /\d{1,2}వ/,
            ordinal: '%dవ',
            meridiemParse: /రాత్రి|ఉదయం|మధ్యాహ్నం|సాయంత్రం/,
            meridiemHour: function (hour, meridiem) {
                if (hour === 12) {
                    hour = 0;
                }
                if (meridiem === 'రాత్రి') {
                    return hour < 4 ? hour : hour + 12;
                } else if (meridiem === 'ఉదయం') {
                    return hour;
                } else if (meridiem === 'మధ్యాహ్నం') {
                    return hour >= 10 ? hour : hour + 12;
                } else if (meridiem === 'సాయంత్రం') {
                    return hour + 12;
                }
            },
            meridiem: function (hour, minute, isLower) {
                if (hour < 4) {
                    return 'రాత్రి';
                } else if (hour < 10) {
                    return 'ఉదయం';
                } else if (hour < 17) {
                    return 'మధ్యాహ్నం';
                } else if (hour < 20) {
                    return 'సాయంత్రం';
                } else {
                    return 'రాత్రి';
                }
            },
            week: {
                dow: 0, // Sunday is the first day of the week.
                doy: 6, // The week that contains Jan 6th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        hooks.defineLocale('tet', {
            months: 'Janeiru_Fevereiru_Marsu_Abril_Maiu_Juñu_Jullu_Agustu_Setembru_Outubru_Novembru_Dezembru'.split(
                '_'
            ),
            monthsShort: 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),
            weekdays: 'Domingu_Segunda_Tersa_Kuarta_Kinta_Sesta_Sabadu'.split('_'),
            weekdaysShort: 'Dom_Seg_Ters_Kua_Kint_Sest_Sab'.split('_'),
            weekdaysMin: 'Do_Seg_Te_Ku_Ki_Ses_Sa'.split('_'),
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'DD/MM/YYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY HH:mm',
                LLLL: 'dddd, D MMMM YYYY HH:mm',
            },
            calendar: {
                sameDay: '[Ohin iha] LT',
                nextDay: '[Aban iha] LT',
                nextWeek: 'dddd [iha] LT',
                lastDay: '[Horiseik iha] LT',
                lastWeek: 'dddd [semana kotuk] [iha] LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: 'iha %s',
                past: '%s liuba',
                s: 'segundu balun',
                ss: 'segundu %d',
                m: 'minutu ida',
                mm: 'minutu %d',
                h: 'oras ida',
                hh: 'oras %d',
                d: 'loron ida',
                dd: 'loron %d',
                M: 'fulan ida',
                MM: 'fulan %d',
                y: 'tinan ida',
                yy: 'tinan %d',
            },
            dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
            ordinal: function (number) {
                var b = number % 10,
                    output =
                        ~~((number % 100) / 10) === 1
                            ? 'th'
                            : b === 1
                            ? 'st'
                            : b === 2
                            ? 'nd'
                            : b === 3
                            ? 'rd'
                            : 'th';
                return number + output;
            },
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 4, // The week that contains Jan 4th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        var suffixes$3 = {
            0: '-ум',
            1: '-ум',
            2: '-юм',
            3: '-юм',
            4: '-ум',
            5: '-ум',
            6: '-ум',
            7: '-ум',
            8: '-ум',
            9: '-ум',
            10: '-ум',
            12: '-ум',
            13: '-ум',
            20: '-ум',
            30: '-юм',
            40: '-ум',
            50: '-ум',
            60: '-ум',
            70: '-ум',
            80: '-ум',
            90: '-ум',
            100: '-ум',
        };

        hooks.defineLocale('tg', {
            months: {
                format: 'январи_феврали_марти_апрели_майи_июни_июли_августи_сентябри_октябри_ноябри_декабри'.split(
                    '_'
                ),
                standalone: 'январ_феврал_март_апрел_май_июн_июл_август_сентябр_октябр_ноябр_декабр'.split(
                    '_'
                ),
            },
            monthsShort: 'янв_фев_мар_апр_май_июн_июл_авг_сен_окт_ноя_дек'.split('_'),
            weekdays: 'якшанбе_душанбе_сешанбе_чоршанбе_панҷшанбе_ҷумъа_шанбе'.split(
                '_'
            ),
            weekdaysShort: 'яшб_дшб_сшб_чшб_пшб_ҷум_шнб'.split('_'),
            weekdaysMin: 'яш_дш_сш_чш_пш_ҷм_шб'.split('_'),
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'DD.MM.YYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY HH:mm',
                LLLL: 'dddd, D MMMM YYYY HH:mm',
            },
            calendar: {
                sameDay: '[Имрӯз соати] LT',
                nextDay: '[Фардо соати] LT',
                lastDay: '[Дирӯз соати] LT',
                nextWeek: 'dddd[и] [ҳафтаи оянда соати] LT',
                lastWeek: 'dddd[и] [ҳафтаи гузашта соати] LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: 'баъди %s',
                past: '%s пеш',
                s: 'якчанд сония',
                m: 'як дақиқа',
                mm: '%d дақиқа',
                h: 'як соат',
                hh: '%d соат',
                d: 'як рӯз',
                dd: '%d рӯз',
                M: 'як моҳ',
                MM: '%d моҳ',
                y: 'як сол',
                yy: '%d сол',
            },
            meridiemParse: /шаб|субҳ|рӯз|бегоҳ/,
            meridiemHour: function (hour, meridiem) {
                if (hour === 12) {
                    hour = 0;
                }
                if (meridiem === 'шаб') {
                    return hour < 4 ? hour : hour + 12;
                } else if (meridiem === 'субҳ') {
                    return hour;
                } else if (meridiem === 'рӯз') {
                    return hour >= 11 ? hour : hour + 12;
                } else if (meridiem === 'бегоҳ') {
                    return hour + 12;
                }
            },
            meridiem: function (hour, minute, isLower) {
                if (hour < 4) {
                    return 'шаб';
                } else if (hour < 11) {
                    return 'субҳ';
                } else if (hour < 16) {
                    return 'рӯз';
                } else if (hour < 19) {
                    return 'бегоҳ';
                } else {
                    return 'шаб';
                }
            },
            dayOfMonthOrdinalParse: /\d{1,2}-(ум|юм)/,
            ordinal: function (number) {
                var a = number % 10,
                    b = number >= 100 ? 100 : null;
                return number + (suffixes$3[number] || suffixes$3[a] || suffixes$3[b]);
            },
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 7, // The week that contains Jan 1th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        hooks.defineLocale('th', {
            months: 'มกราคม_กุมภาพันธ์_มีนาคม_เมษายน_พฤษภาคม_มิถุนายน_กรกฎาคม_สิงหาคม_กันยายน_ตุลาคม_พฤศจิกายน_ธันวาคม'.split(
                '_'
            ),
            monthsShort: 'ม.ค._ก.พ._มี.ค._เม.ย._พ.ค._มิ.ย._ก.ค._ส.ค._ก.ย._ต.ค._พ.ย._ธ.ค.'.split(
                '_'
            ),
            monthsParseExact: true,
            weekdays: 'อาทิตย์_จันทร์_อังคาร_พุธ_พฤหัสบดี_ศุกร์_เสาร์'.split('_'),
            weekdaysShort: 'อาทิตย์_จันทร์_อังคาร_พุธ_พฤหัส_ศุกร์_เสาร์'.split('_'), // yes, three characters difference
            weekdaysMin: 'อา._จ._อ._พ._พฤ._ศ._ส.'.split('_'),
            weekdaysParseExact: true,
            longDateFormat: {
                LT: 'H:mm',
                LTS: 'H:mm:ss',
                L: 'DD/MM/YYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY เวลา H:mm',
                LLLL: 'วันddddที่ D MMMM YYYY เวลา H:mm',
            },
            meridiemParse: /ก่อนเที่ยง|หลังเที่ยง/,
            isPM: function (input) {
                return input === 'หลังเที่ยง';
            },
            meridiem: function (hour, minute, isLower) {
                if (hour < 12) {
                    return 'ก่อนเที่ยง';
                } else {
                    return 'หลังเที่ยง';
                }
            },
            calendar: {
                sameDay: '[วันนี้ เวลา] LT',
                nextDay: '[พรุ่งนี้ เวลา] LT',
                nextWeek: 'dddd[หน้า เวลา] LT',
                lastDay: '[เมื่อวานนี้ เวลา] LT',
                lastWeek: '[วัน]dddd[ที่แล้ว เวลา] LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: 'อีก %s',
                past: '%sที่แล้ว',
                s: 'ไม่กี่วินาที',
                ss: '%d วินาที',
                m: '1 นาที',
                mm: '%d นาที',
                h: '1 ชั่วโมง',
                hh: '%d ชั่วโมง',
                d: '1 วัน',
                dd: '%d วัน',
                w: '1 สัปดาห์',
                ww: '%d สัปดาห์',
                M: '1 เดือน',
                MM: '%d เดือน',
                y: '1 ปี',
                yy: '%d ปี',
            },
        });

        //! moment.js locale configuration

        var suffixes$4 = {
            1: "'inji",
            5: "'inji",
            8: "'inji",
            70: "'inji",
            80: "'inji",
            2: "'nji",
            7: "'nji",
            20: "'nji",
            50: "'nji",
            3: "'ünji",
            4: "'ünji",
            100: "'ünji",
            6: "'njy",
            9: "'unjy",
            10: "'unjy",
            30: "'unjy",
            60: "'ynjy",
            90: "'ynjy",
        };

        hooks.defineLocale('tk', {
            months: 'Ýanwar_Fewral_Mart_Aprel_Maý_Iýun_Iýul_Awgust_Sentýabr_Oktýabr_Noýabr_Dekabr'.split(
                '_'
            ),
            monthsShort: 'Ýan_Few_Mar_Apr_Maý_Iýn_Iýl_Awg_Sen_Okt_Noý_Dek'.split('_'),
            weekdays: 'Ýekşenbe_Duşenbe_Sişenbe_Çarşenbe_Penşenbe_Anna_Şenbe'.split(
                '_'
            ),
            weekdaysShort: 'Ýek_Duş_Siş_Çar_Pen_Ann_Şen'.split('_'),
            weekdaysMin: 'Ýk_Dş_Sş_Çr_Pn_An_Şn'.split('_'),
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'DD.MM.YYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY HH:mm',
                LLLL: 'dddd, D MMMM YYYY HH:mm',
            },
            calendar: {
                sameDay: '[bugün sagat] LT',
                nextDay: '[ertir sagat] LT',
                nextWeek: '[indiki] dddd [sagat] LT',
                lastDay: '[düýn] LT',
                lastWeek: '[geçen] dddd [sagat] LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: '%s soň',
                past: '%s öň',
                s: 'birnäçe sekunt',
                m: 'bir minut',
                mm: '%d minut',
                h: 'bir sagat',
                hh: '%d sagat',
                d: 'bir gün',
                dd: '%d gün',
                M: 'bir aý',
                MM: '%d aý',
                y: 'bir ýyl',
                yy: '%d ýyl',
            },
            ordinal: function (number, period) {
                switch (period) {
                    case 'd':
                    case 'D':
                    case 'Do':
                    case 'DD':
                        return number;
                    default:
                        if (number === 0) {
                            // special case for zero
                            return number + "'unjy";
                        }
                        var a = number % 10,
                            b = (number % 100) - a,
                            c = number >= 100 ? 100 : null;
                        return number + (suffixes$4[a] || suffixes$4[b] || suffixes$4[c]);
                }
            },
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 7, // The week that contains Jan 7th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        hooks.defineLocale('tl-ph', {
            months: 'Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre'.split(
                '_'
            ),
            monthsShort: 'Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis'.split('_'),
            weekdays: 'Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado'.split(
                '_'
            ),
            weekdaysShort: 'Lin_Lun_Mar_Miy_Huw_Biy_Sab'.split('_'),
            weekdaysMin: 'Li_Lu_Ma_Mi_Hu_Bi_Sab'.split('_'),
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'MM/D/YYYY',
                LL: 'MMMM D, YYYY',
                LLL: 'MMMM D, YYYY HH:mm',
                LLLL: 'dddd, MMMM DD, YYYY HH:mm',
            },
            calendar: {
                sameDay: 'LT [ngayong araw]',
                nextDay: '[Bukas ng] LT',
                nextWeek: 'LT [sa susunod na] dddd',
                lastDay: 'LT [kahapon]',
                lastWeek: 'LT [noong nakaraang] dddd',
                sameElse: 'L',
            },
            relativeTime: {
                future: 'sa loob ng %s',
                past: '%s ang nakalipas',
                s: 'ilang segundo',
                ss: '%d segundo',
                m: 'isang minuto',
                mm: '%d minuto',
                h: 'isang oras',
                hh: '%d oras',
                d: 'isang araw',
                dd: '%d araw',
                M: 'isang buwan',
                MM: '%d buwan',
                y: 'isang taon',
                yy: '%d taon',
            },
            dayOfMonthOrdinalParse: /\d{1,2}/,
            ordinal: function (number) {
                return number;
            },
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 4, // The week that contains Jan 4th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        var numbersNouns = 'pagh_wa’_cha’_wej_loS_vagh_jav_Soch_chorgh_Hut'.split('_');

        function translateFuture(output) {
            var time = output;
            time =
                output.indexOf('jaj') !== -1
                    ? time.slice(0, -3) + 'leS'
                    : output.indexOf('jar') !== -1
                    ? time.slice(0, -3) + 'waQ'
                    : output.indexOf('DIS') !== -1
                    ? time.slice(0, -3) + 'nem'
                    : time + ' pIq';
            return time;
        }

        function translatePast(output) {
            var time = output;
            time =
                output.indexOf('jaj') !== -1
                    ? time.slice(0, -3) + 'Hu’'
                    : output.indexOf('jar') !== -1
                    ? time.slice(0, -3) + 'wen'
                    : output.indexOf('DIS') !== -1
                    ? time.slice(0, -3) + 'ben'
                    : time + ' ret';
            return time;
        }

        function translate$a(number, withoutSuffix, string, isFuture) {
            var numberNoun = numberAsNoun(number);
            switch (string) {
                case 'ss':
                    return numberNoun + ' lup';
                case 'mm':
                    return numberNoun + ' tup';
                case 'hh':
                    return numberNoun + ' rep';
                case 'dd':
                    return numberNoun + ' jaj';
                case 'MM':
                    return numberNoun + ' jar';
                case 'yy':
                    return numberNoun + ' DIS';
            }
        }

        function numberAsNoun(number) {
            var hundred = Math.floor((number % 1000) / 100),
                ten = Math.floor((number % 100) / 10),
                one = number % 10,
                word = '';
            if (hundred > 0) {
                word += numbersNouns[hundred] + 'vatlh';
            }
            if (ten > 0) {
                word += (word !== '' ? ' ' : '') + numbersNouns[ten] + 'maH';
            }
            if (one > 0) {
                word += (word !== '' ? ' ' : '') + numbersNouns[one];
            }
            return word === '' ? 'pagh' : word;
        }

        hooks.defineLocale('tlh', {
            months: 'tera’ jar wa’_tera’ jar cha’_tera’ jar wej_tera’ jar loS_tera’ jar vagh_tera’ jar jav_tera’ jar Soch_tera’ jar chorgh_tera’ jar Hut_tera’ jar wa’maH_tera’ jar wa’maH wa’_tera’ jar wa’maH cha’'.split(
                '_'
            ),
            monthsShort: 'jar wa’_jar cha’_jar wej_jar loS_jar vagh_jar jav_jar Soch_jar chorgh_jar Hut_jar wa’maH_jar wa’maH wa’_jar wa’maH cha’'.split(
                '_'
            ),
            monthsParseExact: true,
            weekdays: 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split(
                '_'
            ),
            weekdaysShort: 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split(
                '_'
            ),
            weekdaysMin: 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split(
                '_'
            ),
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'DD.MM.YYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY HH:mm',
                LLLL: 'dddd, D MMMM YYYY HH:mm',
            },
            calendar: {
                sameDay: '[DaHjaj] LT',
                nextDay: '[wa’leS] LT',
                nextWeek: 'LLL',
                lastDay: '[wa’Hu’] LT',
                lastWeek: 'LLL',
                sameElse: 'L',
            },
            relativeTime: {
                future: translateFuture,
                past: translatePast,
                s: 'puS lup',
                ss: translate$a,
                m: 'wa’ tup',
                mm: translate$a,
                h: 'wa’ rep',
                hh: translate$a,
                d: 'wa’ jaj',
                dd: translate$a,
                M: 'wa’ jar',
                MM: translate$a,
                y: 'wa’ DIS',
                yy: translate$a,
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: '%d.',
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 4, // The week that contains Jan 4th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        var suffixes$5 = {
            1: "'inci",
            5: "'inci",
            8: "'inci",
            70: "'inci",
            80: "'inci",
            2: "'nci",
            7: "'nci",
            20: "'nci",
            50: "'nci",
            3: "'üncü",
            4: "'üncü",
            100: "'üncü",
            6: "'ncı",
            9: "'uncu",
            10: "'uncu",
            30: "'uncu",
            60: "'ıncı",
            90: "'ıncı",
        };

        hooks.defineLocale('tr', {
            months: 'Ocak_Şubat_Mart_Nisan_Mayıs_Haziran_Temmuz_Ağustos_Eylül_Ekim_Kasım_Aralık'.split(
                '_'
            ),
            monthsShort: 'Oca_Şub_Mar_Nis_May_Haz_Tem_Ağu_Eyl_Eki_Kas_Ara'.split('_'),
            weekdays: 'Pazar_Pazartesi_Salı_Çarşamba_Perşembe_Cuma_Cumartesi'.split(
                '_'
            ),
            weekdaysShort: 'Paz_Pts_Sal_Çar_Per_Cum_Cts'.split('_'),
            weekdaysMin: 'Pz_Pt_Sa_Ça_Pe_Cu_Ct'.split('_'),
            meridiem: function (hours, minutes, isLower) {
                if (hours < 12) {
                    return isLower ? 'öö' : 'ÖÖ';
                } else {
                    return isLower ? 'ös' : 'ÖS';
                }
            },
            meridiemParse: /öö|ÖÖ|ös|ÖS/,
            isPM: function (input) {
                return input === 'ös' || input === 'ÖS';
            },
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'DD.MM.YYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY HH:mm',
                LLLL: 'dddd, D MMMM YYYY HH:mm',
            },
            calendar: {
                sameDay: '[bugün saat] LT',
                nextDay: '[yarın saat] LT',
                nextWeek: '[gelecek] dddd [saat] LT',
                lastDay: '[dün] LT',
                lastWeek: '[geçen] dddd [saat] LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: '%s sonra',
                past: '%s önce',
                s: 'birkaç saniye',
                ss: '%d saniye',
                m: 'bir dakika',
                mm: '%d dakika',
                h: 'bir saat',
                hh: '%d saat',
                d: 'bir gün',
                dd: '%d gün',
                w: 'bir hafta',
                ww: '%d hafta',
                M: 'bir ay',
                MM: '%d ay',
                y: 'bir yıl',
                yy: '%d yıl',
            },
            ordinal: function (number, period) {
                switch (period) {
                    case 'd':
                    case 'D':
                    case 'Do':
                    case 'DD':
                        return number;
                    default:
                        if (number === 0) {
                            // special case for zero
                            return number + "'ıncı";
                        }
                        var a = number % 10,
                            b = (number % 100) - a,
                            c = number >= 100 ? 100 : null;
                        return number + (suffixes$5[a] || suffixes$5[b] || suffixes$5[c]);
                }
            },
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 7, // The week that contains Jan 7th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        // After the year there should be a slash and the amount of years since December 26, 1979 in Roman numerals.
        // This is currently too difficult (maybe even impossible) to add.
        hooks.defineLocale('tzl', {
            months: 'Januar_Fevraglh_Març_Avrïu_Mai_Gün_Julia_Guscht_Setemvar_Listopäts_Noemvar_Zecemvar'.split(
                '_'
            ),
            monthsShort: 'Jan_Fev_Mar_Avr_Mai_Gün_Jul_Gus_Set_Lis_Noe_Zec'.split('_'),
            weekdays: 'Súladi_Lúneçi_Maitzi_Márcuri_Xhúadi_Viénerçi_Sáturi'.split('_'),
            weekdaysShort: 'Súl_Lún_Mai_Már_Xhú_Vié_Sát'.split('_'),
            weekdaysMin: 'Sú_Lú_Ma_Má_Xh_Vi_Sá'.split('_'),
            longDateFormat: {
                LT: 'HH.mm',
                LTS: 'HH.mm.ss',
                L: 'DD.MM.YYYY',
                LL: 'D. MMMM [dallas] YYYY',
                LLL: 'D. MMMM [dallas] YYYY HH.mm',
                LLLL: 'dddd, [li] D. MMMM [dallas] YYYY HH.mm',
            },
            meridiemParse: /d\'o|d\'a/i,
            isPM: function (input) {
                return "d'o" === input.toLowerCase();
            },
            meridiem: function (hours, minutes, isLower) {
                if (hours > 11) {
                    return isLower ? "d'o" : "D'O";
                } else {
                    return isLower ? "d'a" : "D'A";
                }
            },
            calendar: {
                sameDay: '[oxhi à] LT',
                nextDay: '[demà à] LT',
                nextWeek: 'dddd [à] LT',
                lastDay: '[ieiri à] LT',
                lastWeek: '[sür el] dddd [lasteu à] LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: 'osprei %s',
                past: 'ja%s',
                s: processRelativeTime$8,
                ss: processRelativeTime$8,
                m: processRelativeTime$8,
                mm: processRelativeTime$8,
                h: processRelativeTime$8,
                hh: processRelativeTime$8,
                d: processRelativeTime$8,
                dd: processRelativeTime$8,
                M: processRelativeTime$8,
                MM: processRelativeTime$8,
                y: processRelativeTime$8,
                yy: processRelativeTime$8,
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: '%d.',
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 4, // The week that contains Jan 4th is the first week of the year.
            },
        });

        function processRelativeTime$8(number, withoutSuffix, key, isFuture) {
            var format = {
                s: ['viensas secunds', "'iensas secunds"],
                ss: [number + ' secunds', '' + number + ' secunds'],
                m: ["'n míut", "'iens míut"],
                mm: [number + ' míuts', '' + number + ' míuts'],
                h: ["'n þora", "'iensa þora"],
                hh: [number + ' þoras', '' + number + ' þoras'],
                d: ["'n ziua", "'iensa ziua"],
                dd: [number + ' ziuas', '' + number + ' ziuas'],
                M: ["'n mes", "'iens mes"],
                MM: [number + ' mesen', '' + number + ' mesen'],
                y: ["'n ar", "'iens ar"],
                yy: [number + ' ars', '' + number + ' ars'],
            };
            return isFuture
                ? format[key][0]
                : withoutSuffix
                ? format[key][0]
                : format[key][1];
        }

        //! moment.js locale configuration

        hooks.defineLocale('tzm-latn', {
            months: 'innayr_brˤayrˤ_marˤsˤ_ibrir_mayyw_ywnyw_ywlywz_ɣwšt_šwtanbir_ktˤwbrˤ_nwwanbir_dwjnbir'.split(
                '_'
            ),
            monthsShort: 'innayr_brˤayrˤ_marˤsˤ_ibrir_mayyw_ywnyw_ywlywz_ɣwšt_šwtanbir_ktˤwbrˤ_nwwanbir_dwjnbir'.split(
                '_'
            ),
            weekdays: 'asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas'.split('_'),
            weekdaysShort: 'asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas'.split('_'),
            weekdaysMin: 'asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas'.split('_'),
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'DD/MM/YYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY HH:mm',
                LLLL: 'dddd D MMMM YYYY HH:mm',
            },
            calendar: {
                sameDay: '[asdkh g] LT',
                nextDay: '[aska g] LT',
                nextWeek: 'dddd [g] LT',
                lastDay: '[assant g] LT',
                lastWeek: 'dddd [g] LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: 'dadkh s yan %s',
                past: 'yan %s',
                s: 'imik',
                ss: '%d imik',
                m: 'minuḍ',
                mm: '%d minuḍ',
                h: 'saɛa',
                hh: '%d tassaɛin',
                d: 'ass',
                dd: '%d ossan',
                M: 'ayowr',
                MM: '%d iyyirn',
                y: 'asgas',
                yy: '%d isgasn',
            },
            week: {
                dow: 6, // Saturday is the first day of the week.
                doy: 12, // The week that contains Jan 12th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        hooks.defineLocale('tzm', {
            months: 'ⵉⵏⵏⴰⵢⵔ_ⴱⵕⴰⵢⵕ_ⵎⴰⵕⵚ_ⵉⴱⵔⵉⵔ_ⵎⴰⵢⵢⵓ_ⵢⵓⵏⵢⵓ_ⵢⵓⵍⵢⵓⵣ_ⵖⵓⵛⵜ_ⵛⵓⵜⴰⵏⴱⵉⵔ_ⴽⵟⵓⴱⵕ_ⵏⵓⵡⴰⵏⴱⵉⵔ_ⴷⵓⵊⵏⴱⵉⵔ'.split(
                '_'
            ),
            monthsShort: 'ⵉⵏⵏⴰⵢⵔ_ⴱⵕⴰⵢⵕ_ⵎⴰⵕⵚ_ⵉⴱⵔⵉⵔ_ⵎⴰⵢⵢⵓ_ⵢⵓⵏⵢⵓ_ⵢⵓⵍⵢⵓⵣ_ⵖⵓⵛⵜ_ⵛⵓⵜⴰⵏⴱⵉⵔ_ⴽⵟⵓⴱⵕ_ⵏⵓⵡⴰⵏⴱⵉⵔ_ⴷⵓⵊⵏⴱⵉⵔ'.split(
                '_'
            ),
            weekdays: 'ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ'.split('_'),
            weekdaysShort: 'ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ'.split('_'),
            weekdaysMin: 'ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ'.split('_'),
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'DD/MM/YYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY HH:mm',
                LLLL: 'dddd D MMMM YYYY HH:mm',
            },
            calendar: {
                sameDay: '[ⴰⵙⴷⵅ ⴴ] LT',
                nextDay: '[ⴰⵙⴽⴰ ⴴ] LT',
                nextWeek: 'dddd [ⴴ] LT',
                lastDay: '[ⴰⵚⴰⵏⵜ ⴴ] LT',
                lastWeek: 'dddd [ⴴ] LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: 'ⴷⴰⴷⵅ ⵙ ⵢⴰⵏ %s',
                past: 'ⵢⴰⵏ %s',
                s: 'ⵉⵎⵉⴽ',
                ss: '%d ⵉⵎⵉⴽ',
                m: 'ⵎⵉⵏⵓⴺ',
                mm: '%d ⵎⵉⵏⵓⴺ',
                h: 'ⵙⴰⵄⴰ',
                hh: '%d ⵜⴰⵙⵙⴰⵄⵉⵏ',
                d: 'ⴰⵙⵙ',
                dd: '%d oⵙⵙⴰⵏ',
                M: 'ⴰⵢoⵓⵔ',
                MM: '%d ⵉⵢⵢⵉⵔⵏ',
                y: 'ⴰⵙⴳⴰⵙ',
                yy: '%d ⵉⵙⴳⴰⵙⵏ',
            },
            week: {
                dow: 6, // Saturday is the first day of the week.
                doy: 12, // The week that contains Jan 12th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        hooks.defineLocale('ug-cn', {
            months: 'يانۋار_فېۋرال_مارت_ئاپرېل_ماي_ئىيۇن_ئىيۇل_ئاۋغۇست_سېنتەبىر_ئۆكتەبىر_نويابىر_دېكابىر'.split(
                '_'
            ),
            monthsShort: 'يانۋار_فېۋرال_مارت_ئاپرېل_ماي_ئىيۇن_ئىيۇل_ئاۋغۇست_سېنتەبىر_ئۆكتەبىر_نويابىر_دېكابىر'.split(
                '_'
            ),
            weekdays: 'يەكشەنبە_دۈشەنبە_سەيشەنبە_چارشەنبە_پەيشەنبە_جۈمە_شەنبە'.split(
                '_'
            ),
            weekdaysShort: 'يە_دۈ_سە_چا_پە_جۈ_شە'.split('_'),
            weekdaysMin: 'يە_دۈ_سە_چا_پە_جۈ_شە'.split('_'),
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'YYYY-MM-DD',
                LL: 'YYYY-يىلىM-ئاينىڭD-كۈنى',
                LLL: 'YYYY-يىلىM-ئاينىڭD-كۈنى، HH:mm',
                LLLL: 'dddd، YYYY-يىلىM-ئاينىڭD-كۈنى، HH:mm',
            },
            meridiemParse: /يېرىم كېچە|سەھەر|چۈشتىن بۇرۇن|چۈش|چۈشتىن كېيىن|كەچ/,
            meridiemHour: function (hour, meridiem) {
                if (hour === 12) {
                    hour = 0;
                }
                if (
                    meridiem === 'يېرىم كېچە' ||
                    meridiem === 'سەھەر' ||
                    meridiem === 'چۈشتىن بۇرۇن'
                ) {
                    return hour;
                } else if (meridiem === 'چۈشتىن كېيىن' || meridiem === 'كەچ') {
                    return hour + 12;
                } else {
                    return hour >= 11 ? hour : hour + 12;
                }
            },
            meridiem: function (hour, minute, isLower) {
                var hm = hour * 100 + minute;
                if (hm < 600) {
                    return 'يېرىم كېچە';
                } else if (hm < 900) {
                    return 'سەھەر';
                } else if (hm < 1130) {
                    return 'چۈشتىن بۇرۇن';
                } else if (hm < 1230) {
                    return 'چۈش';
                } else if (hm < 1800) {
                    return 'چۈشتىن كېيىن';
                } else {
                    return 'كەچ';
                }
            },
            calendar: {
                sameDay: '[بۈگۈن سائەت] LT',
                nextDay: '[ئەتە سائەت] LT',
                nextWeek: '[كېلەركى] dddd [سائەت] LT',
                lastDay: '[تۆنۈگۈن] LT',
                lastWeek: '[ئالدىنقى] dddd [سائەت] LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: '%s كېيىن',
                past: '%s بۇرۇن',
                s: 'نەچچە سېكونت',
                ss: '%d سېكونت',
                m: 'بىر مىنۇت',
                mm: '%d مىنۇت',
                h: 'بىر سائەت',
                hh: '%d سائەت',
                d: 'بىر كۈن',
                dd: '%d كۈن',
                M: 'بىر ئاي',
                MM: '%d ئاي',
                y: 'بىر يىل',
                yy: '%d يىل',
            },

            dayOfMonthOrdinalParse: /\d{1,2}(-كۈنى|-ئاي|-ھەپتە)/,
            ordinal: function (number, period) {
                switch (period) {
                    case 'd':
                    case 'D':
                    case 'DDD':
                        return number + '-كۈنى';
                    case 'w':
                    case 'W':
                        return number + '-ھەپتە';
                    default:
                        return number;
                }
            },
            preparse: function (string) {
                return string.replace(/،/g, ',');
            },
            postformat: function (string) {
                return string.replace(/,/g, '،');
            },
            week: {
                // GB/T 7408-1994《数据元和交换格式·信息交换·日期和时间表示法》与ISO 8601:1988等效
                dow: 1, // Monday is the first day of the week.
                doy: 7, // The week that contains Jan 1st is the first week of the year.
            },
        });

        //! moment.js locale configuration

        function plural$6(word, num) {
            var forms = word.split('_');
            return num % 10 === 1 && num % 100 !== 11
                ? forms[0]
                : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20)
                ? forms[1]
                : forms[2];
        }
        function relativeTimeWithPlural$4(number, withoutSuffix, key) {
            var format = {
                ss: withoutSuffix ? 'секунда_секунди_секунд' : 'секунду_секунди_секунд',
                mm: withoutSuffix ? 'хвилина_хвилини_хвилин' : 'хвилину_хвилини_хвилин',
                hh: withoutSuffix ? 'година_години_годин' : 'годину_години_годин',
                dd: 'день_дні_днів',
                MM: 'місяць_місяці_місяців',
                yy: 'рік_роки_років',
            };
            if (key === 'm') {
                return withoutSuffix ? 'хвилина' : 'хвилину';
            } else if (key === 'h') {
                return withoutSuffix ? 'година' : 'годину';
            } else {
                return number + ' ' + plural$6(format[key], +number);
            }
        }
        function weekdaysCaseReplace(m, format) {
            var weekdays = {
                    nominative: 'неділя_понеділок_вівторок_середа_четвер_п’ятниця_субота'.split(
                        '_'
                    ),
                    accusative: 'неділю_понеділок_вівторок_середу_четвер_п’ятницю_суботу'.split(
                        '_'
                    ),
                    genitive: 'неділі_понеділка_вівторка_середи_четверга_п’ятниці_суботи'.split(
                        '_'
                    ),
                },
                nounCase;

            if (m === true) {
                return weekdays['nominative']
                    .slice(1, 7)
                    .concat(weekdays['nominative'].slice(0, 1));
            }
            if (!m) {
                return weekdays['nominative'];
            }

            nounCase = /(\[[ВвУу]\]) ?dddd/.test(format)
                ? 'accusative'
                : /\[?(?:минулої|наступної)? ?\] ?dddd/.test(format)
                ? 'genitive'
                : 'nominative';
            return weekdays[nounCase][m.day()];
        }
        function processHoursFunction(str) {
            return function () {
                return str + 'о' + (this.hours() === 11 ? 'б' : '') + '] LT';
            };
        }

        hooks.defineLocale('uk', {
            months: {
                format: 'січня_лютого_березня_квітня_травня_червня_липня_серпня_вересня_жовтня_листопада_грудня'.split(
                    '_'
                ),
                standalone: 'січень_лютий_березень_квітень_травень_червень_липень_серпень_вересень_жовтень_листопад_грудень'.split(
                    '_'
                ),
            },
            monthsShort: 'січ_лют_бер_квіт_трав_черв_лип_серп_вер_жовт_лист_груд'.split(
                '_'
            ),
            weekdays: weekdaysCaseReplace,
            weekdaysShort: 'нд_пн_вт_ср_чт_пт_сб'.split('_'),
            weekdaysMin: 'нд_пн_вт_ср_чт_пт_сб'.split('_'),
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'DD.MM.YYYY',
                LL: 'D MMMM YYYY р.',
                LLL: 'D MMMM YYYY р., HH:mm',
                LLLL: 'dddd, D MMMM YYYY р., HH:mm',
            },
            calendar: {
                sameDay: processHoursFunction('[Сьогодні '),
                nextDay: processHoursFunction('[Завтра '),
                lastDay: processHoursFunction('[Вчора '),
                nextWeek: processHoursFunction('[У] dddd ['),
                lastWeek: function () {
                    switch (this.day()) {
                        case 0:
                        case 3:
                        case 5:
                        case 6:
                            return processHoursFunction('[Минулої] dddd [').call(this);
                        case 1:
                        case 2:
                        case 4:
                            return processHoursFunction('[Минулого] dddd [').call(this);
                    }
                },
                sameElse: 'L',
            },
            relativeTime: {
                future: 'за %s',
                past: '%s тому',
                s: 'декілька секунд',
                ss: relativeTimeWithPlural$4,
                m: relativeTimeWithPlural$4,
                mm: relativeTimeWithPlural$4,
                h: 'годину',
                hh: relativeTimeWithPlural$4,
                d: 'день',
                dd: relativeTimeWithPlural$4,
                M: 'місяць',
                MM: relativeTimeWithPlural$4,
                y: 'рік',
                yy: relativeTimeWithPlural$4,
            },
            // M. E.: those two are virtually unused but a user might want to implement them for his/her website for some reason
            meridiemParse: /ночі|ранку|дня|вечора/,
            isPM: function (input) {
                return /^(дня|вечора)$/.test(input);
            },
            meridiem: function (hour, minute, isLower) {
                if (hour < 4) {
                    return 'ночі';
                } else if (hour < 12) {
                    return 'ранку';
                } else if (hour < 17) {
                    return 'дня';
                } else {
                    return 'вечора';
                }
            },
            dayOfMonthOrdinalParse: /\d{1,2}-(й|го)/,
            ordinal: function (number, period) {
                switch (period) {
                    case 'M':
                    case 'd':
                    case 'DDD':
                    case 'w':
                    case 'W':
                        return number + '-й';
                    case 'D':
                        return number + '-го';
                    default:
                        return number;
                }
            },
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 7, // The week that contains Jan 7th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        var months$b = [
                'جنوری',
                'فروری',
                'مارچ',
                'اپریل',
                'مئی',
                'جون',
                'جولائی',
                'اگست',
                'ستمبر',
                'اکتوبر',
                'نومبر',
                'دسمبر',
            ],
            days$2 = ['اتوار', 'پیر', 'منگل', 'بدھ', 'جمعرات', 'جمعہ', 'ہفتہ'];

        hooks.defineLocale('ur', {
            months: months$b,
            monthsShort: months$b,
            weekdays: days$2,
            weekdaysShort: days$2,
            weekdaysMin: days$2,
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'DD/MM/YYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY HH:mm',
                LLLL: 'dddd، D MMMM YYYY HH:mm',
            },
            meridiemParse: /صبح|شام/,
            isPM: function (input) {
                return 'شام' === input;
            },
            meridiem: function (hour, minute, isLower) {
                if (hour < 12) {
                    return 'صبح';
                }
                return 'شام';
            },
            calendar: {
                sameDay: '[آج بوقت] LT',
                nextDay: '[کل بوقت] LT',
                nextWeek: 'dddd [بوقت] LT',
                lastDay: '[گذشتہ روز بوقت] LT',
                lastWeek: '[گذشتہ] dddd [بوقت] LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: '%s بعد',
                past: '%s قبل',
                s: 'چند سیکنڈ',
                ss: '%d سیکنڈ',
                m: 'ایک منٹ',
                mm: '%d منٹ',
                h: 'ایک گھنٹہ',
                hh: '%d گھنٹے',
                d: 'ایک دن',
                dd: '%d دن',
                M: 'ایک ماہ',
                MM: '%d ماہ',
                y: 'ایک سال',
                yy: '%d سال',
            },
            preparse: function (string) {
                return string.replace(/،/g, ',');
            },
            postformat: function (string) {
                return string.replace(/,/g, '،');
            },
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 4, // The week that contains Jan 4th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        hooks.defineLocale('uz-latn', {
            months: 'Yanvar_Fevral_Mart_Aprel_May_Iyun_Iyul_Avgust_Sentabr_Oktabr_Noyabr_Dekabr'.split(
                '_'
            ),
            monthsShort: 'Yan_Fev_Mar_Apr_May_Iyun_Iyul_Avg_Sen_Okt_Noy_Dek'.split('_'),
            weekdays: 'Yakshanba_Dushanba_Seshanba_Chorshanba_Payshanba_Juma_Shanba'.split(
                '_'
            ),
            weekdaysShort: 'Yak_Dush_Sesh_Chor_Pay_Jum_Shan'.split('_'),
            weekdaysMin: 'Ya_Du_Se_Cho_Pa_Ju_Sha'.split('_'),
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'DD/MM/YYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY HH:mm',
                LLLL: 'D MMMM YYYY, dddd HH:mm',
            },
            calendar: {
                sameDay: '[Bugun soat] LT [da]',
                nextDay: '[Ertaga] LT [da]',
                nextWeek: 'dddd [kuni soat] LT [da]',
                lastDay: '[Kecha soat] LT [da]',
                lastWeek: "[O'tgan] dddd [kuni soat] LT [da]",
                sameElse: 'L',
            },
            relativeTime: {
                future: 'Yaqin %s ichida',
                past: 'Bir necha %s oldin',
                s: 'soniya',
                ss: '%d soniya',
                m: 'bir daqiqa',
                mm: '%d daqiqa',
                h: 'bir soat',
                hh: '%d soat',
                d: 'bir kun',
                dd: '%d kun',
                M: 'bir oy',
                MM: '%d oy',
                y: 'bir yil',
                yy: '%d yil',
            },
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 7, // The week that contains Jan 7th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        hooks.defineLocale('uz', {
            months: 'январ_феврал_март_апрел_май_июн_июл_август_сентябр_октябр_ноябр_декабр'.split(
                '_'
            ),
            monthsShort: 'янв_фев_мар_апр_май_июн_июл_авг_сен_окт_ноя_дек'.split('_'),
            weekdays: 'Якшанба_Душанба_Сешанба_Чоршанба_Пайшанба_Жума_Шанба'.split('_'),
            weekdaysShort: 'Якш_Душ_Сеш_Чор_Пай_Жум_Шан'.split('_'),
            weekdaysMin: 'Як_Ду_Се_Чо_Па_Жу_Ша'.split('_'),
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'DD/MM/YYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY HH:mm',
                LLLL: 'D MMMM YYYY, dddd HH:mm',
            },
            calendar: {
                sameDay: '[Бугун соат] LT [да]',
                nextDay: '[Эртага] LT [да]',
                nextWeek: 'dddd [куни соат] LT [да]',
                lastDay: '[Кеча соат] LT [да]',
                lastWeek: '[Утган] dddd [куни соат] LT [да]',
                sameElse: 'L',
            },
            relativeTime: {
                future: 'Якин %s ичида',
                past: 'Бир неча %s олдин',
                s: 'фурсат',
                ss: '%d фурсат',
                m: 'бир дакика',
                mm: '%d дакика',
                h: 'бир соат',
                hh: '%d соат',
                d: 'бир кун',
                dd: '%d кун',
                M: 'бир ой',
                MM: '%d ой',
                y: 'бир йил',
                yy: '%d йил',
            },
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 7, // The week that contains Jan 4th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        hooks.defineLocale('vi', {
            months: 'tháng 1_tháng 2_tháng 3_tháng 4_tháng 5_tháng 6_tháng 7_tháng 8_tháng 9_tháng 10_tháng 11_tháng 12'.split(
                '_'
            ),
            monthsShort: 'Thg 01_Thg 02_Thg 03_Thg 04_Thg 05_Thg 06_Thg 07_Thg 08_Thg 09_Thg 10_Thg 11_Thg 12'.split(
                '_'
            ),
            monthsParseExact: true,
            weekdays: 'chủ nhật_thứ hai_thứ ba_thứ tư_thứ năm_thứ sáu_thứ bảy'.split(
                '_'
            ),
            weekdaysShort: 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
            weekdaysMin: 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
            weekdaysParseExact: true,
            meridiemParse: /sa|ch/i,
            isPM: function (input) {
                return /^ch$/i.test(input);
            },
            meridiem: function (hours, minutes, isLower) {
                if (hours < 12) {
                    return isLower ? 'sa' : 'SA';
                } else {
                    return isLower ? 'ch' : 'CH';
                }
            },
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'DD/MM/YYYY',
                LL: 'D MMMM [năm] YYYY',
                LLL: 'D MMMM [năm] YYYY HH:mm',
                LLLL: 'dddd, D MMMM [năm] YYYY HH:mm',
                l: 'DD/M/YYYY',
                ll: 'D MMM YYYY',
                lll: 'D MMM YYYY HH:mm',
                llll: 'ddd, D MMM YYYY HH:mm',
            },
            calendar: {
                sameDay: '[Hôm nay lúc] LT',
                nextDay: '[Ngày mai lúc] LT',
                nextWeek: 'dddd [tuần tới lúc] LT',
                lastDay: '[Hôm qua lúc] LT',
                lastWeek: 'dddd [tuần trước lúc] LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: '%s tới',
                past: '%s trước',
                s: 'vài giây',
                ss: '%d giây',
                m: 'một phút',
                mm: '%d phút',
                h: 'một giờ',
                hh: '%d giờ',
                d: 'một ngày',
                dd: '%d ngày',
                w: 'một tuần',
                ww: '%d tuần',
                M: 'một tháng',
                MM: '%d tháng',
                y: 'một năm',
                yy: '%d năm',
            },
            dayOfMonthOrdinalParse: /\d{1,2}/,
            ordinal: function (number) {
                return number;
            },
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 4, // The week that contains Jan 4th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        hooks.defineLocale('x-pseudo', {
            months: 'J~áñúá~rý_F~ébrú~árý_~Márc~h_Áp~ríl_~Máý_~Júñé~_Júl~ý_Áú~gúst~_Sép~témb~ér_Ó~ctób~ér_Ñ~óvém~bér_~Décé~mbér'.split(
                '_'
            ),
            monthsShort: 'J~áñ_~Féb_~Már_~Ápr_~Máý_~Júñ_~Júl_~Áúg_~Sép_~Óct_~Ñóv_~Déc'.split(
                '_'
            ),
            monthsParseExact: true,
            weekdays: 'S~úñdá~ý_Mó~ñdáý~_Túé~sdáý~_Wéd~ñésd~áý_T~húrs~dáý_~Fríd~áý_S~átúr~dáý'.split(
                '_'
            ),
            weekdaysShort: 'S~úñ_~Móñ_~Túé_~Wéd_~Thú_~Frí_~Sát'.split('_'),
            weekdaysMin: 'S~ú_Mó~_Tú_~Wé_T~h_Fr~_Sá'.split('_'),
            weekdaysParseExact: true,
            longDateFormat: {
                LT: 'HH:mm',
                L: 'DD/MM/YYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY HH:mm',
                LLLL: 'dddd, D MMMM YYYY HH:mm',
            },
            calendar: {
                sameDay: '[T~ódá~ý át] LT',
                nextDay: '[T~ómó~rró~w át] LT',
                nextWeek: 'dddd [át] LT',
                lastDay: '[Ý~ést~érdá~ý át] LT',
                lastWeek: '[L~ást] dddd [át] LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: 'í~ñ %s',
                past: '%s á~gó',
                s: 'á ~féw ~sécó~ñds',
                ss: '%d s~écóñ~ds',
                m: 'á ~míñ~úté',
                mm: '%d m~íñú~tés',
                h: 'á~ñ hó~úr',
                hh: '%d h~óúrs',
                d: 'á ~dáý',
                dd: '%d d~áýs',
                M: 'á ~móñ~th',
                MM: '%d m~óñt~hs',
                y: 'á ~ýéár',
                yy: '%d ý~éárs',
            },
            dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
            ordinal: function (number) {
                var b = number % 10,
                    output =
                        ~~((number % 100) / 10) === 1
                            ? 'th'
                            : b === 1
                            ? 'st'
                            : b === 2
                            ? 'nd'
                            : b === 3
                            ? 'rd'
                            : 'th';
                return number + output;
            },
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 4, // The week that contains Jan 4th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        hooks.defineLocale('yo', {
            months: 'Sẹ́rẹ́_Èrèlè_Ẹrẹ̀nà_Ìgbé_Èbibi_Òkùdu_Agẹmo_Ògún_Owewe_Ọ̀wàrà_Bélú_Ọ̀pẹ̀̀'.split(
                '_'
            ),
            monthsShort: 'Sẹ́r_Èrl_Ẹrn_Ìgb_Èbi_Òkù_Agẹ_Ògú_Owe_Ọ̀wà_Bél_Ọ̀pẹ̀̀'.split('_'),
            weekdays: 'Àìkú_Ajé_Ìsẹ́gun_Ọjọ́rú_Ọjọ́bọ_Ẹtì_Àbámẹ́ta'.split('_'),
            weekdaysShort: 'Àìk_Ajé_Ìsẹ́_Ọjr_Ọjb_Ẹtì_Àbá'.split('_'),
            weekdaysMin: 'Àì_Aj_Ìs_Ọr_Ọb_Ẹt_Àb'.split('_'),
            longDateFormat: {
                LT: 'h:mm A',
                LTS: 'h:mm:ss A',
                L: 'DD/MM/YYYY',
                LL: 'D MMMM YYYY',
                LLL: 'D MMMM YYYY h:mm A',
                LLLL: 'dddd, D MMMM YYYY h:mm A',
            },
            calendar: {
                sameDay: '[Ònì ni] LT',
                nextDay: '[Ọ̀la ni] LT',
                nextWeek: "dddd [Ọsẹ̀ tón'bọ] [ni] LT",
                lastDay: '[Àna ni] LT',
                lastWeek: 'dddd [Ọsẹ̀ tólọ́] [ni] LT',
                sameElse: 'L',
            },
            relativeTime: {
                future: 'ní %s',
                past: '%s kọjá',
                s: 'ìsẹjú aayá die',
                ss: 'aayá %d',
                m: 'ìsẹjú kan',
                mm: 'ìsẹjú %d',
                h: 'wákati kan',
                hh: 'wákati %d',
                d: 'ọjọ́ kan',
                dd: 'ọjọ́ %d',
                M: 'osù kan',
                MM: 'osù %d',
                y: 'ọdún kan',
                yy: 'ọdún %d',
            },
            dayOfMonthOrdinalParse: /ọjọ́\s\d{1,2}/,
            ordinal: 'ọjọ́ %d',
            week: {
                dow: 1, // Monday is the first day of the week.
                doy: 4, // The week that contains Jan 4th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        hooks.defineLocale('zh-cn', {
            months: '一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月'.split(
                '_'
            ),
            monthsShort: '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split(
                '_'
            ),
            weekdays: '星期日_星期一_星期二_星期三_星期四_星期五_星期六'.split('_'),
            weekdaysShort: '周日_周一_周二_周三_周四_周五_周六'.split('_'),
            weekdaysMin: '日_一_二_三_四_五_六'.split('_'),
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'YYYY/MM/DD',
                LL: 'YYYY年M月D日',
                LLL: 'YYYY年M月D日Ah点mm分',
                LLLL: 'YYYY年M月D日ddddAh点mm分',
                l: 'YYYY/M/D',
                ll: 'YYYY年M月D日',
                lll: 'YYYY年M月D日 HH:mm',
                llll: 'YYYY年M月D日dddd HH:mm',
            },
            meridiemParse: /凌晨|早上|上午|中午|下午|晚上/,
            meridiemHour: function (hour, meridiem) {
                if (hour === 12) {
                    hour = 0;
                }
                if (meridiem === '凌晨' || meridiem === '早上' || meridiem === '上午') {
                    return hour;
                } else if (meridiem === '下午' || meridiem === '晚上') {
                    return hour + 12;
                } else {
                    // '中午'
                    return hour >= 11 ? hour : hour + 12;
                }
            },
            meridiem: function (hour, minute, isLower) {
                var hm = hour * 100 + minute;
                if (hm < 600) {
                    return '凌晨';
                } else if (hm < 900) {
                    return '早上';
                } else if (hm < 1130) {
                    return '上午';
                } else if (hm < 1230) {
                    return '中午';
                } else if (hm < 1800) {
                    return '下午';
                } else {
                    return '晚上';
                }
            },
            calendar: {
                sameDay: '[今天]LT',
                nextDay: '[明天]LT',
                nextWeek: function (now) {
                    if (now.week() !== this.week()) {
                        return '[下]dddLT';
                    } else {
                        return '[本]dddLT';
                    }
                },
                lastDay: '[昨天]LT',
                lastWeek: function (now) {
                    if (this.week() !== now.week()) {
                        return '[上]dddLT';
                    } else {
                        return '[本]dddLT';
                    }
                },
                sameElse: 'L',
            },
            dayOfMonthOrdinalParse: /\d{1,2}(日|月|周)/,
            ordinal: function (number, period) {
                switch (period) {
                    case 'd':
                    case 'D':
                    case 'DDD':
                        return number + '日';
                    case 'M':
                        return number + '月';
                    case 'w':
                    case 'W':
                        return number + '周';
                    default:
                        return number;
                }
            },
            relativeTime: {
                future: '%s后',
                past: '%s前',
                s: '几秒',
                ss: '%d 秒',
                m: '1 分钟',
                mm: '%d 分钟',
                h: '1 小时',
                hh: '%d 小时',
                d: '1 天',
                dd: '%d 天',
                w: '1 周',
                ww: '%d 周',
                M: '1 个月',
                MM: '%d 个月',
                y: '1 年',
                yy: '%d 年',
            },
            week: {
                // GB/T 7408-1994《数据元和交换格式·信息交换·日期和时间表示法》与ISO 8601:1988等效
                dow: 1, // Monday is the first day of the week.
                doy: 4, // The week that contains Jan 4th is the first week of the year.
            },
        });

        //! moment.js locale configuration

        hooks.defineLocale('zh-hk', {
            months: '一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月'.split(
                '_'
            ),
            monthsShort: '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split(
                '_'
            ),
            weekdays: '星期日_星期一_星期二_星期三_星期四_星期五_星期六'.split('_'),
            weekdaysShort: '週日_週一_週二_週三_週四_週五_週六'.split('_'),
            weekdaysMin: '日_一_二_三_四_五_六'.split('_'),
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'YYYY/MM/DD',
                LL: 'YYYY年M月D日',
                LLL: 'YYYY年M月D日 HH:mm',
                LLLL: 'YYYY年M月D日dddd HH:mm',
                l: 'YYYY/M/D',
                ll: 'YYYY年M月D日',
                lll: 'YYYY年M月D日 HH:mm',
                llll: 'YYYY年M月D日dddd HH:mm',
            },
            meridiemParse: /凌晨|早上|上午|中午|下午|晚上/,
            meridiemHour: function (hour, meridiem) {
                if (hour === 12) {
                    hour = 0;
                }
                if (meridiem === '凌晨' || meridiem === '早上' || meridiem === '上午') {
                    return hour;
                } else if (meridiem === '中午') {
                    return hour >= 11 ? hour : hour + 12;
                } else if (meridiem === '下午' || meridiem === '晚上') {
                    return hour + 12;
                }
            },
            meridiem: function (hour, minute, isLower) {
                var hm = hour * 100 + minute;
                if (hm < 600) {
                    return '凌晨';
                } else if (hm < 900) {
                    return '早上';
                } else if (hm < 1200) {
                    return '上午';
                } else if (hm === 1200) {
                    return '中午';
                } else if (hm < 1800) {
                    return '下午';
                } else {
                    return '晚上';
                }
            },
            calendar: {
                sameDay: '[今天]LT',
                nextDay: '[明天]LT',
                nextWeek: '[下]ddddLT',
                lastDay: '[昨天]LT',
                lastWeek: '[上]ddddLT',
                sameElse: 'L',
            },
            dayOfMonthOrdinalParse: /\d{1,2}(日|月|週)/,
            ordinal: function (number, period) {
                switch (period) {
                    case 'd':
                    case 'D':
                    case 'DDD':
                        return number + '日';
                    case 'M':
                        return number + '月';
                    case 'w':
                    case 'W':
                        return number + '週';
                    default:
                        return number;
                }
            },
            relativeTime: {
                future: '%s後',
                past: '%s前',
                s: '幾秒',
                ss: '%d 秒',
                m: '1 分鐘',
                mm: '%d 分鐘',
                h: '1 小時',
                hh: '%d 小時',
                d: '1 天',
                dd: '%d 天',
                M: '1 個月',
                MM: '%d 個月',
                y: '1 年',
                yy: '%d 年',
            },
        });

        //! moment.js locale configuration

        hooks.defineLocale('zh-mo', {
            months: '一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月'.split(
                '_'
            ),
            monthsShort: '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split(
                '_'
            ),
            weekdays: '星期日_星期一_星期二_星期三_星期四_星期五_星期六'.split('_'),
            weekdaysShort: '週日_週一_週二_週三_週四_週五_週六'.split('_'),
            weekdaysMin: '日_一_二_三_四_五_六'.split('_'),
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'DD/MM/YYYY',
                LL: 'YYYY年M月D日',
                LLL: 'YYYY年M月D日 HH:mm',
                LLLL: 'YYYY年M月D日dddd HH:mm',
                l: 'D/M/YYYY',
                ll: 'YYYY年M月D日',
                lll: 'YYYY年M月D日 HH:mm',
                llll: 'YYYY年M月D日dddd HH:mm',
            },
            meridiemParse: /凌晨|早上|上午|中午|下午|晚上/,
            meridiemHour: function (hour, meridiem) {
                if (hour === 12) {
                    hour = 0;
                }
                if (meridiem === '凌晨' || meridiem === '早上' || meridiem === '上午') {
                    return hour;
                } else if (meridiem === '中午') {
                    return hour >= 11 ? hour : hour + 12;
                } else if (meridiem === '下午' || meridiem === '晚上') {
                    return hour + 12;
                }
            },
            meridiem: function (hour, minute, isLower) {
                var hm = hour * 100 + minute;
                if (hm < 600) {
                    return '凌晨';
                } else if (hm < 900) {
                    return '早上';
                } else if (hm < 1130) {
                    return '上午';
                } else if (hm < 1230) {
                    return '中午';
                } else if (hm < 1800) {
                    return '下午';
                } else {
                    return '晚上';
                }
            },
            calendar: {
                sameDay: '[今天] LT',
                nextDay: '[明天] LT',
                nextWeek: '[下]dddd LT',
                lastDay: '[昨天] LT',
                lastWeek: '[上]dddd LT',
                sameElse: 'L',
            },
            dayOfMonthOrdinalParse: /\d{1,2}(日|月|週)/,
            ordinal: function (number, period) {
                switch (period) {
                    case 'd':
                    case 'D':
                    case 'DDD':
                        return number + '日';
                    case 'M':
                        return number + '月';
                    case 'w':
                    case 'W':
                        return number + '週';
                    default:
                        return number;
                }
            },
            relativeTime: {
                future: '%s內',
                past: '%s前',
                s: '幾秒',
                ss: '%d 秒',
                m: '1 分鐘',
                mm: '%d 分鐘',
                h: '1 小時',
                hh: '%d 小時',
                d: '1 天',
                dd: '%d 天',
                M: '1 個月',
                MM: '%d 個月',
                y: '1 年',
                yy: '%d 年',
            },
        });

        //! moment.js locale configuration

        hooks.defineLocale('zh-tw', {
            months: '一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月'.split(
                '_'
            ),
            monthsShort: '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split(
                '_'
            ),
            weekdays: '星期日_星期一_星期二_星期三_星期四_星期五_星期六'.split('_'),
            weekdaysShort: '週日_週一_週二_週三_週四_週五_週六'.split('_'),
            weekdaysMin: '日_一_二_三_四_五_六'.split('_'),
            longDateFormat: {
                LT: 'HH:mm',
                LTS: 'HH:mm:ss',
                L: 'YYYY/MM/DD',
                LL: 'YYYY年M月D日',
                LLL: 'YYYY年M月D日 HH:mm',
                LLLL: 'YYYY年M月D日dddd HH:mm',
                l: 'YYYY/M/D',
                ll: 'YYYY年M月D日',
                lll: 'YYYY年M月D日 HH:mm',
                llll: 'YYYY年M月D日dddd HH:mm',
            },
            meridiemParse: /凌晨|早上|上午|中午|下午|晚上/,
            meridiemHour: function (hour, meridiem) {
                if (hour === 12) {
                    hour = 0;
                }
                if (meridiem === '凌晨' || meridiem === '早上' || meridiem === '上午') {
                    return hour;
                } else if (meridiem === '中午') {
                    return hour >= 11 ? hour : hour + 12;
                } else if (meridiem === '下午' || meridiem === '晚上') {
                    return hour + 12;
                }
            },
            meridiem: function (hour, minute, isLower) {
                var hm = hour * 100 + minute;
                if (hm < 600) {
                    return '凌晨';
                } else if (hm < 900) {
                    return '早上';
                } else if (hm < 1130) {
                    return '上午';
                } else if (hm < 1230) {
                    return '中午';
                } else if (hm < 1800) {
                    return '下午';
                } else {
                    return '晚上';
                }
            },
            calendar: {
                sameDay: '[今天] LT',
                nextDay: '[明天] LT',
                nextWeek: '[下]dddd LT',
                lastDay: '[昨天] LT',
                lastWeek: '[上]dddd LT',
                sameElse: 'L',
            },
            dayOfMonthOrdinalParse: /\d{1,2}(日|月|週)/,
            ordinal: function (number, period) {
                switch (period) {
                    case 'd':
                    case 'D':
                    case 'DDD':
                        return number + '日';
                    case 'M':
                        return number + '月';
                    case 'w':
                    case 'W':
                        return number + '週';
                    default:
                        return number;
                }
            },
            relativeTime: {
                future: '%s後',
                past: '%s前',
                s: '幾秒',
                ss: '%d 秒',
                m: '1 分鐘',
                mm: '%d 分鐘',
                h: '1 小時',
                hh: '%d 小時',
                d: '1 天',
                dd: '%d 天',
                M: '1 個月',
                MM: '%d 個月',
                y: '1 年',
                yy: '%d 年',
            },
        });

        hooks.locale('en');

        return hooks;

    })));
    });

    var RouteParameterBuilder = /** @class */ (function () {
        function RouteParameterBuilder(parameterName, app) {
            this.defaultParameters = {};
            this.getFormInstance = function (formId, throwError) { return app.getFormInstance(formId, null); };
            this.parameterName = parameterName;
            this.defaultParameters[parameterName] = "";
        }
        RouteParameterBuilder.prototype.buildFormRouteParameters = function (form, values) {
            var formInstance = this.getFormInstance(form, true);
            var base = formInstance.getSerializedInputValuesFromObject(values);
            if (form === this.currentForm) {
                var d = RouteParameterBuilder.parseQueryStringParameters(location.hash)[this.parameterName] || 0;
                var dAsNumber = parseInt(d, 10);
                base[this.parameterName] = isNaN(dAsNumber) ? 0 : dAsNumber + 1;
            }
            return __assign({}, base, { _id: form });
        };
        RouteParameterBuilder.parseQueryStringParameters = function (url) {
            var queryStartsAt = url.indexOf("?");
            var result = {};
            // If there is a query string.
            if (queryStartsAt !== -1 && url.length > queryStartsAt) {
                url.substr(queryStartsAt + 1).split("&").filter(function (t) {
                    var value = t.split("=");
                    result[value[0]] = value[1];
                });
            }
            return result;
        };
        return RouteParameterBuilder;
    }());

    var stateStringParser = function(stateString) {
    	return stateString.split('.').reduce(function(stateNames, latestNameChunk) {
    		if (stateNames.length) {
    			latestNameChunk = stateNames[stateNames.length - 1] + '.' + latestNameChunk;
    		}
    		stateNames.push(latestNameChunk);
    		return stateNames
    	}, [])
    };

    var parse = stateStringParser;

    var stateState = function StateState() {
    	var states = {};

    	function getHierarchy(name) {
    		var names = stateStringParser(name);

    		return names.map(function(name) {
    			if (!states[name]) {
    				throw new Error('State ' + name + ' not found')
    			}
    			return states[name]
    		})
    	}

    	function getParent(name) {
    		var parentName = getParentName(name);

    		return parentName && states[parentName]
    	}

    	function getParentName(name) {
    		var names = stateStringParser(name);

    		if (names.length > 1) {
    			var secondToLast = names.length - 2;

    			return names[secondToLast]
    		} else {
    			return null
    		}
    	}

    	function guaranteeAllStatesExist(newStateName) {
    		var stateNames = parse(newStateName);
    		var statesThatDontExist = stateNames.filter(function(name) {
    			return !states[name]
    		});

    		if (statesThatDontExist.length > 0) {
    			throw new Error('State ' + statesThatDontExist[statesThatDontExist.length - 1] + ' does not exist')
    		}
    	}

    	function buildFullStateRoute(stateName) {
    		return getHierarchy(stateName).map(function(state) {
    			return '/' + (state.route || '')
    		}).join('').replace(/\/{2,}/g, '/')
    	}

    	function applyDefaultChildStates(stateName) {
    		var state = states[stateName];

    		function getDefaultChildStateName() {
    			return state && (typeof state.defaultChild === 'function'
    				? state.defaultChild()
    				: state.defaultChild)
    		}

    		var defaultChildStateName = getDefaultChildStateName();

    		if (!defaultChildStateName) {
    			return stateName
    		}

    		var fullStateName = stateName + '.' + defaultChildStateName;

    		return applyDefaultChildStates(fullStateName)
    	}


    	return {
    		add: function(name, state) {
    			states[name] = state;
    		},
    		get: function(name) {
    			return name && states[name]
    		},
    		getHierarchy: getHierarchy,
    		getParent: getParent,
    		getParentName: getParentName,
    		guaranteeAllStatesExist: guaranteeAllStatesExist,
    		buildFullStateRoute: buildFullStateRoute,
    		applyDefaultChildStates: applyDefaultChildStates
    	}
    };

    var combineArrays = function(obj) {
    	var keys = Object.keys(obj);

    	keys.forEach(function(key) {
    		if (!Array.isArray(obj[key])) {
    			throw new Error(key + ' is not an array')
    		}
    	});

    	var maxIndex = keys.reduce(function(maxSoFar, key) {
    		var len = obj[key].length;
    		return maxSoFar > len ? maxSoFar : len
    	}, 0);

    	var output = [];

    	function getObject(index) {
    		var o = {};
    		keys.forEach(function(key) {
    			o[key] = obj[key][index];
    		});
    		return o
    	}

    	for (var i = 0; i < maxIndex; ++i) {
    		output.push(getObject(i));
    	}

    	return output
    };

    var isarray = Array.isArray || function (arr) {
      return Object.prototype.toString.call(arr) == '[object Array]';
    };

    /**
     * Expose `pathToRegexp`.
     */
    var pathToRegexpWithReversibleKeys = pathToRegexp;

    /**
     * The main path matching regexp utility.
     *
     * @type {RegExp}
     */
    var PATH_REGEXP = new RegExp([
      // Match escaped characters that would otherwise appear in future matches.
      // This allows the user to escape special characters that won't transform.
      '(\\\\.)',
      // Match Express-style parameters and un-named parameters with a prefix
      // and optional suffixes. Matches appear as:
      //
      // "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?"]
      // "/route(\\d+)" => [undefined, undefined, undefined, "\d+", undefined]
      '([\\/.])?(?:\\:(\\w+)(?:\\(((?:\\\\.|[^)])*)\\))?|\\(((?:\\\\.|[^)])*)\\))([+*?])?',
      // Match regexp special characters that are always escaped.
      '([.+*?=^!:${}()[\\]|\\/])'
    ].join('|'), 'g');

    /**
     * Escape the capturing group by escaping special characters and meaning.
     *
     * @param  {String} group
     * @return {String}
     */
    function escapeGroup (group) {
      return group.replace(/([=!:$\/()])/g, '\\$1');
    }

    /**
     * Attach the keys as a property of the regexp.
     *
     * @param  {RegExp} re
     * @param  {Array}  keys
     * @return {RegExp}
     */
    function attachKeys (re, keys, allTokens) {
      re.keys = keys;
      re.allTokens = allTokens;
      return re;
    }

    /**
     * Get the flags for a regexp from the options.
     *
     * @param  {Object} options
     * @return {String}
     */
    function flags (options) {
      return options.sensitive ? '' : 'i';
    }

    /**
     * Pull out keys from a regexp.
     *
     * @param  {RegExp} path
     * @param  {Array}  keys
     * @return {RegExp}
     */
    function regexpToRegexp (path, keys, allTokens) {
      // Use a negative lookahead to match only capturing groups.
      var groups = path.source.match(/\((?!\?)/g);

      if (groups) {
        for (var i = 0; i < groups.length; i++) {
          keys.push({
            name:      i,
            delimiter: null,
            optional:  false,
            repeat:    false
          });
        }
      }

      return attachKeys(path, keys, allTokens);
    }

    /**
     * Transform an array into a regexp.
     *
     * @param  {Array}  path
     * @param  {Array}  keys
     * @param  {Object} options
     * @return {RegExp}
     */
    function arrayToRegexp (path, keys, options, allTokens) {
      var parts = [];

      for (var i = 0; i < path.length; i++) {
        parts.push(pathToRegexp(path[i], keys, options, allTokens).source);
      }

      var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));
      return attachKeys(regexp, keys, allTokens);
    }

    /**
     * Replace the specific tags with regexp strings.
     *
     * @param  {String} path
     * @param  {Array}  keys
     * @return {String}
     */
    function replacePath (path, keys, allTokens) {
      var index = 0;
      var lastEndIndex = 0;

      function addLastToken(lastToken) {
        if (lastEndIndex === 0 && lastToken[0] !== '/') {
          lastToken = '/' + lastToken;
        }
        allTokens.push({
          string: lastToken
        });
      }


      function replace (match, escaped, prefix, key, capture, group, suffix, escape, offset) {
        if (escaped) {
          return escaped;
        }

        if (escape) {
          return '\\' + escape;
        }

        var repeat   = suffix === '+' || suffix === '*';
        var optional = suffix === '?' || suffix === '*';

        if (offset > lastEndIndex) {
          addLastToken(path.substring(lastEndIndex, offset));
        }

        lastEndIndex = offset + match.length;

        var newKey = {
          name:      key || index++,
          delimiter: prefix || '/',
          optional:  optional,
          repeat:    repeat
        };

        keys.push(newKey);
        allTokens.push(newKey);

        prefix = prefix ? ('\\' + prefix) : '';
        capture = escapeGroup(capture || group || '[^' + (prefix || '\\/') + ']+?');

        if (repeat) {
          capture = capture + '(?:' + prefix + capture + ')*';
        }

        if (optional) {
          return '(?:' + prefix + '(' + capture + '))?';
        }

        // Basic parameter support.
        return prefix + '(' + capture + ')';
      }

      var newPath = path.replace(PATH_REGEXP, replace);

      if (lastEndIndex < path.length) {
        addLastToken(path.substring(lastEndIndex));
      }

      return newPath;
    }

    /**
     * Normalize the given path string, returning a regular expression.
     *
     * An empty array can be passed in for the keys, which will hold the
     * placeholder key descriptions. For example, using `/user/:id`, `keys` will
     * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
     *
     * @param  {(String|RegExp|Array)} path
     * @param  {Array}                 [keys]
     * @param  {Object}                [options]
     * @return {RegExp}
     */
    function pathToRegexp (path, keys, options, allTokens) {
      keys = keys || [];
      allTokens = allTokens || [];

      if (!isarray(keys)) {
        options = keys;
        keys = [];
      } else if (!options) {
        options = {};
      }

      if (path instanceof RegExp) {
        return regexpToRegexp(path, keys, options, allTokens);
      }

      if (isarray(path)) {
        return arrayToRegexp(path, keys, options, allTokens);
      }

      var strict = options.strict;
      var end = options.end !== false;
      var route = replacePath(path, keys, allTokens);
      var endsWithSlash = path.charAt(path.length - 1) === '/';

      // In non-strict mode we allow a slash at the end of match. If the path to
      // match already ends with a slash, we remove it for consistency. The slash
      // is valid at the end of a path match, not in the middle. This is important
      // in non-ending mode, where "/test/" shouldn't match "/test//route".
      if (!strict) {
        route = (endsWithSlash ? route.slice(0, -2) : route) + '(?:\\/(?=$))?';
      }

      if (end) {
        route += '$';
      } else {
        // In non-ending mode, we need the capturing groups to match as much as
        // possible by using a positive lookahead to the end or next path segment.
        route += strict && endsWithSlash ? '' : '(?=\\/|$)';
      }

      return attachKeys(new RegExp('^' + route, flags(options)), keys, allTokens);
    }

    var stateComparison_1 = function StateComparison(stateState) {
    	var getPathParameters = pathParameters();

    	var parametersChanged = parametersThatMatterWereChanged.bind(null, stateState, getPathParameters);

    	return stateComparison.bind(null, parametersChanged)
    };

    function pathParameters() {
    	var parameters = {};

    	return function getPathParameters(path) {
    		if (!path) {
    			return []
    		}

    		if (!parameters[path]) {
    			parameters[path] = pathToRegexpWithReversibleKeys(path).keys.map(function(key) {
    				return key.name
    			});
    		}

    		return parameters[path]
    	}
    }

    function parametersThatMatterWereChanged(stateState, getPathParameters, stateName, fromParameters, toParameters) {
    	var state = stateState.get(stateName);
    	var querystringParameters = state.querystringParameters || [];
    	var parameters = getPathParameters(state.route).concat(querystringParameters);

    	return Array.isArray(parameters) && parameters.some(function(key) {
    		return fromParameters[key] !== toParameters[key]
    	})
    }

    function stateComparison(parametersChanged, originalState, originalParameters, newState, newParameters) {
    	var states = combineArrays({
    		start: stateStringParser(originalState),
    		end: stateStringParser(newState)
    	});

    	return states.map(function(states) {
    		return {
    			nameBefore: states.start,
    			nameAfter: states.end,
    			stateNameChanged: states.start !== states.end,
    			stateParametersChanged: states.start === states.end && parametersChanged(states.start, originalParameters, newParameters)
    		}
    	})
    }

    var currentState = function CurrentState() {
    	var current = {
    		name: '',
    		parameters: {}
    	};

    	return {
    		get: function() {
    			return current
    		},
    		set: function(name, parameters) {
    			current = {
    				name: name,
    				parameters: parameters
    			};
    		}
    	}
    };

    var stateChangeLogic = function stateChangeLogic(stateComparisonResults) {
    	var hitChangingState = false;
    	var hitDestroyedState = false;

    	var output = {
    		destroy: [],
    		change: [],
    		create: []
    	};

    	stateComparisonResults.forEach(function(state) {
    		hitChangingState = hitChangingState || state.stateParametersChanged;
    		hitDestroyedState = hitDestroyedState || state.stateNameChanged;

    		if (state.nameBefore) {
    			if (hitDestroyedState) {
    				output.destroy.push(state.nameBefore);
    			} else if (hitChangingState) {
    				output.change.push(state.nameBefore);
    			}
    		}

    		if (state.nameAfter && hitDestroyedState) {
    			output.create.push(state.nameAfter);
    		}
    	});

    	return output
    };

    var stateTransitionManager = function (emitter) {
    	var currentTransitionAttempt = null;
    	var nextTransition = null;

    	function doneTransitioning() {
    		currentTransitionAttempt = null;
    		if (nextTransition) {
    			beginNextTransitionAttempt();
    		}
    	}

    	function isTransitioning() {
    		return !!currentTransitionAttempt
    	}

    	function beginNextTransitionAttempt() {
    		currentTransitionAttempt = nextTransition;
    		nextTransition = null;
    		currentTransitionAttempt.beginStateChange();
    	}

    	function cancelCurrentTransition() {
    		currentTransitionAttempt.transition.cancelled = true;
    		var err = new Error('State transition cancelled by the state transition manager');
    		err.wasCancelledBySomeoneElse = true;
    		emitter.emit('stateChangeCancelled', err);
    	}

    	emitter.on('stateChangeAttempt', function(beginStateChange) {
    		nextTransition = createStateTransitionAttempt(beginStateChange);

    		if (isTransitioning() && currentTransitionAttempt.transition.cancellable) {
    			cancelCurrentTransition();
    		} else if (!isTransitioning()) {
    			beginNextTransitionAttempt();
    		}
    	});

    	emitter.on('stateChangeError', doneTransitioning);
    	emitter.on('stateChangeCancelled', doneTransitioning);
    	emitter.on('stateChangeEnd', doneTransitioning);

    	function createStateTransitionAttempt(beginStateChange) {
    		var transition = {
    			cancelled: false,
    			cancellable: true
    		};
    		return {
    			transition: transition,
    			beginStateChange: beginStateChange.bind(null, transition)
    		}
    	}
    };

    var defaultRouterOptions = { reverse: false };

    var npo = createCommonjsModule(function (module) {
    /*! Native Promise Only
        v0.8.1 (c) Kyle Simpson
        MIT License: http://getify.mit-license.org
    */
    !function(t,n,e){n[t]=n[t]||e(),module.exports?module.exports=n[t]:"function"==typeof undefined&&undefined.amd&&undefined(function(){return n[t]});}("Promise","undefined"!=typeof commonjsGlobal?commonjsGlobal:commonjsGlobal,function(){function t(t,n){l.add(t,n),h||(h=y(l.drain));}function n(t){var n,e=typeof t;return null==t||"object"!=e&&"function"!=e||(n=t.then),"function"==typeof n?n:!1}function e(){for(var t=0;t<this.chain.length;t++)o(this,1===this.state?this.chain[t].success:this.chain[t].failure,this.chain[t]);this.chain.length=0;}function o(t,e,o){var r,i;try{e===!1?o.reject(t.msg):(r=e===!0?t.msg:e.call(void 0,t.msg),r===o.promise?o.reject(TypeError("Promise-chain cycle")):(i=n(r))?i.call(r,o.resolve,o.reject):o.resolve(r));}catch(c){o.reject(c);}}function r(o){var c,u=this;if(!u.triggered){u.triggered=!0,u.def&&(u=u.def);try{(c=n(o))?t(function(){var t=new f(u);try{c.call(o,function(){r.apply(t,arguments);},function(){i.apply(t,arguments);});}catch(n){i.call(t,n);}}):(u.msg=o,u.state=1,u.chain.length>0&&t(e,u));}catch(a){i.call(new f(u),a);}}}function i(n){var o=this;o.triggered||(o.triggered=!0,o.def&&(o=o.def),o.msg=n,o.state=2,o.chain.length>0&&t(e,o));}function c(t,n,e,o){for(var r=0;r<n.length;r++)!function(r){t.resolve(n[r]).then(function(t){e(r,t);},o);}(r);}function f(t){this.def=t,this.triggered=!1;}function u(t){this.promise=t,this.state=0,this.triggered=!1,this.chain=[],this.msg=void 0;}function a(n){if("function"!=typeof n)throw TypeError("Not a function");if(0!==this.__NPO__)throw TypeError("Not a promise");this.__NPO__=1;var o=new u(this);this.then=function(n,r){var i={success:"function"==typeof n?n:!0,failure:"function"==typeof r?r:!1};return i.promise=new this.constructor(function(t,n){if("function"!=typeof t||"function"!=typeof n)throw TypeError("Not a function");i.resolve=t,i.reject=n;}),o.chain.push(i),0!==o.state&&t(e,o),i.promise},this["catch"]=function(t){return this.then(void 0,t)};try{n.call(void 0,function(t){r.call(o,t);},function(t){i.call(o,t);});}catch(c){i.call(o,c);}}var s,h,l,p=Object.prototype.toString,y="undefined"!=typeof setImmediate?function(t){return setImmediate(t)}:setTimeout;try{Object.defineProperty({},"x",{}),s=function(t,n,e,o){return Object.defineProperty(t,n,{value:e,writable:!0,configurable:o!==!1})};}catch(d){s=function(t,n,e){return t[n]=e,t};}l=function(){function t(t,n){this.fn=t,this.self=n,this.next=void 0;}var n,e,o;return {add:function(r,i){o=new t(r,i),e?e.next=o:n=o,e=o,o=void 0;},drain:function(){var t=n;for(n=e=h=void 0;t;)t.fn.call(t.self),t=t.next;}}}();var g=s({},"constructor",a,!1);return a.prototype=g,s(g,"__NPO__",0,!1),s(a,"resolve",function(t){var n=this;return t&&"object"==typeof t&&1===t.__NPO__?t:new n(function(n,e){if("function"!=typeof n||"function"!=typeof e)throw TypeError("Not a function");n(t);})}),s(a,"reject",function(t){return new this(function(n,e){if("function"!=typeof n||"function"!=typeof e)throw TypeError("Not a function");e(t);})}),s(a,"all",function(t){var n=this;return "[object Array]"!=p.call(t)?n.reject(TypeError("Not an array")):0===t.length?n.resolve([]):new n(function(e,o){if("function"!=typeof e||"function"!=typeof o)throw TypeError("Not a function");var r=t.length,i=Array(r),f=0;c(n,t,function(t,n){i[t]=n,++f===r&&e(i);},o);})}),s(a,"race",function(t){var n=this;return "[object Array]"!=p.call(t)?n.reject(TypeError("Not an array")):new n(function(e,o){if("function"!=typeof e||"function"!=typeof o)throw TypeError("Not a function");c(n,t,function(t,n){e(n);},o);})}),a});
    });

    // Pulled from https://github.com/joliss/promise-map-series and prettied up a bit



    var promiseMapSeries = function sequence(array, iterator, thisArg) {
    	var current = npo.resolve();
    	var cb = arguments.length > 2 ? iterator.bind(thisArg) : iterator;

    	var results = array.map(function(value, i) {
    		return current = current.then(function(j) {
    			return cb(value, j, array)
    		}.bind(null, i))
    	});

    	return npo.all(results)
    };

    var thenDenodeify = function denodeify(fn) {
    	return function() {
    		var self = this;
    		var args = Array.prototype.slice.call(arguments);
    		return new Promise(function(resolve, reject) {
    			args.push(function(err, res) {
    				if (err) {
    					reject(err);
    				} else {
    					resolve(res);
    				}
    			});

    			var res = fn.apply(self, args);

    			var isPromise = res
    				&& (typeof res === 'object' || typeof res === 'function')
    				&& typeof res.then === 'function';

    			if (isPromise) {
    				resolve(res);
    			}
    		})
    	}
    };

    var eventemitter3 = createCommonjsModule(function (module) {

    var has = Object.prototype.hasOwnProperty
      , prefix = '~';

    /**
     * Constructor to create a storage for our `EE` objects.
     * An `Events` instance is a plain object whose properties are event names.
     *
     * @constructor
     * @api private
     */
    function Events() {}

    //
    // We try to not inherit from `Object.prototype`. In some engines creating an
    // instance in this way is faster than calling `Object.create(null)` directly.
    // If `Object.create(null)` is not supported we prefix the event names with a
    // character to make sure that the built-in object properties are not
    // overridden or used as an attack vector.
    //
    if (Object.create) {
      Events.prototype = Object.create(null);

      //
      // This hack is needed because the `__proto__` property is still inherited in
      // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
      //
      if (!new Events().__proto__) prefix = false;
    }

    /**
     * Representation of a single event listener.
     *
     * @param {Function} fn The listener function.
     * @param {Mixed} context The context to invoke the listener with.
     * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
     * @constructor
     * @api private
     */
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }

    /**
     * Minimal `EventEmitter` interface that is molded against the Node.js
     * `EventEmitter` interface.
     *
     * @constructor
     * @api public
     */
    function EventEmitter() {
      this._events = new Events();
      this._eventsCount = 0;
    }

    /**
     * Return an array listing the events for which the emitter has registered
     * listeners.
     *
     * @returns {Array}
     * @api public
     */
    EventEmitter.prototype.eventNames = function eventNames() {
      var names = []
        , events
        , name;

      if (this._eventsCount === 0) return names;

      for (name in (events = this._events)) {
        if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
      }

      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }

      return names;
    };

    /**
     * Return the listeners registered for a given event.
     *
     * @param {String|Symbol} event The event name.
     * @param {Boolean} exists Only check if there are listeners.
     * @returns {Array|Boolean}
     * @api public
     */
    EventEmitter.prototype.listeners = function listeners(event, exists) {
      var evt = prefix ? prefix + event : event
        , available = this._events[evt];

      if (exists) return !!available;
      if (!available) return [];
      if (available.fn) return [available.fn];

      for (var i = 0, l = available.length, ee = new Array(l); i < l; i++) {
        ee[i] = available[i].fn;
      }

      return ee;
    };

    /**
     * Calls each of the listeners registered for a given event.
     *
     * @param {String|Symbol} event The event name.
     * @returns {Boolean} `true` if the event had listeners, else `false`.
     * @api public
     */
    EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;

      if (!this._events[evt]) return false;

      var listeners = this._events[evt]
        , len = arguments.length
        , args
        , i;

      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

        switch (len) {
          case 1: return listeners.fn.call(listeners.context), true;
          case 2: return listeners.fn.call(listeners.context, a1), true;
          case 3: return listeners.fn.call(listeners.context, a1, a2), true;
          case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }

        for (i = 1, args = new Array(len -1); i < len; i++) {
          args[i - 1] = arguments[i];
        }

        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length
          , j;

        for (i = 0; i < length; i++) {
          if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

          switch (len) {
            case 1: listeners[i].fn.call(listeners[i].context); break;
            case 2: listeners[i].fn.call(listeners[i].context, a1); break;
            case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
            case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
            default:
              if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
                args[j - 1] = arguments[j];
              }

              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }

      return true;
    };

    /**
     * Add a listener for a given event.
     *
     * @param {String|Symbol} event The event name.
     * @param {Function} fn The listener function.
     * @param {Mixed} [context=this] The context to invoke the listener with.
     * @returns {EventEmitter} `this`.
     * @api public
     */
    EventEmitter.prototype.on = function on(event, fn, context) {
      var listener = new EE(fn, context || this)
        , evt = prefix ? prefix + event : event;

      if (!this._events[evt]) this._events[evt] = listener, this._eventsCount++;
      else if (!this._events[evt].fn) this._events[evt].push(listener);
      else this._events[evt] = [this._events[evt], listener];

      return this;
    };

    /**
     * Add a one-time listener for a given event.
     *
     * @param {String|Symbol} event The event name.
     * @param {Function} fn The listener function.
     * @param {Mixed} [context=this] The context to invoke the listener with.
     * @returns {EventEmitter} `this`.
     * @api public
     */
    EventEmitter.prototype.once = function once(event, fn, context) {
      var listener = new EE(fn, context || this, true)
        , evt = prefix ? prefix + event : event;

      if (!this._events[evt]) this._events[evt] = listener, this._eventsCount++;
      else if (!this._events[evt].fn) this._events[evt].push(listener);
      else this._events[evt] = [this._events[evt], listener];

      return this;
    };

    /**
     * Remove the listeners of a given event.
     *
     * @param {String|Symbol} event The event name.
     * @param {Function} fn Only remove the listeners that match this function.
     * @param {Mixed} context Only remove the listeners that have this context.
     * @param {Boolean} once Only remove one-time listeners.
     * @returns {EventEmitter} `this`.
     * @api public
     */
    EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;

      if (!this._events[evt]) return this;
      if (!fn) {
        if (--this._eventsCount === 0) this._events = new Events();
        else delete this._events[evt];
        return this;
      }

      var listeners = this._events[evt];

      if (listeners.fn) {
        if (
             listeners.fn === fn
          && (!once || listeners.once)
          && (!context || listeners.context === context)
        ) {
          if (--this._eventsCount === 0) this._events = new Events();
          else delete this._events[evt];
        }
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          if (
               listeners[i].fn !== fn
            || (once && !listeners[i].once)
            || (context && listeners[i].context !== context)
          ) {
            events.push(listeners[i]);
          }
        }

        //
        // Reset the array, or remove it completely if we have no more listeners.
        //
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else if (--this._eventsCount === 0) this._events = new Events();
        else delete this._events[evt];
      }

      return this;
    };

    /**
     * Remove all listeners, or those of the specified event.
     *
     * @param {String|Symbol} [event] The event name.
     * @returns {EventEmitter} `this`.
     * @api public
     */
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;

      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) {
          if (--this._eventsCount === 0) this._events = new Events();
          else delete this._events[evt];
        }
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }

      return this;
    };

    //
    // Alias methods names because people roll like that.
    //
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.addListener = EventEmitter.prototype.on;

    //
    // This function doesn't apply anymore.
    //
    EventEmitter.prototype.setMaxListeners = function setMaxListeners() {
      return this;
    };

    //
    // Expose the prefix.
    //
    EventEmitter.prefixed = prefix;

    //
    // Allow `EventEmitter` to be imported as module namespace.
    //
    EventEmitter.EventEmitter = EventEmitter;

    //
    // Expose the module.
    //
    {
      module.exports = EventEmitter;
    }
    });

    var immutable = extend$1;

    var hasOwnProperty = Object.prototype.hasOwnProperty;

    function extend$1() {
        var target = {};

        for (var i = 0; i < arguments.length; i++) {
            var source = arguments[i];

            for (var key in source) {
                if (hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }

        return target
    }

    var strictUriEncode = function (str) {
    	return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {
    		return '%' + c.charCodeAt(0).toString(16).toUpperCase();
    	});
    };

    /*
    object-assign
    (c) Sindre Sorhus
    @license MIT
    */
    /* eslint-disable no-unused-vars */
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;

    function toObject(val) {
    	if (val === null || val === undefined) {
    		throw new TypeError('Object.assign cannot be called with null or undefined');
    	}

    	return Object(val);
    }

    function shouldUseNative() {
    	try {
    		if (!Object.assign) {
    			return false;
    		}

    		// Detect buggy property enumeration order in older V8 versions.

    		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
    		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
    		test1[5] = 'de';
    		if (Object.getOwnPropertyNames(test1)[0] === '5') {
    			return false;
    		}

    		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
    		var test2 = {};
    		for (var i = 0; i < 10; i++) {
    			test2['_' + String.fromCharCode(i)] = i;
    		}
    		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
    			return test2[n];
    		});
    		if (order2.join('') !== '0123456789') {
    			return false;
    		}

    		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
    		var test3 = {};
    		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
    			test3[letter] = letter;
    		});
    		if (Object.keys(Object.assign({}, test3)).join('') !==
    				'abcdefghijklmnopqrst') {
    			return false;
    		}

    		return true;
    	} catch (err) {
    		// We don't expect any of the above to throw, but better to be safe.
    		return false;
    	}
    }

    var objectAssign = shouldUseNative() ? Object.assign : function (target, source) {
    	var from;
    	var to = toObject(target);
    	var symbols;

    	for (var s = 1; s < arguments.length; s++) {
    		from = Object(arguments[s]);

    		for (var key in from) {
    			if (hasOwnProperty$1.call(from, key)) {
    				to[key] = from[key];
    			}
    		}

    		if (getOwnPropertySymbols) {
    			symbols = getOwnPropertySymbols(from);
    			for (var i = 0; i < symbols.length; i++) {
    				if (propIsEnumerable.call(from, symbols[i])) {
    					to[symbols[i]] = from[symbols[i]];
    				}
    			}
    		}
    	}

    	return to;
    };

    function encoderForArrayFormat(opts) {
    	switch (opts.arrayFormat) {
    		case 'index':
    			return function (key, value, index) {
    				return value === null ? [
    					encode$1(key, opts),
    					'[',
    					index,
    					']'
    				].join('') : [
    					encode$1(key, opts),
    					'[',
    					encode$1(index, opts),
    					']=',
    					encode$1(value, opts)
    				].join('');
    			};

    		case 'bracket':
    			return function (key, value) {
    				return value === null ? encode$1(key, opts) : [
    					encode$1(key, opts),
    					'[]=',
    					encode$1(value, opts)
    				].join('');
    			};

    		default:
    			return function (key, value) {
    				return value === null ? encode$1(key, opts) : [
    					encode$1(key, opts),
    					'=',
    					encode$1(value, opts)
    				].join('');
    			};
    	}
    }

    function parserForArrayFormat(opts) {
    	var result;

    	switch (opts.arrayFormat) {
    		case 'index':
    			return function (key, value, accumulator) {
    				result = /\[(\d*)\]$/.exec(key);

    				key = key.replace(/\[\d*\]$/, '');

    				if (!result) {
    					accumulator[key] = value;
    					return;
    				}

    				if (accumulator[key] === undefined) {
    					accumulator[key] = {};
    				}

    				accumulator[key][result[1]] = value;
    			};

    		case 'bracket':
    			return function (key, value, accumulator) {
    				result = /(\[\])$/.exec(key);
    				key = key.replace(/\[\]$/, '');

    				if (!result) {
    					accumulator[key] = value;
    					return;
    				} else if (accumulator[key] === undefined) {
    					accumulator[key] = [value];
    					return;
    				}

    				accumulator[key] = [].concat(accumulator[key], value);
    			};

    		default:
    			return function (key, value, accumulator) {
    				if (accumulator[key] === undefined) {
    					accumulator[key] = value;
    					return;
    				}

    				accumulator[key] = [].concat(accumulator[key], value);
    			};
    	}
    }

    function encode$1(value, opts) {
    	if (opts.encode) {
    		return opts.strict ? strictUriEncode(value) : encodeURIComponent(value);
    	}

    	return value;
    }

    function keysSorter(input) {
    	if (Array.isArray(input)) {
    		return input.sort();
    	} else if (typeof input === 'object') {
    		return keysSorter(Object.keys(input)).sort(function (a, b) {
    			return Number(a) - Number(b);
    		}).map(function (key) {
    			return input[key];
    		});
    	}

    	return input;
    }

    var extract = function (str) {
    	return str.split('?')[1] || '';
    };

    var parse$1 = function (str, opts) {
    	opts = objectAssign({arrayFormat: 'none'}, opts);

    	var formatter = parserForArrayFormat(opts);

    	// Create an object with no prototype
    	// https://github.com/sindresorhus/query-string/issues/47
    	var ret = Object.create(null);

    	if (typeof str !== 'string') {
    		return ret;
    	}

    	str = str.trim().replace(/^(\?|#|&)/, '');

    	if (!str) {
    		return ret;
    	}

    	str.split('&').forEach(function (param) {
    		var parts = param.replace(/\+/g, ' ').split('=');
    		// Firefox (pre 40) decodes `%3D` to `=`
    		// https://github.com/sindresorhus/query-string/pull/37
    		var key = parts.shift();
    		var val = parts.length > 0 ? parts.join('=') : undefined;

    		// missing `=` should be `null`:
    		// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
    		val = val === undefined ? null : decodeURIComponent(val);

    		formatter(decodeURIComponent(key), val, ret);
    	});

    	return Object.keys(ret).sort().reduce(function (result, key) {
    		var val = ret[key];
    		if (Boolean(val) && typeof val === 'object' && !Array.isArray(val)) {
    			// Sort object keys, not values
    			result[key] = keysSorter(val);
    		} else {
    			result[key] = val;
    		}

    		return result;
    	}, Object.create(null));
    };

    var stringify = function (obj, opts) {
    	var defaults = {
    		encode: true,
    		strict: true,
    		arrayFormat: 'none'
    	};

    	opts = objectAssign(defaults, opts);

    	var formatter = encoderForArrayFormat(opts);

    	return obj ? Object.keys(obj).sort().map(function (key) {
    		var val = obj[key];

    		if (val === undefined) {
    			return '';
    		}

    		if (val === null) {
    			return encode$1(key, opts);
    		}

    		if (Array.isArray(val)) {
    			var result = [];

    			val.slice().forEach(function (val2) {
    				if (val2 === undefined) {
    					return;
    				}

    				result.push(formatter(key, val2, result.length));
    			});

    			return result.join('&');
    		}

    		return encode$1(key, opts) + '=' + encode$1(val, opts);
    	}).filter(function (x) {
    		return x.length > 0;
    	}).join('&') : '';
    };

    var queryString = {
    	extract: extract,
    	parse: parse$1,
    	stringify: stringify
    };

    var hashLocation = function HashLocation(window) {
    	var emitter = new eventemitter3();
    	var last = '';
    	var needToDecode = getNeedToDecode();

    	window.addEventListener('hashchange', function() {
    		if (last !== emitter.get()) {
    			last = emitter.get();
    			emitter.emit('hashchange');
    		}
    	});

    	emitter.go = go.bind(null, window);
    	emitter.replace = replace.bind(null, window);
    	emitter.get = get$1.bind(null, window, needToDecode);

    	return emitter
    };

    function replace(window, newPath) {
    	window.location.replace(everythingBeforeTheSlash(window.location.href) + '#' + newPath);
    }

    function everythingBeforeTheSlash(url) {
    	var hashIndex = url.indexOf('#');
    	return hashIndex === -1 ? url : url.substring(0, hashIndex)
    }

    function go(window, newPath) {
    	window.location.hash = newPath;
    }

    function get$1(window, needToDecode) {
    	var hash = removeHashFromPath(window.location.hash);
    	return needToDecode ? decodeURI(hash) : hash
    }

    function removeHashFromPath(path) {
    	return (path && path[0] === '#') ? path.substr(1) : path
    }

    function getNeedToDecode() {
    	var a = document.createElement('a');
    	a.href = '#x x';
    	return !/x x/.test(a.hash)
    }

    var hashBrownRouter = function Router(opts, hashLocation$$1) {
    	var emitter = new eventemitter3();
    	if (isHashLocation(opts)) {
    		hashLocation$$1 = opts;
    		opts = null;
    	}

    	opts = opts || {};

    	if (!hashLocation$$1) {
    		hashLocation$$1 = hashLocation(window);
    	}

    	function onNotFound(path, queryStringParameters) {
    		emitter.emit('not found', path, queryStringParameters);
    	}

    	var routes = [];

    	var onHashChange = evaluateCurrentPath.bind(null, routes, hashLocation$$1, !!opts.reverse, onNotFound);

    	hashLocation$$1.on('hashchange', onHashChange);

    	function stop() {
    		hashLocation$$1.removeListener('hashchange', onHashChange);
    	}

    	emitter.add = add.bind(null, routes);
    	emitter.stop = stop;
    	emitter.evaluateCurrent = evaluateCurrentPathOrGoToDefault.bind(null, routes, hashLocation$$1, !!opts.reverse, onNotFound);
    	emitter.replace = hashLocation$$1.replace;
    	emitter.go = hashLocation$$1.go;
    	emitter.location = hashLocation$$1;

    	return emitter
    };

    function evaluateCurrentPath(routes, hashLocation$$1, reverse, onNotFound) {
    	evaluatePath(routes, hashLocation$$1.get(), reverse, onNotFound);
    }

    function getPathParts(path) {
    	var chunks = path.split('?');
    	return {
    		path: chunks.shift(),
    		queryString: queryString.parse(chunks.join(''))
    	}
    }

    function evaluatePath(routes, path, reverse, onNotFound) {
    	var pathParts = getPathParts(path);
    	path = pathParts.path;
    	var queryStringParameters = pathParts.queryString;

    	var matchingRoute = find((reverse ? reverseArray(routes) : routes), path);

    	if (matchingRoute) {
    		var regexResult = matchingRoute.exec(path);
    		var routeParameters = makeParametersObjectFromRegexResult(matchingRoute.keys, regexResult);
    		var params = immutable(queryStringParameters, routeParameters);
    		matchingRoute.fn(params);
    	} else {
    		onNotFound(path, queryStringParameters);
    	}
    }

    function reverseArray(ary) {
    	return ary.slice().reverse()
    }

    function makeParametersObjectFromRegexResult(keys, regexResult) {
    	return keys.reduce(function(memo, urlKey, index) {
    		memo[urlKey.name] = regexResult[index + 1];
    		return memo
    	}, {})
    }

    function add(routes, routeString, routeFunction) {
    	if (typeof routeFunction !== 'function') {
    		throw new Error('The router add function must be passed a callback function')
    	}
    	var newRoute = pathToRegexpWithReversibleKeys(routeString);
    	newRoute.fn = routeFunction;
    	routes.push(newRoute);
    }

    function evaluateCurrentPathOrGoToDefault(routes, hashLocation$$1, reverse, onNotFound, defaultPath) {
    	const currentLocation = hashLocation$$1.get();
    	if (currentLocation && currentLocation !== '/') {
    		var routesCopy = routes.slice();

    		evaluateCurrentPath(routesCopy, hashLocation$$1, reverse, onNotFound);
    	} else {
    		hashLocation$$1.go(defaultPath);
    	}
    }

    function isHashLocation(hashLocation$$1) {
    	return hashLocation$$1 && hashLocation$$1.go && hashLocation$$1.replace && hashLocation$$1.on
    }

    function find(aryOfRegexes, str) {
    	for (var i = 0; i < aryOfRegexes.length; ++i) {
    		if (str.match(aryOfRegexes[i])) {
    			return aryOfRegexes[i]
    		}
    	}
    }

    // This file to be replaced with an official implementation maintained by
    // the page.js crew if and when that becomes an option



    var pathParser = function(pathString) {
    	var parseResults = pathToRegexpWithReversibleKeys(pathString);

    	// The only reason I'm returning a new object instead of the results of the pathToRegexp
    	// function is so that if the official implementation ends up returning an
    	// allTokens-style array via some other mechanism, I may be able to change this file
    	// without having to change the rest of the module in index.js
    	return {
    		regex: parseResults,
    		allTokens: parseResults.allTokens
    	}
    };

    var stringifyQuerystring = queryString.stringify;

    var pagePathBuilder = function(pathStr, parameters) {
    	var parsed = typeof pathStr === 'string' ? pathParser(pathStr) : pathStr;
    	var allTokens = parsed.allTokens;
    	var regex = parsed.regex;

    	if (parameters) {
    		var path = allTokens.map(function(bit) {
    			if (bit.string) {
    				return bit.string
    			}

    			var defined = typeof parameters[bit.name] !== 'undefined';
    			if (!bit.optional && !defined) {
    				throw new Error('Must supply argument ' + bit.name + ' for path ' + pathStr)
    			}

    			return defined ? (bit.delimiter + encodeURIComponent(parameters[bit.name])) : ''
    		}).join('');

    		if (!regex.test(path)) {
    			throw new Error('Provided arguments do not match the original arguments')
    		}

    		return buildPathWithQuerystring(path, parameters, allTokens)
    	} else {
    		return parsed
    	}
    };

    function buildPathWithQuerystring(path, parameters, tokenArray) {
    	var parametersInQuerystring = getParametersWithoutMatchingToken(parameters, tokenArray);

    	if (Object.keys(parametersInQuerystring).length === 0) {
    		return path
    	}

    	return path + '?' + stringifyQuerystring(parametersInQuerystring)
    }

    function getParametersWithoutMatchingToken(parameters, tokenArray) {
    	var tokenHash = tokenArray.reduce(function(memo, bit) {
    		if (!bit.string) {
    			memo[bit.name] = bit;
    		}
    		return memo
    	}, {});

    	return Object.keys(parameters).filter(function(param) {
    		return !tokenHash[param]
    	}).reduce(function(newParameters, param) {
    		newParameters[param] = parameters[param];
    		return newParameters
    	}, {})
    }

    var browser$1 = function (fn) {
      typeof setImmediate === 'function' ?
        setImmediate(fn) :
        setTimeout(fn, 0);
    };

    var expectedPropertiesOfAddState = [ 'name', 'route', 'defaultChild', 'data', 'template', 'resolve', 'activate', 'querystringParameters', 'defaultQuerystringParameters', 'defaultParameters' ];

    var abstractStateRouter = function StateProvider(makeRenderer, rootElement, stateRouterOptions) {
    	var prototypalStateHolder = stateState();
    	var lastCompletelyLoadedState = currentState();
    	var lastStateStartedActivating = currentState();
    	var stateProviderEmitter = new eventemitter3();
    	stateTransitionManager(stateProviderEmitter);
    	stateRouterOptions = immutable({
    		throwOnError: true,
    		pathPrefix: '#'
    	}, stateRouterOptions);

    	if (!stateRouterOptions.router) {
    		stateRouterOptions.router = hashBrownRouter(defaultRouterOptions);
    	}

    	stateRouterOptions.router.on('not found', function(route, parameters) {
    		stateProviderEmitter.emit('routeNotFound', route, parameters);
    	});

    	var destroyDom = null;
    	var getDomChild = null;
    	var renderDom = null;
    	var resetDom = null;

    	var activeDomApis = {};
    	var activeStateResolveContent = {};
    	var activeEmitters = {};

    	function handleError(event, err) {
    		browser$1(function() {
    			stateProviderEmitter.emit(event, err);
    			console.error(event + ' - ' + err.message);
    			if (stateRouterOptions.throwOnError) {
    				throw err
    			}
    		});
    	}

    	function destroyStateName(stateName) {
    		var state = prototypalStateHolder.get(stateName);
    		stateProviderEmitter.emit('beforeDestroyState', {
    			state: state,
    			domApi: activeDomApis[stateName]
    		});

    		activeEmitters[stateName].emit('destroy');
    		activeEmitters[stateName].removeAllListeners();
    		delete activeEmitters[stateName];
    		delete activeStateResolveContent[stateName];

    		return destroyDom(activeDomApis[stateName]).then(function() {
    			delete activeDomApis[stateName];
    			stateProviderEmitter.emit('afterDestroyState', {
    				state: state
    			});
    		})
    	}

    	function resetStateName(parameters, stateName) {
    		var domApi = activeDomApis[stateName];
    		var content = getContentObject(activeStateResolveContent, stateName);
    		var state = prototypalStateHolder.get(stateName);

    		stateProviderEmitter.emit('beforeResetState', {
    			domApi: domApi,
    			content: content,
    			state: state,
    			parameters: parameters
    		});

    		activeEmitters[stateName].emit('destroy');
    		delete activeEmitters[stateName];

    		return resetDom({
    			domApi: domApi,
    			content: content,
    			template: state.template,
    			parameters: parameters
    		}).then(function(newDomApi) {
    			if (newDomApi) {
    				activeDomApis[stateName] = newDomApi;
    			}

    			stateProviderEmitter.emit('afterResetState', {
    				domApi: activeDomApis[stateName],
    				content: content,
    				state: state,
    				parameters: parameters
    			});
    		})
    	}

    	function getChildElementForStateName(stateName) {
    		return new Promise(function(resolve) {
    			var parent = prototypalStateHolder.getParent(stateName);
    			if (parent) {
    				var parentDomApi = activeDomApis[parent.name];
    				resolve(getDomChild(parentDomApi));
    			} else {
    				resolve(rootElement);
    			}
    		})
    	}

    	function renderStateName(parameters, stateName) {
    		return getChildElementForStateName(stateName).then(function(childElement) {
    			var state = prototypalStateHolder.get(stateName);
    			var content = getContentObject(activeStateResolveContent, stateName);

    			stateProviderEmitter.emit('beforeCreateState', {
    				state: state,
    				content: content,
    				parameters: parameters
    			});

    			return renderDom({
    				element: childElement,
    				template: state.template,
    				content: content,
    				parameters: parameters
    			}).then(function(domApi) {
    				activeDomApis[stateName] = domApi;
    				stateProviderEmitter.emit('afterCreateState', {
    					state: state,
    					domApi: domApi,
    					content: content,
    					parameters: parameters
    				});
    				return domApi
    			})
    		})
    	}

    	function renderAll(stateNames, parameters) {
    		return promiseMapSeries(stateNames, renderStateName.bind(null, parameters))
    	}

    	function onRouteChange(state, parameters) {
    		try {
    			var finalDestinationStateName = prototypalStateHolder.applyDefaultChildStates(state.name);

    			if (finalDestinationStateName === state.name) {
    				emitEventAndAttemptStateChange(finalDestinationStateName, parameters);
    			} else {
    				// There are default child states that need to be applied

    				var theRouteWeNeedToEndUpAt = makePath(finalDestinationStateName, parameters);
    				var currentRoute = stateRouterOptions.router.location.get();

    				if (theRouteWeNeedToEndUpAt === currentRoute) {
    					// the child state has the same route as the current one, just start navigating there
    					emitEventAndAttemptStateChange(finalDestinationStateName, parameters);
    				} else {
    					// change the url to match the full default child state route
    					stateProviderEmitter.go(finalDestinationStateName, parameters, { replace: true });
    				}
    			}
    		} catch (err) {
    			handleError('stateError', err);
    		}
    	}

    	function addState(state) {
    		if (typeof state === 'undefined') {
    			throw new Error('Expected \'state\' to be passed in.')
    		} else if (typeof state.name === 'undefined') {
    			throw new Error('Expected the \'name\' option to be passed in.')
    		} else if (typeof state.template === 'undefined') {
    			throw new Error('Expected the \'template\' option to be passed in.')
    		}
    		Object.keys(state).filter(function(key) {
    			return expectedPropertiesOfAddState.indexOf(key) === -1
    		}).forEach(function(key) {
    			console.warn('Unexpected property passed to addState:', key);
    		});

    		prototypalStateHolder.add(state.name, state);

    		var route = prototypalStateHolder.buildFullStateRoute(state.name);

    		stateRouterOptions.router.add(route, onRouteChange.bind(null, state));
    	}

    	function getStatesToResolve(stateChanges) {
    		return stateChanges.change.concat(stateChanges.create).map(prototypalStateHolder.get)
    	}

    	function emitEventAndAttemptStateChange(newStateName, parameters) {
    		stateProviderEmitter.emit('stateChangeAttempt', function stateGo(transition) {
    			attemptStateChange(newStateName, parameters, transition);
    		});
    	}

    	function attemptStateChange(newStateName, parameters, transition) {
    		function ifNotCancelled(fn) {
    			return function() {
    				if (transition.cancelled) {
    					var err = new Error('The transition to ' + newStateName + 'was cancelled');
    					err.wasCancelledBySomeoneElse = true;
    					throw err
    				} else {
    					return fn.apply(null, arguments)
    				}
    			}
    		}

    		return promiseMe(prototypalStateHolder.guaranteeAllStatesExist, newStateName)
    		.then(function applyDefaultParameters() {
    			var state = prototypalStateHolder.get(newStateName);
    			var defaultParams = state.defaultParameters || state.defaultQuerystringParameters || {};
    			var needToApplyDefaults = Object.keys(defaultParams).some(function missingParameterValue(param) {
    				return typeof parameters[param] === 'undefined'
    			});

    			if (needToApplyDefaults) {
    				throw redirector(newStateName, immutable(defaultParams, parameters))
    			}
    			return state
    		}).then(ifNotCancelled(function(state) {
    			stateProviderEmitter.emit('stateChangeStart', state, parameters);
    			lastStateStartedActivating.set(state.name, parameters);
    		})).then(function getStateChanges() {
    			var stateComparisonResults = stateComparison_1(prototypalStateHolder)(lastCompletelyLoadedState.get().name, lastCompletelyLoadedState.get().parameters, newStateName, parameters);
    			return stateChangeLogic(stateComparisonResults) // { destroy, change, create }
    		}).then(ifNotCancelled(function resolveDestroyAndActivateStates(stateChanges) {
    			return resolveStates(getStatesToResolve(stateChanges), immutable(parameters)).catch(function onResolveError(e) {
    				e.stateChangeError = true;
    				throw e
    			}).then(ifNotCancelled(function destroyAndActivate(stateResolveResultsObject) {
    				transition.cancellable = false;

    				function activateAll() {
    					var statesToActivate = stateChanges.change.concat(stateChanges.create);

    					return activateStates(statesToActivate)
    				}

    				activeStateResolveContent = immutable(activeStateResolveContent, stateResolveResultsObject);

    				return promiseMapSeries(reverse(stateChanges.destroy), destroyStateName).then(function() {
    					return promiseMapSeries(reverse(stateChanges.change), resetStateName.bind(null, immutable(parameters)))
    				}).then(function() {
    					return renderAll(stateChanges.create, immutable(parameters)).then(activateAll)
    				})
    			}))

    			function activateStates(stateNames) {
    				return stateNames.map(prototypalStateHolder.get).forEach(function(state) {
    					var emitter = new eventemitter3();
    					var context = Object.create(emitter);
    					context.domApi = activeDomApis[state.name];
    					context.data = state.data;
    					context.parameters = parameters;
    					context.content = getContentObject(activeStateResolveContent, state.name);
    					activeEmitters[state.name] = emitter;

    					try {
    						state.activate && state.activate(context);
    					} catch (e) {
    						browser$1(function() {
    							throw e
    						});
    					}
    				})
    			}
    		})).then(function stateChangeComplete() {
    			lastCompletelyLoadedState.set(newStateName, parameters);
    			try {
    				stateProviderEmitter.emit('stateChangeEnd', prototypalStateHolder.get(newStateName), parameters);
    			} catch (e) {
    				handleError('stateError', e);
    			}
    		}).catch(ifNotCancelled(function handleStateChangeError(err) {
    			if (err && err.redirectTo) {
    				stateProviderEmitter.emit('stateChangeCancelled', err);
    				return stateProviderEmitter.go(err.redirectTo.name, err.redirectTo.params, { replace: true })
    			} else if (err) {
    				handleError('stateChangeError', err);
    			}
    		})).catch(function handleCancellation(err) {
    			if (err && err.wasCancelledBySomeoneElse) ; else {
    				throw new Error("This probably shouldn't happen, maybe file an issue or something " + err)
    			}
    		})
    	}

    	function makePath(stateName, parameters, options) {
    		function getGuaranteedPreviousState() {
    			if (!lastStateStartedActivating.get().name) {
    				throw new Error('makePath required a previous state to exist, and none was found')
    			}
    			return lastStateStartedActivating.get()
    		}
    		if (options && options.inherit) {
    			parameters = immutable(getGuaranteedPreviousState().parameters, parameters);
    		}

    		var destinationStateName = stateName === null ? getGuaranteedPreviousState().name : stateName;

    		var destinationState = prototypalStateHolder.get(destinationStateName) || {};
    		var defaultParams = destinationState.defaultParameters || destinationState.defaultQuerystringParameters;

    		parameters = immutable(defaultParams, parameters);

    		prototypalStateHolder.guaranteeAllStatesExist(destinationStateName);
    		var route = prototypalStateHolder.buildFullStateRoute(destinationStateName);
    		return pagePathBuilder(route, parameters || {})
    	}

    	var defaultOptions = {
    		replace: false
    	};

    	stateProviderEmitter.addState = addState;
    	stateProviderEmitter.go = function go(newStateName, parameters, options) {
    		options = immutable(defaultOptions, options);
    		var goFunction = options.replace ? stateRouterOptions.router.replace : stateRouterOptions.router.go;

    		return promiseMe(makePath, newStateName, parameters, options).then(goFunction, handleError.bind(null, 'stateChangeError'))
    	};
    	stateProviderEmitter.evaluateCurrentRoute = function evaluateCurrentRoute(defaultState, defaultParams) {
    		return promiseMe(makePath, defaultState, defaultParams).then(function(defaultPath) {
    			stateRouterOptions.router.evaluateCurrent(defaultPath);
    		}).catch(function(err) {
    			handleError('stateError', err);
    		})
    	};
    	stateProviderEmitter.makePath = function makePathAndPrependHash(stateName, parameters, options) {
    		return stateRouterOptions.pathPrefix + makePath(stateName, parameters, options)
    	};
    	stateProviderEmitter.stateIsActive = function stateIsActive(stateName, opts) {
    		var currentState$$1 = lastCompletelyLoadedState.get();
    		return (currentState$$1.name === stateName || currentState$$1.name.indexOf(stateName + '.') === 0) && (typeof opts === 'undefined' || Object.keys(opts).every(function matches(key) {
    			return opts[key] === currentState$$1.parameters[key]
    		}))
    	};

    	var renderer = makeRenderer(stateProviderEmitter);

    	destroyDom = thenDenodeify(renderer.destroy);
    	getDomChild = thenDenodeify(renderer.getChildElement);
    	renderDom = thenDenodeify(renderer.render);
    	resetDom = thenDenodeify(renderer.reset);

    	return stateProviderEmitter
    };

    function getContentObject(stateResolveResultsObject, stateName) {
    	var allPossibleResolvedStateNames = stateStringParser(stateName);

    	return allPossibleResolvedStateNames.filter(function(stateName) {
    		return stateResolveResultsObject[stateName]
    	}).reduce(function(obj, stateName) {
    		return immutable(obj, stateResolveResultsObject[stateName])
    	}, {})
    }

    function redirector(newStateName, parameters) {
    	return {
    		redirectTo: {
    			name: newStateName,
    			params: parameters
    		}
    	}
    }

    // { [stateName]: resolveResult }
    function resolveStates(states, parameters) {
    	var statesWithResolveFunctions = states.filter(isFunction$1('resolve'));
    	var stateNamesWithResolveFunctions = statesWithResolveFunctions.map(property('name'));
    	var resolves = Promise.all(statesWithResolveFunctions.map(function(state) {
    		return new Promise(function(resolve, reject) {
    			function resolveCb(err, content) {
    				err ? reject(err) : resolve(content);
    			}

    			resolveCb.redirect = function redirect(newStateName, parameters) {
    				reject(redirector(newStateName, parameters));
    			};

    			var res = state.resolve(state.data, parameters, resolveCb);
    			if (res && (typeof res === 'object' || typeof res === 'function') && typeof res.then === 'function') {
    				resolve(res);
    			}
    		})
    	}));

    	return resolves.then(function(resolveResults) {
    		return combineArrays({
    			stateName: stateNamesWithResolveFunctions,
    			resolveResult: resolveResults
    		}).reduce(function(obj, result) {
    			obj[result.stateName] = result.resolveResult;
    			return obj
    		}, {})
    	})
    }

    function property(name) {
    	return function(obj) {
    		return obj[name]
    	}
    }

    function reverse(ary) {
    	return ary.slice().reverse()
    }

    function isFunction$1(property) {
    	return function(obj) {
    		return typeof obj[property] === 'function'
    	}
    }

    function promiseMe() {
    	var fn = Array.prototype.shift.apply(arguments);
    	var args = arguments;
    	return new Promise(function(resolve) {
    		resolve(fn.apply(null, args));
    	})
    }

    var deepmerge = createCommonjsModule(function (module, exports) {
    (function (root, factory) {
        {
            module.exports = factory();
        }
    }(commonjsGlobal, function () {

    function isMergeableObject(val) {
        var nonNullObject = val && typeof val === 'object';

        return nonNullObject
            && Object.prototype.toString.call(val) !== '[object RegExp]'
            && Object.prototype.toString.call(val) !== '[object Date]'
    }

    function emptyTarget(val) {
        return Array.isArray(val) ? [] : {}
    }

    function cloneIfNecessary(value, optionsArgument) {
        var clone = optionsArgument && optionsArgument.clone === true;
        return (clone && isMergeableObject(value)) ? deepmerge(emptyTarget(value), value, optionsArgument) : value
    }

    function defaultArrayMerge(target, source, optionsArgument) {
        var destination = target.slice();
        source.forEach(function(e, i) {
            if (typeof destination[i] === 'undefined') {
                destination[i] = cloneIfNecessary(e, optionsArgument);
            } else if (isMergeableObject(e)) {
                destination[i] = deepmerge(target[i], e, optionsArgument);
            } else if (target.indexOf(e) === -1) {
                destination.push(cloneIfNecessary(e, optionsArgument));
            }
        });
        return destination
    }

    function mergeObject(target, source, optionsArgument) {
        var destination = {};
        if (isMergeableObject(target)) {
            Object.keys(target).forEach(function (key) {
                destination[key] = cloneIfNecessary(target[key], optionsArgument);
            });
        }
        Object.keys(source).forEach(function (key) {
            if (!isMergeableObject(source[key]) || !target[key]) {
                destination[key] = cloneIfNecessary(source[key], optionsArgument);
            } else {
                destination[key] = deepmerge(target[key], source[key], optionsArgument);
            }
        });
        return destination
    }

    function deepmerge(target, source, optionsArgument) {
        var array = Array.isArray(source);
        var options = optionsArgument || { arrayMerge: defaultArrayMerge };
        var arrayMerge = options.arrayMerge || defaultArrayMerge;

        if (array) {
            return Array.isArray(target) ? arrayMerge(target, source, optionsArgument) : cloneIfNecessary(source, optionsArgument)
        } else {
            return mergeObject(target, source, optionsArgument)
        }
    }

    deepmerge.all = function deepmergeAll(array, optionsArgument) {
        if (!Array.isArray(array) || array.length < 2) {
            throw new Error('first argument should be an array with at least two elements')
        }

        // we are sure there are at least 2 values, so it is safe to have no initial value
        return array.reduce(function(prev, next) {
            return deepmerge(prev, next, optionsArgument)
        })
    };

    return deepmerge

    }));
    });

    var svelteStateRenderer = function SvelteStateRendererFactory(defaultOptions = {}) {
    	return function makeRenderer(stateRouter) {
    		const asr = {
    			makePath: stateRouter.makePath,
    			stateIsActive: stateRouter.stateIsActive,
    		};

    		function render(context, cb) {
    			const { element: target, template, content } = context;

    			const rendererSuppliedOptions = deepmerge(defaultOptions, {
    				target,
    				data: Object.assign(content, defaultOptions.data, { asr }),
    			});

    			function construct(component, options) {
    				return options.methods
    					? instantiateWithMethods(component, options, options.methods)
    					: new component(options)
    			}

    			let svelte;

    			try {
    				if (typeof template === `function`) {
    					svelte = construct(template, rendererSuppliedOptions);
    				} else {
    					const options = deepmerge(rendererSuppliedOptions, template.options);

    					svelte = construct(template.component, options);
    				}
    			} catch (e) {
    				cb(e);
    				return
    			}

    			function onRouteChange() {
    				svelte.set({
    					asr,
    				});
    			}

    			stateRouter.on(`stateChangeEnd`, onRouteChange);

    			svelte.on(`destroy`, () => {
    				stateRouter.removeListener(`stateChangeEnd`, onRouteChange);
    			});

    			svelte.mountedToTarget = target;
    			cb(null, svelte);
    		}

    		return {
    			render,
    			reset: function reset(context, cb) {
    				const svelte = context.domApi;
    				const element = svelte.mountedToTarget;

    				svelte.destroy();

    				const renderContext = Object.assign({ element }, context);

    				render(renderContext, cb);
    			},
    			destroy: function destroy(svelte, cb) {
    				svelte.destroy();
    				cb();
    			},
    			getChildElement: function getChildElement(svelte, cb) {
    				try {
    					const element = svelte.mountedToTarget;
    					const child = element.querySelector(`uiView`);
    					cb(null, child);
    				} catch (e) {
    					cb(e);
    				}
    			},
    		}
    	}
    };

    function instantiateWithMethods(Component, options, methods) {
    	// const coolPrototype = Object.assign(Object.create(Component.prototype), methods)
    	// return Component.call(coolPrototype, options)
    	return Object.assign(new Component(options), methods)
    }

    /* src\components\Home.html generated by Svelte v2.16.1 */

    function data$2() {
    	return {
    		canViewHelpFiles: false
    	};
    }
    function oncreate() {
    	// Your web app's Firebase configuration
    	const { app } = this.get();

    	// Initialize Firebase

    	// FirebaseUI config.
    	// const uiConfig = {
    	// 	signInSuccessUrl: "https://localhost:44349/#/form/dashboard",
    	// 	callbacks: {
    	// 		signInSuccessWithAuthResult(authResult, redirectUrl) {
    	// 		// User successfully signed in.
    	// 		// Return type determines whether we continue the redirect automatically
    	// 		// or whether we leave that to developer to handle.
    	// 			// eslint-disable-next-line no-console
    	// 			console.log(authResult);
    	// 			app.loadMenu().then(t => {
    	// 				buildMenu(app);
    	// 			});
    	// 			return true;
    	// 		}
    	// 	},
    	// 	signInOptions: [
    	// 		// eslint-disable-next-line no-undef
    	// 		firebase.auth.EmailAuthProvider.PROVIDER_ID
    	// 	]
    	// };

    	// eslint-disable-next-line no-undef

    	// eslint-disable-next-line no-undef
    	// const storedEmail = localStorage.email;
    	// if (storedEmail == null || storedEmail === undefined) {
    	// 	// eslint-disable-next-line no-undef
    	// 	if (firebaseui.auth.AuthUI.getInstance()) {
    	// 		// eslint-disable-next-line no-undef
    	// 		const ui = firebaseui.auth.AuthUI.getInstance();
    	// 		ui.start(this.refs.container, uiConfig);
    	// 	}
    	// 	else {
    	// 		// eslint-disable-next-line no-undef
    	// 		const ui = new firebaseui.auth.AuthUI(firebase.auth());
    	// 		ui.start(this.refs.container, uiConfig);
    	// 	}
    	// }
    }
    const file$3 = "src\\components\\Home.html";

    function add_css() {
    	var style = createElement("style");
    	style.id = 'svelte-1thv7jn-style';
    	style.textContent = "p.svelte-1thv7jn,strong.svelte-1thv7jn{margin-top:20px;text-align:center;font-size:2rem}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSG9tZS5odG1sIiwic291cmNlcyI6WyJIb21lLmh0bWwiXSwic291cmNlc0NvbnRlbnQiOlsiPHA+V2VsY29tZSB0byA8c3Ryb25nPlVpTUZUZW1wbGF0ZSBhcHA8L3N0cm9uZz48L3A+XHJcbjwhLS0gPGRpdiBpZD1cImZpcmViYXNldWktYXV0aC1jb250YWluZXJcIiByZWY6Y29udGFpbmVyPjwvZGl2PiAtLT5cclxuXHJcbjxzY3JpcHQ+XHJcblx0ZXhwb3J0IGRlZmF1bHQge1xyXG5cdFx0b25jcmVhdGUoKSB7XHJcblx0XHRcdC8vIFlvdXIgd2ViIGFwcCdzIEZpcmViYXNlIGNvbmZpZ3VyYXRpb25cclxuXHRcdFx0Y29uc3QgeyBhcHAgfSA9IHRoaXMuZ2V0KCk7XHJcblxyXG5cdFx0XHQvLyBJbml0aWFsaXplIEZpcmViYXNlXHJcblxyXG5cdFx0XHQvLyBGaXJlYmFzZVVJIGNvbmZpZy5cclxuXHRcdFx0Ly8gY29uc3QgdWlDb25maWcgPSB7XHJcblx0XHRcdC8vIFx0c2lnbkluU3VjY2Vzc1VybDogXCJodHRwczovL2xvY2FsaG9zdDo0NDM0OS8jL2Zvcm0vZGFzaGJvYXJkXCIsXHJcblx0XHRcdC8vIFx0Y2FsbGJhY2tzOiB7XHJcblx0XHRcdC8vIFx0XHRzaWduSW5TdWNjZXNzV2l0aEF1dGhSZXN1bHQoYXV0aFJlc3VsdCwgcmVkaXJlY3RVcmwpIHtcclxuXHRcdFx0Ly8gXHRcdC8vIFVzZXIgc3VjY2Vzc2Z1bGx5IHNpZ25lZCBpbi5cclxuXHRcdFx0Ly8gXHRcdC8vIFJldHVybiB0eXBlIGRldGVybWluZXMgd2hldGhlciB3ZSBjb250aW51ZSB0aGUgcmVkaXJlY3QgYXV0b21hdGljYWxseVxyXG5cdFx0XHQvLyBcdFx0Ly8gb3Igd2hldGhlciB3ZSBsZWF2ZSB0aGF0IHRvIGRldmVsb3BlciB0byBoYW5kbGUuXHJcblx0XHRcdC8vIFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXHJcblx0XHRcdC8vIFx0XHRcdGNvbnNvbGUubG9nKGF1dGhSZXN1bHQpO1xyXG5cdFx0XHQvLyBcdFx0XHRhcHAubG9hZE1lbnUoKS50aGVuKHQgPT4ge1xyXG5cdFx0XHQvLyBcdFx0XHRcdGJ1aWxkTWVudShhcHApO1xyXG5cdFx0XHQvLyBcdFx0XHR9KTtcclxuXHRcdFx0Ly8gXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdC8vIFx0XHR9XHJcblx0XHRcdC8vIFx0fSxcclxuXHRcdFx0Ly8gXHRzaWduSW5PcHRpb25zOiBbXHJcblx0XHRcdC8vIFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcclxuXHRcdFx0Ly8gXHRcdGZpcmViYXNlLmF1dGguRW1haWxBdXRoUHJvdmlkZXIuUFJPVklERVJfSURcclxuXHRcdFx0Ly8gXHRdXHJcblx0XHRcdC8vIH07XHJcblxyXG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcclxuXHJcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxyXG5cdFx0XHQvLyBjb25zdCBzdG9yZWRFbWFpbCA9IGxvY2FsU3RvcmFnZS5lbWFpbDtcclxuXHRcdFx0Ly8gaWYgKHN0b3JlZEVtYWlsID09IG51bGwgfHwgc3RvcmVkRW1haWwgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHQvLyBcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxyXG5cdFx0XHQvLyBcdGlmIChmaXJlYmFzZXVpLmF1dGguQXV0aFVJLmdldEluc3RhbmNlKCkpIHtcclxuXHRcdFx0Ly8gXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxyXG5cdFx0XHQvLyBcdFx0Y29uc3QgdWkgPSBmaXJlYmFzZXVpLmF1dGguQXV0aFVJLmdldEluc3RhbmNlKCk7XHJcblx0XHRcdC8vIFx0XHR1aS5zdGFydCh0aGlzLnJlZnMuY29udGFpbmVyLCB1aUNvbmZpZyk7XHJcblx0XHRcdC8vIFx0fVxyXG5cdFx0XHQvLyBcdGVsc2Uge1xyXG5cdFx0XHQvLyBcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXHJcblx0XHRcdC8vIFx0XHRjb25zdCB1aSA9IG5ldyBmaXJlYmFzZXVpLmF1dGguQXV0aFVJKGZpcmViYXNlLmF1dGgoKSk7XHJcblx0XHRcdC8vIFx0XHR1aS5zdGFydCh0aGlzLnJlZnMuY29udGFpbmVyLCB1aUNvbmZpZyk7XHJcblx0XHRcdC8vIFx0fVxyXG5cdFx0XHQvLyB9XHJcblx0XHR9LFxyXG5cdFx0ZGF0YSgpIHtcclxuXHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHRjYW5WaWV3SGVscEZpbGVzOiBmYWxzZVxyXG5cdFx0XHR9O1xyXG5cdFx0fVxyXG5cdH07XHJcbjwvc2NyaXB0PlxyXG5cclxuPHN0eWxlPlxyXG5cdHAsc3Ryb25nIHtcclxuXHRcdG1hcmdpbi10b3A6IDIwcHg7XHJcblx0XHR0ZXh0LWFsaWduOiBjZW50ZXI7XHJcblx0XHRmb250LXNpemU6IDJyZW07XHJcblx0fVxyXG5cdC5sb2dvLWJpZ3tcclxuXHRcdGxldHRlci1zcGFjaW5nOiAycHg7XHJcblx0XHR0ZXh0LWRlY29yYXRpb246IG5vbmU7XHJcblx0XHRjb2xvcjogIzhkMGMxODtcclxuXHRcdHdpZHRoOiA4MDBweDtcclxuXHRcdG1hcmdpbi1sZWZ0OiBhdXRvO1xyXG5cdFx0bWFyZ2luLXJpZ2h0OiBhdXRvO1xyXG5cdH1cclxuXHQubG9nby1iaWcgcHtcclxuXHRcdGZvbnQtc2l6ZTogNWVtO1xyXG5cdH1cclxuPC9zdHlsZT5cclxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQTREQyxnQkFBQyxDQUFDLE1BQU0sZUFBQyxDQUFDLEFBQ1QsVUFBVSxDQUFFLElBQUksQ0FDaEIsVUFBVSxDQUFFLE1BQU0sQ0FDbEIsU0FBUyxDQUFFLElBQUksQUFDaEIsQ0FBQyJ9 */";
    	append(document.head, style);
    }

    function create_main_fragment$3(component, ctx) {
    	var p, text, strong;

    	return {
    		c: function create() {
    			p = createElement("p");
    			text = createText("Welcome to ");
    			strong = createElement("strong");
    			strong.textContent = "UiMFTemplate app";
    			strong.className = "svelte-1thv7jn";
    			addLoc(strong, file$3, 0, 14, 14);
    			p.className = "svelte-1thv7jn";
    			addLoc(p, file$3, 0, 0, 0);
    		},

    		m: function mount(target, anchor) {
    			insert(target, p, anchor);
    			append(p, text);
    			append(p, strong);
    		},

    		p: noop,

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(p);
    			}
    		}
    	};
    }

    function SvelteComponent$3(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) {
    		throw new Error("'target' is a required option");
    	}

    	init(this, options);
    	this._state = assign(data$2(), options.data);
    	this._intro = true;

    	if (!document.getElementById("svelte-1thv7jn-style")) add_css();

    	this._fragment = create_main_fragment$3(this, this._state);

    	this.root._oncreate.push(() => {
    		oncreate.call(this);
    		this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
    	});

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);

    		flush(this);
    	}
    }

    assign(SvelteComponent$3.prototype, protoDev);

    SvelteComponent$3.prototype._checkReadOnly = function _checkReadOnly(newState) {
    };

    /* src\core\ui\help\Tooltip.html generated by Svelte v2.16.1 */

    const file$4 = "src\\core\\ui\\help\\Tooltip.html";

    function create_main_fragment$4(component, ctx) {
    	var if_block_anchor;

    	var if_block = (ctx.data != null && ctx.data.content != null) && create_if_block$3(component, ctx);

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (ctx.data != null && ctx.data.content != null) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block$3(component, ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (if_block) if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (1:0) {#if data != null && data.content != null}
    function create_if_block$3(component, ctx) {
    	var span, raw_value = ctx.data.content;

    	return {
    		c: function create() {
    			span = createElement("span");
    			span.className = "tooltiptext";
    			addLoc(span, file$4, 1, 1, 45);
    		},

    		m: function mount(target, anchor) {
    			insert(target, span, anchor);
    			span.innerHTML = raw_value;
    		},

    		p: function update(changed, ctx) {
    			if ((changed.data) && raw_value !== (raw_value = ctx.data.content)) {
    				span.innerHTML = raw_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(span);
    			}
    		}
    	};
    }

    function SvelteComponent$4(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) {
    		throw new Error("'target' is a required option");
    	}

    	init(this, options);
    	this._state = assign({}, options.data);
    	if (!('data' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'data'");
    	this._intro = true;

    	this._fragment = create_main_fragment$4(this, this._state);

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);
    	}
    }

    assign(SvelteComponent$4.prototype, protoDev);

    SvelteComponent$4.prototype._checkReadOnly = function _checkReadOnly(newState) {
    };

    /* src\core\ui\Input.html generated by Svelte v2.16.1 */

    let inputId = 0;

    function data$3() {
    	inputId += 1;
    	return {
    		id: `i${inputId}`,
    		visible: false,
    		alwaysHideLabel: false,
    		class: ""
    	};
    }
    var methods = {
    	show(visible) {
    		const { field } = this.get();
    		const currentlyVisible = !!this.get().visible;

    		this.set({ visible: !!visible });

    		if (currentlyVisible === false && visible === true) {
    			const { app } = this.get();
    			const input = app.controlRegister.getInput(field.metadata.type);

    			// eslint-disable-next-line
    			new input.component({
    				target: this.refs.container,
    				data: {
    					field,
    					tabindex: this.get().tabindex,
    					id: this.get().id,
    					app,
    					form: this.get().form,
    					wrapper: this,
    					visible
    				}
    			});
    		}

    		// if (!visible) {
    		// 	field.value = null;
    		// }
    	}
    };

    function oncreate$1() {
    	const { field, app } = this.get();

    	const input = app.controlRegister.getInput(field.metadata.type);

    	// Set correct css class based on the field type.
    	const inputDisplayConfig = field.constants || input.constants || {};

    	const cssClass = field.metadata.customProperties != null ? field.metadata.customProperties.cssClass : null;

    	// Set correct css class based on the field type.
    	if (inputDisplayConfig.block) {
    		this.set({ class: `block ${cssClass}` });
    	}
    	else {
    		this.set({ class: `inline ${cssClass}` });
    	}

    	this.set({
    		class: cssClass,
    		alwaysHideLabel: inputDisplayConfig.alwaysHideLabel
    	});

    	const { inputs } = this.get().form.get();
    	// If `inputs` is null, then it means our parent form has been closed
    	// and "destroyed". In such cases we should just return.
    	// TODO: find a better way to implement "parent form null check".
    	if (inputs != null) {
    		// Register input in the parent form.
    		inputs.push(this);
    	}

    	const isVisible = !field.metadata.eventHandlers.length ||
    		field.metadata.eventHandlers.find(t => t.id === "depend-on") == null;
    	this.show(isVisible);
    }
    const file$5 = "src\\core\\ui\\Input.html";

    function add_css$1() {
    	var style = createElement("style");
    	style.id = 'svelte-1izjarg-style';
    	style.textContent = ".inline.svelte-1izjarg{display:inline-block}.col-form-label.svelte-1izjarg{padding-left:0}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSW5wdXQuaHRtbCIsInNvdXJjZXMiOlsiSW5wdXQuaHRtbCJdLCJzb3VyY2VzQ29udGVudCI6WyJ7I2lmIHZpc2libGV9XHJcbiAgICB7I2lmICFhbHdheXNIaWRlTGFiZWwgJiYgZmllbGQubWV0YWRhdGEubGFiZWwgIT09IFwiXCIgfVxyXG4gICAgPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXAge2NsYXNzfVwiPlxyXG4gICAgICAgIDxsYWJlbCBmb3I9XCJ7aWR9XCIgY2xhc3M9XCJjb2wtZm9ybS1sYWJlbFwiPlxyXG4gICAgICAgICAgICB7I2lmIGZpZWxkLm1ldGFkYXRhLmN1c3RvbVByb3BlcnRpZXMgIT0gbnVsbCAmJiBmaWVsZC5tZXRhZGF0YS5jdXN0b21Qcm9wZXJ0aWVzW1wiZG9jdW1lbnRhdGlvblwiXSAhPSBudWxsfVxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiaGVscC10b29sdGlwXCI+e2ZpZWxkLm1ldGFkYXRhLmxhYmVsfTpcclxuICAgICAgICAgICAgICAgIDxUb29sdGlwIGRhdGE9XCJ7ZmllbGQubWV0YWRhdGEuY3VzdG9tUHJvcGVydGllcy5kb2N1bWVudGF0aW9uWzBdfVwiPjwvVG9vbHRpcD5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIHs6ZWxzZX1cclxuICAgICAgICAgICAge2ZpZWxkLm1ldGFkYXRhLmxhYmVsfTpcclxuICAgICAgICAgICAgey9pZn1cclxuICAgICAgICA8L2xhYmVsPlxyXG4gICAgICAgIDxkaXYgcmVmOmNvbnRhaW5lciBjbGFzcz1cImlucHV0LWNvbnRhaW5lclwiPjwvZGl2PlxyXG4gICAgPC9kaXY+XHJcbiAgICB7OmVsc2V9XHJcbiAgICA8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cCB7Y2xhc3N9XCI+XHJcbiAgICAgICAgPGRpdiByZWY6Y29udGFpbmVyIGNsYXNzPVwiaW5wdXQtY29udGFpbmVyXCI+PC9kaXY+XHJcbiAgICA8L2Rpdj5cclxuICAgIHsvaWZ9XHJcbnsvaWZ9XHJcblxyXG48c2NyaXB0PlxyXG5cdGltcG9ydCBUb29sdGlwIGZyb20gXCIuL2hlbHAvVG9vbHRpcFwiO1xyXG5cclxuXHRsZXQgaW5wdXRJZCA9IDA7XHJcblxyXG5cdGV4cG9ydCBkZWZhdWx0IHtcclxuXHRcdG9uY3JlYXRlKCkge1xyXG5cdFx0XHRjb25zdCB7IGZpZWxkLCBhcHAgfSA9IHRoaXMuZ2V0KCk7XHJcblxyXG5cdFx0XHRjb25zdCBpbnB1dCA9IGFwcC5jb250cm9sUmVnaXN0ZXIuZ2V0SW5wdXQoZmllbGQubWV0YWRhdGEudHlwZSk7XHJcblxyXG5cdFx0XHQvLyBTZXQgY29ycmVjdCBjc3MgY2xhc3MgYmFzZWQgb24gdGhlIGZpZWxkIHR5cGUuXHJcblx0XHRcdGNvbnN0IGlucHV0RGlzcGxheUNvbmZpZyA9IGZpZWxkLmNvbnN0YW50cyB8fCBpbnB1dC5jb25zdGFudHMgfHwge307XHJcblxyXG5cdFx0XHRjb25zdCBjc3NDbGFzcyA9IGZpZWxkLm1ldGFkYXRhLmN1c3RvbVByb3BlcnRpZXMgIT0gbnVsbCA/IGZpZWxkLm1ldGFkYXRhLmN1c3RvbVByb3BlcnRpZXMuY3NzQ2xhc3MgOiBudWxsO1xyXG5cclxuXHRcdFx0Ly8gU2V0IGNvcnJlY3QgY3NzIGNsYXNzIGJhc2VkIG9uIHRoZSBmaWVsZCB0eXBlLlxyXG5cdFx0XHRpZiAoaW5wdXREaXNwbGF5Q29uZmlnLmJsb2NrKSB7XHJcblx0XHRcdFx0dGhpcy5zZXQoeyBjbGFzczogYGJsb2NrICR7Y3NzQ2xhc3N9YCB9KTtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIHtcclxuXHRcdFx0XHR0aGlzLnNldCh7IGNsYXNzOiBgaW5saW5lICR7Y3NzQ2xhc3N9YCB9KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5zZXQoe1xyXG5cdFx0XHRcdGNsYXNzOiBjc3NDbGFzcyxcclxuXHRcdFx0XHRhbHdheXNIaWRlTGFiZWw6IGlucHV0RGlzcGxheUNvbmZpZy5hbHdheXNIaWRlTGFiZWxcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHRjb25zdCB7IGlucHV0cyB9ID0gdGhpcy5nZXQoKS5mb3JtLmdldCgpO1xyXG5cdFx0XHQvLyBJZiBgaW5wdXRzYCBpcyBudWxsLCB0aGVuIGl0IG1lYW5zIG91ciBwYXJlbnQgZm9ybSBoYXMgYmVlbiBjbG9zZWRcclxuXHRcdFx0Ly8gYW5kIFwiZGVzdHJveWVkXCIuIEluIHN1Y2ggY2FzZXMgd2Ugc2hvdWxkIGp1c3QgcmV0dXJuLlxyXG5cdFx0XHQvLyBUT0RPOiBmaW5kIGEgYmV0dGVyIHdheSB0byBpbXBsZW1lbnQgXCJwYXJlbnQgZm9ybSBudWxsIGNoZWNrXCIuXHJcblx0XHRcdGlmIChpbnB1dHMgIT0gbnVsbCkge1xyXG5cdFx0XHRcdC8vIFJlZ2lzdGVyIGlucHV0IGluIHRoZSBwYXJlbnQgZm9ybS5cclxuXHRcdFx0XHRpbnB1dHMucHVzaCh0aGlzKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Y29uc3QgaXNWaXNpYmxlID0gIWZpZWxkLm1ldGFkYXRhLmV2ZW50SGFuZGxlcnMubGVuZ3RoIHx8XHJcblx0XHRcdFx0ZmllbGQubWV0YWRhdGEuZXZlbnRIYW5kbGVycy5maW5kKHQgPT4gdC5pZCA9PT0gXCJkZXBlbmQtb25cIikgPT0gbnVsbDtcclxuXHRcdFx0dGhpcy5zaG93KGlzVmlzaWJsZSk7XHJcblx0XHR9LFxyXG5cdFx0ZGF0YSgpIHtcclxuXHRcdFx0aW5wdXRJZCArPSAxO1xyXG5cdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdGlkOiBgaSR7aW5wdXRJZH1gLFxyXG5cdFx0XHRcdHZpc2libGU6IGZhbHNlLFxyXG5cdFx0XHRcdGFsd2F5c0hpZGVMYWJlbDogZmFsc2UsXHJcblx0XHRcdFx0Y2xhc3M6IFwiXCJcclxuXHRcdFx0fTtcclxuXHRcdH0sXHJcblx0XHRtZXRob2RzOiB7XHJcblx0XHRcdHNob3codmlzaWJsZSkge1xyXG5cdFx0XHRcdGNvbnN0IHsgZmllbGQgfSA9IHRoaXMuZ2V0KCk7XHJcblx0XHRcdFx0Y29uc3QgY3VycmVudGx5VmlzaWJsZSA9ICEhdGhpcy5nZXQoKS52aXNpYmxlO1xyXG5cclxuXHRcdFx0XHR0aGlzLnNldCh7IHZpc2libGU6ICEhdmlzaWJsZSB9KTtcclxuXHJcblx0XHRcdFx0aWYgKGN1cnJlbnRseVZpc2libGUgPT09IGZhbHNlICYmIHZpc2libGUgPT09IHRydWUpIHtcclxuXHRcdFx0XHRcdGNvbnN0IHsgYXBwIH0gPSB0aGlzLmdldCgpO1xyXG5cdFx0XHRcdFx0Y29uc3QgaW5wdXQgPSBhcHAuY29udHJvbFJlZ2lzdGVyLmdldElucHV0KGZpZWxkLm1ldGFkYXRhLnR5cGUpO1xyXG5cclxuXHRcdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxyXG5cdFx0XHRcdFx0bmV3IGlucHV0LmNvbXBvbmVudCh7XHJcblx0XHRcdFx0XHRcdHRhcmdldDogdGhpcy5yZWZzLmNvbnRhaW5lcixcclxuXHRcdFx0XHRcdFx0ZGF0YToge1xyXG5cdFx0XHRcdFx0XHRcdGZpZWxkLFxyXG5cdFx0XHRcdFx0XHRcdHRhYmluZGV4OiB0aGlzLmdldCgpLnRhYmluZGV4LFxyXG5cdFx0XHRcdFx0XHRcdGlkOiB0aGlzLmdldCgpLmlkLFxyXG5cdFx0XHRcdFx0XHRcdGFwcCxcclxuXHRcdFx0XHRcdFx0XHRmb3JtOiB0aGlzLmdldCgpLmZvcm0sXHJcblx0XHRcdFx0XHRcdFx0d3JhcHBlcjogdGhpcyxcclxuXHRcdFx0XHRcdFx0XHR2aXNpYmxlXHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gaWYgKCF2aXNpYmxlKSB7XHJcblx0XHRcdFx0Ly8gXHRmaWVsZC52YWx1ZSA9IG51bGw7XHJcblx0XHRcdFx0Ly8gfVxyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0Y29tcG9uZW50czoge1xyXG5cdFx0XHRUb29sdGlwXHJcblx0XHR9XHJcblx0fTtcclxuPC9zY3JpcHQ+XHJcblxyXG48c3R5bGU+XHJcblx0LmlubGluZSB7XHJcblx0XHRkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XHJcblx0fVxyXG5cclxuXHQuY29sLWZvcm0tbGFiZWwge1xyXG5cdFx0cGFkZGluZy1sZWZ0OiAwO1xyXG5cdH1cclxuPC9zdHlsZT5cclxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQThHQyxPQUFPLGVBQUMsQ0FBQyxBQUNSLE9BQU8sQ0FBRSxZQUFZLEFBQ3RCLENBQUMsQUFFRCxlQUFlLGVBQUMsQ0FBQyxBQUNoQixZQUFZLENBQUUsQ0FBQyxBQUNoQixDQUFDIn0= */";
    	append(document.head, style);
    }

    function create_main_fragment$5(component, ctx) {
    	var if_block_anchor;

    	var if_block = (ctx.visible) && create_if_block$4(component, ctx);

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (ctx.visible) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block$4(component, ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (if_block) if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (1:0) {#if visible}
    function create_if_block$4(component, ctx) {
    	var if_block_anchor;

    	function select_block_type(ctx) {
    		if (!ctx.alwaysHideLabel && ctx.field.metadata.label !== "") return create_if_block_1$2;
    		return create_else_block_1$1;
    	}

    	var current_block_type = select_block_type(ctx);
    	var if_block = current_block_type(component, ctx);

    	return {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(changed, ctx);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(component, ctx);
    				if_block.c();
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},

    		d: function destroy$$1(detach) {
    			if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (15:4) {:else}
    function create_else_block_1$1(component, ctx) {
    	var div1, div0, div1_class_value;

    	return {
    		c: function create() {
    			div1 = createElement("div");
    			div0 = createElement("div");
    			div0.className = "input-container";
    			addLoc(div0, file$5, 16, 8, 686);
    			div1.className = div1_class_value = "form-group " + ctx.class + " svelte-1izjarg";
    			addLoc(div1, file$5, 15, 4, 644);
    		},

    		m: function mount(target, anchor) {
    			insert(target, div1, anchor);
    			append(div1, div0);
    			component.refs.container = div0;
    		},

    		p: function update(changed, ctx) {
    			if ((changed.class) && div1_class_value !== (div1_class_value = "form-group " + ctx.class + " svelte-1izjarg")) {
    				div1.className = div1_class_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(div1);
    			}

    			if (component.refs.container === div0) component.refs.container = null;
    		}
    	};
    }

    // (2:4) {#if !alwaysHideLabel && field.metadata.label !== "" }
    function create_if_block_1$2(component, ctx) {
    	var div1, label, text, div0, div1_class_value;

    	function select_block_type_1(ctx) {
    		if (ctx.field.metadata.customProperties != null && ctx.field.metadata.customProperties["documentation"] != null) return create_if_block_2$1;
    		return create_else_block$2;
    	}

    	var current_block_type = select_block_type_1(ctx);
    	var if_block = current_block_type(component, ctx);

    	return {
    		c: function create() {
    			div1 = createElement("div");
    			label = createElement("label");
    			if_block.c();
    			text = createText("\r\n        ");
    			div0 = createElement("div");
    			label.htmlFor = ctx.id;
    			label.className = "col-form-label svelte-1izjarg";
    			addLoc(label, file$5, 3, 8, 121);
    			div0.className = "input-container";
    			addLoc(div0, file$5, 12, 8, 564);
    			div1.className = div1_class_value = "form-group " + ctx.class + " svelte-1izjarg";
    			addLoc(div1, file$5, 2, 4, 79);
    		},

    		m: function mount(target, anchor) {
    			insert(target, div1, anchor);
    			append(div1, label);
    			if_block.m(label, null);
    			append(div1, text);
    			append(div1, div0);
    			component.refs.container = div0;
    		},

    		p: function update(changed, ctx) {
    			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
    				if_block.p(changed, ctx);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(component, ctx);
    				if_block.c();
    				if_block.m(label, null);
    			}

    			if (changed.id) {
    				label.htmlFor = ctx.id;
    			}

    			if ((changed.class) && div1_class_value !== (div1_class_value = "form-group " + ctx.class + " svelte-1izjarg")) {
    				div1.className = div1_class_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(div1);
    			}

    			if_block.d();
    			if (component.refs.container === div0) component.refs.container = null;
    		}
    	};
    }

    // (9:12) {:else}
    function create_else_block$2(component, ctx) {
    	var text0_value = ctx.field.metadata.label, text0, text1;

    	return {
    		c: function create() {
    			text0 = createText(text0_value);
    			text1 = createText(":");
    		},

    		m: function mount(target, anchor) {
    			insert(target, text0, anchor);
    			insert(target, text1, anchor);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.field) && text0_value !== (text0_value = ctx.field.metadata.label)) {
    				setData(text0, text0_value);
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(text0);
    				detachNode(text1);
    			}
    		}
    	};
    }

    // (5:12) {#if field.metadata.customProperties != null && field.metadata.customProperties["documentation"] != null}
    function create_if_block_2$1(component, ctx) {
    	var div, text0_value = ctx.field.metadata.label, text0, text1;

    	var tooltip_initial_data = { data: ctx.field.metadata.customProperties.documentation[0] };
    	var tooltip = new SvelteComponent$4({
    		root: component.root,
    		store: component.store,
    		data: tooltip_initial_data
    	});

    	return {
    		c: function create() {
    			div = createElement("div");
    			text0 = createText(text0_value);
    			text1 = createText(":\r\n                ");
    			tooltip._fragment.c();
    			div.className = "help-tooltip";
    			addLoc(div, file$5, 5, 12, 295);
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);
    			append(div, text0);
    			append(div, text1);
    			tooltip._mount(div, null);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.field) && text0_value !== (text0_value = ctx.field.metadata.label)) {
    				setData(text0, text0_value);
    			}

    			var tooltip_changes = {};
    			if (changed.field) tooltip_changes.data = ctx.field.metadata.customProperties.documentation[0];
    			tooltip._set(tooltip_changes);
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(div);
    			}

    			tooltip.destroy();
    		}
    	};
    }

    function SvelteComponent$5(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) {
    		throw new Error("'target' is a required option");
    	}

    	init(this, options);
    	this.refs = {};
    	this._state = assign(data$3(), options.data);
    	if (!('visible' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'visible'");
    	if (!('alwaysHideLabel' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'alwaysHideLabel'");
    	if (!('field' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'field'");
    	if (!('class' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'class'");
    	if (!('id' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'id'");
    	this._intro = true;

    	if (!document.getElementById("svelte-1izjarg-style")) add_css$1();

    	this._fragment = create_main_fragment$5(this, this._state);

    	this.root._oncreate.push(() => {
    		oncreate$1.call(this);
    		this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
    	});

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);

    		flush(this);
    	}
    }

    assign(SvelteComponent$5.prototype, protoDev);
    assign(SvelteComponent$5.prototype, methods);

    SvelteComponent$5.prototype._checkReadOnly = function _checkReadOnly(newState) {
    };

    /* src\core\ui\Output.html generated by Svelte v2.16.1 */

    function data$4() {
    	return {
    		alwaysHideLabel: false,
    		showLabel: true,
    		class: ""
    	};
    }
    function oncreate$2() {
    	const {
    		field,
    		app,
    		form,
    		parent
    	} = this.get();

    	const output = app.controlRegister.getOutput(field);

    	// Never show label if `alwaysHideLabel` is set to true.
    	const outputDisplayConfig = output.constants || {};
    	this.set({
    		alwaysHideLabel: outputDisplayConfig.alwaysHideLabel
    	});

    	// Set correct css class based on the field type.
    	const cssClass = field.metadata.customProperties != null ? field.metadata.customProperties.cssClass : null;
    	const layoutCssClass = outputDisplayConfig.block ? "block" : "inline";
    	this.set({ class: `${layoutCssClass} ${cssClass}` });

    	// eslint-disable-next-line
    	new output.constructor({
    		target: this.refs.container,
    		data: {
    			field,
    			app,
    			form,
    			parent
    		}
    	});
    }
    const file$6 = "src\\core\\ui\\Output.html";

    function add_css$2() {
    	var style = createElement("style");
    	style.id = 'svelte-ss8wac-style';
    	style.textContent = ".inline.svelte-ss8wac{display:inline-block}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiT3V0cHV0Lmh0bWwiLCJzb3VyY2VzIjpbIk91dHB1dC5odG1sIl0sInNvdXJjZXNDb250ZW50IjpbInsjaWYgc2hvd0xhYmVsID09PSB0cnVlICYmICFhbHdheXNIaWRlTGFiZWwgJiYgZmllbGQubWV0YWRhdGEubGFiZWwgIT09IFwiXCJ9XHJcbjxkaXY+XHJcblx0eyNpZiBmaWVsZC5tZXRhZGF0YS5jdXN0b21Qcm9wZXJ0aWVzICE9IG51bGwgJiYgZmllbGQubWV0YWRhdGEuY3VzdG9tUHJvcGVydGllc1tcImRvY3VtZW50YXRpb25cIl0gIT0gbnVsbH1cclxuXHQ8bGFiZWwgY2xhc3M9XCJoZWxwLXRvb2x0aXAgb3V0cHV0LWxhYmVsXCI+e2ZpZWxkLm1ldGFkYXRhLmxhYmVsfTpcclxuXHRcdDxUb29sdGlwIGRhdGE9XCJ7ZmllbGQubWV0YWRhdGEuY3VzdG9tUHJvcGVydGllcy5kb2N1bWVudGF0aW9uWzBdfVwiPjwvVG9vbHRpcD5cclxuXHQ8L2xhYmVsPlxyXG5cdHs6ZWxzZX1cclxuXHQ8bGFiZWwgY2xhc3M9XCJvdXRwdXQtbGFiZWxcIj57ZmllbGQubWV0YWRhdGEubGFiZWx9OjwvbGFiZWw+XHJcblx0ey9pZn1cclxuICAgIDxkaXYgcmVmOmNvbnRhaW5lciBjbGFzcz1cIm91dHB1dC1jb250YWluZXIge2NsYXNzfVwiPjwvZGl2PlxyXG48L2Rpdj5cclxuezplbHNlfVxyXG48ZGl2IHJlZjpjb250YWluZXIgY2xhc3M9XCJvdXRwdXQtY29udGFpbmVyIHtjbGFzc31cIj48L2Rpdj5cclxuey9pZn1cclxuXHJcbjxzY3JpcHQ+XHJcblx0aW1wb3J0IFRvb2x0aXAgZnJvbSBcIi4vaGVscC9Ub29sdGlwXCI7XHJcblxyXG5cdGV4cG9ydCBkZWZhdWx0IHtcclxuXHRcdG9uY3JlYXRlKCkge1xyXG5cdFx0XHRjb25zdCB7XHJcblx0XHRcdFx0ZmllbGQsXHJcblx0XHRcdFx0YXBwLFxyXG5cdFx0XHRcdGZvcm0sXHJcblx0XHRcdFx0cGFyZW50XHJcblx0XHRcdH0gPSB0aGlzLmdldCgpO1xyXG5cclxuXHRcdFx0Y29uc3Qgb3V0cHV0ID0gYXBwLmNvbnRyb2xSZWdpc3Rlci5nZXRPdXRwdXQoZmllbGQpO1xyXG5cclxuXHRcdFx0Ly8gTmV2ZXIgc2hvdyBsYWJlbCBpZiBgYWx3YXlzSGlkZUxhYmVsYCBpcyBzZXQgdG8gdHJ1ZS5cclxuXHRcdFx0Y29uc3Qgb3V0cHV0RGlzcGxheUNvbmZpZyA9IG91dHB1dC5jb25zdGFudHMgfHwge307XHJcblx0XHRcdHRoaXMuc2V0KHtcclxuXHRcdFx0XHRhbHdheXNIaWRlTGFiZWw6IG91dHB1dERpc3BsYXlDb25maWcuYWx3YXlzSGlkZUxhYmVsXHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0Ly8gU2V0IGNvcnJlY3QgY3NzIGNsYXNzIGJhc2VkIG9uIHRoZSBmaWVsZCB0eXBlLlxyXG5cdFx0XHRjb25zdCBjc3NDbGFzcyA9IGZpZWxkLm1ldGFkYXRhLmN1c3RvbVByb3BlcnRpZXMgIT0gbnVsbCA/IGZpZWxkLm1ldGFkYXRhLmN1c3RvbVByb3BlcnRpZXMuY3NzQ2xhc3MgOiBudWxsO1xyXG5cdFx0XHRjb25zdCBsYXlvdXRDc3NDbGFzcyA9IG91dHB1dERpc3BsYXlDb25maWcuYmxvY2sgPyBcImJsb2NrXCIgOiBcImlubGluZVwiO1xyXG5cdFx0XHR0aGlzLnNldCh7IGNsYXNzOiBgJHtsYXlvdXRDc3NDbGFzc30gJHtjc3NDbGFzc31gIH0pO1xyXG5cclxuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXHJcblx0XHRcdG5ldyBvdXRwdXQuY29uc3RydWN0b3Ioe1xyXG5cdFx0XHRcdHRhcmdldDogdGhpcy5yZWZzLmNvbnRhaW5lcixcclxuXHRcdFx0XHRkYXRhOiB7XHJcblx0XHRcdFx0XHRmaWVsZCxcclxuXHRcdFx0XHRcdGFwcCxcclxuXHRcdFx0XHRcdGZvcm0sXHJcblx0XHRcdFx0XHRwYXJlbnRcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cdFx0fSxcclxuXHRcdGRhdGEoKSB7XHJcblx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0YWx3YXlzSGlkZUxhYmVsOiBmYWxzZSxcclxuXHRcdFx0XHRzaG93TGFiZWw6IHRydWUsXHJcblx0XHRcdFx0Y2xhc3M6IFwiXCJcclxuXHRcdFx0fTtcclxuXHRcdH0sXHJcblx0XHRjb21wb25lbnRzOiB7XHJcblx0XHRcdFRvb2x0aXBcclxuXHRcdH1cclxuXHR9O1xyXG48L3NjcmlwdD5cclxuXHJcbjxzdHlsZT5cclxuXHQuaW5saW5lIHtcclxuXHRcdGRpc3BsYXk6IGlubGluZS1ibG9jaztcclxuXHR9XHJcbjwvc3R5bGU+XHJcbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFpRUMsT0FBTyxjQUFDLENBQUMsQUFDUixPQUFPLENBQUUsWUFBWSxBQUN0QixDQUFDIn0= */";
    	append(document.head, style);
    }

    function create_main_fragment$6(component, ctx) {
    	var if_block_anchor;

    	function select_block_type(ctx) {
    		if (ctx.showLabel === true && !ctx.alwaysHideLabel && ctx.field.metadata.label !== "") return create_if_block$5;
    		return create_else_block_1$2;
    	}

    	var current_block_type = select_block_type(ctx);
    	var if_block = current_block_type(component, ctx);

    	return {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(changed, ctx);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(component, ctx);
    				if_block.c();
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},

    		d: function destroy$$1(detach) {
    			if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (12:0) {:else}
    function create_else_block_1$2(component, ctx) {
    	var div, div_class_value;

    	return {
    		c: function create() {
    			div = createElement("div");
    			div.className = div_class_value = "output-container " + ctx.class + " svelte-ss8wac";
    			addLoc(div, file$6, 12, 0, 512);
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);
    			component.refs.container = div;
    		},

    		p: function update(changed, ctx) {
    			if ((changed.class) && div_class_value !== (div_class_value = "output-container " + ctx.class + " svelte-ss8wac")) {
    				div.className = div_class_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(div);
    			}

    			if (component.refs.container === div) component.refs.container = null;
    		}
    	};
    }

    // (1:0) {#if showLabel === true && !alwaysHideLabel && field.metadata.label !== ""}
    function create_if_block$5(component, ctx) {
    	var div1, text, div0, div0_class_value;

    	function select_block_type_1(ctx) {
    		if (ctx.field.metadata.customProperties != null && ctx.field.metadata.customProperties["documentation"] != null) return create_if_block_1$3;
    		return create_else_block$3;
    	}

    	var current_block_type = select_block_type_1(ctx);
    	var if_block = current_block_type(component, ctx);

    	return {
    		c: function create() {
    			div1 = createElement("div");
    			if_block.c();
    			text = createText("\r\n    ");
    			div0 = createElement("div");
    			div0.className = div0_class_value = "output-container " + ctx.class + " svelte-ss8wac";
    			addLoc(div0, file$6, 9, 4, 435);
    			addLoc(div1, file$6, 1, 0, 77);
    		},

    		m: function mount(target, anchor) {
    			insert(target, div1, anchor);
    			if_block.m(div1, null);
    			append(div1, text);
    			append(div1, div0);
    			component.refs.container = div0;
    		},

    		p: function update(changed, ctx) {
    			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
    				if_block.p(changed, ctx);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(component, ctx);
    				if_block.c();
    				if_block.m(div1, text);
    			}

    			if ((changed.class) && div0_class_value !== (div0_class_value = "output-container " + ctx.class + " svelte-ss8wac")) {
    				div0.className = div0_class_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(div1);
    			}

    			if_block.d();
    			if (component.refs.container === div0) component.refs.container = null;
    		}
    	};
    }

    // (7:1) {:else}
    function create_else_block$3(component, ctx) {
    	var label, text0_value = ctx.field.metadata.label, text0, text1;

    	return {
    		c: function create() {
    			label = createElement("label");
    			text0 = createText(text0_value);
    			text1 = createText(":");
    			label.className = "output-label";
    			addLoc(label, file$6, 7, 1, 362);
    		},

    		m: function mount(target, anchor) {
    			insert(target, label, anchor);
    			append(label, text0);
    			append(label, text1);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.field) && text0_value !== (text0_value = ctx.field.metadata.label)) {
    				setData(text0, text0_value);
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(label);
    			}
    		}
    	};
    }

    // (3:1) {#if field.metadata.customProperties != null && field.metadata.customProperties["documentation"] != null}
    function create_if_block_1$3(component, ctx) {
    	var label, text0_value = ctx.field.metadata.label, text0, text1;

    	var tooltip_initial_data = { data: ctx.field.metadata.customProperties.documentation[0] };
    	var tooltip = new SvelteComponent$4({
    		root: component.root,
    		store: component.store,
    		data: tooltip_initial_data
    	});

    	return {
    		c: function create() {
    			label = createElement("label");
    			text0 = createText(text0_value);
    			text1 = createText(":\r\n\t\t");
    			tooltip._fragment.c();
    			label.className = "help-tooltip output-label";
    			addLoc(label, file$6, 3, 1, 193);
    		},

    		m: function mount(target, anchor) {
    			insert(target, label, anchor);
    			append(label, text0);
    			append(label, text1);
    			tooltip._mount(label, null);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.field) && text0_value !== (text0_value = ctx.field.metadata.label)) {
    				setData(text0, text0_value);
    			}

    			var tooltip_changes = {};
    			if (changed.field) tooltip_changes.data = ctx.field.metadata.customProperties.documentation[0];
    			tooltip._set(tooltip_changes);
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(label);
    			}

    			tooltip.destroy();
    		}
    	};
    }

    function SvelteComponent$6(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) {
    		throw new Error("'target' is a required option");
    	}

    	init(this, options);
    	this.refs = {};
    	this._state = assign(data$4(), options.data);
    	if (!('showLabel' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'showLabel'");
    	if (!('alwaysHideLabel' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'alwaysHideLabel'");
    	if (!('field' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'field'");
    	if (!('class' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'class'");
    	this._intro = true;

    	if (!document.getElementById("svelte-ss8wac-style")) add_css$2();

    	this._fragment = create_main_fragment$6(this, this._state);

    	this.root._oncreate.push(() => {
    		oncreate$2.call(this);
    		this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
    	});

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);

    		flush(this);
    	}
    }

    assign(SvelteComponent$6.prototype, protoDev);

    SvelteComponent$6.prototype._checkReadOnly = function _checkReadOnly(newState) {
    };

    /* src\core\ui\help\Help.html generated by Svelte v2.16.1 */

    function humanize(e) {
    	return e.replace(/\.[^/.]+$/, "")
    		.split(/(?=[A-Z])/)
    		.join(" ");
    }

    // https://stackoverflow.com/a/3369743/111438
    // Close topmost modal when user presses escape key.
    let currentlyOpenHelpModal = null;
    document.addEventListener("keydown", evt => {
    	const theEvent = evt || window.event;
    	let isEscape = false;
    	if ("key" in theEvent) {
    		isEscape = (theEvent.key === "Escape" || theEvent.key === "Esc");
    	}
    	else {
    		isEscape = (theEvent.keyCode === 27);
    	}
    	if (isEscape && currentlyOpenHelpModal != null) {
    		currentlyOpenHelpModal.close();
    	}
    });

    function data$5() {
    	return {
    		files: [],
    		open: false,
    		modalId: ""
    	};
    }
    var methods$1 = {
    	open() {
    		this.set({ open: true });
    		currentlyOpenHelpModal = this;
    	},
    	close() {
    		this.set({ open: false });
    		currentlyOpenHelpModal = null;
    	}
    };

    function oncreate$3() {
    	const files = this.get().data.files.map(i => ({ file: i, name: humanize(i) }));

    	this.set({
    		files,
    		modalId: this.constructor.name
    	});
    }
    const file$7 = "src\\core\\ui\\help\\Help.html";

    function add_css$3() {
    	var style = createElement("style");
    	style.id = 'svelte-17ly25h-style';
    	style.textContent = ".inline-help.svelte-17ly25h{background:#ecf8fb;padding:10px}.modal-help.svelte-17ly25h>i.svelte-17ly25h{font-size:15pt;color:#5b7b9b}.modal-help.svelte-17ly25h{display:block;margin-left:-10px;position:absolute;right:10px;top:30px}.help-files.svelte-17ly25h{border-top:1px solid #d8d8d8;padding:10px;margin:10px;background:#ecf8fb}.help-files.svelte-17ly25h ul.svelte-17ly25h{list-style:circle}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSGVscC5odG1sIiwic291cmNlcyI6WyJIZWxwLmh0bWwiXSwic291cmNlc0NvbnRlbnQiOlsieyNpZiBkYXRhICE9IG51bGx9XHJcblx0eyNpZiBkYXRhLnBsYWNlbWVudCA9PSAnSGludCd9XHJcblx0PGRpdiBjbGFzcz1cImhlbHAtY29udGVudCBtb2RhbC1oZWxwXCI+XHJcblx0XHQ8aSBvbjpjbGljaz1cIm9wZW4oKVwiIGNsYXNzPVwiZmFyIGZhLXF1ZXN0aW9uLWNpcmNsZVwiIHRpdGxlPVwiQ2xpY2sgdG8gb3BlbiBoZWxwIGZvciB0aGlzIGZvcm1cIj48L2k+XHJcblx0XHQ8aW5wdXQgaWQ9XCJtb2RhbC17bW9kYWxJZH1cIiB0eXBlPVwiY2hlY2tib3hcIiBiaW5kOmNoZWNrZWQ9XCJvcGVuXCIgY2xhc3M9XCJoaWRkZW5cIiAvPlxyXG5cdFx0PGRpdiBjbGFzcz1cIm1vZGFsXCI+XHJcblx0XHRcdDxkaXYgY2xhc3M9XCJjYXJkXCI+XHJcblx0XHRcdFx0PGxhYmVsIGNsYXNzPVwiY2xvc2VcIiBvbjpjbGljaz1cImNsb3NlKClcIj48L2xhYmVsPlxyXG5cdFx0XHRcdDxkaXYgcmVmOmNvbnRhaW5lcj5cclxuXHRcdFx0XHRcdHtAaHRtbCBkYXRhLmNvbnRlbnR9XHJcblxyXG5cdFx0XHRcdFx0eyAjaWYgZmlsZXMgJiYgZmlsZXMubGVuZ3RoID4wIH1cclxuXHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJoZWxwLWZpbGVzXCI+XHJcblx0XHRcdFx0XHRcdDxzcGFuPkZvciBtb3JlIGluZm9ybWF0aW9uOjwvc3Bhbj5cclxuXHRcdFx0XHRcdFx0XHQ8dWw+XHJcblx0XHRcdFx0XHRcdFx0XHR7I2VhY2ggZmlsZXMgYXMgZmlsZX1cclxuXHRcdFx0XHRcdFx0XHRcdDxsaT5cclxuXHRcdFx0XHRcdFx0XHRcdFx0PGEgaHJlZj1cIi8jL2Zvcm0vaGVscD9GaWxlSWQ9e2ZpbGUuZmlsZX1cIj57IGZpbGUubmFtZSB9PC9hPlxyXG5cdFx0XHRcdFx0XHRcdFx0PC9saT5cclxuXHRcdFx0XHRcdFx0XHRcdHsvZWFjaH1cclxuXHRcdFx0XHRcdFx0XHQ8L3VsPlxyXG5cclxuXHRcdFx0XHRcdDwvZGl2PlxyXG5cdFx0XHRcdFx0ey9pZn1cclxuXHRcdFx0XHQ8L2Rpdj5cclxuXHRcdFx0PC9kaXY+XHJcblx0XHQ8L2Rpdj5cclxuXHQ8L2Rpdj5cclxuXHR7OmVsc2VpZiBkYXRhLnBsYWNlbWVudCA9PSAnSW5saW5lJyB9XHJcblx0PGRpdiBjbGFzcz1cImhlbHAtY29udGVudCBpbmxpbmUtaGVscFwiPlxyXG5cdFx0e0BodG1sIGRhdGEuY29udGVudH1cclxuXHRcdHsjaWYgZmlsZXMgJiYgZmlsZXMubGVuZ3RoID4wIH1cclxuXHRcdDxkaXYgY2xhc3M9XCJoZWxwLWZpbGVzXCI+XHJcblx0XHRcdDxzcGFuPkZvciBtb3JlIGluZm9ybWF0aW9uPC9zcGFuPlxyXG5cdFx0XHQ8dWw+XHJcblx0XHRcdFx0eyNlYWNoIGZpbGVzIGFzIGZpbGV9XHJcblx0XHRcdFx0PGxpPlxyXG5cdFx0XHRcdFx0PGEgaHJlZj1cIi8jL2Zvcm0vaGVscD9GaWxlSWQ9e2ZpbGUuZmlsZX1cIj57IGZpbGUubmFtZSB9PC9hPlxyXG5cdFx0XHRcdDwvbGk+XHJcblx0XHRcdFx0ey9lYWNofVxyXG5cdFx0XHQ8L3VsPlxyXG5cdFx0PC9kaXY+XHJcblx0XHR7L2lmfVxyXG5cdDwvZGl2PlxyXG5cdHsvaWZ9XHJcbnsvaWZ9XHJcblxyXG48c2NyaXB0PlxyXG5cdGZ1bmN0aW9uIGh1bWFuaXplKGUpIHtcclxuXHRcdHJldHVybiBlLnJlcGxhY2UoL1xcLlteLy5dKyQvLCBcIlwiKVxyXG5cdFx0XHQuc3BsaXQoLyg/PVtBLVpdKS8pXHJcblx0XHRcdC5qb2luKFwiIFwiKTtcclxuXHR9XHJcblxyXG5cdC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zMzY5NzQzLzExMTQzOFxyXG5cdC8vIENsb3NlIHRvcG1vc3QgbW9kYWwgd2hlbiB1c2VyIHByZXNzZXMgZXNjYXBlIGtleS5cclxuXHRsZXQgY3VycmVudGx5T3BlbkhlbHBNb2RhbCA9IG51bGw7XHJcblx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgZXZ0ID0+IHtcclxuXHRcdGNvbnN0IHRoZUV2ZW50ID0gZXZ0IHx8IHdpbmRvdy5ldmVudDtcclxuXHRcdGxldCBpc0VzY2FwZSA9IGZhbHNlO1xyXG5cdFx0aWYgKFwia2V5XCIgaW4gdGhlRXZlbnQpIHtcclxuXHRcdFx0aXNFc2NhcGUgPSAodGhlRXZlbnQua2V5ID09PSBcIkVzY2FwZVwiIHx8IHRoZUV2ZW50LmtleSA9PT0gXCJFc2NcIik7XHJcblx0XHR9XHJcblx0XHRlbHNlIHtcclxuXHRcdFx0aXNFc2NhcGUgPSAodGhlRXZlbnQua2V5Q29kZSA9PT0gMjcpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGlzRXNjYXBlICYmIGN1cnJlbnRseU9wZW5IZWxwTW9kYWwgIT0gbnVsbCkge1xyXG5cdFx0XHRjdXJyZW50bHlPcGVuSGVscE1vZGFsLmNsb3NlKCk7XHJcblx0XHR9XHJcblx0fSk7XHJcblxyXG5cdGV4cG9ydCBkZWZhdWx0IHtcclxuXHRcdG9uY3JlYXRlKCkge1xyXG5cdFx0XHRjb25zdCBmaWxlcyA9IHRoaXMuZ2V0KCkuZGF0YS5maWxlcy5tYXAoaSA9PiAoeyBmaWxlOiBpLCBuYW1lOiBodW1hbml6ZShpKSB9KSk7XHJcblxyXG5cdFx0XHR0aGlzLnNldCh7XHJcblx0XHRcdFx0ZmlsZXMsXHJcblx0XHRcdFx0bW9kYWxJZDogdGhpcy5jb25zdHJ1Y3Rvci5uYW1lXHJcblx0XHRcdH0pO1xyXG5cdFx0fSxcclxuXHRcdGRhdGEoKSB7XHJcblx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0ZmlsZXM6IFtdLFxyXG5cdFx0XHRcdG9wZW46IGZhbHNlLFxyXG5cdFx0XHRcdG1vZGFsSWQ6IFwiXCJcclxuXHRcdFx0fTtcclxuXHRcdH0sXHJcblx0XHRtZXRob2RzOiB7XHJcblx0XHRcdG9wZW4oKSB7XHJcblx0XHRcdFx0dGhpcy5zZXQoeyBvcGVuOiB0cnVlIH0pO1xyXG5cdFx0XHRcdGN1cnJlbnRseU9wZW5IZWxwTW9kYWwgPSB0aGlzO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRjbG9zZSgpIHtcclxuXHRcdFx0XHR0aGlzLnNldCh7IG9wZW46IGZhbHNlIH0pO1xyXG5cdFx0XHRcdGN1cnJlbnRseU9wZW5IZWxwTW9kYWwgPSBudWxsO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fTtcclxuPC9zY3JpcHQ+XHJcblxyXG48c3R5bGU+XHJcblx0LmlubGluZS1oZWxwIHtcclxuXHRcdGJhY2tncm91bmQ6ICNlY2Y4ZmI7XHJcblx0XHRwYWRkaW5nOiAxMHB4O1xyXG5cdH1cclxuXHJcblx0Lm1vZGFsLWhlbHAgPiBpIHtcclxuXHRcdGZvbnQtc2l6ZTogMTVwdDtcclxuXHRcdGNvbG9yOiAjNWI3YjliO1xyXG5cdH1cclxuXHJcblx0Lm1vZGFsLWhlbHAge1xyXG5cdFx0ZGlzcGxheTogYmxvY2s7XHJcblx0XHRtYXJnaW4tbGVmdDogLTEwcHg7XHJcblx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XHJcblx0XHRyaWdodDogMTBweDtcclxuXHRcdHRvcDogMzBweDtcclxuXHR9XHJcblxyXG5cdC5oZWxwLWZpbGVzIHtcclxuXHRcdGJvcmRlci10b3A6IDFweCBzb2xpZCAjZDhkOGQ4O1xyXG5cdFx0cGFkZGluZzogMTBweDtcclxuXHRcdG1hcmdpbjogMTBweDtcclxuXHRcdGJhY2tncm91bmQ6ICNlY2Y4ZmI7XHJcblx0fVxyXG5cclxuXHQuaGVscC1maWxlcyB1bCB7XHJcblx0XHRsaXN0LXN0eWxlOiBjaXJjbGU7XHJcblx0fVxyXG48L3N0eWxlPlxyXG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBcUdDLFlBQVksZUFBQyxDQUFDLEFBQ2IsVUFBVSxDQUFFLE9BQU8sQ0FDbkIsT0FBTyxDQUFFLElBQUksQUFDZCxDQUFDLEFBRUQsMEJBQVcsQ0FBRyxDQUFDLGVBQUMsQ0FBQyxBQUNoQixTQUFTLENBQUUsSUFBSSxDQUNmLEtBQUssQ0FBRSxPQUFPLEFBQ2YsQ0FBQyxBQUVELFdBQVcsZUFBQyxDQUFDLEFBQ1osT0FBTyxDQUFFLEtBQUssQ0FDZCxXQUFXLENBQUUsS0FBSyxDQUNsQixRQUFRLENBQUUsUUFBUSxDQUNsQixLQUFLLENBQUUsSUFBSSxDQUNYLEdBQUcsQ0FBRSxJQUFJLEFBQ1YsQ0FBQyxBQUVELFdBQVcsZUFBQyxDQUFDLEFBQ1osVUFBVSxDQUFFLEdBQUcsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUM3QixPQUFPLENBQUUsSUFBSSxDQUNiLE1BQU0sQ0FBRSxJQUFJLENBQ1osVUFBVSxDQUFFLE9BQU8sQUFDcEIsQ0FBQyxBQUVELDBCQUFXLENBQUMsRUFBRSxlQUFDLENBQUMsQUFDZixVQUFVLENBQUUsTUFBTSxBQUNuQixDQUFDIn0= */";
    	append(document.head, style);
    }

    function get_each_context_1(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.file = list[i];
    	return child_ctx;
    }

    function get_each_context$2(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.file = list[i];
    	return child_ctx;
    }

    function create_main_fragment$7(component, ctx) {
    	var if_block_anchor;

    	var if_block = (ctx.data != null) && create_if_block$6(component, ctx);

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (ctx.data != null) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block$6(component, ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (if_block) if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (1:0) {#if data != null}
    function create_if_block$6(component, ctx) {
    	var if_block_anchor;

    	function select_block_type(ctx) {
    		if (ctx.data.placement == 'Hint') return create_if_block_1$4;
    		if (ctx.data.placement == 'Inline') return create_if_block_3$1;
    	}

    	var current_block_type = select_block_type(ctx);
    	var if_block = current_block_type && current_block_type(component, ctx);

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(changed, ctx);
    			} else {
    				if (if_block) if_block.d(1);
    				if_block = current_block_type && current_block_type(component, ctx);
    				if (if_block) if_block.c();
    				if (if_block) if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (if_block) if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (29:38) 
    function create_if_block_3$1(component, ctx) {
    	var div, raw_value = ctx.data.content, raw_after, text;

    	var if_block = (ctx.files && ctx.files.length >0) && create_if_block_4(component, ctx);

    	return {
    		c: function create() {
    			div = createElement("div");
    			raw_after = createElement('noscript');
    			text = createText("\r\n\t\t");
    			if (if_block) if_block.c();
    			div.className = "help-content inline-help svelte-17ly25h";
    			addLoc(div, file$7, 29, 1, 829);
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);
    			append(div, raw_after);
    			raw_after.insertAdjacentHTML("beforebegin", raw_value);
    			append(div, text);
    			if (if_block) if_block.m(div, null);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.data) && raw_value !== (raw_value = ctx.data.content)) {
    				detachBefore(raw_after);
    				raw_after.insertAdjacentHTML("beforebegin", raw_value);
    			}

    			if (ctx.files && ctx.files.length >0) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block_4(component, ctx);
    					if_block.c();
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(div);
    			}

    			if (if_block) if_block.d();
    		}
    	};
    }

    // (2:1) {#if data.placement == 'Hint'}
    function create_if_block_1$4(component, ctx) {
    	var div3, i, text0, input, input_id_value, text1, div2, div1, label, text2, div0, raw_value = ctx.data.content, raw_after, text3;

    	function click_handler(event) {
    		component.open();
    	}

    	function input_change_handler() {
    		component.set({ open: input.checked });
    	}

    	function click_handler_1(event) {
    		component.close();
    	}

    	var if_block = (ctx.files && ctx.files.length >0) && create_if_block_2$2(component, ctx);

    	return {
    		c: function create() {
    			div3 = createElement("div");
    			i = createElement("i");
    			text0 = createText("\r\n\t\t");
    			input = createElement("input");
    			text1 = createText("\r\n\t\t");
    			div2 = createElement("div");
    			div1 = createElement("div");
    			label = createElement("label");
    			text2 = createText("\r\n\t\t\t\t");
    			div0 = createElement("div");
    			raw_after = createElement('noscript');
    			text3 = createText("\r\n\r\n\t\t\t\t\t");
    			if (if_block) if_block.c();
    			addListener(i, "click", click_handler);
    			i.className = "far fa-question-circle svelte-17ly25h";
    			i.title = "Click to open help for this form";
    			addLoc(i, file$7, 3, 2, 95);
    			addListener(input, "change", input_change_handler);
    			input.id = input_id_value = "modal-" + ctx.modalId;
    			setAttribute(input, "type", "checkbox");
    			input.className = "hidden";
    			addLoc(input, file$7, 4, 2, 196);
    			addListener(label, "click", click_handler_1);
    			label.className = "close";
    			addLoc(label, file$7, 7, 4, 329);
    			addLoc(div0, file$7, 8, 4, 383);
    			div1.className = "card";
    			addLoc(div1, file$7, 6, 3, 305);
    			div2.className = "modal";
    			addLoc(div2, file$7, 5, 2, 281);
    			div3.className = "help-content modal-help svelte-17ly25h";
    			addLoc(div3, file$7, 2, 1, 54);
    		},

    		m: function mount(target, anchor) {
    			insert(target, div3, anchor);
    			append(div3, i);
    			append(div3, text0);
    			append(div3, input);

    			input.checked = ctx.open;

    			append(div3, text1);
    			append(div3, div2);
    			append(div2, div1);
    			append(div1, label);
    			append(div1, text2);
    			append(div1, div0);
    			append(div0, raw_after);
    			raw_after.insertAdjacentHTML("beforebegin", raw_value);
    			append(div0, text3);
    			if (if_block) if_block.m(div0, null);
    			component.refs.container = div0;
    		},

    		p: function update(changed, ctx) {
    			if (changed.open) input.checked = ctx.open;
    			if ((changed.modalId) && input_id_value !== (input_id_value = "modal-" + ctx.modalId)) {
    				input.id = input_id_value;
    			}

    			if ((changed.data) && raw_value !== (raw_value = ctx.data.content)) {
    				detachBefore(raw_after);
    				raw_after.insertAdjacentHTML("beforebegin", raw_value);
    			}

    			if (ctx.files && ctx.files.length >0) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block_2$2(component, ctx);
    					if_block.c();
    					if_block.m(div0, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(div3);
    			}

    			removeListener(i, "click", click_handler);
    			removeListener(input, "change", input_change_handler);
    			removeListener(label, "click", click_handler_1);
    			if (if_block) if_block.d();
    			if (component.refs.container === div0) component.refs.container = null;
    		}
    	};
    }

    // (32:2) {#if files && files.length >0 }
    function create_if_block_4(component, ctx) {
    	var div, span, text_1, ul;

    	var each_value_1 = ctx.files;

    	var each_blocks = [];

    	for (var i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1(component, get_each_context_1(ctx, each_value_1, i));
    	}

    	return {
    		c: function create() {
    			div = createElement("div");
    			span = createElement("span");
    			span.textContent = "For more information";
    			text_1 = createText("\r\n\t\t\t");
    			ul = createElement("ul");

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}
    			addLoc(span, file$7, 33, 3, 959);
    			ul.className = "svelte-17ly25h";
    			addLoc(ul, file$7, 34, 3, 997);
    			div.className = "help-files svelte-17ly25h";
    			addLoc(div, file$7, 32, 2, 930);
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);
    			append(div, span);
    			append(div, text_1);
    			append(div, ul);

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}
    		},

    		p: function update(changed, ctx) {
    			if (changed.files) {
    				each_value_1 = ctx.files;

    				for (var i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    					} else {
    						each_blocks[i] = create_each_block_1(component, child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(ul, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}
    				each_blocks.length = each_value_1.length;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(div);
    			}

    			destroyEach(each_blocks, detach);
    		}
    	};
    }

    // (36:4) {#each files as file}
    function create_each_block_1(component, ctx) {
    	var li, a, text0_value = ctx.file.name, text0, a_href_value, text1;

    	return {
    		c: function create() {
    			li = createElement("li");
    			a = createElement("a");
    			text0 = createText(text0_value);
    			text1 = createText("\r\n\t\t\t\t");
    			a.href = a_href_value = "/#/form/help?FileId=" + ctx.file.file;
    			addLoc(a, file$7, 37, 5, 1045);
    			addLoc(li, file$7, 36, 4, 1034);
    		},

    		m: function mount(target, anchor) {
    			insert(target, li, anchor);
    			append(li, a);
    			append(a, text0);
    			append(li, text1);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.files) && text0_value !== (text0_value = ctx.file.name)) {
    				setData(text0, text0_value);
    			}

    			if ((changed.files) && a_href_value !== (a_href_value = "/#/form/help?FileId=" + ctx.file.file)) {
    				a.href = a_href_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(li);
    			}
    		}
    	};
    }

    // (12:5) { #if files && files.length >0 }
    function create_if_block_2$2(component, ctx) {
    	var div, span, text_1, ul;

    	var each_value = ctx.files;

    	var each_blocks = [];

    	for (var i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$2(component, get_each_context$2(ctx, each_value, i));
    	}

    	return {
    		c: function create() {
    			div = createElement("div");
    			span = createElement("span");
    			span.textContent = "For more information:";
    			text_1 = createText("\r\n\t\t\t\t\t\t\t");
    			ul = createElement("ul");

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}
    			addLoc(span, file$7, 13, 6, 509);
    			ul.className = "svelte-17ly25h";
    			addLoc(ul, file$7, 14, 7, 552);
    			div.className = "help-files svelte-17ly25h";
    			addLoc(div, file$7, 12, 5, 477);
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);
    			append(div, span);
    			append(div, text_1);
    			append(div, ul);

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}
    		},

    		p: function update(changed, ctx) {
    			if (changed.files) {
    				each_value = ctx.files;

    				for (var i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$2(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    					} else {
    						each_blocks[i] = create_each_block$2(component, child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(ul, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}
    				each_blocks.length = each_value.length;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(div);
    			}

    			destroyEach(each_blocks, detach);
    		}
    	};
    }

    // (16:8) {#each files as file}
    function create_each_block$2(component, ctx) {
    	var li, a, text0_value = ctx.file.name, text0, a_href_value, text1;

    	return {
    		c: function create() {
    			li = createElement("li");
    			a = createElement("a");
    			text0 = createText(text0_value);
    			text1 = createText("\r\n\t\t\t\t\t\t\t\t");
    			a.href = a_href_value = "/#/form/help?FileId=" + ctx.file.file;
    			addLoc(a, file$7, 17, 9, 612);
    			addLoc(li, file$7, 16, 8, 597);
    		},

    		m: function mount(target, anchor) {
    			insert(target, li, anchor);
    			append(li, a);
    			append(a, text0);
    			append(li, text1);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.files) && text0_value !== (text0_value = ctx.file.name)) {
    				setData(text0, text0_value);
    			}

    			if ((changed.files) && a_href_value !== (a_href_value = "/#/form/help?FileId=" + ctx.file.file)) {
    				a.href = a_href_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(li);
    			}
    		}
    	};
    }

    function SvelteComponent$7(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) {
    		throw new Error("'target' is a required option");
    	}

    	init(this, options);
    	this.refs = {};
    	this._state = assign(data$5(), options.data);
    	if (!('data' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'data'");
    	if (!('modalId' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'modalId'");
    	if (!('open' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'open'");
    	if (!('files' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'files'");
    	this._intro = true;

    	if (!document.getElementById("svelte-17ly25h-style")) add_css$3();

    	this._fragment = create_main_fragment$7(this, this._state);

    	this.root._oncreate.push(() => {
    		oncreate$3.call(this);
    		this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
    	});

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);

    		flush(this);
    	}
    }

    assign(SvelteComponent$7.prototype, protoDev);
    assign(SvelteComponent$7.prototype, methods$1);

    SvelteComponent$7.prototype._checkReadOnly = function _checkReadOnly(newState) {
    };

    /* src\core\ui\Form.html generated by Svelte v2.16.1 */

    let tabindex = 1;
    let openForms = [];

    function bindEventHandlersToCustomEvents(formComponent, eventHandlers) {
    	const formInstance = formComponent.get().form;

    	for (const eventHandler of eventHandlers) {
    		// Don't bind default event handlers, because they are already auto-bound inside FormInstance.
    		if (eventHandler.runAt.indexOf("form:") === 0) {
    			continue;
    		}

    		formComponent.on(eventHandler.runAt, e => {
    			// Augment event args with form which is firing the event. This is needed,
    			// so that event handler can know from which particular form this event is coming.
    			e.form = formComponent;

    			formInstance.handleEvent(eventHandler.runAt, eventHandler, e);
    		});
    	}
    }

    function data$6() {
    	return {
    		cssClass: null,
    		documentation: null,
    		visibleInputFields: null,
    		outputFieldValues: null,
    		submitButtonLabel: "Submit",
    		disabled: false,
    		tabindex,
    		self: this,
    		urlData: null,
    		initialized: false,
    		responseMetadata: {},
    		useUrl: true,
    		parent: null, // Can be set if this is a nested form within another form (i.e. - InlineForm.html)
    		inputs: []
    	};
    }
    var methods$2 = {
    	async init() {
    		if (!this.get().initialized) {
    			const { form } = this.get();

    			this.set({
    				self: this,
    				initialized: true,
    				visibleInputFields: form.inputs.filter(t => t.metadata.hidden === false),
    				submitButtonLabel: form.metadata.getCustomProperty("submitButtonLabel") || "Submit",
    				cssClass: form.metadata.getCustomProperty("cssClass") || "",
    				initiallyHideForm: form.metadata.getCustomProperty("initiallyHideForm") || null,
    				documentation: form.metadata.getCustomProperty("documentation"),
    				hideForm: form.metadata.getCustomProperty("initiallyHideForm") != null ? "hidden" : null
    			});

    			tabindex += 1;

    			const { app } = this.get();

    			// Subscribe all event handlers (form, inputs, outputs).
    			const formMetadata = form.metadata;
    			const handlers = [];
    			formMetadata.inputFields.forEach(t => t.eventHandlers.forEach(h => handlers.push(h)));
    			formMetadata.outputFields.forEach(t => t.eventHandlers.forEach(h => handlers.push(h)));
    			formMetadata.eventHandlers.forEach(h => handlers.push(h));
    			bindEventHandlersToCustomEvents(this, handlers);

    			form.fire("form:loaded", { app });

    			// Auto-submit form if necessary.
    			if (form.metadata.postOnLoad) {
    				await this.submit();
    			}

    			openForms.push(this);

    			if (this.get().parent == null) {
    				if (this.get().responseMetadata.title == null) {
    					document.title = form.metadata.label;
    				}
    			}
    		}
    	},
    	fireAndBubbleUp(eventName, eventArgs) {
    		this.fire(eventName, eventArgs);
    		const parentFormComponent = this.get().parent;

    		if (parentFormComponent != null) {
    			parentFormComponent.fireAndBubbleUp(eventName, eventArgs);
    		}
    	},
    	enableForm() {
    		const formInstance = this.get().form;

    		// Hide all inputs, to re-render them. This is needed due to the way that
    		// Svelte *seems* to work - it doesn't re-render nested components, unless they are recreated.
    		this.set({ visibleInputFields: [] });

    		this.set({
    		// Show inputs again.
    			visibleInputFields: formInstance.inputs.filter(t => t.metadata.hidden === false),

    			disabled: false
    		});
    	},
    	renderResponse(response) {
    		const formInstance = this.get().form;

    		// Force Svelte to re-render outputs.
    		this.set({
    			outputFieldValues: null
    		});

    		this.set({
    			outputFieldValues: formInstance.outputs,
    			responseMetadata: response.metadata
    		});

    		if (this.get().parent == null) {
    			document.title = response.metadata.title;
    		}
    	},
    	async submit(event, redirect) {
    		// Disable double-posts.
    		this.set({ disabled: true });
    		const self = this;
    		const { form: formInstance, app } = this.get();

    		if (event != null) {
    			event.preventDefault();
    		}

    		// If not all required inputs are filled.
    		const allRequiredInputsHaveValues = await formInstance.allRequiredInputsHaveData(redirect == null);
    		if (!allRequiredInputsHaveValues) {
    			return;
    		}

    		// If postOnLoad == true, then the input field values should appear in the url.
    		// Reason is that postOnLoad == true is used by "report" pages, which need
    		// their filters to be saved in the url. This does not apply to forms
    		// with postOnLoad == false, because those forms are usually for creating new data
    		// and hence should not be tracked in browser's history based on parameters.

    		const isRedirectForm = formInstance.metadata.inputFields
    			.filter(t => t.eventHandlers.some(r => r.id === "bind-to-output")).length > 0;
    	
    		if (formInstance.metadata.postOnLoad && redirect && this.get().useUrl && !isRedirectForm) {
    			const urlParams = await formInstance.getSerializedInputValues();

    			// Update url in the browser.
    			app.go(formInstance.metadata.id, urlParams);

    			return;
    		}

    		try {
    			const response = await formInstance.submit(app, redirect == null, { formComponent: self });
    			// Signal event to child controls.
    			self.fire("form:responseHandled", {
    				form: self,
    				invokedByUser: event != null,
    				response
    			});
    			self.enableForm();
    		}
    		catch (e) {
    			self.enableForm();
    		}
    	},
    	reloadTopForm() {
    		const parentFormComponent = this.get().parent;

    		if (parentFormComponent != null) {
    			parentFormComponent.reloadTopForm();
    		}
    		else {
    			this.submit(null, true);
    		}
    	},
    	reloadAllForms() {
    		for (const f of openForms) {
    			f.reloadTopForm();
    		}
    	},
    	toggleForm() {
    		let hideForm = this.get("hideForm");
    		// eslint-disable-next-line no-console
    		if (hideForm.hideForm == null) {
    			hideForm = "hidden";
    		}
    		else {
    			hideForm = null;
    		}
    		this.set({
    			hideForm
    		});
    	},
    	getInputComponent(inputId) {
    		return this.get().inputs != null ?
    			this.get().inputs.find(t => t.get().field != null && t.get().field.metadata.id === inputId) :
    			null;
    	}
    };

    function ondestroy() {
    	openForms = openForms.filter(f => f !== this);
    }
    const file$8 = "src\\core\\ui\\Form.html";

    function add_css$4() {
    	var style = createElement("style");
    	style.id = 'svelte-1rxxhm5-style';
    	style.textContent = ".response.svelte-1rxxhm5{margin-top:15px;padding-left:10px;padding-right:10px}.form-header.svelte-1rxxhm5{text-align:center;padding-top:20px;border-bottom:1px solid #17a2b8;background-color:#fff;position:relative}.form-header.svelte-1rxxhm5 h2.svelte-1rxxhm5{display:inline-block}.help-content.svelte-1rxxhm5{text-align:left}.alert.svelte-1rxxhm5{margin:5px 8px;padding:10px 15px;border:1px solid #bbb}.alert.svelte-1rxxhm5>.heading.svelte-1rxxhm5{font-weight:bold;font-size:14px}.alert.success.svelte-1rxxhm5{background:#ebfff8}.alert.warning.svelte-1rxxhm5{background:#fdffeb}.alert.danger.svelte-1rxxhm5{background:#ffeaea}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRm9ybS5odG1sIiwic291cmNlcyI6WyJGb3JtLmh0bWwiXSwic291cmNlc0NvbnRlbnQiOlsieyNpZiBpbml0aWFsaXplZH1cclxuPGRpdiBjbGFzcz1cImlucHV0cy1ob3Jpem9udGFsLW9uZS1jb2x1bW4ge2Nzc0NsYXNzfVwiPlxyXG5cdCB7I2lmIChyZXNwb25zZU1ldGFkYXRhLnRpdGxlICE9IG51bGwgJiYgcmVzcG9uc2VNZXRhZGF0YS50aXRsZSAhPSBcIlwiKSB8fCAobWV0YWRhdGEubGFiZWwgIT0gbnVsbCAmJiBtZXRhZGF0YS5sYWJlbCAhPSBcIlwiKX1cclxuXHQgIDxkaXYgY2xhc3M9XCJmb3JtLWhlYWRlclwiPlxyXG5cdFx0PGgyPntyZXNwb25zZU1ldGFkYXRhLnRpdGxlIHx8IG1ldGFkYXRhLmxhYmVsfTwvaDI+XHJcblx0XHR7I2lmIHJlc3BvbnNlTWV0YWRhdGEuc3RhdHVzfVxyXG5cdFx0PGRpdiBjbGFzcz1cImFsZXJ0IHtyZXNwb25zZU1ldGFkYXRhLnN0YXR1cy5zdHlsZX1cIj5cclxuXHRcdFx0eyNpZiByZXNwb25zZU1ldGFkYXRhLnN0YXR1cy5oZWFkaW5nICE9IG51bGx9XHJcblx0XHRcdDxkaXYgY2xhc3M9XCJoZWFkaW5nXCI+XHJcblx0XHRcdFx0eyNpZiByZXNwb25zZU1ldGFkYXRhLnN0YXR1cy5pY29uICE9IG51bGx9XHJcblx0XHRcdFx0XHQ8c3Bhbj57QGh0bWwgcmVzcG9uc2VNZXRhZGF0YS5zdGF0dXMuaWNvbn08L3NwYW4+XHJcblx0XHRcdFx0ey9pZn1cclxuXHRcdFx0XHR7cmVzcG9uc2VNZXRhZGF0YS5zdGF0dXMuaGVhZGluZ308L2Rpdj5cclxuXHRcdFx0ey9pZn1cclxuXHRcdFx0eyNpZiByZXNwb25zZU1ldGFkYXRhLnN0YXR1cy5tZXNzYWdlICE9IG51bGx9XHJcblx0XHRcdDxkaXYgY2xhc3M9XCJib2R5XCI+e0BodG1sIHJlc3BvbnNlTWV0YWRhdGEuc3RhdHVzLm1lc3NhZ2V9PC9kaXY+XHJcblx0XHRcdHsvaWZ9XHJcblx0XHQ8L2Rpdj5cclxuXHRcdHsvaWZ9XHJcblx0XHR7I2lmIGRvY3VtZW50YXRpb24gfVxyXG5cdFx0XHR7I2VhY2ggZG9jdW1lbnRhdGlvbiBhcyBkb2N1bWVudCB9XHJcblx0XHRcdFx0PEhlbHAgZGF0YT17ZG9jdW1lbnR9Lz5cclxuXHRcdFx0ey9lYWNofVxyXG5cdFx0ey9pZn1cclxuXHQgIDwvZGl2PlxyXG5cdHsvaWZ9XHJcblxyXG5cdHsjaWYgaW5pdGlhbGl6ZWQgJiYgdmlzaWJsZUlucHV0RmllbGRzLmxlbmd0aCA+IDB9XHJcblx0PGRpdiBjbGFzcz1cImZvcm0tYm9keVwiPlxyXG5cdFx0eyNpZiBpbml0aWFsbHlIaWRlRm9ybX1cclxuXHRcdDxkaXYgY2xhc3M9XCJoaWRlRm9ybS1oZWFkZXJcIiBvbjpjbGljaz1cInRvZ2dsZUZvcm0oKVwiPlxyXG5cdFx0XHQ8c3Bhbj57QGh0bWwgaW5pdGlhbGx5SGlkZUZvcm19PC9zcGFuPlxyXG5cdFx0PC9kaXY+XHRcdFx0XHJcblx0XHR7L2lmfVxyXG5cdFx0PGZvcm0gb246c3VibWl0PVwic3VibWl0KGV2ZW50LCB0cnVlKVwiIGNsYXNzPVwie2hpZGVGb3JtfVwiPlxyXG5cdFx0XHR7I2VhY2ggdmlzaWJsZUlucHV0RmllbGRzIGFzIGlucHV0RmllbGR9XHJcblx0XHRcdDxGb3JtSW5wdXQgZmllbGQ9XCJ7aW5wdXRGaWVsZH1cIiBhcHA9XCJ7YXBwfVwiIHRhYmluZGV4PVwie3RhYmluZGV4ICogMTAwICsgaW5wdXRGaWVsZC5tZXRhZGF0YS5vcmRlckluZGV4fVwiIGZvcm09XCJ7c2VsZn1cIiAvPlxyXG5cdFx0XHR7L2VhY2h9XHJcblx0XHRcdDxkaXYgY2xhc3M9XCJmdWxsLXdpZHRoXCI+XHJcblx0XHRcdFx0PGJ1dHRvbiB0eXBlPVwic3VibWl0XCIgZGlzYWJsZWQ9XCJ7ZGlzYWJsZWR9XCIgdGFiaW5kZXg9XCItMVwiIGNsYXNzPVwiYnRuIGJ0bi1kZWZhdWx0XCI+e0BodG1sIHN1Ym1pdEJ1dHRvbkxhYmVsfTwvYnV0dG9uPlxyXG5cdFx0XHQ8L2Rpdj5cclxuXHRcdDwvZm9ybT5cclxuXHQ8L2Rpdj5cclxuXHR7L2lmfVxyXG5cclxuXHR7I2lmIG91dHB1dEZpZWxkVmFsdWVzICE9IG51bGx9XHJcblx0PGRpdiBjbGFzcz1cInJlc3BvbnNlXCI+XHJcblx0XHR7I2VhY2ggb3V0cHV0RmllbGRWYWx1ZXMgYXMgb3V0cHV0RmllbGQgfVxyXG5cdFx0eyNpZiBvdXRwdXRGaWVsZC5tZXRhZGF0YS5oaWRkZW4gPT0gZmFsc2UgJiYgIShvdXRwdXRGaWVsZC5tZXRhZGF0YS5nZXRDdXN0b21Qcm9wZXJ0eShcImhpZGVJZk51bGxcIikgPT09IHRydWUgJiYgb3V0cHV0RmllbGQuZGF0YSA9PT0gbnVsbCl9XHJcblx0XHQ8Rm9ybU91dHB1dCBmaWVsZD1cIntvdXRwdXRGaWVsZH1cIiBhcHA9XCJ7YXBwfVwiIGZvcm09XCJ7Zm9ybX1cIiBwYXJlbnQ9XCJ7c2VsZn1cIiAvPlxyXG5cdFx0ey9pZn1cclxuXHRcdHsvZWFjaH1cclxuXHQ8L2Rpdj5cclxuXHR7L2lmfVxyXG48L2Rpdj5cclxuey9pZn1cclxuXHJcbjxzY3JpcHQ+XHJcblx0aW1wb3J0ICogYXMgYWxlcnRpZnlMaWIgZnJvbSBcImFsZXJ0aWZ5anNcIjtcclxuXHRpbXBvcnQgRm9ybUlucHV0IGZyb20gXCIuL0lucHV0XCI7XHJcblx0aW1wb3J0IEZvcm1PdXRwdXQgZnJvbSBcIi4vT3V0cHV0XCI7XHJcblx0aW1wb3J0IEhlbHAgZnJvbSBcIi4vaGVscC9IZWxwXCI7XHJcblxyXG5cdGNvbnN0IGFsZXJ0aWZ5ID0gYWxlcnRpZnlMaWIuZGVmYXVsdDtcclxuXHJcblx0bGV0IHRhYmluZGV4ID0gMTtcclxuXHRsZXQgb3BlbkZvcm1zID0gW107XHJcblxyXG5cdGZ1bmN0aW9uIGJpbmRFdmVudEhhbmRsZXJzVG9DdXN0b21FdmVudHMoZm9ybUNvbXBvbmVudCwgZXZlbnRIYW5kbGVycykge1xyXG5cdFx0Y29uc3QgZm9ybUluc3RhbmNlID0gZm9ybUNvbXBvbmVudC5nZXQoKS5mb3JtO1xyXG5cclxuXHRcdGZvciAoY29uc3QgZXZlbnRIYW5kbGVyIG9mIGV2ZW50SGFuZGxlcnMpIHtcclxuXHRcdFx0Ly8gRG9uJ3QgYmluZCBkZWZhdWx0IGV2ZW50IGhhbmRsZXJzLCBiZWNhdXNlIHRoZXkgYXJlIGFscmVhZHkgYXV0by1ib3VuZCBpbnNpZGUgRm9ybUluc3RhbmNlLlxyXG5cdFx0XHRpZiAoZXZlbnRIYW5kbGVyLnJ1bkF0LmluZGV4T2YoXCJmb3JtOlwiKSA9PT0gMCkge1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmb3JtQ29tcG9uZW50Lm9uKGV2ZW50SGFuZGxlci5ydW5BdCwgZSA9PiB7XHJcblx0XHRcdFx0Ly8gQXVnbWVudCBldmVudCBhcmdzIHdpdGggZm9ybSB3aGljaCBpcyBmaXJpbmcgdGhlIGV2ZW50LiBUaGlzIGlzIG5lZWRlZCxcclxuXHRcdFx0XHQvLyBzbyB0aGF0IGV2ZW50IGhhbmRsZXIgY2FuIGtub3cgZnJvbSB3aGljaCBwYXJ0aWN1bGFyIGZvcm0gdGhpcyBldmVudCBpcyBjb21pbmcuXHJcblx0XHRcdFx0ZS5mb3JtID0gZm9ybUNvbXBvbmVudDtcclxuXHJcblx0XHRcdFx0Zm9ybUluc3RhbmNlLmhhbmRsZUV2ZW50KGV2ZW50SGFuZGxlci5ydW5BdCwgZXZlbnRIYW5kbGVyLCBlKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRleHBvcnQgZGVmYXVsdCB7XHJcblx0XHRvbmRlc3Ryb3koKSB7XHJcblx0XHRcdG9wZW5Gb3JtcyA9IG9wZW5Gb3Jtcy5maWx0ZXIoZiA9PiBmICE9PSB0aGlzKTtcclxuXHRcdH0sXHJcblx0XHRtZXRob2RzOiB7XHJcblx0XHRcdGFzeW5jIGluaXQoKSB7XHJcblx0XHRcdFx0aWYgKCF0aGlzLmdldCgpLmluaXRpYWxpemVkKSB7XHJcblx0XHRcdFx0XHRjb25zdCB7IGZvcm0gfSA9IHRoaXMuZ2V0KCk7XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5zZXQoe1xyXG5cdFx0XHRcdFx0XHRzZWxmOiB0aGlzLFxyXG5cdFx0XHRcdFx0XHRpbml0aWFsaXplZDogdHJ1ZSxcclxuXHRcdFx0XHRcdFx0dmlzaWJsZUlucHV0RmllbGRzOiBmb3JtLmlucHV0cy5maWx0ZXIodCA9PiB0Lm1ldGFkYXRhLmhpZGRlbiA9PT0gZmFsc2UpLFxyXG5cdFx0XHRcdFx0XHRzdWJtaXRCdXR0b25MYWJlbDogZm9ybS5tZXRhZGF0YS5nZXRDdXN0b21Qcm9wZXJ0eShcInN1Ym1pdEJ1dHRvbkxhYmVsXCIpIHx8IFwiU3VibWl0XCIsXHJcblx0XHRcdFx0XHRcdGNzc0NsYXNzOiBmb3JtLm1ldGFkYXRhLmdldEN1c3RvbVByb3BlcnR5KFwiY3NzQ2xhc3NcIikgfHwgXCJcIixcclxuXHRcdFx0XHRcdFx0aW5pdGlhbGx5SGlkZUZvcm06IGZvcm0ubWV0YWRhdGEuZ2V0Q3VzdG9tUHJvcGVydHkoXCJpbml0aWFsbHlIaWRlRm9ybVwiKSB8fCBudWxsLFxyXG5cdFx0XHRcdFx0XHRkb2N1bWVudGF0aW9uOiBmb3JtLm1ldGFkYXRhLmdldEN1c3RvbVByb3BlcnR5KFwiZG9jdW1lbnRhdGlvblwiKSxcclxuXHRcdFx0XHRcdFx0aGlkZUZvcm06IGZvcm0ubWV0YWRhdGEuZ2V0Q3VzdG9tUHJvcGVydHkoXCJpbml0aWFsbHlIaWRlRm9ybVwiKSAhPSBudWxsID8gXCJoaWRkZW5cIiA6IG51bGxcclxuXHRcdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0XHRcdHRhYmluZGV4ICs9IDE7XHJcblxyXG5cdFx0XHRcdFx0Y29uc3QgeyBhcHAgfSA9IHRoaXMuZ2V0KCk7XHJcblxyXG5cdFx0XHRcdFx0Ly8gU3Vic2NyaWJlIGFsbCBldmVudCBoYW5kbGVycyAoZm9ybSwgaW5wdXRzLCBvdXRwdXRzKS5cclxuXHRcdFx0XHRcdGNvbnN0IGZvcm1NZXRhZGF0YSA9IGZvcm0ubWV0YWRhdGE7XHJcblx0XHRcdFx0XHRjb25zdCBoYW5kbGVycyA9IFtdO1xyXG5cdFx0XHRcdFx0Zm9ybU1ldGFkYXRhLmlucHV0RmllbGRzLmZvckVhY2godCA9PiB0LmV2ZW50SGFuZGxlcnMuZm9yRWFjaChoID0+IGhhbmRsZXJzLnB1c2goaCkpKTtcclxuXHRcdFx0XHRcdGZvcm1NZXRhZGF0YS5vdXRwdXRGaWVsZHMuZm9yRWFjaCh0ID0+IHQuZXZlbnRIYW5kbGVycy5mb3JFYWNoKGggPT4gaGFuZGxlcnMucHVzaChoKSkpO1xyXG5cdFx0XHRcdFx0Zm9ybU1ldGFkYXRhLmV2ZW50SGFuZGxlcnMuZm9yRWFjaChoID0+IGhhbmRsZXJzLnB1c2goaCkpO1xyXG5cdFx0XHRcdFx0YmluZEV2ZW50SGFuZGxlcnNUb0N1c3RvbUV2ZW50cyh0aGlzLCBoYW5kbGVycyk7XHJcblxyXG5cdFx0XHRcdFx0Zm9ybS5maXJlKFwiZm9ybTpsb2FkZWRcIiwgeyBhcHAgfSk7XHJcblxyXG5cdFx0XHRcdFx0Ly8gQXV0by1zdWJtaXQgZm9ybSBpZiBuZWNlc3NhcnkuXHJcblx0XHRcdFx0XHRpZiAoZm9ybS5tZXRhZGF0YS5wb3N0T25Mb2FkKSB7XHJcblx0XHRcdFx0XHRcdGF3YWl0IHRoaXMuc3VibWl0KCk7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0b3BlbkZvcm1zLnB1c2godGhpcyk7XHJcblxyXG5cdFx0XHRcdFx0aWYgKHRoaXMuZ2V0KCkucGFyZW50ID09IG51bGwpIHtcclxuXHRcdFx0XHRcdFx0aWYgKHRoaXMuZ2V0KCkucmVzcG9uc2VNZXRhZGF0YS50aXRsZSA9PSBudWxsKSB7XHJcblx0XHRcdFx0XHRcdFx0ZG9jdW1lbnQudGl0bGUgPSBmb3JtLm1ldGFkYXRhLmxhYmVsO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9LFxyXG5cdFx0XHRmaXJlQW5kQnViYmxlVXAoZXZlbnROYW1lLCBldmVudEFyZ3MpIHtcclxuXHRcdFx0XHR0aGlzLmZpcmUoZXZlbnROYW1lLCBldmVudEFyZ3MpO1xyXG5cdFx0XHRcdGNvbnN0IHBhcmVudEZvcm1Db21wb25lbnQgPSB0aGlzLmdldCgpLnBhcmVudDtcclxuXHJcblx0XHRcdFx0aWYgKHBhcmVudEZvcm1Db21wb25lbnQgIT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0cGFyZW50Rm9ybUNvbXBvbmVudC5maXJlQW5kQnViYmxlVXAoZXZlbnROYW1lLCBldmVudEFyZ3MpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSxcclxuXHRcdFx0ZW5hYmxlRm9ybSgpIHtcclxuXHRcdFx0XHRjb25zdCBmb3JtSW5zdGFuY2UgPSB0aGlzLmdldCgpLmZvcm07XHJcblxyXG5cdFx0XHRcdC8vIEhpZGUgYWxsIGlucHV0cywgdG8gcmUtcmVuZGVyIHRoZW0uIFRoaXMgaXMgbmVlZGVkIGR1ZSB0byB0aGUgd2F5IHRoYXRcclxuXHRcdFx0XHQvLyBTdmVsdGUgKnNlZW1zKiB0byB3b3JrIC0gaXQgZG9lc24ndCByZS1yZW5kZXIgbmVzdGVkIGNvbXBvbmVudHMsIHVubGVzcyB0aGV5IGFyZSByZWNyZWF0ZWQuXHJcblx0XHRcdFx0dGhpcy5zZXQoeyB2aXNpYmxlSW5wdXRGaWVsZHM6IFtdIH0pO1xyXG5cclxuXHRcdFx0XHR0aGlzLnNldCh7XHJcblx0XHRcdFx0Ly8gU2hvdyBpbnB1dHMgYWdhaW4uXHJcblx0XHRcdFx0XHR2aXNpYmxlSW5wdXRGaWVsZHM6IGZvcm1JbnN0YW5jZS5pbnB1dHMuZmlsdGVyKHQgPT4gdC5tZXRhZGF0YS5oaWRkZW4gPT09IGZhbHNlKSxcclxuXHJcblx0XHRcdFx0XHRkaXNhYmxlZDogZmFsc2VcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fSxcclxuXHRcdFx0cmVuZGVyUmVzcG9uc2UocmVzcG9uc2UpIHtcclxuXHRcdFx0XHRjb25zdCBmb3JtSW5zdGFuY2UgPSB0aGlzLmdldCgpLmZvcm07XHJcblxyXG5cdFx0XHRcdC8vIEZvcmNlIFN2ZWx0ZSB0byByZS1yZW5kZXIgb3V0cHV0cy5cclxuXHRcdFx0XHR0aGlzLnNldCh7XHJcblx0XHRcdFx0XHRvdXRwdXRGaWVsZFZhbHVlczogbnVsbFxyXG5cdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0XHR0aGlzLnNldCh7XHJcblx0XHRcdFx0XHRvdXRwdXRGaWVsZFZhbHVlczogZm9ybUluc3RhbmNlLm91dHB1dHMsXHJcblx0XHRcdFx0XHRyZXNwb25zZU1ldGFkYXRhOiByZXNwb25zZS5tZXRhZGF0YVxyXG5cdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0XHRpZiAodGhpcy5nZXQoKS5wYXJlbnQgPT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0ZG9jdW1lbnQudGl0bGUgPSByZXNwb25zZS5tZXRhZGF0YS50aXRsZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0sXHJcblx0XHRcdGFzeW5jIHN1Ym1pdChldmVudCwgcmVkaXJlY3QpIHtcclxuXHRcdFx0XHQvLyBEaXNhYmxlIGRvdWJsZS1wb3N0cy5cclxuXHRcdFx0XHR0aGlzLnNldCh7IGRpc2FibGVkOiB0cnVlIH0pO1xyXG5cdFx0XHRcdGNvbnN0IHNlbGYgPSB0aGlzO1xyXG5cdFx0XHRcdGNvbnN0IHsgZm9ybTogZm9ybUluc3RhbmNlLCBhcHAgfSA9IHRoaXMuZ2V0KCk7XHJcblxyXG5cdFx0XHRcdGlmIChldmVudCAhPSBudWxsKSB7XHJcblx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gSWYgbm90IGFsbCByZXF1aXJlZCBpbnB1dHMgYXJlIGZpbGxlZC5cclxuXHRcdFx0XHRjb25zdCBhbGxSZXF1aXJlZElucHV0c0hhdmVWYWx1ZXMgPSBhd2FpdCBmb3JtSW5zdGFuY2UuYWxsUmVxdWlyZWRJbnB1dHNIYXZlRGF0YShyZWRpcmVjdCA9PSBudWxsKTtcclxuXHRcdFx0XHRpZiAoIWFsbFJlcXVpcmVkSW5wdXRzSGF2ZVZhbHVlcykge1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gSWYgcG9zdE9uTG9hZCA9PSB0cnVlLCB0aGVuIHRoZSBpbnB1dCBmaWVsZCB2YWx1ZXMgc2hvdWxkIGFwcGVhciBpbiB0aGUgdXJsLlxyXG5cdFx0XHRcdC8vIFJlYXNvbiBpcyB0aGF0IHBvc3RPbkxvYWQgPT0gdHJ1ZSBpcyB1c2VkIGJ5IFwicmVwb3J0XCIgcGFnZXMsIHdoaWNoIG5lZWRcclxuXHRcdFx0XHQvLyB0aGVpciBmaWx0ZXJzIHRvIGJlIHNhdmVkIGluIHRoZSB1cmwuIFRoaXMgZG9lcyBub3QgYXBwbHkgdG8gZm9ybXNcclxuXHRcdFx0XHQvLyB3aXRoIHBvc3RPbkxvYWQgPT0gZmFsc2UsIGJlY2F1c2UgdGhvc2UgZm9ybXMgYXJlIHVzdWFsbHkgZm9yIGNyZWF0aW5nIG5ldyBkYXRhXHJcblx0XHRcdFx0Ly8gYW5kIGhlbmNlIHNob3VsZCBub3QgYmUgdHJhY2tlZCBpbiBicm93c2VyJ3MgaGlzdG9yeSBiYXNlZCBvbiBwYXJhbWV0ZXJzLlxyXG5cclxuXHRcdFx0XHRjb25zdCBpc1JlZGlyZWN0Rm9ybSA9IGZvcm1JbnN0YW5jZS5tZXRhZGF0YS5pbnB1dEZpZWxkc1xyXG5cdFx0XHRcdFx0LmZpbHRlcih0ID0+IHQuZXZlbnRIYW5kbGVycy5zb21lKHIgPT4gci5pZCA9PT0gXCJiaW5kLXRvLW91dHB1dFwiKSkubGVuZ3RoID4gMDtcclxuXHRcclxuXHRcdFx0XHRpZiAoZm9ybUluc3RhbmNlLm1ldGFkYXRhLnBvc3RPbkxvYWQgJiYgcmVkaXJlY3QgJiYgdGhpcy5nZXQoKS51c2VVcmwgJiYgIWlzUmVkaXJlY3RGb3JtKSB7XHJcblx0XHRcdFx0XHRjb25zdCB1cmxQYXJhbXMgPSBhd2FpdCBmb3JtSW5zdGFuY2UuZ2V0U2VyaWFsaXplZElucHV0VmFsdWVzKCk7XHJcblxyXG5cdFx0XHRcdFx0Ly8gVXBkYXRlIHVybCBpbiB0aGUgYnJvd3Nlci5cclxuXHRcdFx0XHRcdGFwcC5nbyhmb3JtSW5zdGFuY2UubWV0YWRhdGEuaWQsIHVybFBhcmFtcyk7XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRcdGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZm9ybUluc3RhbmNlLnN1Ym1pdChhcHAsIHJlZGlyZWN0ID09IG51bGwsIHsgZm9ybUNvbXBvbmVudDogc2VsZiB9KTtcclxuXHRcdFx0XHRcdC8vIFNpZ25hbCBldmVudCB0byBjaGlsZCBjb250cm9scy5cclxuXHRcdFx0XHRcdHNlbGYuZmlyZShcImZvcm06cmVzcG9uc2VIYW5kbGVkXCIsIHtcclxuXHRcdFx0XHRcdFx0Zm9ybTogc2VsZixcclxuXHRcdFx0XHRcdFx0aW52b2tlZEJ5VXNlcjogZXZlbnQgIT0gbnVsbCxcclxuXHRcdFx0XHRcdFx0cmVzcG9uc2VcclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdFx0c2VsZi5lbmFibGVGb3JtKCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGNhdGNoIChlKSB7XHJcblx0XHRcdFx0XHRzZWxmLmVuYWJsZUZvcm0oKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0sXHJcblx0XHRcdHJlbG9hZFRvcEZvcm0oKSB7XHJcblx0XHRcdFx0Y29uc3QgcGFyZW50Rm9ybUNvbXBvbmVudCA9IHRoaXMuZ2V0KCkucGFyZW50O1xyXG5cclxuXHRcdFx0XHRpZiAocGFyZW50Rm9ybUNvbXBvbmVudCAhPSBudWxsKSB7XHJcblx0XHRcdFx0XHRwYXJlbnRGb3JtQ29tcG9uZW50LnJlbG9hZFRvcEZvcm0oKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHR0aGlzLnN1Ym1pdChudWxsLCB0cnVlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0sXHJcblx0XHRcdHJlbG9hZEFsbEZvcm1zKCkge1xyXG5cdFx0XHRcdGZvciAoY29uc3QgZiBvZiBvcGVuRm9ybXMpIHtcclxuXHRcdFx0XHRcdGYucmVsb2FkVG9wRm9ybSgpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSxcclxuXHRcdFx0dG9nZ2xlRm9ybSgpIHtcclxuXHRcdFx0XHRsZXQgaGlkZUZvcm0gPSB0aGlzLmdldChcImhpZGVGb3JtXCIpO1xyXG5cdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXHJcblx0XHRcdFx0aWYgKGhpZGVGb3JtLmhpZGVGb3JtID09IG51bGwpIHtcclxuXHRcdFx0XHRcdGhpZGVGb3JtID0gXCJoaWRkZW5cIjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHRoaWRlRm9ybSA9IG51bGw7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHRoaXMuc2V0KHtcclxuXHRcdFx0XHRcdGhpZGVGb3JtXHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH0sXHJcblx0XHRcdGdldElucHV0Q29tcG9uZW50KGlucHV0SWQpIHtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5nZXQoKS5pbnB1dHMgIT0gbnVsbCA/XHJcblx0XHRcdFx0XHR0aGlzLmdldCgpLmlucHV0cy5maW5kKHQgPT4gdC5nZXQoKS5maWVsZCAhPSBudWxsICYmIHQuZ2V0KCkuZmllbGQubWV0YWRhdGEuaWQgPT09IGlucHV0SWQpIDpcclxuXHRcdFx0XHRcdG51bGw7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRkYXRhKCkge1xyXG5cdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdGNzc0NsYXNzOiBudWxsLFxyXG5cdFx0XHRcdGRvY3VtZW50YXRpb246IG51bGwsXHJcblx0XHRcdFx0dmlzaWJsZUlucHV0RmllbGRzOiBudWxsLFxyXG5cdFx0XHRcdG91dHB1dEZpZWxkVmFsdWVzOiBudWxsLFxyXG5cdFx0XHRcdHN1Ym1pdEJ1dHRvbkxhYmVsOiBcIlN1Ym1pdFwiLFxyXG5cdFx0XHRcdGRpc2FibGVkOiBmYWxzZSxcclxuXHRcdFx0XHR0YWJpbmRleCxcclxuXHRcdFx0XHRzZWxmOiB0aGlzLFxyXG5cdFx0XHRcdHVybERhdGE6IG51bGwsXHJcblx0XHRcdFx0aW5pdGlhbGl6ZWQ6IGZhbHNlLFxyXG5cdFx0XHRcdHJlc3BvbnNlTWV0YWRhdGE6IHt9LFxyXG5cdFx0XHRcdHVzZVVybDogdHJ1ZSxcclxuXHRcdFx0XHRwYXJlbnQ6IG51bGwsIC8vIENhbiBiZSBzZXQgaWYgdGhpcyBpcyBhIG5lc3RlZCBmb3JtIHdpdGhpbiBhbm90aGVyIGZvcm0gKGkuZS4gLSBJbmxpbmVGb3JtLmh0bWwpXHJcblx0XHRcdFx0aW5wdXRzOiBbXVxyXG5cdFx0XHR9O1xyXG5cdFx0fSxcclxuXHRcdGNvbXBvbmVudHM6IHtcclxuXHRcdFx0Rm9ybUlucHV0LFxyXG5cdFx0XHRGb3JtT3V0cHV0LFxyXG5cdFx0XHRIZWxwXHJcblx0XHR9XHJcblx0fTtcclxuPC9zY3JpcHQ+XHJcblxyXG48c3R5bGU+XHJcblx0LnJlc3BvbnNlIHtcclxuXHRcdG1hcmdpbi10b3A6IDE1cHg7XHJcblx0XHRwYWRkaW5nLWxlZnQ6IDEwcHg7XHJcblx0XHRwYWRkaW5nLXJpZ2h0OiAxMHB4O1xyXG5cdH1cclxuXHJcblx0LmZvcm0taGVhZGVyIHtcclxuXHRcdHRleHQtYWxpZ246IGNlbnRlcjtcclxuXHRcdHBhZGRpbmctdG9wOiAyMHB4O1xyXG5cdFx0Ym9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICMxN2EyYjg7XHJcblx0XHRiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xyXG5cdFx0cG9zaXRpb246IHJlbGF0aXZlO1xyXG5cdH1cclxuXHJcblx0LmZvcm0taGVhZGVyIGgyIHtcclxuXHRcdGRpc3BsYXk6IGlubGluZS1ibG9jaztcclxuXHR9XHJcblxyXG5cdC5oZWxwLWNvbnRlbnQge1xyXG5cdFx0dGV4dC1hbGlnbjogbGVmdDtcclxuXHR9XHJcblxyXG5cdC5hbGVydCB7XHJcblx0XHRtYXJnaW46IDVweCA4cHg7XHJcblx0XHRwYWRkaW5nOiAxMHB4IDE1cHg7XHJcblx0XHRib3JkZXI6IDFweCBzb2xpZCAjYmJiO1xyXG5cdH1cclxuXHJcblx0LmFsZXJ0ID4gLmhlYWRpbmcge1xyXG5cdFx0Zm9udC13ZWlnaHQ6IGJvbGQ7XHJcblx0XHRmb250LXNpemU6IDE0cHg7XHJcblx0fVxyXG5cclxuXHQuYWxlcnQuc3VjY2VzcyB7XHJcblx0XHRiYWNrZ3JvdW5kOiAjZWJmZmY4O1xyXG5cdH1cclxuXHJcblx0LmFsZXJ0Lndhcm5pbmcge1xyXG5cdFx0YmFja2dyb3VuZDogI2ZkZmZlYjtcclxuXHR9XHJcblxyXG5cdC5hbGVydC5kYW5nZXIge1xyXG5cdFx0YmFja2dyb3VuZDogI2ZmZWFlYTtcclxuXHR9XHJcbjwvc3R5bGU+XHJcbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUEyUkMsU0FBUyxlQUFDLENBQUMsQUFDVixVQUFVLENBQUUsSUFBSSxDQUNoQixZQUFZLENBQUUsSUFBSSxDQUNsQixhQUFhLENBQUUsSUFBSSxBQUNwQixDQUFDLEFBRUQsWUFBWSxlQUFDLENBQUMsQUFDYixVQUFVLENBQUUsTUFBTSxDQUNsQixXQUFXLENBQUUsSUFBSSxDQUNqQixhQUFhLENBQUUsR0FBRyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQ2hDLGdCQUFnQixDQUFFLElBQUksQ0FDdEIsUUFBUSxDQUFFLFFBQVEsQUFDbkIsQ0FBQyxBQUVELDJCQUFZLENBQUMsRUFBRSxlQUFDLENBQUMsQUFDaEIsT0FBTyxDQUFFLFlBQVksQUFDdEIsQ0FBQyxBQUVELGFBQWEsZUFBQyxDQUFDLEFBQ2QsVUFBVSxDQUFFLElBQUksQUFDakIsQ0FBQyxBQUVELE1BQU0sZUFBQyxDQUFDLEFBQ1AsTUFBTSxDQUFFLEdBQUcsQ0FBQyxHQUFHLENBQ2YsT0FBTyxDQUFFLElBQUksQ0FBQyxJQUFJLENBQ2xCLE1BQU0sQ0FBRSxHQUFHLENBQUMsS0FBSyxDQUFDLElBQUksQUFDdkIsQ0FBQyxBQUVELHFCQUFNLENBQUcsUUFBUSxlQUFDLENBQUMsQUFDbEIsV0FBVyxDQUFFLElBQUksQ0FDakIsU0FBUyxDQUFFLElBQUksQUFDaEIsQ0FBQyxBQUVELE1BQU0sUUFBUSxlQUFDLENBQUMsQUFDZixVQUFVLENBQUUsT0FBTyxBQUNwQixDQUFDLEFBRUQsTUFBTSxRQUFRLGVBQUMsQ0FBQyxBQUNmLFVBQVUsQ0FBRSxPQUFPLEFBQ3BCLENBQUMsQUFFRCxNQUFNLE9BQU8sZUFBQyxDQUFDLEFBQ2QsVUFBVSxDQUFFLE9BQU8sQUFDcEIsQ0FBQyJ9 */";
    	append(document.head, style);
    }

    function get_each_context_2(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.outputField = list[i];
    	return child_ctx;
    }

    function get_each_context_1$1(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.inputField = list[i];
    	return child_ctx;
    }

    function get_each_context$3(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.document = list[i];
    	return child_ctx;
    }

    function create_main_fragment$8(component, ctx) {
    	var if_block_anchor;

    	var if_block = (ctx.initialized) && create_if_block$7(component, ctx);

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (ctx.initialized) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block$7(component, ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (if_block) if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (1:0) {#if initialized}
    function create_if_block$7(component, ctx) {
    	var div, text0, text1, div_class_value;

    	var if_block0 = ((ctx.responseMetadata.title != null && ctx.responseMetadata.title != "") || (ctx.metadata.label != null && ctx.metadata.label != "")) && create_if_block_5(component, ctx);

    	var if_block1 = (ctx.initialized && ctx.visibleInputFields.length > 0) && create_if_block_3$2(component, ctx);

    	var if_block2 = (ctx.outputFieldValues != null) && create_if_block_1$5(component, ctx);

    	return {
    		c: function create() {
    			div = createElement("div");
    			if (if_block0) if_block0.c();
    			text0 = createText("\r\n\r\n\t");
    			if (if_block1) if_block1.c();
    			text1 = createText("\r\n\r\n\t");
    			if (if_block2) if_block2.c();
    			div.className = div_class_value = "inputs-horizontal-one-column " + ctx.cssClass + " svelte-1rxxhm5";
    			addLoc(div, file$8, 1, 0, 19);
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append(div, text0);
    			if (if_block1) if_block1.m(div, null);
    			append(div, text1);
    			if (if_block2) if_block2.m(div, null);
    		},

    		p: function update(changed, ctx) {
    			if ((ctx.responseMetadata.title != null && ctx.responseMetadata.title != "") || (ctx.metadata.label != null && ctx.metadata.label != "")) {
    				if (if_block0) {
    					if_block0.p(changed, ctx);
    				} else {
    					if_block0 = create_if_block_5(component, ctx);
    					if_block0.c();
    					if_block0.m(div, text0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (ctx.initialized && ctx.visibleInputFields.length > 0) {
    				if (if_block1) {
    					if_block1.p(changed, ctx);
    				} else {
    					if_block1 = create_if_block_3$2(component, ctx);
    					if_block1.c();
    					if_block1.m(div, text1);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (ctx.outputFieldValues != null) {
    				if (if_block2) {
    					if_block2.p(changed, ctx);
    				} else {
    					if_block2 = create_if_block_1$5(component, ctx);
    					if_block2.c();
    					if_block2.m(div, null);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}

    			if ((changed.cssClass) && div_class_value !== (div_class_value = "inputs-horizontal-one-column " + ctx.cssClass + " svelte-1rxxhm5")) {
    				div.className = div_class_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(div);
    			}

    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    		}
    	};
    }

    // (3:2) {#if (responseMetadata.title != null && responseMetadata.title != "") || (metadata.label != null && metadata.label != "")}
    function create_if_block_5(component, ctx) {
    	var div, h2, text0_value = ctx.responseMetadata.title || ctx.metadata.label, text0, text1, text2;

    	var if_block0 = (ctx.responseMetadata.status) && create_if_block_7(component, ctx);

    	var if_block1 = (ctx.documentation) && create_if_block_6(component, ctx);

    	return {
    		c: function create() {
    			div = createElement("div");
    			h2 = createElement("h2");
    			text0 = createText(text0_value);
    			text1 = createText("\r\n\t\t");
    			if (if_block0) if_block0.c();
    			text2 = createText("\r\n\t\t");
    			if (if_block1) if_block1.c();
    			h2.className = "svelte-1rxxhm5";
    			addLoc(h2, file$8, 4, 2, 232);
    			div.className = "form-header svelte-1rxxhm5";
    			addLoc(div, file$8, 3, 3, 203);
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);
    			append(div, h2);
    			append(h2, text0);
    			append(div, text1);
    			if (if_block0) if_block0.m(div, null);
    			append(div, text2);
    			if (if_block1) if_block1.m(div, null);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.responseMetadata || changed.metadata) && text0_value !== (text0_value = ctx.responseMetadata.title || ctx.metadata.label)) {
    				setData(text0, text0_value);
    			}

    			if (ctx.responseMetadata.status) {
    				if (if_block0) {
    					if_block0.p(changed, ctx);
    				} else {
    					if_block0 = create_if_block_7(component, ctx);
    					if_block0.c();
    					if_block0.m(div, text2);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (ctx.documentation) {
    				if (if_block1) {
    					if_block1.p(changed, ctx);
    				} else {
    					if_block1 = create_if_block_6(component, ctx);
    					if_block1.c();
    					if_block1.m(div, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(div);
    			}

    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    		}
    	};
    }

    // (6:2) {#if responseMetadata.status}
    function create_if_block_7(component, ctx) {
    	var div, text, div_class_value;

    	var if_block0 = (ctx.responseMetadata.status.heading != null) && create_if_block_9(component, ctx);

    	var if_block1 = (ctx.responseMetadata.status.message != null) && create_if_block_8(component, ctx);

    	return {
    		c: function create() {
    			div = createElement("div");
    			if (if_block0) if_block0.c();
    			text = createText("\r\n\t\t\t");
    			if (if_block1) if_block1.c();
    			div.className = div_class_value = "alert " + ctx.responseMetadata.status.style + " svelte-1rxxhm5";
    			addLoc(div, file$8, 6, 2, 320);
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append(div, text);
    			if (if_block1) if_block1.m(div, null);
    		},

    		p: function update(changed, ctx) {
    			if (ctx.responseMetadata.status.heading != null) {
    				if (if_block0) {
    					if_block0.p(changed, ctx);
    				} else {
    					if_block0 = create_if_block_9(component, ctx);
    					if_block0.c();
    					if_block0.m(div, text);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (ctx.responseMetadata.status.message != null) {
    				if (if_block1) {
    					if_block1.p(changed, ctx);
    				} else {
    					if_block1 = create_if_block_8(component, ctx);
    					if_block1.c();
    					if_block1.m(div, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if ((changed.responseMetadata) && div_class_value !== (div_class_value = "alert " + ctx.responseMetadata.status.style + " svelte-1rxxhm5")) {
    				div.className = div_class_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(div);
    			}

    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    		}
    	};
    }

    // (8:3) {#if responseMetadata.status.heading != null}
    function create_if_block_9(component, ctx) {
    	var div, text0, text1_value = ctx.responseMetadata.status.heading, text1;

    	var if_block = (ctx.responseMetadata.status.icon != null) && create_if_block_10(component, ctx);

    	return {
    		c: function create() {
    			div = createElement("div");
    			if (if_block) if_block.c();
    			text0 = createText("\r\n\t\t\t\t");
    			text1 = createText(text1_value);
    			div.className = "heading svelte-1rxxhm5";
    			addLoc(div, file$8, 8, 3, 426);
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    			append(div, text0);
    			append(div, text1);
    		},

    		p: function update(changed, ctx) {
    			if (ctx.responseMetadata.status.icon != null) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block_10(component, ctx);
    					if_block.c();
    					if_block.m(div, text0);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if ((changed.responseMetadata) && text1_value !== (text1_value = ctx.responseMetadata.status.heading)) {
    				setData(text1, text1_value);
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(div);
    			}

    			if (if_block) if_block.d();
    		}
    	};
    }

    // (10:4) {#if responseMetadata.status.icon != null}
    function create_if_block_10(component, ctx) {
    	var span, raw_value = ctx.responseMetadata.status.icon;

    	return {
    		c: function create() {
    			span = createElement("span");
    			addLoc(span, file$8, 10, 5, 502);
    		},

    		m: function mount(target, anchor) {
    			insert(target, span, anchor);
    			span.innerHTML = raw_value;
    		},

    		p: function update(changed, ctx) {
    			if ((changed.responseMetadata) && raw_value !== (raw_value = ctx.responseMetadata.status.icon)) {
    				span.innerHTML = raw_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(span);
    			}
    		}
    	};
    }

    // (15:3) {#if responseMetadata.status.message != null}
    function create_if_block_8(component, ctx) {
    	var div, raw_value = ctx.responseMetadata.status.message;

    	return {
    		c: function create() {
    			div = createElement("div");
    			div.className = "body";
    			addLoc(div, file$8, 15, 3, 672);
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);
    			div.innerHTML = raw_value;
    		},

    		p: function update(changed, ctx) {
    			if ((changed.responseMetadata) && raw_value !== (raw_value = ctx.responseMetadata.status.message)) {
    				div.innerHTML = raw_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(div);
    			}
    		}
    	};
    }

    // (20:2) {#if documentation }
    function create_if_block_6(component, ctx) {
    	var each_anchor;

    	var each_value = ctx.documentation;

    	var each_blocks = [];

    	for (var i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block_2(component, get_each_context$3(ctx, each_value, i));
    	}

    	return {
    		c: function create() {
    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert(target, each_anchor, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (changed.documentation) {
    				each_value = ctx.documentation;

    				for (var i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$3(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    					} else {
    						each_blocks[i] = create_each_block_2(component, child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_anchor.parentNode, each_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}
    				each_blocks.length = each_value.length;
    			}
    		},

    		d: function destroy$$1(detach) {
    			destroyEach(each_blocks, detach);

    			if (detach) {
    				detachNode(each_anchor);
    			}
    		}
    	};
    }

    // (21:3) {#each documentation as document }
    function create_each_block_2(component, ctx) {

    	var help_initial_data = { data: ctx.document };
    	var help = new SvelteComponent$7({
    		root: component.root,
    		store: component.store,
    		data: help_initial_data
    	});

    	return {
    		c: function create() {
    			help._fragment.c();
    		},

    		m: function mount(target, anchor) {
    			help._mount(target, anchor);
    		},

    		p: function update(changed, ctx) {
    			var help_changes = {};
    			if (changed.documentation) help_changes.data = ctx.document;
    			help._set(help_changes);
    		},

    		d: function destroy$$1(detach) {
    			help.destroy(detach);
    		}
    	};
    }

    // (28:1) {#if initialized && visibleInputFields.length > 0}
    function create_if_block_3$2(component, ctx) {
    	var div1, text0, form, text1, div0, button;

    	var if_block = (ctx.initiallyHideForm) && create_if_block_4$1(component, ctx);

    	var each_value_1 = ctx.visibleInputFields;

    	var each_blocks = [];

    	for (var i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$1(component, get_each_context_1$1(ctx, each_value_1, i));
    	}

    	function submit_handler(event) {
    		component.submit(event, true);
    	}

    	return {
    		c: function create() {
    			div1 = createElement("div");
    			if (if_block) if_block.c();
    			text0 = createText("\r\n\t\t");
    			form = createElement("form");

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			text1 = createText("\r\n\t\t\t");
    			div0 = createElement("div");
    			button = createElement("button");
    			button.type = "submit";
    			button.disabled = ctx.disabled;
    			button.tabIndex = "-1";
    			button.className = "btn btn-default";
    			addLoc(button, file$8, 39, 4, 1405);
    			div0.className = "full-width";
    			addLoc(div0, file$8, 38, 3, 1375);
    			addListener(form, "submit", submit_handler);
    			form.className = "" + ctx.hideForm + " svelte-1rxxhm5";
    			addLoc(form, file$8, 34, 2, 1130);
    			div1.className = "form-body";
    			addLoc(div1, file$8, 28, 1, 954);
    		},

    		m: function mount(target, anchor) {
    			insert(target, div1, anchor);
    			if (if_block) if_block.m(div1, null);
    			append(div1, text0);
    			append(div1, form);

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(form, null);
    			}

    			append(form, text1);
    			append(form, div0);
    			append(div0, button);
    			button.innerHTML = ctx.submitButtonLabel;
    		},

    		p: function update(changed, ctx) {
    			if (ctx.initiallyHideForm) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block_4$1(component, ctx);
    					if_block.c();
    					if_block.m(div1, text0);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (changed.visibleInputFields || changed.app || changed.tabindex || changed.self) {
    				each_value_1 = ctx.visibleInputFields;

    				for (var i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$1(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    					} else {
    						each_blocks[i] = create_each_block_1$1(component, child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(form, text1);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}
    				each_blocks.length = each_value_1.length;
    			}

    			if (changed.submitButtonLabel) {
    				button.innerHTML = ctx.submitButtonLabel;
    			}

    			if (changed.disabled) {
    				button.disabled = ctx.disabled;
    			}

    			if (changed.hideForm) {
    				form.className = "" + ctx.hideForm + " svelte-1rxxhm5";
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(div1);
    			}

    			if (if_block) if_block.d();

    			destroyEach(each_blocks, detach);

    			removeListener(form, "submit", submit_handler);
    		}
    	};
    }

    // (30:2) {#if initiallyHideForm}
    function create_if_block_4$1(component, ctx) {
    	var div, span;

    	function click_handler(event) {
    		component.toggleForm();
    	}

    	return {
    		c: function create() {
    			div = createElement("div");
    			span = createElement("span");
    			addLoc(span, file$8, 31, 3, 1066);
    			addListener(div, "click", click_handler);
    			div.className = "hideForm-header";
    			addLoc(div, file$8, 30, 2, 1008);
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);
    			append(div, span);
    			span.innerHTML = ctx.initiallyHideForm;
    		},

    		p: function update(changed, ctx) {
    			if (changed.initiallyHideForm) {
    				span.innerHTML = ctx.initiallyHideForm;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(div);
    			}

    			removeListener(div, "click", click_handler);
    		}
    	};
    }

    // (36:3) {#each visibleInputFields as inputField}
    function create_each_block_1$1(component, ctx) {

    	var forminput_initial_data = {
    	 	field: ctx.inputField,
    	 	app: ctx.app,
    	 	tabindex: ctx.tabindex * 100 + ctx.inputField.metadata.orderIndex,
    	 	form: ctx.self
    	 };
    	var forminput = new SvelteComponent$5({
    		root: component.root,
    		store: component.store,
    		data: forminput_initial_data
    	});

    	return {
    		c: function create() {
    			forminput._fragment.c();
    		},

    		m: function mount(target, anchor) {
    			forminput._mount(target, anchor);
    		},

    		p: function update(changed, ctx) {
    			var forminput_changes = {};
    			if (changed.visibleInputFields) forminput_changes.field = ctx.inputField;
    			if (changed.app) forminput_changes.app = ctx.app;
    			if (changed.tabindex || changed.visibleInputFields) forminput_changes.tabindex = ctx.tabindex * 100 + ctx.inputField.metadata.orderIndex;
    			if (changed.self) forminput_changes.form = ctx.self;
    			forminput._set(forminput_changes);
    		},

    		d: function destroy$$1(detach) {
    			forminput.destroy(detach);
    		}
    	};
    }

    // (46:1) {#if outputFieldValues != null}
    function create_if_block_1$5(component, ctx) {
    	var div;

    	var each_value_2 = ctx.outputFieldValues;

    	var each_blocks = [];

    	for (var i = 0; i < each_value_2.length; i += 1) {
    		each_blocks[i] = create_each_block$3(component, get_each_context_2(ctx, each_value_2, i));
    	}

    	return {
    		c: function create() {
    			div = createElement("div");

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}
    			div.className = "response svelte-1rxxhm5";
    			addLoc(div, file$8, 46, 1, 1599);
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}
    		},

    		p: function update(changed, ctx) {
    			if (changed.outputFieldValues || changed.app || changed.form || changed.self) {
    				each_value_2 = ctx.outputFieldValues;

    				for (var i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2(ctx, each_value_2, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    					} else {
    						each_blocks[i] = create_each_block$3(component, child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}
    				each_blocks.length = each_value_2.length;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(div);
    			}

    			destroyEach(each_blocks, detach);
    		}
    	};
    }

    // (49:2) {#if outputField.metadata.hidden == false && !(outputField.metadata.getCustomProperty("hideIfNull") === true && outputField.data === null)}
    function create_if_block_2$3(component, ctx) {

    	var formoutput_initial_data = {
    	 	field: ctx.outputField,
    	 	app: ctx.app,
    	 	form: ctx.form,
    	 	parent: ctx.self
    	 };
    	var formoutput = new SvelteComponent$6({
    		root: component.root,
    		store: component.store,
    		data: formoutput_initial_data
    	});

    	return {
    		c: function create() {
    			formoutput._fragment.c();
    		},

    		m: function mount(target, anchor) {
    			formoutput._mount(target, anchor);
    		},

    		p: function update(changed, ctx) {
    			var formoutput_changes = {};
    			if (changed.outputFieldValues) formoutput_changes.field = ctx.outputField;
    			if (changed.app) formoutput_changes.app = ctx.app;
    			if (changed.form) formoutput_changes.form = ctx.form;
    			if (changed.self) formoutput_changes.parent = ctx.self;
    			formoutput._set(formoutput_changes);
    		},

    		d: function destroy$$1(detach) {
    			formoutput.destroy(detach);
    		}
    	};
    }

    // (48:2) {#each outputFieldValues as outputField }
    function create_each_block$3(component, ctx) {
    	var if_block_anchor;

    	var if_block = (ctx.outputField.metadata.hidden == false && !(ctx.outputField.metadata.getCustomProperty("hideIfNull") === true && ctx.outputField.data === null)) && create_if_block_2$3(component, ctx);

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (ctx.outputField.metadata.hidden == false && !(ctx.outputField.metadata.getCustomProperty("hideIfNull") === true && ctx.outputField.data === null)) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block_2$3(component, ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (if_block) if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    function SvelteComponent$8(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) {
    		throw new Error("'target' is a required option");
    	}

    	init(this, options);
    	this._state = assign(data$6(), options.data);
    	if (!('initialized' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'initialized'");
    	if (!('cssClass' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'cssClass'");
    	if (!('responseMetadata' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'responseMetadata'");
    	if (!('metadata' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'metadata'");
    	if (!('documentation' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'documentation'");
    	if (!('visibleInputFields' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'visibleInputFields'");
    	if (!('initiallyHideForm' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'initiallyHideForm'");
    	if (!('hideForm' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'hideForm'");
    	if (!('app' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'app'");
    	if (!('tabindex' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'tabindex'");
    	if (!('self' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'self'");
    	if (!('disabled' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'disabled'");
    	if (!('submitButtonLabel' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'submitButtonLabel'");
    	if (!('outputFieldValues' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'outputFieldValues'");
    	if (!('form' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'form'");
    	this._intro = true;

    	this._handlers.destroy = [ondestroy];

    	if (!document.getElementById("svelte-1rxxhm5-style")) add_css$4();

    	this._fragment = create_main_fragment$8(this, this._state);

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);

    		flush(this);
    	}
    }

    assign(SvelteComponent$8.prototype, protoDev);
    assign(SvelteComponent$8.prototype, methods$2);

    SvelteComponent$8.prototype._checkReadOnly = function _checkReadOnly(newState) {
    };

    var AppRouter = /** @class */ (function () {
        function AppRouter(element, app) {
            this.element = element;
            this.stateRenderer = svelteStateRenderer({});
            this.stateRouter = abstractStateRouter(this.stateRenderer, this.element);
            var rpb = this.rpb = new RouteParameterBuilder("_", app);
            this.stateRouter.addState({
                name: "home",
                route: "/home",
                template: SvelteComponent$3,
                resolve: function (data, parameters, cb) {
                    cb(false, {
                        app: app,
                        parent: SvelteComponent$8
                    });
                }
            });
            var self = this;
            this.stateRouter.addState({
                name: "menu",
                route: "/menu",
                template: SvelteComponent$2,
                resolve: function (data, parameters, cb) {
                    cb(false, {
                        forms: app.forms,
                        makeUrl: function (formId) { return self.makeUrl(formId, null); }
                    });
                }
            });
            this.stateRouter.addState({
                name: "form",
                data: {},
                route: "/form/:_id",
                template: SvelteComponent$8,
                // Force route reload when value of _d parameter changes. This is
                // needed because by default the router will not reload route even if
                // any of the parameters change, unless they are specified in "querystringParameters".
                // This means that if we are trying to reload same form, but with different parameters,
                // nothing will happen, unless _d changes too.
                querystringParameters: [rpb.parameterName],
                defaultParameters: rpb.defaultParameters,
                activate: function (context) {
                    context.domApi.init();
                    rpb.currentForm = context.parameters._id;
                    context.on("destroy", function () { return rpb.currentForm = null; });
                    self.fire("router:activated", null);
                },
                resolve: function (data, parameters, cb) {
                    var formInstance = app.getFormInstance(parameters._id, false);
                    if (formInstance == null) {
                        self.stateRouter.go("form", { _id: "login" });
                    }
                    else {
                        formInstance.initializeInputFields(parameters).then(function () {
                            cb(false, {
                                metadata: formInstance.metadata,
                                form: formInstance,
                                app: app
                            });
                        });
                    }
                }
            });
            if (app.getForm("login") != null) {
                this.stateRouter.evaluateCurrentRoute("form", { _id: "login" });
            }
            else {
                this.stateRouter.evaluateCurrentRoute("form", { _id: "dashboard" });
            }
        }
        AppRouter.prototype.fire = function (eventName, params) {
            var event = new Event(eventName, params);
            this.element.dispatchEvent(event);
        };
        AppRouter.prototype.on = function (eventName, fn) {
            this.element.addEventListener(eventName, function () {
                fn();
            });
        };
        AppRouter.prototype.go = function (form, values) {
            this.stateRouter.go("form", this.rpb.buildFormRouteParameters(form, values));
        };
        AppRouter.prototype.makeUrl = function (form, values) {
            return this.stateRouter.makePath("form", this.rpb.buildFormRouteParameters(form, values));
        };
        return AppRouter;
    }());

    var BooleanInputController = /** @class */ (function (_super) {
        __extends(BooleanInputController, _super);
        function BooleanInputController() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        BooleanInputController.prototype.serializeValue = function (value) {
            var parsed = this.parse(value);
            return parsed != null ? parsed.toString() : null;
        };
        BooleanInputController.prototype.init = function (value) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                _this.value = _this.parse(value);
                resolve(_this);
            });
        };
        BooleanInputController.prototype.getValue = function () {
            return Promise.resolve(this.parse(this.value));
        };
        BooleanInputController.prototype.parse = function (value) {
            return value != null && value.toString() !== ""
                ? value.toString() === "true"
                : this.metadata.required ? false : null;
        };
        return BooleanInputController;
    }(InputController));

    var DateInputController = /** @class */ (function (_super) {
        __extends(DateInputController, _super);
        function DateInputController() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.valueAsText = null;
            return _this;
        }
        DateInputController.prototype.init = function (value) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                _this.value = DateInputController.parseDate(value);
                _this.valueAsText = _this.serializeValue(_this.value);
                resolve(_this);
            });
        };
        DateInputController.prototype.getValue = function () {
            return Promise.resolve(this.value);
        };
        DateInputController.prototype.serializeValue = function (date) {
            return DateInputController.serialize(date);
        };
        DateInputController.serialize = function (date) {
            var asDate = typeof (date) === "string"
                ? DateInputController.parseDate(date)
                : date;
            return asDate != null
                ? asDate.getFullYear() + "-" + DateInputController.format2DecimalPlaces(asDate.getMonth() + 1) + "-" + DateInputController.format2DecimalPlaces(asDate.getDate())
                : null;
        };
        DateInputController.parseDate = function (value) {
            var selectedDate = this.asUtcTime(value, 7, 0, 0);
            if (selectedDate) {
                var dateAsNumber = Date.parse(selectedDate.toString());
                return isNaN(dateAsNumber) ? null : new Date(dateAsNumber);
            }
        };
        DateInputController.asUtcTime = function (date, hour, min, second) {
            /// <summary>Returns provided date as if it was UTC date.</summary>
            /// <param name="date">Local date/time.</param>
            /// <returns type="Date">Date object.</returns>
            if (date == null) {
                return null;
            }
            // If string but not UTC.
            if (typeof (date) === "string" && date[date.length - 1] !== "Z") {
                var year = parseInt(date.substr(0, 4), 10);
                var month = parseInt(date.substr(5, 2), 10);
                var day = parseInt(date.substr(8, 2), 10);
                // Assume UTC.
                return this.getIsoDate(year, month, day, hour, min, second);
            }
            var datepart = new Date(new Date(date).toISOString());
            return this.getIsoDate(datepart.getFullYear(), datepart.getMonth() + 1, datepart.getDate(), hour, min, second);
        };
        DateInputController.getIsoDate = function (year, month, day, hour, min, second) {
            var iso = year +
                "-" + // year
                this.format2DecimalPlaces(month) +
                "-" + // month
                this.format2DecimalPlaces(day) + // day
                "T" +
                this.format2DecimalPlaces(hour) +
                ":" +
                this.format2DecimalPlaces(min) +
                ":" +
                this.format2DecimalPlaces(second) +
                ".000Z";
            return new Date(iso);
        };
        DateInputController.format2DecimalPlaces = function (n) {
            return ("0" + n).slice(-2);
        };
        return DateInputController;
    }(InputController));

    var DateRangeInputController = /** @class */ (function (_super) {
        __extends(DateRangeInputController, _super);
        function DateRangeInputController() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.minValueAsText = null;
            _this.maxValueAsText = null;
            return _this;
        }
        DateRangeInputController.prototype.init = function (value) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                _this.value = _this.parse(value);
                if (_this.value != null && _this.value.min != null) {
                    _this.minValueAsText = DateInputController.serialize(_this.value.min);
                }
                if (_this.value != null && _this.value.max != null) {
                    _this.maxValueAsText = DateInputController.serialize(_this.value.max);
                }
                resolve(_this);
            });
        };
        DateRangeInputController.prototype.getValue = function () {
            return Promise.resolve(this.value);
        };
        DateRangeInputController.prototype.serializeValue = function (date) {
            var parsed = this.parse(date);
            return parsed != null ? parsed.serialize() : "";
        };
        DateRangeInputController.prototype.parse = function (value) {
            if (value == null) {
                return new DateRange();
            }
            return typeof (value) === "string"
                ? DateRange.parse(value)
                : value;
        };
        return DateRangeInputController;
    }(InputController));
    // tslint:disable-next-line:max-classes-per-file
    var DateRange = /** @class */ (function () {
        function DateRange(min, max) {
            if (min === void 0) { min = null; }
            if (max === void 0) { max = null; }
            this.min = min;
            this.max = max;
        }
        DateRange.parse = function (date) {
            var split = date.split("|");
            var minPart = DateInputController.parseDate(split[0]);
            var maxPart = DateInputController.parseDate(split[1]);
            return new DateRange(minPart, maxPart);
        };
        DateRange.prototype.serialize = function () {
            return DateInputController.serialize(this.min) + "|" + DateInputController.serialize(this.max);
        };
        return DateRange;
    }());

    var DropdownInputController = /** @class */ (function (_super) {
        __extends(DropdownInputController, _super);
        function DropdownInputController() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DropdownInputController.prototype.serializeValue = function (value) {
            if (typeof (value) === "string") {
                return value;
            }
            return value != null ? value.value : null;
        };
        DropdownInputController.prototype.init = function (value) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                _this.selected = value != null ? value.toString() : null;
                _this.value = _this.parse(value);
                resolve(_this);
            });
        };
        DropdownInputController.prototype.getValue = function () {
            return Promise.resolve(this.parse(this.selected));
        };
        DropdownInputController.prototype.initFromSelected = function () {
            this.value = this.parse(this.selected);
        };
        DropdownInputController.prototype.parse = function (value) {
            return value == null || value === "" ? null : { value: value };
        };
        return DropdownInputController;
    }(InputController));

    var EmailInputController = /** @class */ (function (_super) {
        __extends(EmailInputController, _super);
        function EmailInputController() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        EmailInputController.prototype.serializeValue = function (value) {
            if (typeof (value) === "string") {
                return value;
            }
            return value != null ? value.value : null;
        };
        EmailInputController.prototype.init = function (value) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                _this.selected = value;
                _this.value = _this.parse(value);
                resolve(_this);
            });
        };
        EmailInputController.prototype.getValue = function () {
            return Promise.resolve(this.parse(this.selected));
        };
        EmailInputController.prototype.parse = function (value) {
            return value == null || value === "" ? null : Email.parse(value);
        };
        return EmailInputController;
    }(InputController));
    // tslint:disable-next-line:max-classes-per-file
    var Email = /** @class */ (function () {
        function Email(value) {
            if (value === void 0) { value = null; }
            this.value = value;
        }
        Email.parse = function (value) {
            return new Email(value);
        };
        return Email;
    }());

    var axios$3 = axios$1;
    var FileUploaderController = /** @class */ (function (_super) {
        __extends(FileUploaderController, _super);
        function FileUploaderController() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.filesIds = [];
            return _this;
        }
        FileUploaderController.prototype.serializeValue = function (value) {
            return value != null ? JSON.stringify(value) : null;
        };
        FileUploaderController.prototype.init = function () {
            var _this = this;
            return new Promise(function (resolve, reject) {
                // Don't do anything. File uploader doesn't allow initialization
                // from pre-existing value.
                resolve(_this);
            });
        };
        FileUploaderController.prototype.getValue = function () {
            var self = this;
            if (self.selected == null ||
                self.selected.length === 0) {
                return Promise.resolve(new FileUploaderValue());
            }
            var promises = [];
            var result = new FileUploaderValue();
            var files = self.selected;
            if (self.filesIds.length > 0) {
                for (var _i = 0, _a = self.filesIds; _i < _a.length; _i++) {
                    var fileId = _a[_i];
                    result.files.push(fileId);
                }
                self.filesIds = [];
                self.selected = null;
            }
            else {
                var p = new Promise(function (resolve, reject) {
                    var formData = new FormData();
                    for (var _i = 0, files_1 = files; _i < files_1.length; _i++) {
                        var f = files_1[_i];
                        formData.append("file", f);
                    }
                    // Make http request to upload the files.
                    axios$3.post("/file/upload", formData, {
                        headers: {
                            "Content-Type": "multipart/form-data"
                        }
                    }).then(function (response) {
                        if (response.data.fileIds != null && response.data.fileIds.length > 0) {
                            for (var _i = 0, _a = response.data.fileIds; _i < _a.length; _i++) {
                                var fileId = _a[_i];
                                result.files.push(fileId);
                                self.filesIds.push(fileId);
                            }
                        }
                        resolve();
                    }).catch(function (error) {
                        alert(error.response.data.error);
                        reject(error);
                    });
                });
                promises.push(p);
            }
            return Promise.all(promises).then(function (t) {
                return result;
            });
        };
        return FileUploaderController;
    }(InputController));
    // tslint:disable-next-line:max-classes-per-file
    var FileUploaderValue = /** @class */ (function () {
        function FileUploaderValue() {
            this.files = [];
        }
        return FileUploaderValue;
    }());

    var MultiSelectInputController = /** @class */ (function (_super) {
        __extends(MultiSelectInputController, _super);
        function MultiSelectInputController() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.maxItemCount = -1;
            return _this;
        }
        MultiSelectInputController.prototype.serializeValue = function (value) {
            if (typeof (value) === "string") {
                return value;
            }
            return value != null ? (value.items || []).join(",") : null;
        };
        MultiSelectInputController.prototype.init = function (value) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                _this.value = _this.parse(value);
                resolve(_this);
            });
        };
        MultiSelectInputController.prototype.getValue = function () {
            var valueToSubmit = this.value == null || this.value.items == null || this.value.items.length === 0
                ? null
                : this.value;
            return Promise.resolve(valueToSubmit);
        };
        MultiSelectInputController.prototype.parse = function (value) {
            return value == null || value === ""
                ? new MultiSelectValue()
                : new MultiSelectValue(value.split(","));
        };
        return MultiSelectInputController;
    }(InputController));
    // tslint:disable-next-line:max-classes-per-file
    var MultiSelectValue = /** @class */ (function () {
        function MultiSelectValue(items) {
            this.items = [];
            this.items = items;
        }
        return MultiSelectValue;
    }());

    var NumberInputController = /** @class */ (function (_super) {
        __extends(NumberInputController, _super);
        function NumberInputController() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        NumberInputController.prototype.serializeValue = function (value) {
            return NumberInputController.serialize(value);
        };
        NumberInputController.prototype.init = function (value) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                var v = parseFloat(value);
                _this.value = isNaN(v) ? null : v;
                resolve(_this);
            });
        };
        NumberInputController.prototype.getValue = function () {
            return Promise.resolve(this.value);
        };
        NumberInputController.serialize = function (value) {
            return value != null ? value.toString() : null;
        };
        return NumberInputController;
    }(InputController));

    var NumberObjectInputController = /** @class */ (function (_super) {
        __extends(NumberObjectInputController, _super);
        function NumberObjectInputController() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        NumberObjectInputController.prototype.serializeValue = function (value) {
            if (typeof (value) === "number") {
                return value;
            }
            return value != null ? value.value : null;
        };
        NumberObjectInputController.prototype.init = function (value) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                _this.selected = value;
                _this.value = _this.parse(value);
                resolve(_this);
            });
        };
        NumberObjectInputController.prototype.getValue = function () {
            return Promise.resolve(this.parse(this.selected));
        };
        NumberObjectInputController.prototype.parse = function (value) {
            return value == null ? null : NumberObject.parse(value);
        };
        return NumberObjectInputController;
    }(InputController));
    // tslint:disable-next-line:max-classes-per-file
    var NumberObject = /** @class */ (function () {
        function NumberObject(value) {
            if (value === void 0) { value = null; }
            this.value = value;
        }
        NumberObject.parse = function (value) {
            return new NumberObject(value);
        };
        return NumberObject;
    }());

    var NumberRangeInputController = /** @class */ (function (_super) {
        __extends(NumberRangeInputController, _super);
        function NumberRangeInputController() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.min = null;
            _this.max = null;
            return _this;
        }
        NumberRangeInputController.prototype.init = function (value) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                _this.value = _this.parse(value);
                resolve(_this);
            });
        };
        NumberRangeInputController.prototype.getValue = function () {
            return Promise.resolve(this.value);
        };
        NumberRangeInputController.prototype.serializeValue = function (num) {
            var parsed = this.parse(num);
            return parsed != null ? parsed.serialize() : "";
        };
        NumberRangeInputController.prototype.parse = function (value) {
            if (value == null) {
                return new NumberRange();
            }
            return typeof (value) === "string"
                ? NumberRange.parse(value)
                : value;
        };
        return NumberRangeInputController;
    }(InputController));
    // tslint:disable-next-line:max-classes-per-file
    var NumberRange = /** @class */ (function () {
        function NumberRange(min, max) {
            if (min === void 0) { min = null; }
            if (max === void 0) { max = null; }
            this.min = min;
            this.max = max;
        }
        NumberRange.parse = function (range) {
            var split = range.split("|");
            var minValue = parseFloat(split[0]);
            var maxValue = parseFloat(split[1]);
            return new NumberRange(minValue, maxValue);
        };
        NumberRange.prototype.serialize = function () {
            return NumberInputController.serialize(this.min) + "|" + NumberInputController.serialize(this.max);
        };
        return NumberRange;
    }());

    var PaginationParameters = /** @class */ (function () {
        function PaginationParameters(pageIndex, pageSize, orderBy, ascending) {
            this.pageIndex = PaginationParameters.asInt(pageIndex, 1);
            this.pageSize = PaginationParameters.asInt(pageSize, 10);
            this.orderBy = orderBy || null;
            this.ascending = PaginationParameters.asBool(ascending, null);
        }
        PaginationParameters.asInt = function (value, defaultValue) {
            if (typeof (value) === "string") {
                var result = parseInt(value, 10);
                return isNaN(result) ? defaultValue : result;
            }
            if (value == null) {
                return defaultValue;
            }
            return value;
        };
        PaginationParameters.asBool = function (value, defaultValue) {
            if (typeof (value) === "string" || value == null) {
                return value != null
                    ? value.toString() === "true"
                    : defaultValue;
            }
            return value;
        };
        return PaginationParameters;
    }());
    // tslint:disable-next-line:max-classes-per-file
    var PaginatorInputController = /** @class */ (function (_super) {
        __extends(PaginatorInputController, _super);
        function PaginatorInputController() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        PaginatorInputController.prototype.serializeValue = function (value) {
            var p = typeof (value) === "string" || value == null
                ? this.parse(value)
                : value;
            if (p.pageIndex === 1 &&
                p.pageSize === 10 &&
                p.ascending == null &&
                p.orderBy == null) {
                return "";
            }
            var result = p.pageIndex + "-" + p.pageSize;
            if (p.orderBy != null) {
                result += "-" + p.orderBy + "-" + p.ascending + "}";
            }
            return result;
        };
        PaginatorInputController.prototype.init = function (value) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                _this.value = _this.parse(value);
                resolve(_this);
            });
        };
        PaginatorInputController.prototype.getValue = function () {
            return Promise.resolve(this.value);
        };
        PaginatorInputController.prototype.parse = function (value) {
            // 1-10-firstname-asc
            // 1-10
            if (value == null || value.length === 0) {
                return new PaginationParameters();
            }
            var components = value.split("-");
            return new PaginationParameters(components[0], components[1], components[2], components[3]);
        };
        return PaginatorInputController;
    }(InputController));

    var PasswordInputController = /** @class */ (function (_super) {
        __extends(PasswordInputController, _super);
        function PasswordInputController() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        PasswordInputController.prototype.serializeValue = function (value) {
            if (typeof (value) === "string") {
                return value;
            }
            return value != null ? value.value : null;
        };
        PasswordInputController.prototype.init = function (value) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                _this.selected = value;
                _this.value = _this.parse(value);
                resolve(_this);
            });
        };
        PasswordInputController.prototype.getValue = function () {
            return Promise.resolve(this.parse(this.selected));
        };
        PasswordInputController.prototype.parse = function (value) {
            return value == null || value === "" ? null : { value: value };
        };
        return PasswordInputController;
    }(InputController));

    var ReceiptListInputController = /** @class */ (function (_super) {
        __extends(ReceiptListInputController, _super);
        function ReceiptListInputController() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.entityId = null;
            _this.price = null;
            _this.quantity = null;
            return _this;
        }
        ReceiptListInputController.prototype.init = function (value) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                _this.value = _this.parse(value);
                resolve(_this);
            });
        };
        ReceiptListInputController.prototype.getValue = function () {
            return Promise.resolve(this.value);
        };
        ReceiptListInputController.prototype.serializeValue = function (list) {
            var parsed = this.parse(list);
            return parsed != null ? parsed.serialize() : "";
        };
        ReceiptListInputController.prototype.parse = function (value) {
            if (value == null) {
                return new ReceiptList();
            }
            return typeof (value) === "string"
                ? ReceiptList.parse(value)
                : value;
        };
        return ReceiptListInputController;
    }(InputController));
    // tslint:disable-next-line:max-classes-per-file
    var ReceiptList = /** @class */ (function () {
        function ReceiptList(entityId, quantity, price) {
            if (entityId === void 0) { entityId = null; }
            if (quantity === void 0) { quantity = null; }
            if (price === void 0) { price = null; }
            this.entityId = entityId;
            this.quantity = quantity;
            this.price = price;
        }
        ReceiptList.parse = function (list) {
            var split = list.split("|");
            var entityId = parseFloat(split[0]);
            var price = parseFloat(split[1]);
            var quantity = parseFloat(split[2]);
            return new ReceiptList(entityId, quantity, price);
        };
        ReceiptList.prototype.serialize = function () {
            return NumberInputController.serialize(this.entityId) + "|" + NumberInputController.serialize(this.price) + "|" + NumberInputController.serialize(this.quantity);
        };
        return ReceiptList;
    }());

    var TextareaInputController = /** @class */ (function (_super) {
        __extends(TextareaInputController, _super);
        function TextareaInputController() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        TextareaInputController.prototype.serializeValue = function (value) {
            if (typeof (value) === "string") {
                return value;
            }
            return value != null ? value.value : null;
        };
        TextareaInputController.prototype.init = function (value) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                _this.selected = value;
                _this.value = _this.parse(value);
                resolve(_this);
            });
        };
        TextareaInputController.prototype.getValue = function () {
            return Promise.resolve(this.parse(this.selected));
        };
        TextareaInputController.prototype.parse = function (value) {
            return value == null || value === "" || value === undefined ? null : { value: value };
        };
        return TextareaInputController;
    }(InputController));

    var TypeaheadInputController = /** @class */ (function (_super) {
        __extends(TypeaheadInputController, _super);
        function TypeaheadInputController() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.maxItemCount = 1;
            return _this;
        }
        TypeaheadInputController.prototype.serializeValue = function (value) {
            if (typeof (value) === "string") {
                return value;
            }
            return value != null ? value.value : null;
        };
        TypeaheadInputController.prototype.init = function (value) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                _this.value = _this.parse(value);
                resolve(_this);
            });
        };
        TypeaheadInputController.prototype.getValue = function () {
            var valueToSubmit = this.value == null || this.value.value == null
                ? null
                : this.value;
            return Promise.resolve(valueToSubmit);
        };
        TypeaheadInputController.prototype.parse = function (value) {
            return value == null || value === ""
                ? new TypeaheadValue()
                : new TypeaheadValue(value);
        };
        return TypeaheadInputController;
    }(InputController));
    // tslint:disable-next-line:max-classes-per-file
    var TypeaheadValue = /** @class */ (function () {
        function TypeaheadValue(value) {
            this.value = value;
        }
        return TypeaheadValue;
    }());

    /* src\core\ui\inputs\Boolean.html generated by Svelte v2.16.1 */

    var methods$3 = {
    	onChange() {
    		this.get().form.fireAndBubbleUp("input:changed", {
    			app: this.get().app,
    			form: this.get().form,
    			input: this
    		});
    	}
    };

    const file$9 = "src\\core\\ui\\inputs\\Boolean.html";

    function add_css$5() {
    	var style = createElement("style");
    	style.id = 'svelte-1h5tf6j-style';
    	style.textContent = ".checkbox.svelte-1h5tf6j{height:20px;width:20px;margin:0.6rem 0.5rem 1.1rem 0.5rem;overflow:initial;position:relative;clip:initial;-webkit-clip-path:initial;clip-path:initial;top:3px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQm9vbGVhbi5odG1sIiwic291cmNlcyI6WyJCb29sZWFuLmh0bWwiXSwic291cmNlc0NvbnRlbnQiOlsieyNpZiBmaWVsZC5tZXRhZGF0YS5yZXF1aXJlZH1cclxuPGlucHV0IHR5cGU9XCJjaGVja2JveFwiXHJcblx0aWQ9XCJ7aWR9XCJcclxuXHRjbGFzcz1cImNoZWNrYm94IGZvcm0tY29udHJvbFwiXHJcblx0YmluZDpjaGVja2VkPVwiZmllbGQudmFsdWVcIlxyXG5cdG9uOmNoYW5nZT1cIm9uQ2hhbmdlKClcIlxyXG5cdHRhYmluZGV4PVwie3RhYmluZGV4fVwiPlxyXG57OmVsc2V9XHJcbjxzZWxlY3QgYmluZDp2YWx1ZT1cImZpZWxkLnZhbHVlXCJcclxuXHRvbjpjaGFuZ2U9XCJvbkNoYW5nZSgpXCJcclxuXHRpZD1cIntpZH1cIlxyXG5cdGNsYXNzPVwiZm9ybS1jb250cm9sXCI+XHJcblx0PG9wdGlvbj48L29wdGlvbj5cclxuXHQ8b3B0aW9uIHZhbHVlPVwie3RydWV9XCI+WWVzPC9vcHRpb24+XHJcblx0PG9wdGlvbiB2YWx1ZT1cIntmYWxzZX1cIj5Obzwvb3B0aW9uPlxyXG48L3NlbGVjdD5cclxuey9pZn1cclxuXHJcbjxzY3JpcHQ+XHJcblx0ZXhwb3J0IGRlZmF1bHQge1xyXG5cdFx0bWV0aG9kczoge1xyXG5cdFx0XHRvbkNoYW5nZSgpIHtcclxuXHRcdFx0XHR0aGlzLmdldCgpLmZvcm0uZmlyZUFuZEJ1YmJsZVVwKFwiaW5wdXQ6Y2hhbmdlZFwiLCB7XHJcblx0XHRcdFx0XHRhcHA6IHRoaXMuZ2V0KCkuYXBwLFxyXG5cdFx0XHRcdFx0Zm9ybTogdGhpcy5nZXQoKS5mb3JtLFxyXG5cdFx0XHRcdFx0aW5wdXQ6IHRoaXNcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH07XHJcbjwvc2NyaXB0PlxyXG48c3R5bGU+XHJcblx0LmNoZWNrYm94IHtcclxuXHRcdGhlaWdodDogMjBweDtcclxuXHRcdHdpZHRoOiAyMHB4O1xyXG5cdFx0bWFyZ2luOiAwLjZyZW0gMC41cmVtIDEuMXJlbSAwLjVyZW07XHJcblx0XHRvdmVyZmxvdzogaW5pdGlhbDtcclxuXHRcdHBvc2l0aW9uOiByZWxhdGl2ZTtcclxuXHRcdGNsaXA6IGluaXRpYWw7XHJcblx0XHQtd2Via2l0LWNsaXAtcGF0aDogaW5pdGlhbDtcclxuXHRcdGNsaXAtcGF0aDogaW5pdGlhbDtcclxuXHRcdHRvcDogM3B4O1xyXG5cdH1cclxuPC9zdHlsZT5cclxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQWdDQyxTQUFTLGVBQUMsQ0FBQyxBQUNWLE1BQU0sQ0FBRSxJQUFJLENBQ1osS0FBSyxDQUFFLElBQUksQ0FDWCxNQUFNLENBQUUsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUNuQyxRQUFRLENBQUUsT0FBTyxDQUNqQixRQUFRLENBQUUsUUFBUSxDQUNsQixJQUFJLENBQUUsT0FBTyxDQUNiLGlCQUFpQixDQUFFLE9BQU8sQ0FDMUIsU0FBUyxDQUFFLE9BQU8sQ0FDbEIsR0FBRyxDQUFFLEdBQUcsQUFDVCxDQUFDIn0= */";
    	append(document.head, style);
    }

    function create_main_fragment$9(component, ctx) {
    	var if_block_anchor;

    	function select_block_type(ctx) {
    		if (ctx.field.metadata.required) return create_if_block$8;
    		return create_else_block$4;
    	}

    	var current_block_type = select_block_type(ctx);
    	var if_block = current_block_type(component, ctx);

    	return {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(changed, ctx);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(component, ctx);
    				if_block.c();
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},

    		d: function destroy$$1(detach) {
    			if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (8:0) {:else}
    function create_else_block$4(component, ctx) {
    	var select, option0, option1, option2, select_updating = false;

    	function select_change_handler() {
    		select_updating = true;
    		ctx.field.value = selectValue(select);
    		component.set({ field: ctx.field });
    		select_updating = false;
    	}

    	function change_handler(event) {
    		component.onChange();
    	}

    	return {
    		c: function create() {
    			select = createElement("select");
    			option0 = createElement("option");
    			option1 = createElement("option");
    			option1.textContent = "Yes";
    			option2 = createElement("option");
    			option2.textContent = "No";
    			option0.__value = "";
    			option0.value = option0.__value;
    			addLoc(option0, file$9, 12, 1, 283);
    			option1.__value = true;
    			option1.value = option1.__value;
    			addLoc(option1, file$9, 13, 1, 303);
    			option2.__value = false;
    			option2.value = option2.__value;
    			addLoc(option2, file$9, 14, 1, 341);
    			addListener(select, "change", select_change_handler);
    			if (!('field' in ctx)) component.root._beforecreate.push(select_change_handler);
    			addListener(select, "change", change_handler);
    			select.id = ctx.id;
    			select.className = "form-control";
    			addLoc(select, file$9, 8, 0, 187);
    		},

    		m: function mount(target, anchor) {
    			insert(target, select, anchor);
    			append(select, option0);
    			append(select, option1);
    			append(select, option2);

    			selectOption(select, ctx.field.value);
    		},

    		p: function update(changed, _ctx) {
    			ctx = _ctx;
    			if (!select_updating && changed.field) selectOption(select, ctx.field.value);
    			if (changed.id) {
    				select.id = ctx.id;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(select);
    			}

    			removeListener(select, "change", select_change_handler);
    			removeListener(select, "change", change_handler);
    		}
    	};
    }

    // (1:0) {#if field.metadata.required}
    function create_if_block$8(component, ctx) {
    	var input;

    	function input_change_handler() {
    		ctx.field.value = input.checked;
    		component.set({ field: ctx.field });
    	}

    	function change_handler(event) {
    		component.onChange();
    	}

    	return {
    		c: function create() {
    			input = createElement("input");
    			addListener(input, "change", input_change_handler);
    			addListener(input, "change", change_handler);
    			setAttribute(input, "type", "checkbox");
    			input.id = ctx.id;
    			input.className = "checkbox form-control svelte-1h5tf6j";
    			input.tabIndex = ctx.tabindex;
    			addLoc(input, file$9, 1, 0, 31);
    		},

    		m: function mount(target, anchor) {
    			insert(target, input, anchor);

    			input.checked = ctx.field.value;
    		},

    		p: function update(changed, _ctx) {
    			ctx = _ctx;
    			if (changed.field) input.checked = ctx.field.value;
    			if (changed.id) {
    				input.id = ctx.id;
    			}

    			if (changed.tabindex) {
    				input.tabIndex = ctx.tabindex;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(input);
    			}

    			removeListener(input, "change", input_change_handler);
    			removeListener(input, "change", change_handler);
    		}
    	};
    }

    function SvelteComponent$9(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) {
    		throw new Error("'target' is a required option");
    	}

    	init(this, options);
    	this._state = assign({}, options.data);
    	if (!('field' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'field'");
    	if (!('id' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'id'");
    	if (!('tabindex' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'tabindex'");
    	this._intro = true;

    	if (!document.getElementById("svelte-1h5tf6j-style")) add_css$5();

    	this._fragment = create_main_fragment$9(this, this._state);

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);

    		flush(this);
    	}
    }

    assign(SvelteComponent$9.prototype, protoDev);
    assign(SvelteComponent$9.prototype, methods$3);

    SvelteComponent$9.prototype._checkReadOnly = function _checkReadOnly(newState) {
    };

    //! moment.js
    //! version : 2.29.1
    //! authors : Tim Wood, Iskren Chernev, Moment.js contributors
    //! license : MIT
    //! momentjs.com

    var hookCallback;

    function hooks() {
        return hookCallback.apply(null, arguments);
    }

    // This is done to register the method called with moment()
    // without creating circular dependencies.
    function setHookCallback(callback) {
        hookCallback = callback;
    }

    function isArray$1(input) {
        return (
            input instanceof Array ||
            Object.prototype.toString.call(input) === '[object Array]'
        );
    }

    function isObject$1(input) {
        // IE8 will treat undefined and null as object if it wasn't for
        // input != null
        return (
            input != null &&
            Object.prototype.toString.call(input) === '[object Object]'
        );
    }

    function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
    }

    function isObjectEmpty(obj) {
        if (Object.getOwnPropertyNames) {
            return Object.getOwnPropertyNames(obj).length === 0;
        } else {
            var k;
            for (k in obj) {
                if (hasOwnProp(obj, k)) {
                    return false;
                }
            }
            return true;
        }
    }

    function isUndefined$1(input) {
        return input === void 0;
    }

    function isNumber$1(input) {
        return (
            typeof input === 'number' ||
            Object.prototype.toString.call(input) === '[object Number]'
        );
    }

    function isDate$1(input) {
        return (
            input instanceof Date ||
            Object.prototype.toString.call(input) === '[object Date]'
        );
    }

    function map(arr, fn) {
        var res = [],
            i;
        for (i = 0; i < arr.length; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }

    function extend$2(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }

        if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
        }

        if (hasOwnProp(b, 'valueOf')) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function createUTC(input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, true).utc();
    }

    function defaultParsingFlags() {
        // We need to deep clone this object.
        return {
            empty: false,
            unusedTokens: [],
            unusedInput: [],
            overflow: -2,
            charsLeftOver: 0,
            nullInput: false,
            invalidEra: null,
            invalidMonth: null,
            invalidFormat: false,
            userInvalidated: false,
            iso: false,
            parsedDateParts: [],
            era: null,
            meridiem: null,
            rfc2822: false,
            weekdayMismatch: false,
        };
    }

    function getParsingFlags(m) {
        if (m._pf == null) {
            m._pf = defaultParsingFlags();
        }
        return m._pf;
    }

    var some;
    if (Array.prototype.some) {
        some = Array.prototype.some;
    } else {
        some = function (fun) {
            var t = Object(this),
                len = t.length >>> 0,
                i;

            for (i = 0; i < len; i++) {
                if (i in t && fun.call(this, t[i], i, t)) {
                    return true;
                }
            }

            return false;
        };
    }

    function isValid(m) {
        if (m._isValid == null) {
            var flags = getParsingFlags(m),
                parsedParts = some.call(flags.parsedDateParts, function (i) {
                    return i != null;
                }),
                isNowValid =
                    !isNaN(m._d.getTime()) &&
                    flags.overflow < 0 &&
                    !flags.empty &&
                    !flags.invalidEra &&
                    !flags.invalidMonth &&
                    !flags.invalidWeekday &&
                    !flags.weekdayMismatch &&
                    !flags.nullInput &&
                    !flags.invalidFormat &&
                    !flags.userInvalidated &&
                    (!flags.meridiem || (flags.meridiem && parsedParts));

            if (m._strict) {
                isNowValid =
                    isNowValid &&
                    flags.charsLeftOver === 0 &&
                    flags.unusedTokens.length === 0 &&
                    flags.bigHour === undefined;
            }

            if (Object.isFrozen == null || !Object.isFrozen(m)) {
                m._isValid = isNowValid;
            } else {
                return isNowValid;
            }
        }
        return m._isValid;
    }

    function createInvalid(flags) {
        var m = createUTC(NaN);
        if (flags != null) {
            extend$2(getParsingFlags(m), flags);
        } else {
            getParsingFlags(m).userInvalidated = true;
        }

        return m;
    }

    // Plugins that add properties should also add the key here (null value),
    // so we can properly clone ourselves.
    var momentProperties = (hooks.momentProperties = []),
        updateInProgress = false;

    function copyConfig(to, from) {
        var i, prop, val;

        if (!isUndefined$1(from._isAMomentObject)) {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (!isUndefined$1(from._i)) {
            to._i = from._i;
        }
        if (!isUndefined$1(from._f)) {
            to._f = from._f;
        }
        if (!isUndefined$1(from._l)) {
            to._l = from._l;
        }
        if (!isUndefined$1(from._strict)) {
            to._strict = from._strict;
        }
        if (!isUndefined$1(from._tzm)) {
            to._tzm = from._tzm;
        }
        if (!isUndefined$1(from._isUTC)) {
            to._isUTC = from._isUTC;
        }
        if (!isUndefined$1(from._offset)) {
            to._offset = from._offset;
        }
        if (!isUndefined$1(from._pf)) {
            to._pf = getParsingFlags(from);
        }
        if (!isUndefined$1(from._locale)) {
            to._locale = from._locale;
        }

        if (momentProperties.length > 0) {
            for (i = 0; i < momentProperties.length; i++) {
                prop = momentProperties[i];
                val = from[prop];
                if (!isUndefined$1(val)) {
                    to[prop] = val;
                }
            }
        }

        return to;
    }

    // Moment prototype object
    function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        if (!this.isValid()) {
            this._d = new Date(NaN);
        }
        // Prevent infinite loop in case updateOffset creates new moment
        // objects.
        if (updateInProgress === false) {
            updateInProgress = true;
            hooks.updateOffset(this);
            updateInProgress = false;
        }
    }

    function isMoment(obj) {
        return (
            obj instanceof Moment || (obj != null && obj._isAMomentObject != null)
        );
    }

    function warn(msg) {
        if (
            hooks.suppressDeprecationWarnings === false &&
            typeof console !== 'undefined' &&
            console.warn
        ) {
            console.warn('Deprecation warning: ' + msg);
        }
    }

    function deprecate(msg, fn) {
        var firstTime = true;

        return extend$2(function () {
            if (hooks.deprecationHandler != null) {
                hooks.deprecationHandler(null, msg);
            }
            if (firstTime) {
                var args = [],
                    arg,
                    i,
                    key;
                for (i = 0; i < arguments.length; i++) {
                    arg = '';
                    if (typeof arguments[i] === 'object') {
                        arg += '\n[' + i + '] ';
                        for (key in arguments[0]) {
                            if (hasOwnProp(arguments[0], key)) {
                                arg += key + ': ' + arguments[0][key] + ', ';
                            }
                        }
                        arg = arg.slice(0, -2); // Remove trailing comma and space
                    } else {
                        arg = arguments[i];
                    }
                    args.push(arg);
                }
                warn(
                    msg +
                        '\nArguments: ' +
                        Array.prototype.slice.call(args).join('') +
                        '\n' +
                        new Error().stack
                );
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    var deprecations = {};

    function deprecateSimple(name, msg) {
        if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
        }
    }

    hooks.suppressDeprecationWarnings = false;
    hooks.deprecationHandler = null;

    function isFunction$2(input) {
        return (
            (typeof Function !== 'undefined' && input instanceof Function) ||
            Object.prototype.toString.call(input) === '[object Function]'
        );
    }

    function set$1(config) {
        var prop, i;
        for (i in config) {
            if (hasOwnProp(config, i)) {
                prop = config[i];
                if (isFunction$2(prop)) {
                    this[i] = prop;
                } else {
                    this['_' + i] = prop;
                }
            }
        }
        this._config = config;
        // Lenient ordinal parsing accepts just a number in addition to
        // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
        // TODO: Remove "ordinalParse" fallback in next major release.
        this._dayOfMonthOrdinalParseLenient = new RegExp(
            (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
                '|' +
                /\d{1,2}/.source
        );
    }

    function mergeConfigs(parentConfig, childConfig) {
        var res = extend$2({}, parentConfig),
            prop;
        for (prop in childConfig) {
            if (hasOwnProp(childConfig, prop)) {
                if (isObject$1(parentConfig[prop]) && isObject$1(childConfig[prop])) {
                    res[prop] = {};
                    extend$2(res[prop], parentConfig[prop]);
                    extend$2(res[prop], childConfig[prop]);
                } else if (childConfig[prop] != null) {
                    res[prop] = childConfig[prop];
                } else {
                    delete res[prop];
                }
            }
        }
        for (prop in parentConfig) {
            if (
                hasOwnProp(parentConfig, prop) &&
                !hasOwnProp(childConfig, prop) &&
                isObject$1(parentConfig[prop])
            ) {
                // make sure changes to properties don't modify parent config
                res[prop] = extend$2({}, res[prop]);
            }
        }
        return res;
    }

    function Locale(config) {
        if (config != null) {
            this.set(config);
        }
    }

    var keys;

    if (Object.keys) {
        keys = Object.keys;
    } else {
        keys = function (obj) {
            var i,
                res = [];
            for (i in obj) {
                if (hasOwnProp(obj, i)) {
                    res.push(i);
                }
            }
            return res;
        };
    }

    var defaultCalendar = {
        sameDay: '[Today at] LT',
        nextDay: '[Tomorrow at] LT',
        nextWeek: 'dddd [at] LT',
        lastDay: '[Yesterday at] LT',
        lastWeek: '[Last] dddd [at] LT',
        sameElse: 'L',
    };

    function calendar(key, mom, now) {
        var output = this._calendar[key] || this._calendar['sameElse'];
        return isFunction$2(output) ? output.call(mom, now) : output;
    }

    function zeroFill(number, targetLength, forceSign) {
        var absNumber = '' + Math.abs(number),
            zerosToFill = targetLength - absNumber.length,
            sign = number >= 0;
        return (
            (sign ? (forceSign ? '+' : '') : '-') +
            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) +
            absNumber
        );
    }

    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,
        localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,
        formatFunctions = {},
        formatTokenFunctions = {};

    // token:    'M'
    // padded:   ['MM', 2]
    // ordinal:  'Mo'
    // callback: function () { this.month() + 1 }
    function addFormatToken(token, padded, ordinal, callback) {
        var func = callback;
        if (typeof callback === 'string') {
            func = function () {
                return this[callback]();
            };
        }
        if (token) {
            formatTokenFunctions[token] = func;
        }
        if (padded) {
            formatTokenFunctions[padded[0]] = function () {
                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
        }
        if (ordinal) {
            formatTokenFunctions[ordinal] = function () {
                return this.localeData().ordinal(
                    func.apply(this, arguments),
                    token
                );
            };
        }
    }

    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens),
            i,
            length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = '',
                i;
            for (i = 0; i < length; i++) {
                output += isFunction$2(array[i])
                    ? array[i].call(mom, format)
                    : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }

        format = expandFormat(format, m.localeData());
        formatFunctions[format] =
            formatFunctions[format] || makeFormatFunction(format);

        return formatFunctions[format](m);
    }

    function expandFormat(format, locale) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(
                localFormattingTokens,
                replaceLongDateFormatTokens
            );
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }

    var defaultLongDateFormat = {
        LTS: 'h:mm:ss A',
        LT: 'h:mm A',
        L: 'MM/DD/YYYY',
        LL: 'MMMM D, YYYY',
        LLL: 'MMMM D, YYYY h:mm A',
        LLLL: 'dddd, MMMM D, YYYY h:mm A',
    };

    function longDateFormat(key) {
        var format = this._longDateFormat[key],
            formatUpper = this._longDateFormat[key.toUpperCase()];

        if (format || !formatUpper) {
            return format;
        }

        this._longDateFormat[key] = formatUpper
            .match(formattingTokens)
            .map(function (tok) {
                if (
                    tok === 'MMMM' ||
                    tok === 'MM' ||
                    tok === 'DD' ||
                    tok === 'dddd'
                ) {
                    return tok.slice(1);
                }
                return tok;
            })
            .join('');

        return this._longDateFormat[key];
    }

    var defaultInvalidDate = 'Invalid date';

    function invalidDate() {
        return this._invalidDate;
    }

    var defaultOrdinal = '%d',
        defaultDayOfMonthOrdinalParse = /\d{1,2}/;

    function ordinal(number) {
        return this._ordinal.replace('%d', number);
    }

    var defaultRelativeTime = {
        future: 'in %s',
        past: '%s ago',
        s: 'a few seconds',
        ss: '%d seconds',
        m: 'a minute',
        mm: '%d minutes',
        h: 'an hour',
        hh: '%d hours',
        d: 'a day',
        dd: '%d days',
        w: 'a week',
        ww: '%d weeks',
        M: 'a month',
        MM: '%d months',
        y: 'a year',
        yy: '%d years',
    };

    function relativeTime(number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return isFunction$2(output)
            ? output(number, withoutSuffix, string, isFuture)
            : output.replace(/%d/i, number);
    }

    function pastFuture(diff, output) {
        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
        return isFunction$2(format) ? format(output) : format.replace(/%s/i, output);
    }

    var aliases = {};

    function addUnitAlias(unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
    }

    function normalizeUnits(units) {
        return typeof units === 'string'
            ? aliases[units] || aliases[units.toLowerCase()]
            : undefined;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    var priorities = {};

    function addUnitPriority(unit, priority) {
        priorities[unit] = priority;
    }

    function getPrioritizedUnits(unitsObj) {
        var units = [],
            u;
        for (u in unitsObj) {
            if (hasOwnProp(unitsObj, u)) {
                units.push({ unit: u, priority: priorities[u] });
            }
        }
        units.sort(function (a, b) {
            return a.priority - b.priority;
        });
        return units;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    function absFloor(number) {
        if (number < 0) {
            // -0 -> 0
            return Math.ceil(number) || 0;
        } else {
            return Math.floor(number);
        }
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
        }

        return value;
    }

    function makeGetSet(unit, keepTime) {
        return function (value) {
            if (value != null) {
                set$1$1(this, unit, value);
                hooks.updateOffset(this, keepTime);
                return this;
            } else {
                return get$2(this, unit);
            }
        };
    }

    function get$2(mom, unit) {
        return mom.isValid()
            ? mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]()
            : NaN;
    }

    function set$1$1(mom, unit, value) {
        if (mom.isValid() && !isNaN(value)) {
            if (
                unit === 'FullYear' &&
                isLeapYear(mom.year()) &&
                mom.month() === 1 &&
                mom.date() === 29
            ) {
                value = toInt(value);
                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](
                    value,
                    mom.month(),
                    daysInMonth(value, mom.month())
                );
            } else {
                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
            }
        }
    }

    // MOMENTS

    function stringGet(units) {
        units = normalizeUnits(units);
        if (isFunction$2(this[units])) {
            return this[units]();
        }
        return this;
    }

    function stringSet(units, value) {
        if (typeof units === 'object') {
            units = normalizeObjectUnits(units);
            var prioritized = getPrioritizedUnits(units),
                i;
            for (i = 0; i < prioritized.length; i++) {
                this[prioritized[i].unit](units[prioritized[i].unit]);
            }
        } else {
            units = normalizeUnits(units);
            if (isFunction$2(this[units])) {
                return this[units](value);
            }
        }
        return this;
    }

    var match1 = /\d/, //       0 - 9
        match2 = /\d\d/, //      00 - 99
        match3 = /\d{3}/, //     000 - 999
        match4 = /\d{4}/, //    0000 - 9999
        match6 = /[+-]?\d{6}/, // -999999 - 999999
        match1to2 = /\d\d?/, //       0 - 99
        match3to4 = /\d\d\d\d?/, //     999 - 9999
        match5to6 = /\d\d\d\d\d\d?/, //   99999 - 999999
        match1to3 = /\d{1,3}/, //       0 - 999
        match1to4 = /\d{1,4}/, //       0 - 9999
        match1to6 = /[+-]?\d{1,6}/, // -999999 - 999999
        matchUnsigned = /\d+/, //       0 - inf
        matchSigned = /[+-]?\d+/, //    -inf - inf
        matchOffset = /Z|[+-]\d\d:?\d\d/gi, // +00:00 -00:00 +0000 -0000 or Z
        matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, // +00 -00 +00:00 -00:00 +0000 -0000 or Z
        matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, // 123456789 123456789.123
        // any word (or two) characters or numbers including two/three word month in arabic.
        // includes scottish gaelic two word and hyphenated months
        matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i,
        regexes;

    regexes = {};

    function addRegexToken(token, regex, strictRegex) {
        regexes[token] = isFunction$2(regex)
            ? regex
            : function (isStrict, localeData) {
                  return isStrict && strictRegex ? strictRegex : regex;
              };
    }

    function getParseRegexForToken(token, config) {
        if (!hasOwnProp(regexes, token)) {
            return new RegExp(unescapeFormat(token));
        }

        return regexes[token](config._strict, config._locale);
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function unescapeFormat(s) {
        return regexEscape(
            s
                .replace('\\', '')
                .replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (
                    matched,
                    p1,
                    p2,
                    p3,
                    p4
                ) {
                    return p1 || p2 || p3 || p4;
                })
        );
    }

    function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    var tokens = {};

    function addParseToken(token, callback) {
        var i,
            func = callback;
        if (typeof token === 'string') {
            token = [token];
        }
        if (isNumber$1(callback)) {
            func = function (input, array) {
                array[callback] = toInt(input);
            };
        }
        for (i = 0; i < token.length; i++) {
            tokens[token[i]] = func;
        }
    }

    function addWeekParseToken(token, callback) {
        addParseToken(token, function (input, array, config, token) {
            config._w = config._w || {};
            callback(input, config._w, config, token);
        });
    }

    function addTimeToArrayFromToken(token, input, config) {
        if (input != null && hasOwnProp(tokens, token)) {
            tokens[token](input, config._a, config, token);
        }
    }

    var YEAR = 0,
        MONTH = 1,
        DATE = 2,
        HOUR = 3,
        MINUTE = 4,
        SECOND = 5,
        MILLISECOND = 6,
        WEEK = 7,
        WEEKDAY = 8;

    function mod(n, x) {
        return ((n % x) + x) % x;
    }

    var indexOf;

    if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
    } else {
        indexOf = function (o) {
            // I know
            var i;
            for (i = 0; i < this.length; ++i) {
                if (this[i] === o) {
                    return i;
                }
            }
            return -1;
        };
    }

    function daysInMonth(year, month) {
        if (isNaN(year) || isNaN(month)) {
            return NaN;
        }
        var modMonth = mod(month, 12);
        year += (month - modMonth) / 12;
        return modMonth === 1
            ? isLeapYear(year)
                ? 29
                : 28
            : 31 - ((modMonth % 7) % 2);
    }

    // FORMATTING

    addFormatToken('M', ['MM', 2], 'Mo', function () {
        return this.month() + 1;
    });

    addFormatToken('MMM', 0, 0, function (format) {
        return this.localeData().monthsShort(this, format);
    });

    addFormatToken('MMMM', 0, 0, function (format) {
        return this.localeData().months(this, format);
    });

    // ALIASES

    addUnitAlias('month', 'M');

    // PRIORITY

    addUnitPriority('month', 8);

    // PARSING

    addRegexToken('M', match1to2);
    addRegexToken('MM', match1to2, match2);
    addRegexToken('MMM', function (isStrict, locale) {
        return locale.monthsShortRegex(isStrict);
    });
    addRegexToken('MMMM', function (isStrict, locale) {
        return locale.monthsRegex(isStrict);
    });

    addParseToken(['M', 'MM'], function (input, array) {
        array[MONTH] = toInt(input) - 1;
    });

    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        // if we didn't find a month name, mark the date as invalid.
        if (month != null) {
            array[MONTH] = month;
        } else {
            getParsingFlags(config).invalidMonth = input;
        }
    });

    // LOCALES

    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split(
            '_'
        ),
        defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split(
            '_'
        ),
        MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,
        defaultMonthsShortRegex = matchWord,
        defaultMonthsRegex = matchWord;

    function localeMonths(m, format) {
        if (!m) {
            return isArray$1(this._months)
                ? this._months
                : this._months['standalone'];
        }
        return isArray$1(this._months)
            ? this._months[m.month()]
            : this._months[
                  (this._months.isFormat || MONTHS_IN_FORMAT).test(format)
                      ? 'format'
                      : 'standalone'
              ][m.month()];
    }

    function localeMonthsShort(m, format) {
        if (!m) {
            return isArray$1(this._monthsShort)
                ? this._monthsShort
                : this._monthsShort['standalone'];
        }
        return isArray$1(this._monthsShort)
            ? this._monthsShort[m.month()]
            : this._monthsShort[
                  MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'
              ][m.month()];
    }

    function handleStrictParse(monthName, format, strict) {
        var i,
            ii,
            mom,
            llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
            // this is not used
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
            for (i = 0; i < 12; ++i) {
                mom = createUTC([2000, i]);
                this._shortMonthsParse[i] = this.monthsShort(
                    mom,
                    ''
                ).toLocaleLowerCase();
                this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeMonthsParse(monthName, format, strict) {
        var i, mom, regex;

        if (this._monthsParseExact) {
            return handleStrictParse.call(this, monthName, format, strict);
        }

        if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
        }

        // TODO: add sorting
        // Sorting makes sure if one month (or abbr) is a prefix of another
        // see sorting in computeMonthsParse
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, i]);
            if (strict && !this._longMonthsParse[i]) {
                this._longMonthsParse[i] = new RegExp(
                    '^' + this.months(mom, '').replace('.', '') + '$',
                    'i'
                );
                this._shortMonthsParse[i] = new RegExp(
                    '^' + this.monthsShort(mom, '').replace('.', '') + '$',
                    'i'
                );
            }
            if (!strict && !this._monthsParse[i]) {
                regex =
                    '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (
                strict &&
                format === 'MMMM' &&
                this._longMonthsParse[i].test(monthName)
            ) {
                return i;
            } else if (
                strict &&
                format === 'MMM' &&
                this._shortMonthsParse[i].test(monthName)
            ) {
                return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function setMonth(mom, value) {
        var dayOfMonth;

        if (!mom.isValid()) {
            // No op
            return mom;
        }

        if (typeof value === 'string') {
            if (/^\d+$/.test(value)) {
                value = toInt(value);
            } else {
                value = mom.localeData().monthsParse(value);
                // TODO: Another silent failure?
                if (!isNumber$1(value)) {
                    return mom;
                }
            }
        }

        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }

    function getSetMonth(value) {
        if (value != null) {
            setMonth(this, value);
            hooks.updateOffset(this, true);
            return this;
        } else {
            return get$2(this, 'Month');
        }
    }

    function getDaysInMonth() {
        return daysInMonth(this.year(), this.month());
    }

    function monthsShortRegex(isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsShortStrictRegex;
            } else {
                return this._monthsShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsShortRegex')) {
                this._monthsShortRegex = defaultMonthsShortRegex;
            }
            return this._monthsShortStrictRegex && isStrict
                ? this._monthsShortStrictRegex
                : this._monthsShortRegex;
        }
    }

    function monthsRegex(isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsStrictRegex;
            } else {
                return this._monthsRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsRegex')) {
                this._monthsRegex = defaultMonthsRegex;
            }
            return this._monthsStrictRegex && isStrict
                ? this._monthsStrictRegex
                : this._monthsRegex;
        }
    }

    function computeMonthsParse() {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var shortPieces = [],
            longPieces = [],
            mixedPieces = [],
            i,
            mom;
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, i]);
            shortPieces.push(this.monthsShort(mom, ''));
            longPieces.push(this.months(mom, ''));
            mixedPieces.push(this.months(mom, ''));
            mixedPieces.push(this.monthsShort(mom, ''));
        }
        // Sorting makes sure if one month (or abbr) is a prefix of another it
        // will match the longer piece.
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 12; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
        }
        for (i = 0; i < 24; i++) {
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp(
            '^(' + longPieces.join('|') + ')',
            'i'
        );
        this._monthsShortStrictRegex = new RegExp(
            '^(' + shortPieces.join('|') + ')',
            'i'
        );
    }

    // FORMATTING

    addFormatToken('Y', 0, 0, function () {
        var y = this.year();
        return y <= 9999 ? zeroFill(y, 4) : '+' + y;
    });

    addFormatToken(0, ['YY', 2], 0, function () {
        return this.year() % 100;
    });

    addFormatToken(0, ['YYYY', 4], 0, 'year');
    addFormatToken(0, ['YYYYY', 5], 0, 'year');
    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

    // ALIASES

    addUnitAlias('year', 'y');

    // PRIORITIES

    addUnitPriority('year', 1);

    // PARSING

    addRegexToken('Y', matchSigned);
    addRegexToken('YY', match1to2, match2);
    addRegexToken('YYYY', match1to4, match4);
    addRegexToken('YYYYY', match1to6, match6);
    addRegexToken('YYYYYY', match1to6, match6);

    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
    addParseToken('YYYY', function (input, array) {
        array[YEAR] =
            input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken('YY', function (input, array) {
        array[YEAR] = hooks.parseTwoDigitYear(input);
    });
    addParseToken('Y', function (input, array) {
        array[YEAR] = parseInt(input, 10);
    });

    // HELPERS

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    // HOOKS

    hooks.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };

    // MOMENTS

    var getSetYear = makeGetSet('FullYear', true);

    function getIsLeapYear() {
        return isLeapYear(this.year());
    }

    function createDate(y, m, d, h, M, s, ms) {
        // can't just apply() to create a date:
        // https://stackoverflow.com/q/181348
        var date;
        // the date constructor remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            date = new Date(y + 400, m, d, h, M, s, ms);
            if (isFinite(date.getFullYear())) {
                date.setFullYear(y);
            }
        } else {
            date = new Date(y, m, d, h, M, s, ms);
        }

        return date;
    }

    function createUTCDate(y) {
        var date, args;
        // the Date.UTC function remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            args = Array.prototype.slice.call(arguments);
            // preserve leap years using a full 400 year cycle, then reset
            args[0] = y + 400;
            date = new Date(Date.UTC.apply(null, args));
            if (isFinite(date.getUTCFullYear())) {
                date.setUTCFullYear(y);
            }
        } else {
            date = new Date(Date.UTC.apply(null, arguments));
        }

        return date;
    }

    // start-of-first-week - start-of-year
    function firstWeekOffset(year, dow, doy) {
        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
            fwd = 7 + dow - doy,
            // first-week day local weekday -- which local weekday is fwd
            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

        return -fwdlw + fwd - 1;
    }

    // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7,
            weekOffset = firstWeekOffset(year, dow, doy),
            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
            resYear,
            resDayOfYear;

        if (dayOfYear <= 0) {
            resYear = year - 1;
            resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
            resYear = year + 1;
            resDayOfYear = dayOfYear - daysInYear(year);
        } else {
            resYear = year;
            resDayOfYear = dayOfYear;
        }

        return {
            year: resYear,
            dayOfYear: resDayOfYear,
        };
    }

    function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy),
            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
            resWeek,
            resYear;

        if (week < 1) {
            resYear = mom.year() - 1;
            resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
            resWeek = week - weeksInYear(mom.year(), dow, doy);
            resYear = mom.year() + 1;
        } else {
            resYear = mom.year();
            resWeek = week;
        }

        return {
            week: resWeek,
            year: resYear,
        };
    }

    function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy),
            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    }

    // FORMATTING

    addFormatToken('w', ['ww', 2], 'wo', 'week');
    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

    // ALIASES

    addUnitAlias('week', 'w');
    addUnitAlias('isoWeek', 'W');

    // PRIORITIES

    addUnitPriority('week', 5);
    addUnitPriority('isoWeek', 5);

    // PARSING

    addRegexToken('w', match1to2);
    addRegexToken('ww', match1to2, match2);
    addRegexToken('W', match1to2);
    addRegexToken('WW', match1to2, match2);

    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (
        input,
        week,
        config,
        token
    ) {
        week[token.substr(0, 1)] = toInt(input);
    });

    // HELPERS

    // LOCALES

    function localeWeek(mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }

    var defaultLocaleWeek = {
        dow: 0, // Sunday is the first day of the week.
        doy: 6, // The week that contains Jan 6th is the first week of the year.
    };

    function localeFirstDayOfWeek() {
        return this._week.dow;
    }

    function localeFirstDayOfYear() {
        return this._week.doy;
    }

    // MOMENTS

    function getSetWeek(input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    function getSetISOWeek(input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    // FORMATTING

    addFormatToken('d', 0, 'do', 'day');

    addFormatToken('dd', 0, 0, function (format) {
        return this.localeData().weekdaysMin(this, format);
    });

    addFormatToken('ddd', 0, 0, function (format) {
        return this.localeData().weekdaysShort(this, format);
    });

    addFormatToken('dddd', 0, 0, function (format) {
        return this.localeData().weekdays(this, format);
    });

    addFormatToken('e', 0, 0, 'weekday');
    addFormatToken('E', 0, 0, 'isoWeekday');

    // ALIASES

    addUnitAlias('day', 'd');
    addUnitAlias('weekday', 'e');
    addUnitAlias('isoWeekday', 'E');

    // PRIORITY
    addUnitPriority('day', 11);
    addUnitPriority('weekday', 11);
    addUnitPriority('isoWeekday', 11);

    // PARSING

    addRegexToken('d', match1to2);
    addRegexToken('e', match1to2);
    addRegexToken('E', match1to2);
    addRegexToken('dd', function (isStrict, locale) {
        return locale.weekdaysMinRegex(isStrict);
    });
    addRegexToken('ddd', function (isStrict, locale) {
        return locale.weekdaysShortRegex(isStrict);
    });
    addRegexToken('dddd', function (isStrict, locale) {
        return locale.weekdaysRegex(isStrict);
    });

    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
        var weekday = config._locale.weekdaysParse(input, token, config._strict);
        // if we didn't get a weekday name, mark the date as invalid
        if (weekday != null) {
            week.d = weekday;
        } else {
            getParsingFlags(config).invalidWeekday = input;
        }
    });

    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
        week[token] = toInt(input);
    });

    // HELPERS

    function parseWeekday(input, locale) {
        if (typeof input !== 'string') {
            return input;
        }

        if (!isNaN(input)) {
            return parseInt(input, 10);
        }

        input = locale.weekdaysParse(input);
        if (typeof input === 'number') {
            return input;
        }

        return null;
    }

    function parseIsoWeekday(input, locale) {
        if (typeof input === 'string') {
            return locale.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
    }

    // LOCALES
    function shiftWeekdays(ws, n) {
        return ws.slice(n, 7).concat(ws.slice(0, n));
    }

    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split(
            '_'
        ),
        defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        defaultWeekdaysRegex = matchWord,
        defaultWeekdaysShortRegex = matchWord,
        defaultWeekdaysMinRegex = matchWord;

    function localeWeekdays(m, format) {
        var weekdays = isArray$1(this._weekdays)
            ? this._weekdays
            : this._weekdays[
                  m && m !== true && this._weekdays.isFormat.test(format)
                      ? 'format'
                      : 'standalone'
              ];
        return m === true
            ? shiftWeekdays(weekdays, this._week.dow)
            : m
            ? weekdays[m.day()]
            : weekdays;
    }

    function localeWeekdaysShort(m) {
        return m === true
            ? shiftWeekdays(this._weekdaysShort, this._week.dow)
            : m
            ? this._weekdaysShort[m.day()]
            : this._weekdaysShort;
    }

    function localeWeekdaysMin(m) {
        return m === true
            ? shiftWeekdays(this._weekdaysMin, this._week.dow)
            : m
            ? this._weekdaysMin[m.day()]
            : this._weekdaysMin;
    }

    function handleStrictParse$1(weekdayName, format, strict) {
        var i,
            ii,
            mom,
            llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._minWeekdaysParse = [];

            for (i = 0; i < 7; ++i) {
                mom = createUTC([2000, 1]).day(i);
                this._minWeekdaysParse[i] = this.weekdaysMin(
                    mom,
                    ''
                ).toLocaleLowerCase();
                this._shortWeekdaysParse[i] = this.weekdaysShort(
                    mom,
                    ''
                ).toLocaleLowerCase();
                this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeWeekdaysParse(weekdayName, format, strict) {
        var i, mom, regex;

        if (this._weekdaysParseExact) {
            return handleStrictParse$1.call(this, weekdayName, format, strict);
        }

        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._minWeekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._fullWeekdaysParse = [];
        }

        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already

            mom = createUTC([2000, 1]).day(i);
            if (strict && !this._fullWeekdaysParse[i]) {
                this._fullWeekdaysParse[i] = new RegExp(
                    '^' + this.weekdays(mom, '').replace('.', '\\.?') + '$',
                    'i'
                );
                this._shortWeekdaysParse[i] = new RegExp(
                    '^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$',
                    'i'
                );
                this._minWeekdaysParse[i] = new RegExp(
                    '^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$',
                    'i'
                );
            }
            if (!this._weekdaysParse[i]) {
                regex =
                    '^' +
                    this.weekdays(mom, '') +
                    '|^' +
                    this.weekdaysShort(mom, '') +
                    '|^' +
                    this.weekdaysMin(mom, '');
                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (
                strict &&
                format === 'dddd' &&
                this._fullWeekdaysParse[i].test(weekdayName)
            ) {
                return i;
            } else if (
                strict &&
                format === 'ddd' &&
                this._shortWeekdaysParse[i].test(weekdayName)
            ) {
                return i;
            } else if (
                strict &&
                format === 'dd' &&
                this._minWeekdaysParse[i].test(weekdayName)
            ) {
                return i;
            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function getSetDayOfWeek(input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, 'd');
        } else {
            return day;
        }
    }

    function getSetLocaleDayOfWeek(input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, 'd');
    }

    function getSetISODayOfWeek(input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }

        // behaves the same as moment#day except
        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
        // as a setter, sunday should belong to the previous week.

        if (input != null) {
            var weekday = parseIsoWeekday(input, this.localeData());
            return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
            return this.day() || 7;
        }
    }

    function weekdaysRegex(isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysStrictRegex;
            } else {
                return this._weekdaysRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                this._weekdaysRegex = defaultWeekdaysRegex;
            }
            return this._weekdaysStrictRegex && isStrict
                ? this._weekdaysStrictRegex
                : this._weekdaysRegex;
        }
    }

    function weekdaysShortRegex(isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysShortStrictRegex;
            } else {
                return this._weekdaysShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysShortRegex')) {
                this._weekdaysShortRegex = defaultWeekdaysShortRegex;
            }
            return this._weekdaysShortStrictRegex && isStrict
                ? this._weekdaysShortStrictRegex
                : this._weekdaysShortRegex;
        }
    }

    function weekdaysMinRegex(isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysMinStrictRegex;
            } else {
                return this._weekdaysMinRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysMinRegex')) {
                this._weekdaysMinRegex = defaultWeekdaysMinRegex;
            }
            return this._weekdaysMinStrictRegex && isStrict
                ? this._weekdaysMinStrictRegex
                : this._weekdaysMinRegex;
        }
    }

    function computeWeekdaysParse() {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var minPieces = [],
            shortPieces = [],
            longPieces = [],
            mixedPieces = [],
            i,
            mom,
            minp,
            shortp,
            longp;
        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, 1]).day(i);
            minp = regexEscape(this.weekdaysMin(mom, ''));
            shortp = regexEscape(this.weekdaysShort(mom, ''));
            longp = regexEscape(this.weekdays(mom, ''));
            minPieces.push(minp);
            shortPieces.push(shortp);
            longPieces.push(longp);
            mixedPieces.push(minp);
            mixedPieces.push(shortp);
            mixedPieces.push(longp);
        }
        // Sorting makes sure if one weekday (or abbr) is a prefix of another it
        // will match the longer piece.
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);

        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;

        this._weekdaysStrictRegex = new RegExp(
            '^(' + longPieces.join('|') + ')',
            'i'
        );
        this._weekdaysShortStrictRegex = new RegExp(
            '^(' + shortPieces.join('|') + ')',
            'i'
        );
        this._weekdaysMinStrictRegex = new RegExp(
            '^(' + minPieces.join('|') + ')',
            'i'
        );
    }

    // FORMATTING

    function hFormat() {
        return this.hours() % 12 || 12;
    }

    function kFormat() {
        return this.hours() || 24;
    }

    addFormatToken('H', ['HH', 2], 0, 'hour');
    addFormatToken('h', ['hh', 2], 0, hFormat);
    addFormatToken('k', ['kk', 2], 0, kFormat);

    addFormatToken('hmm', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });

    addFormatToken('hmmss', 0, 0, function () {
        return (
            '' +
            hFormat.apply(this) +
            zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2)
        );
    });

    addFormatToken('Hmm', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2);
    });

    addFormatToken('Hmmss', 0, 0, function () {
        return (
            '' +
            this.hours() +
            zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2)
        );
    });

    function meridiem(token, lowercase) {
        addFormatToken(token, 0, 0, function () {
            return this.localeData().meridiem(
                this.hours(),
                this.minutes(),
                lowercase
            );
        });
    }

    meridiem('a', true);
    meridiem('A', false);

    // ALIASES

    addUnitAlias('hour', 'h');

    // PRIORITY
    addUnitPriority('hour', 13);

    // PARSING

    function matchMeridiem(isStrict, locale) {
        return locale._meridiemParse;
    }

    addRegexToken('a', matchMeridiem);
    addRegexToken('A', matchMeridiem);
    addRegexToken('H', match1to2);
    addRegexToken('h', match1to2);
    addRegexToken('k', match1to2);
    addRegexToken('HH', match1to2, match2);
    addRegexToken('hh', match1to2, match2);
    addRegexToken('kk', match1to2, match2);

    addRegexToken('hmm', match3to4);
    addRegexToken('hmmss', match5to6);
    addRegexToken('Hmm', match3to4);
    addRegexToken('Hmmss', match5to6);

    addParseToken(['H', 'HH'], HOUR);
    addParseToken(['k', 'kk'], function (input, array, config) {
        var kInput = toInt(input);
        array[HOUR] = kInput === 24 ? 0 : kInput;
    });
    addParseToken(['a', 'A'], function (input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
    });
    addParseToken(['h', 'hh'], function (input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmmss', function (input, array, config) {
        var pos1 = input.length - 4,
            pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('Hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken('Hmmss', function (input, array, config) {
        var pos1 = input.length - 4,
            pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
    });

    // LOCALES

    function localeIsPM(input) {
        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
        // Using charAt should be more compatible.
        return (input + '').toLowerCase().charAt(0) === 'p';
    }

    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i,
        // Setting the hour should keep the time, because the user explicitly
        // specified which hour they want. So trying to maintain the same hour (in
        // a new timezone) makes sense. Adding/subtracting hours does not follow
        // this rule.
        getSetHour = makeGetSet('Hours', true);

    function localeMeridiem(hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? 'pm' : 'PM';
        } else {
            return isLower ? 'am' : 'AM';
        }
    }

    var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
        relativeTime: defaultRelativeTime,

        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,

        week: defaultLocaleWeek,

        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,

        meridiemParse: defaultLocaleMeridiemParse,
    };

    // internal storage for locale config files
    var locales = {},
        localeFamilies = {},
        globalLocale;

    function commonPrefix(arr1, arr2) {
        var i,
            minl = Math.min(arr1.length, arr2.length);
        for (i = 0; i < minl; i += 1) {
            if (arr1[i] !== arr2[i]) {
                return i;
            }
        }
        return minl;
    }

    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // pick the locale from the array
    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
    function chooseLocale(names) {
        var i = 0,
            j,
            next,
            locale,
            split;

        while (i < names.length) {
            split = normalizeLocale(names[i]).split('-');
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join('-'));
                if (locale) {
                    return locale;
                }
                if (
                    next &&
                    next.length >= j &&
                    commonPrefix(split, next) >= j - 1
                ) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return globalLocale;
    }

    function loadLocale(name) {
        var oldLocale = null,
            aliasedRequire;
        // TODO: Find a better way to register and load all the locales in Node
        if (
            locales[name] === undefined &&
            typeof module !== 'undefined' &&
            module &&
            module.exports
        ) {
            try {
                oldLocale = globalLocale._abbr;
                aliasedRequire = require;
                aliasedRequire('./locale/' + name);
                getSetGlobalLocale(oldLocale);
            } catch (e) {
                // mark as not found to avoid repeating expensive file require call causing high CPU
                // when trying to find en-US, en_US, en-us for every format call
                locales[name] = null; // null means not found
            }
        }
        return locales[name];
    }

    // This function will load locale and then set the global locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.
    function getSetGlobalLocale(key, values) {
        var data;
        if (key) {
            if (isUndefined$1(values)) {
                data = getLocale(key);
            } else {
                data = defineLocale(key, values);
            }

            if (data) {
                // moment.duration._locale = moment._locale = data;
                globalLocale = data;
            } else {
                if (typeof console !== 'undefined' && console.warn) {
                    //warn user if arguments are passed but the locale could not be set
                    console.warn(
                        'Locale ' + key + ' not found. Did you forget to load it?'
                    );
                }
            }
        }

        return globalLocale._abbr;
    }

    function defineLocale(name, config) {
        if (config !== null) {
            var locale,
                parentConfig = baseConfig;
            config.abbr = name;
            if (locales[name] != null) {
                deprecateSimple(
                    'defineLocaleOverride',
                    'use moment.updateLocale(localeName, config) to change ' +
                        'an existing locale. moment.defineLocale(localeName, ' +
                        'config) should only be used for creating a new locale ' +
                        'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.'
                );
                parentConfig = locales[name]._config;
            } else if (config.parentLocale != null) {
                if (locales[config.parentLocale] != null) {
                    parentConfig = locales[config.parentLocale]._config;
                } else {
                    locale = loadLocale(config.parentLocale);
                    if (locale != null) {
                        parentConfig = locale._config;
                    } else {
                        if (!localeFamilies[config.parentLocale]) {
                            localeFamilies[config.parentLocale] = [];
                        }
                        localeFamilies[config.parentLocale].push({
                            name: name,
                            config: config,
                        });
                        return null;
                    }
                }
            }
            locales[name] = new Locale(mergeConfigs(parentConfig, config));

            if (localeFamilies[name]) {
                localeFamilies[name].forEach(function (x) {
                    defineLocale(x.name, x.config);
                });
            }

            // backwards compat for now: also set the locale
            // make sure we set the locale AFTER all child locales have been
            // created, so we won't end up with the child locale set.
            getSetGlobalLocale(name);

            return locales[name];
        } else {
            // useful for testing
            delete locales[name];
            return null;
        }
    }

    function updateLocale(name, config) {
        if (config != null) {
            var locale,
                tmpLocale,
                parentConfig = baseConfig;

            if (locales[name] != null && locales[name].parentLocale != null) {
                // Update existing child locale in-place to avoid memory-leaks
                locales[name].set(mergeConfigs(locales[name]._config, config));
            } else {
                // MERGE
                tmpLocale = loadLocale(name);
                if (tmpLocale != null) {
                    parentConfig = tmpLocale._config;
                }
                config = mergeConfigs(parentConfig, config);
                if (tmpLocale == null) {
                    // updateLocale is called for creating a new locale
                    // Set abbr so it will have a name (getters return
                    // undefined otherwise).
                    config.abbr = name;
                }
                locale = new Locale(config);
                locale.parentLocale = locales[name];
                locales[name] = locale;
            }

            // backwards compat for now: also set the locale
            getSetGlobalLocale(name);
        } else {
            // pass null for config to unupdate, useful for tests
            if (locales[name] != null) {
                if (locales[name].parentLocale != null) {
                    locales[name] = locales[name].parentLocale;
                    if (name === getSetGlobalLocale()) {
                        getSetGlobalLocale(name);
                    }
                } else if (locales[name] != null) {
                    delete locales[name];
                }
            }
        }
        return locales[name];
    }

    // returns locale data
    function getLocale(key) {
        var locale;

        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }

        if (!key) {
            return globalLocale;
        }

        if (!isArray$1(key)) {
            //short-circuit everything else
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [key];
        }

        return chooseLocale(key);
    }

    function listLocales() {
        return keys(locales);
    }

    function checkOverflow(m) {
        var overflow,
            a = m._a;

        if (a && getParsingFlags(m).overflow === -2) {
            overflow =
                a[MONTH] < 0 || a[MONTH] > 11
                    ? MONTH
                    : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH])
                    ? DATE
                    : a[HOUR] < 0 ||
                      a[HOUR] > 24 ||
                      (a[HOUR] === 24 &&
                          (a[MINUTE] !== 0 ||
                              a[SECOND] !== 0 ||
                              a[MILLISECOND] !== 0))
                    ? HOUR
                    : a[MINUTE] < 0 || a[MINUTE] > 59
                    ? MINUTE
                    : a[SECOND] < 0 || a[SECOND] > 59
                    ? SECOND
                    : a[MILLISECOND] < 0 || a[MILLISECOND] > 999
                    ? MILLISECOND
                    : -1;

            if (
                getParsingFlags(m)._overflowDayOfYear &&
                (overflow < YEAR || overflow > DATE)
            ) {
                overflow = DATE;
            }
            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                overflow = WEEK;
            }
            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                overflow = WEEKDAY;
            }

            getParsingFlags(m).overflow = overflow;
        }

        return m;
    }

    // iso 8601 regex
    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
        basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
        tzRegex = /Z|[+-]\d\d(?::?\d\d)?/,
        isoDates = [
            ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
            ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
            ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
            ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
            ['YYYY-DDD', /\d{4}-\d{3}/],
            ['YYYY-MM', /\d{4}-\d\d/, false],
            ['YYYYYYMMDD', /[+-]\d{10}/],
            ['YYYYMMDD', /\d{8}/],
            ['GGGG[W]WWE', /\d{4}W\d{3}/],
            ['GGGG[W]WW', /\d{4}W\d{2}/, false],
            ['YYYYDDD', /\d{7}/],
            ['YYYYMM', /\d{6}/, false],
            ['YYYY', /\d{4}/, false],
        ],
        // iso time formats and regexes
        isoTimes = [
            ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
            ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
            ['HH:mm:ss', /\d\d:\d\d:\d\d/],
            ['HH:mm', /\d\d:\d\d/],
            ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
            ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
            ['HHmmss', /\d\d\d\d\d\d/],
            ['HHmm', /\d\d\d\d/],
            ['HH', /\d\d/],
        ],
        aspNetJsonRegex = /^\/?Date\((-?\d+)/i,
        // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
        rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/,
        obsOffsets = {
            UT: 0,
            GMT: 0,
            EDT: -4 * 60,
            EST: -5 * 60,
            CDT: -5 * 60,
            CST: -6 * 60,
            MDT: -6 * 60,
            MST: -7 * 60,
            PDT: -7 * 60,
            PST: -8 * 60,
        };

    // date from iso format
    function configFromISO(config) {
        var i,
            l,
            string = config._i,
            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
            allowTime,
            dateFormat,
            timeFormat,
            tzFormat;

        if (match) {
            getParsingFlags(config).iso = true;

            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(match[1])) {
                    dateFormat = isoDates[i][0];
                    allowTime = isoDates[i][2] !== false;
                    break;
                }
            }
            if (dateFormat == null) {
                config._isValid = false;
                return;
            }
            if (match[3]) {
                for (i = 0, l = isoTimes.length; i < l; i++) {
                    if (isoTimes[i][1].exec(match[3])) {
                        // match[2] should be 'T' or space
                        timeFormat = (match[2] || ' ') + isoTimes[i][0];
                        break;
                    }
                }
                if (timeFormat == null) {
                    config._isValid = false;
                    return;
                }
            }
            if (!allowTime && timeFormat != null) {
                config._isValid = false;
                return;
            }
            if (match[4]) {
                if (tzRegex.exec(match[4])) {
                    tzFormat = 'Z';
                } else {
                    config._isValid = false;
                    return;
                }
            }
            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
            configFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }

    function extractFromRFC2822Strings(
        yearStr,
        monthStr,
        dayStr,
        hourStr,
        minuteStr,
        secondStr
    ) {
        var result = [
            untruncateYear(yearStr),
            defaultLocaleMonthsShort.indexOf(monthStr),
            parseInt(dayStr, 10),
            parseInt(hourStr, 10),
            parseInt(minuteStr, 10),
        ];

        if (secondStr) {
            result.push(parseInt(secondStr, 10));
        }

        return result;
    }

    function untruncateYear(yearStr) {
        var year = parseInt(yearStr, 10);
        if (year <= 49) {
            return 2000 + year;
        } else if (year <= 999) {
            return 1900 + year;
        }
        return year;
    }

    function preprocessRFC2822(s) {
        // Remove comments and folding whitespace and replace multiple-spaces with a single space
        return s
            .replace(/\([^)]*\)|[\n\t]/g, ' ')
            .replace(/(\s\s+)/g, ' ')
            .replace(/^\s\s*/, '')
            .replace(/\s\s*$/, '');
    }

    function checkWeekday(weekdayStr, parsedInput, config) {
        if (weekdayStr) {
            // TODO: Replace the vanilla JS Date object with an independent day-of-week check.
            var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
                weekdayActual = new Date(
                    parsedInput[0],
                    parsedInput[1],
                    parsedInput[2]
                ).getDay();
            if (weekdayProvided !== weekdayActual) {
                getParsingFlags(config).weekdayMismatch = true;
                config._isValid = false;
                return false;
            }
        }
        return true;
    }

    function calculateOffset(obsOffset, militaryOffset, numOffset) {
        if (obsOffset) {
            return obsOffsets[obsOffset];
        } else if (militaryOffset) {
            // the only allowed military tz is Z
            return 0;
        } else {
            var hm = parseInt(numOffset, 10),
                m = hm % 100,
                h = (hm - m) / 100;
            return h * 60 + m;
        }
    }

    // date and time from ref 2822 format
    function configFromRFC2822(config) {
        var match = rfc2822.exec(preprocessRFC2822(config._i)),
            parsedArray;
        if (match) {
            parsedArray = extractFromRFC2822Strings(
                match[4],
                match[3],
                match[2],
                match[5],
                match[6],
                match[7]
            );
            if (!checkWeekday(match[1], parsedArray, config)) {
                return;
            }

            config._a = parsedArray;
            config._tzm = calculateOffset(match[8], match[9], match[10]);

            config._d = createUTCDate.apply(null, config._a);
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

            getParsingFlags(config).rfc2822 = true;
        } else {
            config._isValid = false;
        }
    }

    // date from 1) ASP.NET, 2) ISO, 3) RFC 2822 formats, or 4) optional fallback if parsing isn't strict
    function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);
        if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
        }

        configFromISO(config);
        if (config._isValid === false) {
            delete config._isValid;
        } else {
            return;
        }

        configFromRFC2822(config);
        if (config._isValid === false) {
            delete config._isValid;
        } else {
            return;
        }

        if (config._strict) {
            config._isValid = false;
        } else {
            // Final attempt, use Input Fallback
            hooks.createFromInputFallback(config);
        }
    }

    hooks.createFromInputFallback = deprecate(
        'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
            'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
            'discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.',
        function (config) {
            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
        }
    );

    // Pick the first defined of two or three arguments.
    function defaults$1(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function currentDateArray(config) {
        // hooks is actually the exported moment object
        var nowValue = new Date(hooks.now());
        if (config._useUTC) {
            return [
                nowValue.getUTCFullYear(),
                nowValue.getUTCMonth(),
                nowValue.getUTCDate(),
            ];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function configFromArray(config) {
        var i,
            date,
            input = [],
            currentDate,
            expectedWeekday,
            yearToUse;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear != null) {
            yearToUse = defaults$1(config._a[YEAR], currentDate[YEAR]);

            if (
                config._dayOfYear > daysInYear(yearToUse) ||
                config._dayOfYear === 0
            ) {
                getParsingFlags(config)._overflowDayOfYear = true;
            }

            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] =
                config._a[i] == null ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // Check for 24:00:00.000
        if (
            config._a[HOUR] === 24 &&
            config._a[MINUTE] === 0 &&
            config._a[SECOND] === 0 &&
            config._a[MILLISECOND] === 0
        ) {
            config._nextDay = true;
            config._a[HOUR] = 0;
        }

        config._d = (config._useUTC ? createUTCDate : createDate).apply(
            null,
            input
        );
        expectedWeekday = config._useUTC
            ? config._d.getUTCDay()
            : config._d.getDay();

        // Apply timezone offset from input. The actual utcOffset can be changed
        // with parseZone.
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }

        if (config._nextDay) {
            config._a[HOUR] = 24;
        }

        // check for mismatching day of week
        if (
            config._w &&
            typeof config._w.d !== 'undefined' &&
            config._w.d !== expectedWeekday
        ) {
            getParsingFlags(config).weekdayMismatch = true;
        }
    }

    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;

        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;

            // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).
            weekYear = defaults$1(
                w.GG,
                config._a[YEAR],
                weekOfYear(createLocal(), 1, 4).year
            );
            week = defaults$1(w.W, 1);
            weekday = defaults$1(w.E, 1);
            if (weekday < 1 || weekday > 7) {
                weekdayOverflow = true;
            }
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;

            curWeek = weekOfYear(createLocal(), dow, doy);

            weekYear = defaults$1(w.gg, config._a[YEAR], curWeek.year);

            // Default to current week.
            week = defaults$1(w.w, curWeek.week);

            if (w.d != null) {
                // weekday -- low day numbers are considered next week
                weekday = w.d;
                if (weekday < 0 || weekday > 6) {
                    weekdayOverflow = true;
                }
            } else if (w.e != null) {
                // local weekday -- counting starts from beginning of week
                weekday = w.e + dow;
                if (w.e < 0 || w.e > 6) {
                    weekdayOverflow = true;
                }
            } else {
                // default to beginning of week
                weekday = dow;
            }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
            getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
            getParsingFlags(config)._overflowWeekday = true;
        } else {
            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
        }
    }

    // constant that refers to the ISO standard
    hooks.ISO_8601 = function () {};

    // constant that refers to the RFC 2822 form
    hooks.RFC_2822 = function () {};

    // date from string and format string
    function configFromStringAndFormat(config) {
        // TODO: Move this to another part of the creation flow to prevent circular deps
        if (config._f === hooks.ISO_8601) {
            configFromISO(config);
            return;
        }
        if (config._f === hooks.RFC_2822) {
            configFromRFC2822(config);
            return;
        }
        config._a = [];
        getParsingFlags(config).empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var string = '' + config._i,
            i,
            parsedInput,
            tokens,
            token,
            skipped,
            stringLength = string.length,
            totalParsedInputLength = 0,
            era;

        tokens =
            expandFormat(config._f, config._locale).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) ||
                [])[0];
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    getParsingFlags(config).unusedInput.push(skipped);
                }
                string = string.slice(
                    string.indexOf(parsedInput) + parsedInput.length
                );
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    getParsingFlags(config).empty = false;
                } else {
                    getParsingFlags(config).unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            } else if (config._strict && !parsedInput) {
                getParsingFlags(config).unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        getParsingFlags(config).charsLeftOver =
            stringLength - totalParsedInputLength;
        if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
        }

        // clear _12h flag if hour is <= 12
        if (
            config._a[HOUR] <= 12 &&
            getParsingFlags(config).bigHour === true &&
            config._a[HOUR] > 0
        ) {
            getParsingFlags(config).bigHour = undefined;
        }

        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        // handle meridiem
        config._a[HOUR] = meridiemFixWrap(
            config._locale,
            config._a[HOUR],
            config._meridiem
        );

        // handle era
        era = getParsingFlags(config).era;
        if (era !== null) {
            config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
        }

        configFromArray(config);
        checkOverflow(config);
    }

    function meridiemFixWrap(locale, hour, meridiem) {
        var isPm;

        if (meridiem == null) {
            // nothing to do
            return hour;
        }
        if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
            // Fallback
            isPm = locale.isPM(meridiem);
            if (isPm && hour < 12) {
                hour += 12;
            }
            if (!isPm && hour === 12) {
                hour = 0;
            }
            return hour;
        } else {
            // this is not supposed to happen
            return hour;
        }
    }

    // date from string and array of format strings
    function configFromStringAndArray(config) {
        var tempConfig,
            bestMoment,
            scoreToBeat,
            i,
            currentScore,
            validFormatFound,
            bestFormatIsValid = false;

        if (config._f.length === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            validFormatFound = false;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);

            if (isValid(tempConfig)) {
                validFormatFound = true;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += getParsingFlags(tempConfig).charsLeftOver;

            //or tokens
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

            getParsingFlags(tempConfig).score = currentScore;

            if (!bestFormatIsValid) {
                if (
                    scoreToBeat == null ||
                    currentScore < scoreToBeat ||
                    validFormatFound
                ) {
                    scoreToBeat = currentScore;
                    bestMoment = tempConfig;
                    if (validFormatFound) {
                        bestFormatIsValid = true;
                    }
                }
            } else {
                if (currentScore < scoreToBeat) {
                    scoreToBeat = currentScore;
                    bestMoment = tempConfig;
                }
            }
        }

        extend$2(config, bestMoment || tempConfig);
    }

    function configFromObject(config) {
        if (config._d) {
            return;
        }

        var i = normalizeObjectUnits(config._i),
            dayOrDate = i.day === undefined ? i.date : i.day;
        config._a = map(
            [i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond],
            function (obj) {
                return obj && parseInt(obj, 10);
            }
        );

        configFromArray(config);
    }

    function createFromConfig(config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
            // Adding is smart enough around DST
            res.add(1, 'd');
            res._nextDay = undefined;
        }

        return res;
    }

    function prepareConfig(config) {
        var input = config._i,
            format = config._f;

        config._locale = config._locale || getLocale(config._l);

        if (input === null || (format === undefined && input === '')) {
            return createInvalid({ nullInput: true });
        }

        if (typeof input === 'string') {
            config._i = input = config._locale.preparse(input);
        }

        if (isMoment(input)) {
            return new Moment(checkOverflow(input));
        } else if (isDate$1(input)) {
            config._d = input;
        } else if (isArray$1(format)) {
            configFromStringAndArray(config);
        } else if (format) {
            configFromStringAndFormat(config);
        } else {
            configFromInput(config);
        }

        if (!isValid(config)) {
            config._d = null;
        }

        return config;
    }

    function configFromInput(config) {
        var input = config._i;
        if (isUndefined$1(input)) {
            config._d = new Date(hooks.now());
        } else if (isDate$1(input)) {
            config._d = new Date(input.valueOf());
        } else if (typeof input === 'string') {
            configFromString(config);
        } else if (isArray$1(input)) {
            config._a = map(input.slice(0), function (obj) {
                return parseInt(obj, 10);
            });
            configFromArray(config);
        } else if (isObject$1(input)) {
            configFromObject(config);
        } else if (isNumber$1(input)) {
            // from milliseconds
            config._d = new Date(input);
        } else {
            hooks.createFromInputFallback(config);
        }
    }

    function createLocalOrUTC(input, format, locale, strict, isUTC) {
        var c = {};

        if (format === true || format === false) {
            strict = format;
            format = undefined;
        }

        if (locale === true || locale === false) {
            strict = locale;
            locale = undefined;
        }

        if (
            (isObject$1(input) && isObjectEmpty(input)) ||
            (isArray$1(input) && input.length === 0)
        ) {
            input = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;

        return createFromConfig(c);
    }

    function createLocal(input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, false);
    }

    var prototypeMin = deprecate(
            'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
            function () {
                var other = createLocal.apply(null, arguments);
                if (this.isValid() && other.isValid()) {
                    return other < this ? this : other;
                } else {
                    return createInvalid();
                }
            }
        ),
        prototypeMax = deprecate(
            'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
            function () {
                var other = createLocal.apply(null, arguments);
                if (this.isValid() && other.isValid()) {
                    return other > this ? this : other;
                } else {
                    return createInvalid();
                }
            }
        );

    // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray$1(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }

    // TODO: Use [].sort instead?
    function min() {
        var args = [].slice.call(arguments, 0);

        return pickBy('isBefore', args);
    }

    function max() {
        var args = [].slice.call(arguments, 0);

        return pickBy('isAfter', args);
    }

    var now = function () {
        return Date.now ? Date.now() : +new Date();
    };

    var ordering = [
        'year',
        'quarter',
        'month',
        'week',
        'day',
        'hour',
        'minute',
        'second',
        'millisecond',
    ];

    function isDurationValid(m) {
        var key,
            unitHasDecimal = false,
            i;
        for (key in m) {
            if (
                hasOwnProp(m, key) &&
                !(
                    indexOf.call(ordering, key) !== -1 &&
                    (m[key] == null || !isNaN(m[key]))
                )
            ) {
                return false;
            }
        }

        for (i = 0; i < ordering.length; ++i) {
            if (m[ordering[i]]) {
                if (unitHasDecimal) {
                    return false; // only allow non-integers for smallest unit
                }
                if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                    unitHasDecimal = true;
                }
            }
        }

        return true;
    }

    function isValid$1() {
        return this._isValid;
    }

    function createInvalid$1() {
        return createDuration(NaN);
    }

    function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        this._isValid = isDurationValid(normalizedInput);

        // representation for dateAddRemove
        this._milliseconds =
            +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days + weeks * 7;
        // It is impossible to translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months + quarters * 3 + years * 12;

        this._data = {};

        this._locale = getLocale();

        this._bubble();
    }

    function isDuration(obj) {
        return obj instanceof Duration;
    }

    function absRound(number) {
        if (number < 0) {
            return Math.round(-1 * number) * -1;
        } else {
            return Math.round(number);
        }
    }

    // compare two arrays, return the number of differences
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if (
                (dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))
            ) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    // FORMATTING

    function offset(token, separator) {
        addFormatToken(token, 0, 0, function () {
            var offset = this.utcOffset(),
                sign = '+';
            if (offset < 0) {
                offset = -offset;
                sign = '-';
            }
            return (
                sign +
                zeroFill(~~(offset / 60), 2) +
                separator +
                zeroFill(~~offset % 60, 2)
            );
        });
    }

    offset('Z', ':');
    offset('ZZ', '');

    // PARSING

    addRegexToken('Z', matchShortOffset);
    addRegexToken('ZZ', matchShortOffset);
    addParseToken(['Z', 'ZZ'], function (input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
    });

    // HELPERS

    // timezone chunker
    // '+10:00' > ['10',  '00']
    // '-1530'  > ['-15', '30']
    var chunkOffset = /([\+\-]|\d\d)/gi;

    function offsetFromString(matcher, string) {
        var matches = (string || '').match(matcher),
            chunk,
            parts,
            minutes;

        if (matches === null) {
            return null;
        }

        chunk = matches[matches.length - 1] || [];
        parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
        minutes = +(parts[1] * 60) + toInt(parts[2]);

        return minutes === 0 ? 0 : parts[0] === '+' ? minutes : -minutes;
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function cloneWithOffset(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff =
                (isMoment(input) || isDate$1(input)
                    ? input.valueOf()
                    : createLocal(input).valueOf()) - res.valueOf();
            // Use low-level api, because this fn is low-level api.
            res._d.setTime(res._d.valueOf() + diff);
            hooks.updateOffset(res, false);
            return res;
        } else {
            return createLocal(input).local();
        }
    }

    function getDateOffset(m) {
        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
        // https://github.com/moment/moment/pull/1871
        return -Math.round(m._d.getTimezoneOffset());
    }

    // HOOKS

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    hooks.updateOffset = function () {};

    // MOMENTS

    // keepLocalTime = true means only change the timezone, without
    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
    // +0200, so we adjust the time as needed, to be valid.
    //
    // Keeping the time actually adds/subtracts (one hour)
    // from the actual represented time. That is why we call updateOffset
    // a second time. In case it wants us to change the offset again
    // _changeInProgress == true case, then we have to adjust, because
    // there is no such time in the given timezone.
    function getSetOffset(input, keepLocalTime, keepMinutes) {
        var offset = this._offset || 0,
            localAdjust;
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        if (input != null) {
            if (typeof input === 'string') {
                input = offsetFromString(matchShortOffset, input);
                if (input === null) {
                    return this;
                }
            } else if (Math.abs(input) < 16 && !keepMinutes) {
                input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
                localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
                this.add(localAdjust, 'm');
            }
            if (offset !== input) {
                if (!keepLocalTime || this._changeInProgress) {
                    addSubtract(
                        this,
                        createDuration(input - offset, 'm'),
                        1,
                        false
                    );
                } else if (!this._changeInProgress) {
                    this._changeInProgress = true;
                    hooks.updateOffset(this, true);
                    this._changeInProgress = null;
                }
            }
            return this;
        } else {
            return this._isUTC ? offset : getDateOffset(this);
        }
    }

    function getSetZone(input, keepLocalTime) {
        if (input != null) {
            if (typeof input !== 'string') {
                input = -input;
            }

            this.utcOffset(input, keepLocalTime);

            return this;
        } else {
            return -this.utcOffset();
        }
    }

    function setOffsetToUTC(keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
    }

    function setOffsetToLocal(keepLocalTime) {
        if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;

            if (keepLocalTime) {
                this.subtract(getDateOffset(this), 'm');
            }
        }
        return this;
    }

    function setOffsetToParsedOffset() {
        if (this._tzm != null) {
            this.utcOffset(this._tzm, false, true);
        } else if (typeof this._i === 'string') {
            var tZone = offsetFromString(matchOffset, this._i);
            if (tZone != null) {
                this.utcOffset(tZone);
            } else {
                this.utcOffset(0, true);
            }
        }
        return this;
    }

    function hasAlignedHourOffset(input) {
        if (!this.isValid()) {
            return false;
        }
        input = input ? createLocal(input).utcOffset() : 0;

        return (this.utcOffset() - input) % 60 === 0;
    }

    function isDaylightSavingTime() {
        return (
            this.utcOffset() > this.clone().month(0).utcOffset() ||
            this.utcOffset() > this.clone().month(5).utcOffset()
        );
    }

    function isDaylightSavingTimeShifted() {
        if (!isUndefined$1(this._isDSTShifted)) {
            return this._isDSTShifted;
        }

        var c = {},
            other;

        copyConfig(c, this);
        c = prepareConfig(c);

        if (c._a) {
            other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
            this._isDSTShifted =
                this.isValid() && compareArrays(c._a, other.toArray()) > 0;
        } else {
            this._isDSTShifted = false;
        }

        return this._isDSTShifted;
    }

    function isLocal() {
        return this.isValid() ? !this._isUTC : false;
    }

    function isUtcOffset() {
        return this.isValid() ? this._isUTC : false;
    }

    function isUtc() {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
    }

    // ASP.NET json date format regex
    var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/,
        // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
        // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
        // and further modified to allow for strings containing both week and day
        isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

    function createDuration(input, key) {
        var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            diffRes;

        if (isDuration(input)) {
            duration = {
                ms: input._milliseconds,
                d: input._days,
                M: input._months,
            };
        } else if (isNumber$1(input) || !isNaN(+input)) {
            duration = {};
            if (key) {
                duration[key] = +input;
            } else {
                duration.milliseconds = +input;
            }
        } else if ((match = aspNetRegex.exec(input))) {
            sign = match[1] === '-' ? -1 : 1;
            duration = {
                y: 0,
                d: toInt(match[DATE]) * sign,
                h: toInt(match[HOUR]) * sign,
                m: toInt(match[MINUTE]) * sign,
                s: toInt(match[SECOND]) * sign,
                ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign, // the millisecond decimal point is included in the match
            };
        } else if ((match = isoRegex.exec(input))) {
            sign = match[1] === '-' ? -1 : 1;
            duration = {
                y: parseIso(match[2], sign),
                M: parseIso(match[3], sign),
                w: parseIso(match[4], sign),
                d: parseIso(match[5], sign),
                h: parseIso(match[6], sign),
                m: parseIso(match[7], sign),
                s: parseIso(match[8], sign),
            };
        } else if (duration == null) {
            // checks for null or undefined
            duration = {};
        } else if (
            typeof duration === 'object' &&
            ('from' in duration || 'to' in duration)
        ) {
            diffRes = momentsDifference(
                createLocal(duration.from),
                createLocal(duration.to)
            );

            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }

        ret = new Duration(duration);

        if (isDuration(input) && hasOwnProp(input, '_locale')) {
            ret._locale = input._locale;
        }

        if (isDuration(input) && hasOwnProp(input, '_isValid')) {
            ret._isValid = input._isValid;
        }

        return ret;
    }

    createDuration.fn = Duration.prototype;
    createDuration.invalid = createInvalid$1;

    function parseIso(inp, sign) {
        // We'd normally use ~~inp for this, but unfortunately it also
        // converts floats to ints.
        // inp may be undefined, so careful calling replace on it.
        var res = inp && parseFloat(inp.replace(',', '.'));
        // apply sign while we're at it
        return (isNaN(res) ? 0 : res) * sign;
    }

    function positiveMomentsDifference(base, other) {
        var res = {};

        res.months =
            other.month() - base.month() + (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, 'M').isAfter(other)) {
            --res.months;
        }

        res.milliseconds = +other - +base.clone().add(res.months, 'M');

        return res;
    }

    function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
            return { milliseconds: 0, months: 0 };
        }

        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }

        return res;
    }

    // TODO: remove 'name' arg after deprecation is removed
    function createAdder(direction, name) {
        return function (val, period) {
            var dur, tmp;
            //invert the arguments, but complain about it
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(
                    name,
                    'moment().' +
                        name +
                        '(period, number) is deprecated. Please use moment().' +
                        name +
                        '(number, period). ' +
                        'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.'
                );
                tmp = val;
                val = period;
                period = tmp;
            }

            dur = createDuration(val, period);
            addSubtract(this, dur, direction);
            return this;
        };
    }

    function addSubtract(mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = absRound(duration._days),
            months = absRound(duration._months);

        if (!mom.isValid()) {
            // No op
            return;
        }

        updateOffset = updateOffset == null ? true : updateOffset;

        if (months) {
            setMonth(mom, get$2(mom, 'Month') + months * isAdding);
        }
        if (days) {
            set$1$1(mom, 'Date', get$2(mom, 'Date') + days * isAdding);
        }
        if (milliseconds) {
            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
        }
        if (updateOffset) {
            hooks.updateOffset(mom, days || months);
        }
    }

    var add$1 = createAdder(1, 'add'),
        subtract = createAdder(-1, 'subtract');

    function isString$1(input) {
        return typeof input === 'string' || input instanceof String;
    }

    // type MomentInput = Moment | Date | string | number | (number | string)[] | MomentInputObject | void; // null | undefined
    function isMomentInput(input) {
        return (
            isMoment(input) ||
            isDate$1(input) ||
            isString$1(input) ||
            isNumber$1(input) ||
            isNumberOrStringArray(input) ||
            isMomentInputObject(input) ||
            input === null ||
            input === undefined
        );
    }

    function isMomentInputObject(input) {
        var objectTest = isObject$1(input) && !isObjectEmpty(input),
            propertyTest = false,
            properties = [
                'years',
                'year',
                'y',
                'months',
                'month',
                'M',
                'days',
                'day',
                'd',
                'dates',
                'date',
                'D',
                'hours',
                'hour',
                'h',
                'minutes',
                'minute',
                'm',
                'seconds',
                'second',
                's',
                'milliseconds',
                'millisecond',
                'ms',
            ],
            i,
            property;

        for (i = 0; i < properties.length; i += 1) {
            property = properties[i];
            propertyTest = propertyTest || hasOwnProp(input, property);
        }

        return objectTest && propertyTest;
    }

    function isNumberOrStringArray(input) {
        var arrayTest = isArray$1(input),
            dataTypeTest = false;
        if (arrayTest) {
            dataTypeTest =
                input.filter(function (item) {
                    return !isNumber$1(item) && isString$1(input);
                }).length === 0;
        }
        return arrayTest && dataTypeTest;
    }

    function isCalendarSpec(input) {
        var objectTest = isObject$1(input) && !isObjectEmpty(input),
            propertyTest = false,
            properties = [
                'sameDay',
                'nextDay',
                'lastDay',
                'nextWeek',
                'lastWeek',
                'sameElse',
            ],
            i,
            property;

        for (i = 0; i < properties.length; i += 1) {
            property = properties[i];
            propertyTest = propertyTest || hasOwnProp(input, property);
        }

        return objectTest && propertyTest;
    }

    function getCalendarFormat(myMoment, now) {
        var diff = myMoment.diff(now, 'days', true);
        return diff < -6
            ? 'sameElse'
            : diff < -1
            ? 'lastWeek'
            : diff < 0
            ? 'lastDay'
            : diff < 1
            ? 'sameDay'
            : diff < 2
            ? 'nextDay'
            : diff < 7
            ? 'nextWeek'
            : 'sameElse';
    }

    function calendar$1(time, formats) {
        // Support for single parameter, formats only overload to the calendar function
        if (arguments.length === 1) {
            if (!arguments[0]) {
                time = undefined;
                formats = undefined;
            } else if (isMomentInput(arguments[0])) {
                time = arguments[0];
                formats = undefined;
            } else if (isCalendarSpec(arguments[0])) {
                formats = arguments[0];
                time = undefined;
            }
        }
        // We want to compare the start of today, vs this.
        // Getting start-of-today depends on whether we're local/utc/offset or not.
        var now = time || createLocal(),
            sod = cloneWithOffset(now, this).startOf('day'),
            format = hooks.calendarFormat(this, sod) || 'sameElse',
            output =
                formats &&
                (isFunction$2(formats[format])
                    ? formats[format].call(this, now)
                    : formats[format]);

        return this.format(
            output || this.localeData().calendar(format, this, createLocal(now))
        );
    }

    function clone() {
        return new Moment(this);
    }

    function isAfter(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() > localInput.valueOf();
        } else {
            return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
    }

    function isBefore(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() < localInput.valueOf();
        } else {
            return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
    }

    function isBetween(from, to, units, inclusivity) {
        var localFrom = isMoment(from) ? from : createLocal(from),
            localTo = isMoment(to) ? to : createLocal(to);
        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
            return false;
        }
        inclusivity = inclusivity || '()';
        return (
            (inclusivity[0] === '('
                ? this.isAfter(localFrom, units)
                : !this.isBefore(localFrom, units)) &&
            (inclusivity[1] === ')'
                ? this.isBefore(localTo, units)
                : !this.isAfter(localTo, units))
        );
    }

    function isSame(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input),
            inputMs;
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() === localInput.valueOf();
        } else {
            inputMs = localInput.valueOf();
            return (
                this.clone().startOf(units).valueOf() <= inputMs &&
                inputMs <= this.clone().endOf(units).valueOf()
            );
        }
    }

    function isSameOrAfter(input, units) {
        return this.isSame(input, units) || this.isAfter(input, units);
    }

    function isSameOrBefore(input, units) {
        return this.isSame(input, units) || this.isBefore(input, units);
    }

    function diff(input, units, asFloat) {
        var that, zoneDelta, output;

        if (!this.isValid()) {
            return NaN;
        }

        that = cloneWithOffset(input, this);

        if (!that.isValid()) {
            return NaN;
        }

        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

        units = normalizeUnits(units);

        switch (units) {
            case 'year':
                output = monthDiff(this, that) / 12;
                break;
            case 'month':
                output = monthDiff(this, that);
                break;
            case 'quarter':
                output = monthDiff(this, that) / 3;
                break;
            case 'second':
                output = (this - that) / 1e3;
                break; // 1000
            case 'minute':
                output = (this - that) / 6e4;
                break; // 1000 * 60
            case 'hour':
                output = (this - that) / 36e5;
                break; // 1000 * 60 * 60
            case 'day':
                output = (this - that - zoneDelta) / 864e5;
                break; // 1000 * 60 * 60 * 24, negate dst
            case 'week':
                output = (this - that - zoneDelta) / 6048e5;
                break; // 1000 * 60 * 60 * 24 * 7, negate dst
            default:
                output = this - that;
        }

        return asFloat ? output : absFloor(output);
    }

    function monthDiff(a, b) {
        if (a.date() < b.date()) {
            // end-of-month calculations work correct when the start month has more
            // days than the end month.
            return -monthDiff(b, a);
        }
        // difference in months
        var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()),
            // b is in (anchor - 1 month, anchor + 1 month)
            anchor = a.clone().add(wholeMonthDiff, 'months'),
            anchor2,
            adjust;

        if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor - anchor2);
        } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor2 - anchor);
        }

        //check for negative zero, return zero if negative zero
        return -(wholeMonthDiff + adjust) || 0;
    }

    hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
    hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

    function toString$1() {
        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
    }

    function toISOString(keepOffset) {
        if (!this.isValid()) {
            return null;
        }
        var utc = keepOffset !== true,
            m = utc ? this.clone().utc() : this;
        if (m.year() < 0 || m.year() > 9999) {
            return formatMoment(
                m,
                utc
                    ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]'
                    : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ'
            );
        }
        if (isFunction$2(Date.prototype.toISOString)) {
            // native implementation is ~50x faster, use it when we can
            if (utc) {
                return this.toDate().toISOString();
            } else {
                return new Date(this.valueOf() + this.utcOffset() * 60 * 1000)
                    .toISOString()
                    .replace('Z', formatMoment(m, 'Z'));
            }
        }
        return formatMoment(
            m,
            utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ'
        );
    }

    /**
     * Return a human readable representation of a moment that can
     * also be evaluated to get a new moment which is the same
     *
     * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
     */
    function inspect() {
        if (!this.isValid()) {
            return 'moment.invalid(/* ' + this._i + ' */)';
        }
        var func = 'moment',
            zone = '',
            prefix,
            year,
            datetime,
            suffix;
        if (!this.isLocal()) {
            func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
            zone = 'Z';
        }
        prefix = '[' + func + '("]';
        year = 0 <= this.year() && this.year() <= 9999 ? 'YYYY' : 'YYYYYY';
        datetime = '-MM-DD[T]HH:mm:ss.SSS';
        suffix = zone + '[")]';

        return this.format(prefix + year + datetime + suffix);
    }

    function format(inputString) {
        if (!inputString) {
            inputString = this.isUtc()
                ? hooks.defaultFormatUtc
                : hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
    }

    function from(time, withoutSuffix) {
        if (
            this.isValid() &&
            ((isMoment(time) && time.isValid()) || createLocal(time).isValid())
        ) {
            return createDuration({ to: this, from: time })
                .locale(this.locale())
                .humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function fromNow(withoutSuffix) {
        return this.from(createLocal(), withoutSuffix);
    }

    function to(time, withoutSuffix) {
        if (
            this.isValid() &&
            ((isMoment(time) && time.isValid()) || createLocal(time).isValid())
        ) {
            return createDuration({ from: this, to: time })
                .locale(this.locale())
                .humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function toNow(withoutSuffix) {
        return this.to(createLocal(), withoutSuffix);
    }

    // If passed a locale key, it will set the locale for this
    // instance.  Otherwise, it will return the locale configuration
    // variables for this instance.
    function locale(key) {
        var newLocaleData;

        if (key === undefined) {
            return this._locale._abbr;
        } else {
            newLocaleData = getLocale(key);
            if (newLocaleData != null) {
                this._locale = newLocaleData;
            }
            return this;
        }
    }

    var lang = deprecate(
        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
        function (key) {
            if (key === undefined) {
                return this.localeData();
            } else {
                return this.locale(key);
            }
        }
    );

    function localeData() {
        return this._locale;
    }

    var MS_PER_SECOND = 1000,
        MS_PER_MINUTE = 60 * MS_PER_SECOND,
        MS_PER_HOUR = 60 * MS_PER_MINUTE,
        MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;

    // actual modulo - handles negative numbers (for dates before 1970):
    function mod$1(dividend, divisor) {
        return ((dividend % divisor) + divisor) % divisor;
    }

    function localStartOfDate(y, m, d) {
        // the date constructor remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            return new Date(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
            return new Date(y, m, d).valueOf();
        }
    }

    function utcStartOfDate(y, m, d) {
        // Date.UTC remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
            return Date.UTC(y, m, d);
        }
    }

    function startOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond' || !this.isValid()) {
            return this;
        }

        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

        switch (units) {
            case 'year':
                time = startOfDate(this.year(), 0, 1);
                break;
            case 'quarter':
                time = startOfDate(
                    this.year(),
                    this.month() - (this.month() % 3),
                    1
                );
                break;
            case 'month':
                time = startOfDate(this.year(), this.month(), 1);
                break;
            case 'week':
                time = startOfDate(
                    this.year(),
                    this.month(),
                    this.date() - this.weekday()
                );
                break;
            case 'isoWeek':
                time = startOfDate(
                    this.year(),
                    this.month(),
                    this.date() - (this.isoWeekday() - 1)
                );
                break;
            case 'day':
            case 'date':
                time = startOfDate(this.year(), this.month(), this.date());
                break;
            case 'hour':
                time = this._d.valueOf();
                time -= mod$1(
                    time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
                    MS_PER_HOUR
                );
                break;
            case 'minute':
                time = this._d.valueOf();
                time -= mod$1(time, MS_PER_MINUTE);
                break;
            case 'second':
                time = this._d.valueOf();
                time -= mod$1(time, MS_PER_SECOND);
                break;
        }

        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
    }

    function endOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond' || !this.isValid()) {
            return this;
        }

        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

        switch (units) {
            case 'year':
                time = startOfDate(this.year() + 1, 0, 1) - 1;
                break;
            case 'quarter':
                time =
                    startOfDate(
                        this.year(),
                        this.month() - (this.month() % 3) + 3,
                        1
                    ) - 1;
                break;
            case 'month':
                time = startOfDate(this.year(), this.month() + 1, 1) - 1;
                break;
            case 'week':
                time =
                    startOfDate(
                        this.year(),
                        this.month(),
                        this.date() - this.weekday() + 7
                    ) - 1;
                break;
            case 'isoWeek':
                time =
                    startOfDate(
                        this.year(),
                        this.month(),
                        this.date() - (this.isoWeekday() - 1) + 7
                    ) - 1;
                break;
            case 'day':
            case 'date':
                time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
                break;
            case 'hour':
                time = this._d.valueOf();
                time +=
                    MS_PER_HOUR -
                    mod$1(
                        time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
                        MS_PER_HOUR
                    ) -
                    1;
                break;
            case 'minute':
                time = this._d.valueOf();
                time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
                break;
            case 'second':
                time = this._d.valueOf();
                time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
                break;
        }

        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
    }

    function valueOf() {
        return this._d.valueOf() - (this._offset || 0) * 60000;
    }

    function unix() {
        return Math.floor(this.valueOf() / 1000);
    }

    function toDate() {
        return new Date(this.valueOf());
    }

    function toArray() {
        var m = this;
        return [
            m.year(),
            m.month(),
            m.date(),
            m.hour(),
            m.minute(),
            m.second(),
            m.millisecond(),
        ];
    }

    function toObject$1() {
        var m = this;
        return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds(),
        };
    }

    function toJSON() {
        // new Date(NaN).toJSON() === null
        return this.isValid() ? this.toISOString() : null;
    }

    function isValid$2() {
        return isValid(this);
    }

    function parsingFlags() {
        return extend$2({}, getParsingFlags(this));
    }

    function invalidAt() {
        return getParsingFlags(this).overflow;
    }

    function creationData() {
        return {
            input: this._i,
            format: this._f,
            locale: this._locale,
            isUTC: this._isUTC,
            strict: this._strict,
        };
    }

    addFormatToken('N', 0, 0, 'eraAbbr');
    addFormatToken('NN', 0, 0, 'eraAbbr');
    addFormatToken('NNN', 0, 0, 'eraAbbr');
    addFormatToken('NNNN', 0, 0, 'eraName');
    addFormatToken('NNNNN', 0, 0, 'eraNarrow');

    addFormatToken('y', ['y', 1], 'yo', 'eraYear');
    addFormatToken('y', ['yy', 2], 0, 'eraYear');
    addFormatToken('y', ['yyy', 3], 0, 'eraYear');
    addFormatToken('y', ['yyyy', 4], 0, 'eraYear');

    addRegexToken('N', matchEraAbbr);
    addRegexToken('NN', matchEraAbbr);
    addRegexToken('NNN', matchEraAbbr);
    addRegexToken('NNNN', matchEraName);
    addRegexToken('NNNNN', matchEraNarrow);

    addParseToken(['N', 'NN', 'NNN', 'NNNN', 'NNNNN'], function (
        input,
        array,
        config,
        token
    ) {
        var era = config._locale.erasParse(input, token, config._strict);
        if (era) {
            getParsingFlags(config).era = era;
        } else {
            getParsingFlags(config).invalidEra = input;
        }
    });

    addRegexToken('y', matchUnsigned);
    addRegexToken('yy', matchUnsigned);
    addRegexToken('yyy', matchUnsigned);
    addRegexToken('yyyy', matchUnsigned);
    addRegexToken('yo', matchEraYearOrdinal);

    addParseToken(['y', 'yy', 'yyy', 'yyyy'], YEAR);
    addParseToken(['yo'], function (input, array, config, token) {
        var match;
        if (config._locale._eraYearOrdinalRegex) {
            match = input.match(config._locale._eraYearOrdinalRegex);
        }

        if (config._locale.eraYearOrdinalParse) {
            array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
        } else {
            array[YEAR] = parseInt(input, 10);
        }
    });

    function localeEras(m, format) {
        var i,
            l,
            date,
            eras = this._eras || getLocale('en')._eras;
        for (i = 0, l = eras.length; i < l; ++i) {
            switch (typeof eras[i].since) {
                case 'string':
                    // truncate time
                    date = hooks(eras[i].since).startOf('day');
                    eras[i].since = date.valueOf();
                    break;
            }

            switch (typeof eras[i].until) {
                case 'undefined':
                    eras[i].until = +Infinity;
                    break;
                case 'string':
                    // truncate time
                    date = hooks(eras[i].until).startOf('day').valueOf();
                    eras[i].until = date.valueOf();
                    break;
            }
        }
        return eras;
    }

    function localeErasParse(eraName, format, strict) {
        var i,
            l,
            eras = this.eras(),
            name,
            abbr,
            narrow;
        eraName = eraName.toUpperCase();

        for (i = 0, l = eras.length; i < l; ++i) {
            name = eras[i].name.toUpperCase();
            abbr = eras[i].abbr.toUpperCase();
            narrow = eras[i].narrow.toUpperCase();

            if (strict) {
                switch (format) {
                    case 'N':
                    case 'NN':
                    case 'NNN':
                        if (abbr === eraName) {
                            return eras[i];
                        }
                        break;

                    case 'NNNN':
                        if (name === eraName) {
                            return eras[i];
                        }
                        break;

                    case 'NNNNN':
                        if (narrow === eraName) {
                            return eras[i];
                        }
                        break;
                }
            } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
                return eras[i];
            }
        }
    }

    function localeErasConvertYear(era, year) {
        var dir = era.since <= era.until ? +1 : -1;
        if (year === undefined) {
            return hooks(era.since).year();
        } else {
            return hooks(era.since).year() + (year - era.offset) * dir;
        }
    }

    function getEraName() {
        var i,
            l,
            val,
            eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
            // truncate time
            val = this.clone().startOf('day').valueOf();

            if (eras[i].since <= val && val <= eras[i].until) {
                return eras[i].name;
            }
            if (eras[i].until <= val && val <= eras[i].since) {
                return eras[i].name;
            }
        }

        return '';
    }

    function getEraNarrow() {
        var i,
            l,
            val,
            eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
            // truncate time
            val = this.clone().startOf('day').valueOf();

            if (eras[i].since <= val && val <= eras[i].until) {
                return eras[i].narrow;
            }
            if (eras[i].until <= val && val <= eras[i].since) {
                return eras[i].narrow;
            }
        }

        return '';
    }

    function getEraAbbr() {
        var i,
            l,
            val,
            eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
            // truncate time
            val = this.clone().startOf('day').valueOf();

            if (eras[i].since <= val && val <= eras[i].until) {
                return eras[i].abbr;
            }
            if (eras[i].until <= val && val <= eras[i].since) {
                return eras[i].abbr;
            }
        }

        return '';
    }

    function getEraYear() {
        var i,
            l,
            dir,
            val,
            eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
            dir = eras[i].since <= eras[i].until ? +1 : -1;

            // truncate time
            val = this.clone().startOf('day').valueOf();

            if (
                (eras[i].since <= val && val <= eras[i].until) ||
                (eras[i].until <= val && val <= eras[i].since)
            ) {
                return (
                    (this.year() - hooks(eras[i].since).year()) * dir +
                    eras[i].offset
                );
            }
        }

        return this.year();
    }

    function erasNameRegex(isStrict) {
        if (!hasOwnProp(this, '_erasNameRegex')) {
            computeErasParse.call(this);
        }
        return isStrict ? this._erasNameRegex : this._erasRegex;
    }

    function erasAbbrRegex(isStrict) {
        if (!hasOwnProp(this, '_erasAbbrRegex')) {
            computeErasParse.call(this);
        }
        return isStrict ? this._erasAbbrRegex : this._erasRegex;
    }

    function erasNarrowRegex(isStrict) {
        if (!hasOwnProp(this, '_erasNarrowRegex')) {
            computeErasParse.call(this);
        }
        return isStrict ? this._erasNarrowRegex : this._erasRegex;
    }

    function matchEraAbbr(isStrict, locale) {
        return locale.erasAbbrRegex(isStrict);
    }

    function matchEraName(isStrict, locale) {
        return locale.erasNameRegex(isStrict);
    }

    function matchEraNarrow(isStrict, locale) {
        return locale.erasNarrowRegex(isStrict);
    }

    function matchEraYearOrdinal(isStrict, locale) {
        return locale._eraYearOrdinalRegex || matchUnsigned;
    }

    function computeErasParse() {
        var abbrPieces = [],
            namePieces = [],
            narrowPieces = [],
            mixedPieces = [],
            i,
            l,
            eras = this.eras();

        for (i = 0, l = eras.length; i < l; ++i) {
            namePieces.push(regexEscape(eras[i].name));
            abbrPieces.push(regexEscape(eras[i].abbr));
            narrowPieces.push(regexEscape(eras[i].narrow));

            mixedPieces.push(regexEscape(eras[i].name));
            mixedPieces.push(regexEscape(eras[i].abbr));
            mixedPieces.push(regexEscape(eras[i].narrow));
        }

        this._erasRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._erasNameRegex = new RegExp('^(' + namePieces.join('|') + ')', 'i');
        this._erasAbbrRegex = new RegExp('^(' + abbrPieces.join('|') + ')', 'i');
        this._erasNarrowRegex = new RegExp(
            '^(' + narrowPieces.join('|') + ')',
            'i'
        );
    }

    // FORMATTING

    addFormatToken(0, ['gg', 2], 0, function () {
        return this.weekYear() % 100;
    });

    addFormatToken(0, ['GG', 2], 0, function () {
        return this.isoWeekYear() % 100;
    });

    function addWeekYearFormatToken(token, getter) {
        addFormatToken(0, [token, token.length], 0, getter);
    }

    addWeekYearFormatToken('gggg', 'weekYear');
    addWeekYearFormatToken('ggggg', 'weekYear');
    addWeekYearFormatToken('GGGG', 'isoWeekYear');
    addWeekYearFormatToken('GGGGG', 'isoWeekYear');

    // ALIASES

    addUnitAlias('weekYear', 'gg');
    addUnitAlias('isoWeekYear', 'GG');

    // PRIORITY

    addUnitPriority('weekYear', 1);
    addUnitPriority('isoWeekYear', 1);

    // PARSING

    addRegexToken('G', matchSigned);
    addRegexToken('g', matchSigned);
    addRegexToken('GG', match1to2, match2);
    addRegexToken('gg', match1to2, match2);
    addRegexToken('GGGG', match1to4, match4);
    addRegexToken('gggg', match1to4, match4);
    addRegexToken('GGGGG', match1to6, match6);
    addRegexToken('ggggg', match1to6, match6);

    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (
        input,
        week,
        config,
        token
    ) {
        week[token.substr(0, 2)] = toInt(input);
    });

    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
        week[token] = hooks.parseTwoDigitYear(input);
    });

    // MOMENTS

    function getSetWeekYear(input) {
        return getSetWeekYearHelper.call(
            this,
            input,
            this.week(),
            this.weekday(),
            this.localeData()._week.dow,
            this.localeData()._week.doy
        );
    }

    function getSetISOWeekYear(input) {
        return getSetWeekYearHelper.call(
            this,
            input,
            this.isoWeek(),
            this.isoWeekday(),
            1,
            4
        );
    }

    function getISOWeeksInYear() {
        return weeksInYear(this.year(), 1, 4);
    }

    function getISOWeeksInISOWeekYear() {
        return weeksInYear(this.isoWeekYear(), 1, 4);
    }

    function getWeeksInYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }

    function getWeeksInWeekYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
    }

    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
            return weekOfYear(this, dow, doy).year;
        } else {
            weeksTarget = weeksInYear(input, dow, doy);
            if (week > weeksTarget) {
                week = weeksTarget;
            }
            return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
    }

    function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
    }

    // FORMATTING

    addFormatToken('Q', 0, 'Qo', 'quarter');

    // ALIASES

    addUnitAlias('quarter', 'Q');

    // PRIORITY

    addUnitPriority('quarter', 7);

    // PARSING

    addRegexToken('Q', match1);
    addParseToken('Q', function (input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
    });

    // MOMENTS

    function getSetQuarter(input) {
        return input == null
            ? Math.ceil((this.month() + 1) / 3)
            : this.month((input - 1) * 3 + (this.month() % 3));
    }

    // FORMATTING

    addFormatToken('D', ['DD', 2], 'Do', 'date');

    // ALIASES

    addUnitAlias('date', 'D');

    // PRIORITY
    addUnitPriority('date', 9);

    // PARSING

    addRegexToken('D', match1to2);
    addRegexToken('DD', match1to2, match2);
    addRegexToken('Do', function (isStrict, locale) {
        // TODO: Remove "ordinalParse" fallback in next major release.
        return isStrict
            ? locale._dayOfMonthOrdinalParse || locale._ordinalParse
            : locale._dayOfMonthOrdinalParseLenient;
    });

    addParseToken(['D', 'DD'], DATE);
    addParseToken('Do', function (input, array) {
        array[DATE] = toInt(input.match(match1to2)[0]);
    });

    // MOMENTS

    var getSetDayOfMonth = makeGetSet('Date', true);

    // FORMATTING

    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

    // ALIASES

    addUnitAlias('dayOfYear', 'DDD');

    // PRIORITY
    addUnitPriority('dayOfYear', 4);

    // PARSING

    addRegexToken('DDD', match1to3);
    addRegexToken('DDDD', match3);
    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
        config._dayOfYear = toInt(input);
    });

    // HELPERS

    // MOMENTS

    function getSetDayOfYear(input) {
        var dayOfYear =
            Math.round(
                (this.clone().startOf('day') - this.clone().startOf('year')) / 864e5
            ) + 1;
        return input == null ? dayOfYear : this.add(input - dayOfYear, 'd');
    }

    // FORMATTING

    addFormatToken('m', ['mm', 2], 0, 'minute');

    // ALIASES

    addUnitAlias('minute', 'm');

    // PRIORITY

    addUnitPriority('minute', 14);

    // PARSING

    addRegexToken('m', match1to2);
    addRegexToken('mm', match1to2, match2);
    addParseToken(['m', 'mm'], MINUTE);

    // MOMENTS

    var getSetMinute = makeGetSet('Minutes', false);

    // FORMATTING

    addFormatToken('s', ['ss', 2], 0, 'second');

    // ALIASES

    addUnitAlias('second', 's');

    // PRIORITY

    addUnitPriority('second', 15);

    // PARSING

    addRegexToken('s', match1to2);
    addRegexToken('ss', match1to2, match2);
    addParseToken(['s', 'ss'], SECOND);

    // MOMENTS

    var getSetSecond = makeGetSet('Seconds', false);

    // FORMATTING

    addFormatToken('S', 0, 0, function () {
        return ~~(this.millisecond() / 100);
    });

    addFormatToken(0, ['SS', 2], 0, function () {
        return ~~(this.millisecond() / 10);
    });

    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
    addFormatToken(0, ['SSSS', 4], 0, function () {
        return this.millisecond() * 10;
    });
    addFormatToken(0, ['SSSSS', 5], 0, function () {
        return this.millisecond() * 100;
    });
    addFormatToken(0, ['SSSSSS', 6], 0, function () {
        return this.millisecond() * 1000;
    });
    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
        return this.millisecond() * 10000;
    });
    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
        return this.millisecond() * 100000;
    });
    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
        return this.millisecond() * 1000000;
    });

    // ALIASES

    addUnitAlias('millisecond', 'ms');

    // PRIORITY

    addUnitPriority('millisecond', 16);

    // PARSING

    addRegexToken('S', match1to3, match1);
    addRegexToken('SS', match1to3, match2);
    addRegexToken('SSS', match1to3, match3);

    var token, getSetMillisecond;
    for (token = 'SSSS'; token.length <= 9; token += 'S') {
        addRegexToken(token, matchUnsigned);
    }

    function parseMs(input, array) {
        array[MILLISECOND] = toInt(('0.' + input) * 1000);
    }

    for (token = 'S'; token.length <= 9; token += 'S') {
        addParseToken(token, parseMs);
    }

    getSetMillisecond = makeGetSet('Milliseconds', false);

    // FORMATTING

    addFormatToken('z', 0, 0, 'zoneAbbr');
    addFormatToken('zz', 0, 0, 'zoneName');

    // MOMENTS

    function getZoneAbbr() {
        return this._isUTC ? 'UTC' : '';
    }

    function getZoneName() {
        return this._isUTC ? 'Coordinated Universal Time' : '';
    }

    var proto$1 = Moment.prototype;

    proto$1.add = add$1;
    proto$1.calendar = calendar$1;
    proto$1.clone = clone;
    proto$1.diff = diff;
    proto$1.endOf = endOf;
    proto$1.format = format;
    proto$1.from = from;
    proto$1.fromNow = fromNow;
    proto$1.to = to;
    proto$1.toNow = toNow;
    proto$1.get = stringGet;
    proto$1.invalidAt = invalidAt;
    proto$1.isAfter = isAfter;
    proto$1.isBefore = isBefore;
    proto$1.isBetween = isBetween;
    proto$1.isSame = isSame;
    proto$1.isSameOrAfter = isSameOrAfter;
    proto$1.isSameOrBefore = isSameOrBefore;
    proto$1.isValid = isValid$2;
    proto$1.lang = lang;
    proto$1.locale = locale;
    proto$1.localeData = localeData;
    proto$1.max = prototypeMax;
    proto$1.min = prototypeMin;
    proto$1.parsingFlags = parsingFlags;
    proto$1.set = stringSet;
    proto$1.startOf = startOf;
    proto$1.subtract = subtract;
    proto$1.toArray = toArray;
    proto$1.toObject = toObject$1;
    proto$1.toDate = toDate;
    proto$1.toISOString = toISOString;
    proto$1.inspect = inspect;
    if (typeof Symbol !== 'undefined' && Symbol.for != null) {
        proto$1[Symbol.for('nodejs.util.inspect.custom')] = function () {
            return 'Moment<' + this.format() + '>';
        };
    }
    proto$1.toJSON = toJSON;
    proto$1.toString = toString$1;
    proto$1.unix = unix;
    proto$1.valueOf = valueOf;
    proto$1.creationData = creationData;
    proto$1.eraName = getEraName;
    proto$1.eraNarrow = getEraNarrow;
    proto$1.eraAbbr = getEraAbbr;
    proto$1.eraYear = getEraYear;
    proto$1.year = getSetYear;
    proto$1.isLeapYear = getIsLeapYear;
    proto$1.weekYear = getSetWeekYear;
    proto$1.isoWeekYear = getSetISOWeekYear;
    proto$1.quarter = proto$1.quarters = getSetQuarter;
    proto$1.month = getSetMonth;
    proto$1.daysInMonth = getDaysInMonth;
    proto$1.week = proto$1.weeks = getSetWeek;
    proto$1.isoWeek = proto$1.isoWeeks = getSetISOWeek;
    proto$1.weeksInYear = getWeeksInYear;
    proto$1.weeksInWeekYear = getWeeksInWeekYear;
    proto$1.isoWeeksInYear = getISOWeeksInYear;
    proto$1.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
    proto$1.date = getSetDayOfMonth;
    proto$1.day = proto$1.days = getSetDayOfWeek;
    proto$1.weekday = getSetLocaleDayOfWeek;
    proto$1.isoWeekday = getSetISODayOfWeek;
    proto$1.dayOfYear = getSetDayOfYear;
    proto$1.hour = proto$1.hours = getSetHour;
    proto$1.minute = proto$1.minutes = getSetMinute;
    proto$1.second = proto$1.seconds = getSetSecond;
    proto$1.millisecond = proto$1.milliseconds = getSetMillisecond;
    proto$1.utcOffset = getSetOffset;
    proto$1.utc = setOffsetToUTC;
    proto$1.local = setOffsetToLocal;
    proto$1.parseZone = setOffsetToParsedOffset;
    proto$1.hasAlignedHourOffset = hasAlignedHourOffset;
    proto$1.isDST = isDaylightSavingTime;
    proto$1.isLocal = isLocal;
    proto$1.isUtcOffset = isUtcOffset;
    proto$1.isUtc = isUtc;
    proto$1.isUTC = isUtc;
    proto$1.zoneAbbr = getZoneAbbr;
    proto$1.zoneName = getZoneName;
    proto$1.dates = deprecate(
        'dates accessor is deprecated. Use date instead.',
        getSetDayOfMonth
    );
    proto$1.months = deprecate(
        'months accessor is deprecated. Use month instead',
        getSetMonth
    );
    proto$1.years = deprecate(
        'years accessor is deprecated. Use year instead',
        getSetYear
    );
    proto$1.zone = deprecate(
        'moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/',
        getSetZone
    );
    proto$1.isDSTShifted = deprecate(
        'isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information',
        isDaylightSavingTimeShifted
    );

    function createUnix(input) {
        return createLocal(input * 1000);
    }

    function createInZone() {
        return createLocal.apply(null, arguments).parseZone();
    }

    function preParsePostFormat(string) {
        return string;
    }

    var proto$1$1 = Locale.prototype;

    proto$1$1.calendar = calendar;
    proto$1$1.longDateFormat = longDateFormat;
    proto$1$1.invalidDate = invalidDate;
    proto$1$1.ordinal = ordinal;
    proto$1$1.preparse = preParsePostFormat;
    proto$1$1.postformat = preParsePostFormat;
    proto$1$1.relativeTime = relativeTime;
    proto$1$1.pastFuture = pastFuture;
    proto$1$1.set = set$1;
    proto$1$1.eras = localeEras;
    proto$1$1.erasParse = localeErasParse;
    proto$1$1.erasConvertYear = localeErasConvertYear;
    proto$1$1.erasAbbrRegex = erasAbbrRegex;
    proto$1$1.erasNameRegex = erasNameRegex;
    proto$1$1.erasNarrowRegex = erasNarrowRegex;

    proto$1$1.months = localeMonths;
    proto$1$1.monthsShort = localeMonthsShort;
    proto$1$1.monthsParse = localeMonthsParse;
    proto$1$1.monthsRegex = monthsRegex;
    proto$1$1.monthsShortRegex = monthsShortRegex;
    proto$1$1.week = localeWeek;
    proto$1$1.firstDayOfYear = localeFirstDayOfYear;
    proto$1$1.firstDayOfWeek = localeFirstDayOfWeek;

    proto$1$1.weekdays = localeWeekdays;
    proto$1$1.weekdaysMin = localeWeekdaysMin;
    proto$1$1.weekdaysShort = localeWeekdaysShort;
    proto$1$1.weekdaysParse = localeWeekdaysParse;

    proto$1$1.weekdaysRegex = weekdaysRegex;
    proto$1$1.weekdaysShortRegex = weekdaysShortRegex;
    proto$1$1.weekdaysMinRegex = weekdaysMinRegex;

    proto$1$1.isPM = localeIsPM;
    proto$1$1.meridiem = localeMeridiem;

    function get$1$1(format, index, field, setter) {
        var locale = getLocale(),
            utc = createUTC().set(setter, index);
        return locale[field](utc, format);
    }

    function listMonthsImpl(format, index, field) {
        if (isNumber$1(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';

        if (index != null) {
            return get$1$1(format, index, field, 'month');
        }

        var i,
            out = [];
        for (i = 0; i < 12; i++) {
            out[i] = get$1$1(format, i, field, 'month');
        }
        return out;
    }

    // ()
    // (5)
    // (fmt, 5)
    // (fmt)
    // (true)
    // (true, 5)
    // (true, fmt, 5)
    // (true, fmt)
    function listWeekdaysImpl(localeSorted, format, index, field) {
        if (typeof localeSorted === 'boolean') {
            if (isNumber$1(format)) {
                index = format;
                format = undefined;
            }

            format = format || '';
        } else {
            format = localeSorted;
            index = format;
            localeSorted = false;

            if (isNumber$1(format)) {
                index = format;
                format = undefined;
            }

            format = format || '';
        }

        var locale = getLocale(),
            shift = localeSorted ? locale._week.dow : 0,
            i,
            out = [];

        if (index != null) {
            return get$1$1(format, (index + shift) % 7, field, 'day');
        }

        for (i = 0; i < 7; i++) {
            out[i] = get$1$1(format, (i + shift) % 7, field, 'day');
        }
        return out;
    }

    function listMonths(format, index) {
        return listMonthsImpl(format, index, 'months');
    }

    function listMonthsShort(format, index) {
        return listMonthsImpl(format, index, 'monthsShort');
    }

    function listWeekdays(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
    }

    function listWeekdaysShort(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
    }

    function listWeekdaysMin(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
    }

    getSetGlobalLocale('en', {
        eras: [
            {
                since: '0001-01-01',
                until: +Infinity,
                offset: 1,
                name: 'Anno Domini',
                narrow: 'AD',
                abbr: 'AD',
            },
            {
                since: '0000-12-31',
                until: -Infinity,
                offset: 1,
                name: 'Before Christ',
                narrow: 'BC',
                abbr: 'BC',
            },
        ],
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function (number) {
            var b = number % 10,
                output =
                    toInt((number % 100) / 10) === 1
                        ? 'th'
                        : b === 1
                        ? 'st'
                        : b === 2
                        ? 'nd'
                        : b === 3
                        ? 'rd'
                        : 'th';
            return number + output;
        },
    });

    // Side effect imports

    hooks.lang = deprecate(
        'moment.lang is deprecated. Use moment.locale instead.',
        getSetGlobalLocale
    );
    hooks.langData = deprecate(
        'moment.langData is deprecated. Use moment.localeData instead.',
        getLocale
    );

    var mathAbs = Math.abs;

    function abs() {
        var data = this._data;

        this._milliseconds = mathAbs(this._milliseconds);
        this._days = mathAbs(this._days);
        this._months = mathAbs(this._months);

        data.milliseconds = mathAbs(data.milliseconds);
        data.seconds = mathAbs(data.seconds);
        data.minutes = mathAbs(data.minutes);
        data.hours = mathAbs(data.hours);
        data.months = mathAbs(data.months);
        data.years = mathAbs(data.years);

        return this;
    }

    function addSubtract$1(duration, input, value, direction) {
        var other = createDuration(input, value);

        duration._milliseconds += direction * other._milliseconds;
        duration._days += direction * other._days;
        duration._months += direction * other._months;

        return duration._bubble();
    }

    // supports only 2.0-style add(1, 's') or add(duration)
    function add$1$1(input, value) {
        return addSubtract$1(this, input, value, 1);
    }

    // supports only 2.0-style subtract(1, 's') or subtract(duration)
    function subtract$1(input, value) {
        return addSubtract$1(this, input, value, -1);
    }

    function absCeil(number) {
        if (number < 0) {
            return Math.floor(number);
        } else {
            return Math.ceil(number);
        }
    }

    function bubble() {
        var milliseconds = this._milliseconds,
            days = this._days,
            months = this._months,
            data = this._data,
            seconds,
            minutes,
            hours,
            years,
            monthsFromDays;

        // if we have a mix of positive and negative values, bubble down first
        // check: https://github.com/moment/moment/issues/2166
        if (
            !(
                (milliseconds >= 0 && days >= 0 && months >= 0) ||
                (milliseconds <= 0 && days <= 0 && months <= 0)
            )
        ) {
            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
            days = 0;
            months = 0;
        }

        // The following code bubbles up values, see the tests for
        // examples of what that means.
        data.milliseconds = milliseconds % 1000;

        seconds = absFloor(milliseconds / 1000);
        data.seconds = seconds % 60;

        minutes = absFloor(seconds / 60);
        data.minutes = minutes % 60;

        hours = absFloor(minutes / 60);
        data.hours = hours % 24;

        days += absFloor(hours / 24);

        // convert days to months
        monthsFromDays = absFloor(daysToMonths(days));
        months += monthsFromDays;
        days -= absCeil(monthsToDays(monthsFromDays));

        // 12 months -> 1 year
        years = absFloor(months / 12);
        months %= 12;

        data.days = days;
        data.months = months;
        data.years = years;

        return this;
    }

    function daysToMonths(days) {
        // 400 years have 146097 days (taking into account leap year rules)
        // 400 years have 12 months === 4800
        return (days * 4800) / 146097;
    }

    function monthsToDays(months) {
        // the reverse of daysToMonths
        return (months * 146097) / 4800;
    }

    function as(units) {
        if (!this.isValid()) {
            return NaN;
        }
        var days,
            months,
            milliseconds = this._milliseconds;

        units = normalizeUnits(units);

        if (units === 'month' || units === 'quarter' || units === 'year') {
            days = this._days + milliseconds / 864e5;
            months = this._months + daysToMonths(days);
            switch (units) {
                case 'month':
                    return months;
                case 'quarter':
                    return months / 3;
                case 'year':
                    return months / 12;
            }
        } else {
            // handle milliseconds separately because of floating point math errors (issue #1867)
            days = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
                case 'week':
                    return days / 7 + milliseconds / 6048e5;
                case 'day':
                    return days + milliseconds / 864e5;
                case 'hour':
                    return days * 24 + milliseconds / 36e5;
                case 'minute':
                    return days * 1440 + milliseconds / 6e4;
                case 'second':
                    return days * 86400 + milliseconds / 1000;
                // Math.floor prevents floating point math errors here
                case 'millisecond':
                    return Math.floor(days * 864e5) + milliseconds;
                default:
                    throw new Error('Unknown unit ' + units);
            }
        }
    }

    // TODO: Use this.as('ms')?
    function valueOf$1() {
        if (!this.isValid()) {
            return NaN;
        }
        return (
            this._milliseconds +
            this._days * 864e5 +
            (this._months % 12) * 2592e6 +
            toInt(this._months / 12) * 31536e6
        );
    }

    function makeAs(alias) {
        return function () {
            return this.as(alias);
        };
    }

    var asMilliseconds = makeAs('ms'),
        asSeconds = makeAs('s'),
        asMinutes = makeAs('m'),
        asHours = makeAs('h'),
        asDays = makeAs('d'),
        asWeeks = makeAs('w'),
        asMonths = makeAs('M'),
        asQuarters = makeAs('Q'),
        asYears = makeAs('y');

    function clone$1() {
        return createDuration(this);
    }

    function get$2$1(units) {
        units = normalizeUnits(units);
        return this.isValid() ? this[units + 's']() : NaN;
    }

    function makeGetter(name) {
        return function () {
            return this.isValid() ? this._data[name] : NaN;
        };
    }

    var milliseconds = makeGetter('milliseconds'),
        seconds = makeGetter('seconds'),
        minutes = makeGetter('minutes'),
        hours = makeGetter('hours'),
        days = makeGetter('days'),
        months = makeGetter('months'),
        years = makeGetter('years');

    function weeks() {
        return absFloor(this.days() / 7);
    }

    var round = Math.round,
        thresholds = {
            ss: 44, // a few seconds to seconds
            s: 45, // seconds to minute
            m: 45, // minutes to hour
            h: 22, // hours to day
            d: 26, // days to month/week
            w: null, // weeks to month
            M: 11, // months to year
        };

    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function relativeTime$1(posNegDuration, withoutSuffix, thresholds, locale) {
        var duration = createDuration(posNegDuration).abs(),
            seconds = round(duration.as('s')),
            minutes = round(duration.as('m')),
            hours = round(duration.as('h')),
            days = round(duration.as('d')),
            months = round(duration.as('M')),
            weeks = round(duration.as('w')),
            years = round(duration.as('y')),
            a =
                (seconds <= thresholds.ss && ['s', seconds]) ||
                (seconds < thresholds.s && ['ss', seconds]) ||
                (minutes <= 1 && ['m']) ||
                (minutes < thresholds.m && ['mm', minutes]) ||
                (hours <= 1 && ['h']) ||
                (hours < thresholds.h && ['hh', hours]) ||
                (days <= 1 && ['d']) ||
                (days < thresholds.d && ['dd', days]);

        if (thresholds.w != null) {
            a =
                a ||
                (weeks <= 1 && ['w']) ||
                (weeks < thresholds.w && ['ww', weeks]);
        }
        a = a ||
            (months <= 1 && ['M']) ||
            (months < thresholds.M && ['MM', months]) ||
            (years <= 1 && ['y']) || ['yy', years];

        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale;
        return substituteTimeAgo.apply(null, a);
    }

    // This function allows you to set the rounding function for relative time strings
    function getSetRelativeTimeRounding(roundingFunction) {
        if (roundingFunction === undefined) {
            return round;
        }
        if (typeof roundingFunction === 'function') {
            round = roundingFunction;
            return true;
        }
        return false;
    }

    // This function allows you to set a threshold for relative time strings
    function getSetRelativeTimeThreshold(threshold, limit) {
        if (thresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        if (threshold === 's') {
            thresholds.ss = limit - 1;
        }
        return true;
    }

    function humanize$1(argWithSuffix, argThresholds) {
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }

        var withSuffix = false,
            th = thresholds,
            locale,
            output;

        if (typeof argWithSuffix === 'object') {
            argThresholds = argWithSuffix;
            argWithSuffix = false;
        }
        if (typeof argWithSuffix === 'boolean') {
            withSuffix = argWithSuffix;
        }
        if (typeof argThresholds === 'object') {
            th = Object.assign({}, thresholds, argThresholds);
            if (argThresholds.s != null && argThresholds.ss == null) {
                th.ss = argThresholds.s - 1;
            }
        }

        locale = this.localeData();
        output = relativeTime$1(this, !withSuffix, th, locale);

        if (withSuffix) {
            output = locale.pastFuture(+this, output);
        }

        return locale.postformat(output);
    }

    var abs$1 = Math.abs;

    function sign(x) {
        return (x > 0) - (x < 0) || +x;
    }

    function toISOString$1() {
        // for ISO strings we do not use the normal bubbling rules:
        //  * milliseconds bubble up until they become hours
        //  * days do not bubble at all
        //  * months bubble up until they become years
        // This is because there is no context-free conversion between hours and days
        // (think of clock changes)
        // and also not between days and months (28-31 days per month)
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }

        var seconds = abs$1(this._milliseconds) / 1000,
            days = abs$1(this._days),
            months = abs$1(this._months),
            minutes,
            hours,
            years,
            s,
            total = this.asSeconds(),
            totalSign,
            ymSign,
            daysSign,
            hmsSign;

        if (!total) {
            // this is the same as C#'s (Noda) and python (isodate)...
            // but not other JS (goog.date)
            return 'P0D';
        }

        // 3600 seconds -> 60 minutes -> 1 hour
        minutes = absFloor(seconds / 60);
        hours = absFloor(minutes / 60);
        seconds %= 60;
        minutes %= 60;

        // 12 months -> 1 year
        years = absFloor(months / 12);
        months %= 12;

        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
        s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';

        totalSign = total < 0 ? '-' : '';
        ymSign = sign(this._months) !== sign(total) ? '-' : '';
        daysSign = sign(this._days) !== sign(total) ? '-' : '';
        hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';

        return (
            totalSign +
            'P' +
            (years ? ymSign + years + 'Y' : '') +
            (months ? ymSign + months + 'M' : '') +
            (days ? daysSign + days + 'D' : '') +
            (hours || minutes || seconds ? 'T' : '') +
            (hours ? hmsSign + hours + 'H' : '') +
            (minutes ? hmsSign + minutes + 'M' : '') +
            (seconds ? hmsSign + s + 'S' : '')
        );
    }

    var proto$2 = Duration.prototype;

    proto$2.isValid = isValid$1;
    proto$2.abs = abs;
    proto$2.add = add$1$1;
    proto$2.subtract = subtract$1;
    proto$2.as = as;
    proto$2.asMilliseconds = asMilliseconds;
    proto$2.asSeconds = asSeconds;
    proto$2.asMinutes = asMinutes;
    proto$2.asHours = asHours;
    proto$2.asDays = asDays;
    proto$2.asWeeks = asWeeks;
    proto$2.asMonths = asMonths;
    proto$2.asQuarters = asQuarters;
    proto$2.asYears = asYears;
    proto$2.valueOf = valueOf$1;
    proto$2._bubble = bubble;
    proto$2.clone = clone$1;
    proto$2.get = get$2$1;
    proto$2.milliseconds = milliseconds;
    proto$2.seconds = seconds;
    proto$2.minutes = minutes;
    proto$2.hours = hours;
    proto$2.days = days;
    proto$2.weeks = weeks;
    proto$2.months = months;
    proto$2.years = years;
    proto$2.humanize = humanize$1;
    proto$2.toISOString = toISOString$1;
    proto$2.toString = toISOString$1;
    proto$2.toJSON = toISOString$1;
    proto$2.locale = locale;
    proto$2.localeData = localeData;

    proto$2.toIsoString = deprecate(
        'toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)',
        toISOString$1
    );
    proto$2.lang = lang;

    // FORMATTING

    addFormatToken('X', 0, 0, 'unix');
    addFormatToken('x', 0, 0, 'valueOf');

    // PARSING

    addRegexToken('x', matchSigned);
    addRegexToken('X', matchTimestamp);
    addParseToken('X', function (input, array, config) {
        config._d = new Date(parseFloat(input) * 1000);
    });
    addParseToken('x', function (input, array, config) {
        config._d = new Date(toInt(input));
    });

    //! moment.js

    hooks.version = '2.29.1';

    setHookCallback(createLocal);

    hooks.fn = proto$1;
    hooks.min = min;
    hooks.max = max;
    hooks.now = now;
    hooks.utc = createUTC;
    hooks.unix = createUnix;
    hooks.months = listMonths;
    hooks.isDate = isDate$1;
    hooks.locale = getSetGlobalLocale;
    hooks.invalid = createInvalid;
    hooks.duration = createDuration;
    hooks.isMoment = isMoment;
    hooks.weekdays = listWeekdays;
    hooks.parseZone = createInZone;
    hooks.localeData = getLocale;
    hooks.isDuration = isDuration;
    hooks.monthsShort = listMonthsShort;
    hooks.weekdaysMin = listWeekdaysMin;
    hooks.defineLocale = defineLocale;
    hooks.updateLocale = updateLocale;
    hooks.locales = listLocales;
    hooks.weekdaysShort = listWeekdaysShort;
    hooks.normalizeUnits = normalizeUnits;
    hooks.relativeTimeRounding = getSetRelativeTimeRounding;
    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
    hooks.calendarFormat = getCalendarFormat;
    hooks.prototype = proto$1;

    // currently HTML5 input type only supports 24-hour formats
    hooks.HTML5_FMT = {
        DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm', // <input type="datetime-local" />
        DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss', // <input type="datetime-local" step="1" />
        DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS', // <input type="datetime-local" step="0.001" />
        DATE: 'YYYY-MM-DD', // <input type="date" />
        TIME: 'HH:mm', // <input type="time" />
        TIME_SECONDS: 'HH:mm:ss', // <input type="time" step="1" />
        TIME_MS: 'HH:mm:ss.SSS', // <input type="time" step="0.001" />
        WEEK: 'GGGG-[W]WW', // <input type="week" />
        MONTH: 'YYYY-MM', // <input type="month" />
    };

    var pikaday = createCommonjsModule(function (module, exports) {
    /*!
     * Pikaday
     *
     * Copyright © 2014 David Bushell | BSD & MIT license | https://github.com/Pikaday/Pikaday
     */

    (function (root, factory)
    {

        var moment;
        {
            // CommonJS module
            // Load moment.js as an optional dependency
            try { moment = hooks; } catch (e) {}
            module.exports = factory(moment);
        }
    }(commonjsGlobal, function (moment)
    {

        /**
         * feature detection and helper functions
         */
        var hasMoment = typeof moment === 'function',

        hasEventListeners = !!window.addEventListener,

        document = window.document,

        sto = window.setTimeout,

        addEvent = function(el, e, callback, capture)
        {
            if (hasEventListeners) {
                el.addEventListener(e, callback, !!capture);
            } else {
                el.attachEvent('on' + e, callback);
            }
        },

        removeEvent = function(el, e, callback, capture)
        {
            if (hasEventListeners) {
                el.removeEventListener(e, callback, !!capture);
            } else {
                el.detachEvent('on' + e, callback);
            }
        },

        trim = function(str)
        {
            return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g,'');
        },

        hasClass = function(el, cn)
        {
            return (' ' + el.className + ' ').indexOf(' ' + cn + ' ') !== -1;
        },

        addClass = function(el, cn)
        {
            if (!hasClass(el, cn)) {
                el.className = (el.className === '') ? cn : el.className + ' ' + cn;
            }
        },

        removeClass = function(el, cn)
        {
            el.className = trim((' ' + el.className + ' ').replace(' ' + cn + ' ', ' '));
        },

        isArray = function(obj)
        {
            return (/Array/).test(Object.prototype.toString.call(obj));
        },

        isDate = function(obj)
        {
            return (/Date/).test(Object.prototype.toString.call(obj)) && !isNaN(obj.getTime());
        },

        isWeekend = function(date)
        {
            var day = date.getDay();
            return day === 0 || day === 6;
        },

        isLeapYear = function(year)
        {
            // solution by Matti Virkkunen: http://stackoverflow.com/a/4881951
            return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
        },

        getDaysInMonth = function(year, month)
        {
            return [31, isLeapYear(year) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month];
        },

        setToStartOfDay = function(date)
        {
            if (isDate(date)) date.setHours(0,0,0,0);
        },

        compareDates = function(a,b)
        {
            // weak date comparison (use setToStartOfDay(date) to ensure correct result)
            return a.getTime() === b.getTime();
        },

        extend = function(to, from, overwrite)
        {
            var prop, hasProp;
            for (prop in from) {
                hasProp = to[prop] !== undefined;
                if (hasProp && typeof from[prop] === 'object' && from[prop] !== null && from[prop].nodeName === undefined) {
                    if (isDate(from[prop])) {
                        if (overwrite) {
                            to[prop] = new Date(from[prop].getTime());
                        }
                    }
                    else if (isArray(from[prop])) {
                        if (overwrite) {
                            to[prop] = from[prop].slice(0);
                        }
                    } else {
                        to[prop] = extend({}, from[prop], overwrite);
                    }
                } else if (overwrite || !hasProp) {
                    to[prop] = from[prop];
                }
            }
            return to;
        },

        fireEvent = function(el, eventName, data)
        {
            var ev;

            if (document.createEvent) {
                ev = document.createEvent('HTMLEvents');
                ev.initEvent(eventName, true, false);
                ev = extend(ev, data);
                el.dispatchEvent(ev);
            } else if (document.createEventObject) {
                ev = document.createEventObject();
                ev = extend(ev, data);
                el.fireEvent('on' + eventName, ev);
            }
        },

        adjustCalendar = function(calendar) {
            if (calendar.month < 0) {
                calendar.year -= Math.ceil(Math.abs(calendar.month)/12);
                calendar.month += 12;
            }
            if (calendar.month > 11) {
                calendar.year += Math.floor(Math.abs(calendar.month)/12);
                calendar.month -= 12;
            }
            return calendar;
        },

        /**
         * defaults and localisation
         */
        defaults = {

            // bind the picker to a form field
            field: null,

            // automatically show/hide the picker on `field` focus (default `true` if `field` is set)
            bound: undefined,

            // data-attribute on the input field with an aria assistance tekst (only applied when `bound` is set)
            ariaLabel: 'Use the arrow keys to pick a date',

            // position of the datepicker, relative to the field (default to bottom & left)
            // ('bottom' & 'left' keywords are not used, 'top' & 'right' are modifier on the bottom/left position)
            position: 'bottom left',

            // automatically fit in the viewport even if it means repositioning from the position option
            reposition: true,

            // the default output format for `.toString()` and `field` value
            format: 'YYYY-MM-DD',

            // the toString function which gets passed a current date object and format
            // and returns a string
            toString: null,

            // used to create date object from current input string
            parse: null,

            // the initial date to view when first opened
            defaultDate: null,

            // make the `defaultDate` the initial selected value
            setDefaultDate: false,

            // first day of week (0: Sunday, 1: Monday etc)
            firstDay: 0,

            // the default flag for moment's strict date parsing
            formatStrict: false,

            // the minimum/earliest date that can be selected
            minDate: null,
            // the maximum/latest date that can be selected
            maxDate: null,

            // number of years either side, or array of upper/lower range
            yearRange: 10,

            // show week numbers at head of row
            showWeekNumber: false,

            // Week picker mode
            pickWholeWeek: false,

            // used internally (don't config outside)
            minYear: 0,
            maxYear: 9999,
            minMonth: undefined,
            maxMonth: undefined,

            startRange: null,
            endRange: null,

            isRTL: false,

            // Additional text to append to the year in the calendar title
            yearSuffix: '',

            // Render the month after year in the calendar title
            showMonthAfterYear: false,

            // Render days of the calendar grid that fall in the next or previous month
            showDaysInNextAndPreviousMonths: false,

            // Allows user to select days that fall in the next or previous month
            enableSelectionDaysInNextAndPreviousMonths: false,

            // how many months are visible
            numberOfMonths: 1,

            // when numberOfMonths is used, this will help you to choose where the main calendar will be (default `left`, can be set to `right`)
            // only used for the first display or when a selected date is not visible
            mainCalendar: 'left',

            // Specify a DOM element to render the calendar in
            container: undefined,

            // Blur field when date is selected
            blurFieldOnSelect : true,

            // internationalization
            i18n: {
                previousMonth : 'Previous Month',
                nextMonth     : 'Next Month',
                months        : ['January','February','March','April','May','June','July','August','September','October','November','December'],
                weekdays      : ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'],
                weekdaysShort : ['Sun','Mon','Tue','Wed','Thu','Fri','Sat']
            },

            // Theme Classname
            theme: null,

            // events array
            events: [],

            // callback function
            onSelect: null,
            onOpen: null,
            onClose: null,
            onDraw: null,

            // Enable keyboard input
            keyboardInput: true
        },


        /**
         * templating functions to abstract HTML rendering
         */
        renderDayName = function(opts, day, abbr)
        {
            day += opts.firstDay;
            while (day >= 7) {
                day -= 7;
            }
            return abbr ? opts.i18n.weekdaysShort[day] : opts.i18n.weekdays[day];
        },

        renderDay = function(opts)
        {
            var arr = [];
            var ariaSelected = 'false';
            if (opts.isEmpty) {
                if (opts.showDaysInNextAndPreviousMonths) {
                    arr.push('is-outside-current-month');

                    if(!opts.enableSelectionDaysInNextAndPreviousMonths) {
                        arr.push('is-selection-disabled');
                    }

                } else {
                    return '<td class="is-empty"></td>';
                }
            }
            if (opts.isDisabled) {
                arr.push('is-disabled');
            }
            if (opts.isToday) {
                arr.push('is-today');
            }
            if (opts.isSelected) {
                arr.push('is-selected');
                ariaSelected = 'true';
            }
            if (opts.hasEvent) {
                arr.push('has-event');
            }
            if (opts.isInRange) {
                arr.push('is-inrange');
            }
            if (opts.isStartRange) {
                arr.push('is-startrange');
            }
            if (opts.isEndRange) {
                arr.push('is-endrange');
            }
            return '<td data-day="' + opts.day + '" class="' + arr.join(' ') + '" aria-selected="' + ariaSelected + '">' +
                     '<button class="pika-button pika-day" type="button" ' +
                        'data-pika-year="' + opts.year + '" data-pika-month="' + opts.month + '" data-pika-day="' + opts.day + '">' +
                            opts.day +
                     '</button>' +
                   '</td>';
        },

        renderWeek = function (d, m, y) {
            // Lifted from http://javascript.about.com/library/blweekyear.htm, lightly modified.
            var onejan = new Date(y, 0, 1),
                weekNum = Math.ceil((((new Date(y, m, d) - onejan) / 86400000) + onejan.getDay()+1)/7);
            return '<td class="pika-week">' + weekNum + '</td>';
        },

        renderRow = function(days, isRTL, pickWholeWeek, isRowSelected)
        {
            return '<tr class="pika-row' + (pickWholeWeek ? ' pick-whole-week' : '') + (isRowSelected ? ' is-selected' : '') + '">' + (isRTL ? days.reverse() : days).join('') + '</tr>';
        },

        renderBody = function(rows)
        {
            return '<tbody>' + rows.join('') + '</tbody>';
        },

        renderHead = function(opts)
        {
            var i, arr = [];
            if (opts.showWeekNumber) {
                arr.push('<th></th>');
            }
            for (i = 0; i < 7; i++) {
                arr.push('<th scope="col"><abbr title="' + renderDayName(opts, i) + '">' + renderDayName(opts, i, true) + '</abbr></th>');
            }
            return '<thead><tr>' + (opts.isRTL ? arr.reverse() : arr).join('') + '</tr></thead>';
        },

        renderTitle = function(instance, c, year, month, refYear, randId)
        {
            var i, j, arr,
                opts = instance._o,
                isMinYear = year === opts.minYear,
                isMaxYear = year === opts.maxYear,
                html = '<div id="' + randId + '" class="pika-title" role="heading" aria-live="assertive">',
                monthHtml,
                yearHtml,
                prev = true,
                next = true;

            for (arr = [], i = 0; i < 12; i++) {
                arr.push('<option value="' + (year === refYear ? i - c : 12 + i - c) + '"' +
                    (i === month ? ' selected="selected"': '') +
                    ((isMinYear && i < opts.minMonth) || (isMaxYear && i > opts.maxMonth) ? 'disabled="disabled"' : '') + '>' +
                    opts.i18n.months[i] + '</option>');
            }

            monthHtml = '<div class="pika-label">' + opts.i18n.months[month] + '<select class="pika-select pika-select-month" tabindex="-1">' + arr.join('') + '</select></div>';

            if (isArray(opts.yearRange)) {
                i = opts.yearRange[0];
                j = opts.yearRange[1] + 1;
            } else {
                i = year - opts.yearRange;
                j = 1 + year + opts.yearRange;
            }

            for (arr = []; i < j && i <= opts.maxYear; i++) {
                if (i >= opts.minYear) {
                    arr.push('<option value="' + i + '"' + (i === year ? ' selected="selected"': '') + '>' + (i) + '</option>');
                }
            }
            yearHtml = '<div class="pika-label">' + year + opts.yearSuffix + '<select class="pika-select pika-select-year" tabindex="-1">' + arr.join('') + '</select></div>';

            if (opts.showMonthAfterYear) {
                html += yearHtml + monthHtml;
            } else {
                html += monthHtml + yearHtml;
            }

            if (isMinYear && (month === 0 || opts.minMonth >= month)) {
                prev = false;
            }

            if (isMaxYear && (month === 11 || opts.maxMonth <= month)) {
                next = false;
            }

            if (c === 0) {
                html += '<button class="pika-prev' + (prev ? '' : ' is-disabled') + '" type="button">' + opts.i18n.previousMonth + '</button>';
            }
            if (c === (instance._o.numberOfMonths - 1) ) {
                html += '<button class="pika-next' + (next ? '' : ' is-disabled') + '" type="button">' + opts.i18n.nextMonth + '</button>';
            }

            return html += '</div>';
        },

        renderTable = function(opts, data, randId)
        {
            return '<table cellpadding="0" cellspacing="0" class="pika-table" role="grid" aria-labelledby="' + randId + '">' + renderHead(opts) + renderBody(data) + '</table>';
        },


        /**
         * Pikaday constructor
         */
        Pikaday = function(options)
        {
            var self = this,
                opts = self.config(options);

            self._onMouseDown = function(e)
            {
                if (!self._v) {
                    return;
                }
                e = e || window.event;
                var target = e.target || e.srcElement;
                if (!target) {
                    return;
                }

                if (!hasClass(target, 'is-disabled')) {
                    if (hasClass(target, 'pika-button') && !hasClass(target, 'is-empty') && !hasClass(target.parentNode, 'is-disabled')) {
                        self.setDate(new Date(target.getAttribute('data-pika-year'), target.getAttribute('data-pika-month'), target.getAttribute('data-pika-day')));
                        if (opts.bound) {
                            sto(function() {
                                self.hide();
                                if (opts.blurFieldOnSelect && opts.field) {
                                    opts.field.blur();
                                }
                            }, 100);
                        }
                    }
                    else if (hasClass(target, 'pika-prev')) {
                        self.prevMonth();
                    }
                    else if (hasClass(target, 'pika-next')) {
                        self.nextMonth();
                    }
                }
                if (!hasClass(target, 'pika-select')) {
                    // if this is touch event prevent mouse events emulation
                    if (e.preventDefault) {
                        e.preventDefault();
                    } else {
                        e.returnValue = false;
                        return false;
                    }
                } else {
                    self._c = true;
                }
            };

            self._onChange = function(e)
            {
                e = e || window.event;
                var target = e.target || e.srcElement;
                if (!target) {
                    return;
                }
                if (hasClass(target, 'pika-select-month')) {
                    self.gotoMonth(target.value);
                }
                else if (hasClass(target, 'pika-select-year')) {
                    self.gotoYear(target.value);
                }
            };

            self._onKeyChange = function(e)
            {
                e = e || window.event;

                if (self.isVisible()) {

                    switch(e.keyCode){
                        case 13:
                        case 27:
                            if (opts.field) {
                                opts.field.blur();
                            }
                            break;
                        case 37:
                            e.preventDefault();
                            self.adjustDate('subtract', 1);
                            break;
                        case 38:
                            self.adjustDate('subtract', 7);
                            break;
                        case 39:
                            self.adjustDate('add', 1);
                            break;
                        case 40:
                            self.adjustDate('add', 7);
                            break;
                    }
                }
            };

            self._onInputChange = function(e)
            {
                var date;

                if (e.firedBy === self) {
                    return;
                }
                if (opts.parse) {
                    date = opts.parse(opts.field.value, opts.format);
                } else if (hasMoment) {
                    date = moment(opts.field.value, opts.format, opts.formatStrict);
                    date = (date && date.isValid()) ? date.toDate() : null;
                }
                else {
                    date = new Date(Date.parse(opts.field.value));
                }
                if (isDate(date)) {
                  self.setDate(date);
                }
                if (!self._v) {
                    self.show();
                }
            };

            self._onInputFocus = function()
            {
                self.show();
            };

            self._onInputClick = function()
            {
                self.show();
            };

            self._onInputBlur = function()
            {
                // IE allows pika div to gain focus; catch blur the input field
                var pEl = document.activeElement;
                do {
                    if (hasClass(pEl, 'pika-single')) {
                        return;
                    }
                }
                while ((pEl = pEl.parentNode));

                if (!self._c) {
                    self._b = sto(function() {
                        self.hide();
                    }, 50);
                }
                self._c = false;
            };

            self._onClick = function(e)
            {
                e = e || window.event;
                var target = e.target || e.srcElement,
                    pEl = target;
                if (!target) {
                    return;
                }
                if (!hasEventListeners && hasClass(target, 'pika-select')) {
                    if (!target.onchange) {
                        target.setAttribute('onchange', 'return;');
                        addEvent(target, 'change', self._onChange);
                    }
                }
                do {
                    if (hasClass(pEl, 'pika-single') || pEl === opts.trigger) {
                        return;
                    }
                }
                while ((pEl = pEl.parentNode));
                if (self._v && target !== opts.trigger && pEl !== opts.trigger) {
                    self.hide();
                }
            };

            self.el = document.createElement('div');
            self.el.className = 'pika-single' + (opts.isRTL ? ' is-rtl' : '') + (opts.theme ? ' ' + opts.theme : '');

            addEvent(self.el, 'mousedown', self._onMouseDown, true);
            addEvent(self.el, 'touchend', self._onMouseDown, true);
            addEvent(self.el, 'change', self._onChange);

            if (opts.keyboardInput) {
                addEvent(document, 'keydown', self._onKeyChange);
            }

            if (opts.field) {
                if (opts.container) {
                    opts.container.appendChild(self.el);
                } else if (opts.bound) {
                    document.body.appendChild(self.el);
                } else {
                    opts.field.parentNode.insertBefore(self.el, opts.field.nextSibling);
                }
                addEvent(opts.field, 'change', self._onInputChange);

                if (!opts.defaultDate) {
                    if (hasMoment && opts.field.value) {
                        opts.defaultDate = moment(opts.field.value, opts.format).toDate();
                    } else {
                        opts.defaultDate = new Date(Date.parse(opts.field.value));
                    }
                    opts.setDefaultDate = true;
                }
            }

            var defDate = opts.defaultDate;

            if (isDate(defDate)) {
                if (opts.setDefaultDate) {
                    self.setDate(defDate, true);
                } else {
                    self.gotoDate(defDate);
                }
            } else {
                self.gotoDate(new Date());
            }

            if (opts.bound) {
                this.hide();
                self.el.className += ' is-bound';
                addEvent(opts.trigger, 'click', self._onInputClick);
                addEvent(opts.trigger, 'focus', self._onInputFocus);
                addEvent(opts.trigger, 'blur', self._onInputBlur);
            } else {
                this.show();
            }
        };


        /**
         * public Pikaday API
         */
        Pikaday.prototype = {


            /**
             * configure functionality
             */
            config: function(options)
            {
                if (!this._o) {
                    this._o = extend({}, defaults, true);
                }

                var opts = extend(this._o, options, true);

                opts.isRTL = !!opts.isRTL;

                opts.field = (opts.field && opts.field.nodeName) ? opts.field : null;

                opts.theme = (typeof opts.theme) === 'string' && opts.theme ? opts.theme : null;

                opts.bound = !!(opts.bound !== undefined ? opts.field && opts.bound : opts.field);

                opts.trigger = (opts.trigger && opts.trigger.nodeName) ? opts.trigger : opts.field;

                opts.disableWeekends = !!opts.disableWeekends;

                opts.disableDayFn = (typeof opts.disableDayFn) === 'function' ? opts.disableDayFn : null;

                var nom = parseInt(opts.numberOfMonths, 10) || 1;
                opts.numberOfMonths = nom > 4 ? 4 : nom;

                if (!isDate(opts.minDate)) {
                    opts.minDate = false;
                }
                if (!isDate(opts.maxDate)) {
                    opts.maxDate = false;
                }
                if ((opts.minDate && opts.maxDate) && opts.maxDate < opts.minDate) {
                    opts.maxDate = opts.minDate = false;
                }
                if (opts.minDate) {
                    this.setMinDate(opts.minDate);
                }
                if (opts.maxDate) {
                    this.setMaxDate(opts.maxDate);
                }

                if (isArray(opts.yearRange)) {
                    var fallback = new Date().getFullYear() - 10;
                    opts.yearRange[0] = parseInt(opts.yearRange[0], 10) || fallback;
                    opts.yearRange[1] = parseInt(opts.yearRange[1], 10) || fallback;
                } else {
                    opts.yearRange = Math.abs(parseInt(opts.yearRange, 10)) || defaults.yearRange;
                    if (opts.yearRange > 100) {
                        opts.yearRange = 100;
                    }
                }

                return opts;
            },

            /**
             * return a formatted string of the current selection (using Moment.js if available)
             */
            toString: function(format)
            {
                format = format || this._o.format;
                if (!isDate(this._d)) {
                    return '';
                }
                if (this._o.toString) {
                  return this._o.toString(this._d, format);
                }
                if (hasMoment) {
                  return moment(this._d).format(format);
                }
                return this._d.toDateString();
            },

            /**
             * return a Moment.js object of the current selection (if available)
             */
            getMoment: function()
            {
                return hasMoment ? moment(this._d) : null;
            },

            /**
             * set the current selection from a Moment.js object (if available)
             */
            setMoment: function(date, preventOnSelect)
            {
                if (hasMoment && moment.isMoment(date)) {
                    this.setDate(date.toDate(), preventOnSelect);
                }
            },

            /**
             * return a Date object of the current selection
             */
            getDate: function()
            {
                return isDate(this._d) ? new Date(this._d.getTime()) : null;
            },

            /**
             * set the current selection
             */
            setDate: function(date, preventOnSelect)
            {
                if (!date) {
                    this._d = null;

                    if (this._o.field) {
                        this._o.field.value = '';
                        fireEvent(this._o.field, 'change', { firedBy: this });
                    }

                    return this.draw();
                }
                if (typeof date === 'string') {
                    date = new Date(Date.parse(date));
                }
                if (!isDate(date)) {
                    return;
                }

                var min = this._o.minDate,
                    max = this._o.maxDate;

                if (isDate(min) && date < min) {
                    date = min;
                } else if (isDate(max) && date > max) {
                    date = max;
                }

                this._d = new Date(date.getTime());
                setToStartOfDay(this._d);
                this.gotoDate(this._d);

                if (this._o.field) {
                    this._o.field.value = this.toString();
                    fireEvent(this._o.field, 'change', { firedBy: this });
                }
                if (!preventOnSelect && typeof this._o.onSelect === 'function') {
                    this._o.onSelect.call(this, this.getDate());
                }
            },

            /**
             * change view to a specific date
             */
            gotoDate: function(date)
            {
                var newCalendar = true;

                if (!isDate(date)) {
                    return;
                }

                if (this.calendars) {
                    var firstVisibleDate = new Date(this.calendars[0].year, this.calendars[0].month, 1),
                        lastVisibleDate = new Date(this.calendars[this.calendars.length-1].year, this.calendars[this.calendars.length-1].month, 1),
                        visibleDate = date.getTime();
                    // get the end of the month
                    lastVisibleDate.setMonth(lastVisibleDate.getMonth()+1);
                    lastVisibleDate.setDate(lastVisibleDate.getDate()-1);
                    newCalendar = (visibleDate < firstVisibleDate.getTime() || lastVisibleDate.getTime() < visibleDate);
                }

                if (newCalendar) {
                    this.calendars = [{
                        month: date.getMonth(),
                        year: date.getFullYear()
                    }];
                    if (this._o.mainCalendar === 'right') {
                        this.calendars[0].month += 1 - this._o.numberOfMonths;
                    }
                }

                this.adjustCalendars();
            },

            adjustDate: function(sign, days) {

                var day = this.getDate() || new Date();
                var difference = parseInt(days)*24*60*60*1000;

                var newDay;

                if (sign === 'add') {
                    newDay = new Date(day.valueOf() + difference);
                } else if (sign === 'subtract') {
                    newDay = new Date(day.valueOf() - difference);
                }

                this.setDate(newDay);
            },

            adjustCalendars: function() {
                this.calendars[0] = adjustCalendar(this.calendars[0]);
                for (var c = 1; c < this._o.numberOfMonths; c++) {
                    this.calendars[c] = adjustCalendar({
                        month: this.calendars[0].month + c,
                        year: this.calendars[0].year
                    });
                }
                this.draw();
            },

            gotoToday: function()
            {
                this.gotoDate(new Date());
            },

            /**
             * change view to a specific month (zero-index, e.g. 0: January)
             */
            gotoMonth: function(month)
            {
                if (!isNaN(month)) {
                    this.calendars[0].month = parseInt(month, 10);
                    this.adjustCalendars();
                }
            },

            nextMonth: function()
            {
                this.calendars[0].month++;
                this.adjustCalendars();
            },

            prevMonth: function()
            {
                this.calendars[0].month--;
                this.adjustCalendars();
            },

            /**
             * change view to a specific full year (e.g. "2012")
             */
            gotoYear: function(year)
            {
                if (!isNaN(year)) {
                    this.calendars[0].year = parseInt(year, 10);
                    this.adjustCalendars();
                }
            },

            /**
             * change the minDate
             */
            setMinDate: function(value)
            {
                if(value instanceof Date) {
                    setToStartOfDay(value);
                    this._o.minDate = value;
                    this._o.minYear  = value.getFullYear();
                    this._o.minMonth = value.getMonth();
                } else {
                    this._o.minDate = defaults.minDate;
                    this._o.minYear  = defaults.minYear;
                    this._o.minMonth = defaults.minMonth;
                    this._o.startRange = defaults.startRange;
                }

                this.draw();
            },

            /**
             * change the maxDate
             */
            setMaxDate: function(value)
            {
                if(value instanceof Date) {
                    setToStartOfDay(value);
                    this._o.maxDate = value;
                    this._o.maxYear = value.getFullYear();
                    this._o.maxMonth = value.getMonth();
                } else {
                    this._o.maxDate = defaults.maxDate;
                    this._o.maxYear = defaults.maxYear;
                    this._o.maxMonth = defaults.maxMonth;
                    this._o.endRange = defaults.endRange;
                }

                this.draw();
            },

            setStartRange: function(value)
            {
                this._o.startRange = value;
            },

            setEndRange: function(value)
            {
                this._o.endRange = value;
            },

            /**
             * refresh the HTML
             */
            draw: function(force)
            {
                if (!this._v && !force) {
                    return;
                }
                var opts = this._o,
                    minYear = opts.minYear,
                    maxYear = opts.maxYear,
                    minMonth = opts.minMonth,
                    maxMonth = opts.maxMonth,
                    html = '',
                    randId;

                if (this._y <= minYear) {
                    this._y = minYear;
                    if (!isNaN(minMonth) && this._m < minMonth) {
                        this._m = minMonth;
                    }
                }
                if (this._y >= maxYear) {
                    this._y = maxYear;
                    if (!isNaN(maxMonth) && this._m > maxMonth) {
                        this._m = maxMonth;
                    }
                }

                randId = 'pika-title-' + Math.random().toString(36).replace(/[^a-z]+/g, '').substr(0, 2);

                for (var c = 0; c < opts.numberOfMonths; c++) {
                    html += '<div class="pika-lendar">' + renderTitle(this, c, this.calendars[c].year, this.calendars[c].month, this.calendars[0].year, randId) + this.render(this.calendars[c].year, this.calendars[c].month, randId) + '</div>';
                }

                this.el.innerHTML = html;

                if (opts.bound) {
                    if(opts.field.type !== 'hidden') {
                        sto(function() {
                            opts.trigger.focus();
                        }, 1);
                    }
                }

                if (typeof this._o.onDraw === 'function') {
                    this._o.onDraw(this);
                }

                if (opts.bound) {
                    // let the screen reader user know to use arrow keys
                    opts.field.setAttribute('aria-label', opts.ariaLabel);
                }
            },

            adjustPosition: function()
            {
                var field, pEl, width, height, viewportWidth, viewportHeight, scrollTop, left, top, clientRect, leftAligned, bottomAligned;

                if (this._o.container) return;

                this.el.style.position = 'absolute';

                field = this._o.trigger;
                pEl = field;
                width = this.el.offsetWidth;
                height = this.el.offsetHeight;
                viewportWidth = window.innerWidth || document.documentElement.clientWidth;
                viewportHeight = window.innerHeight || document.documentElement.clientHeight;
                scrollTop = window.pageYOffset || document.body.scrollTop || document.documentElement.scrollTop;
                leftAligned = true;
                bottomAligned = true;

                if (typeof field.getBoundingClientRect === 'function') {
                    clientRect = field.getBoundingClientRect();
                    left = clientRect.left + window.pageXOffset;
                    top = clientRect.bottom + window.pageYOffset;
                } else {
                    left = pEl.offsetLeft;
                    top  = pEl.offsetTop + pEl.offsetHeight;
                    while((pEl = pEl.offsetParent)) {
                        left += pEl.offsetLeft;
                        top  += pEl.offsetTop;
                    }
                }

                // default position is bottom & left
                if ((this._o.reposition && left + width > viewportWidth) ||
                    (
                        this._o.position.indexOf('right') > -1 &&
                        left - width + field.offsetWidth > 0
                    )
                ) {
                    left = left - width + field.offsetWidth;
                    leftAligned = false;
                }
                if ((this._o.reposition && top + height > viewportHeight + scrollTop) ||
                    (
                        this._o.position.indexOf('top') > -1 &&
                        top - height - field.offsetHeight > 0
                    )
                ) {
                    top = top - height - field.offsetHeight;
                    bottomAligned = false;
                }

                this.el.style.left = left + 'px';
                this.el.style.top = top + 'px';

                addClass(this.el, leftAligned ? 'left-aligned' : 'right-aligned');
                addClass(this.el, bottomAligned ? 'bottom-aligned' : 'top-aligned');
                removeClass(this.el, !leftAligned ? 'left-aligned' : 'right-aligned');
                removeClass(this.el, !bottomAligned ? 'bottom-aligned' : 'top-aligned');
            },

            /**
             * render HTML for a particular month
             */
            render: function(year, month, randId)
            {
                var opts   = this._o,
                    now    = new Date(),
                    days   = getDaysInMonth(year, month),
                    before = new Date(year, month, 1).getDay(),
                    data   = [],
                    row    = [];
                setToStartOfDay(now);
                if (opts.firstDay > 0) {
                    before -= opts.firstDay;
                    if (before < 0) {
                        before += 7;
                    }
                }
                var previousMonth = month === 0 ? 11 : month - 1,
                    nextMonth = month === 11 ? 0 : month + 1,
                    yearOfPreviousMonth = month === 0 ? year - 1 : year,
                    yearOfNextMonth = month === 11 ? year + 1 : year,
                    daysInPreviousMonth = getDaysInMonth(yearOfPreviousMonth, previousMonth);
                var cells = days + before,
                    after = cells;
                while(after > 7) {
                    after -= 7;
                }
                cells += 7 - after;
                var isWeekSelected = false;
                for (var i = 0, r = 0; i < cells; i++)
                {
                    var day = new Date(year, month, 1 + (i - before)),
                        isSelected = isDate(this._d) ? compareDates(day, this._d) : false,
                        isToday = compareDates(day, now),
                        hasEvent = opts.events.indexOf(day.toDateString()) !== -1 ? true : false,
                        isEmpty = i < before || i >= (days + before),
                        dayNumber = 1 + (i - before),
                        monthNumber = month,
                        yearNumber = year,
                        isStartRange = opts.startRange && compareDates(opts.startRange, day),
                        isEndRange = opts.endRange && compareDates(opts.endRange, day),
                        isInRange = opts.startRange && opts.endRange && opts.startRange < day && day < opts.endRange,
                        isDisabled = (opts.minDate && day < opts.minDate) ||
                                     (opts.maxDate && day > opts.maxDate) ||
                                     (opts.disableWeekends && isWeekend(day)) ||
                                     (opts.disableDayFn && opts.disableDayFn(day));

                    if (isEmpty) {
                        if (i < before) {
                            dayNumber = daysInPreviousMonth + dayNumber;
                            monthNumber = previousMonth;
                            yearNumber = yearOfPreviousMonth;
                        } else {
                            dayNumber = dayNumber - days;
                            monthNumber = nextMonth;
                            yearNumber = yearOfNextMonth;
                        }
                    }

                    var dayConfig = {
                            day: dayNumber,
                            month: monthNumber,
                            year: yearNumber,
                            hasEvent: hasEvent,
                            isSelected: isSelected,
                            isToday: isToday,
                            isDisabled: isDisabled,
                            isEmpty: isEmpty,
                            isStartRange: isStartRange,
                            isEndRange: isEndRange,
                            isInRange: isInRange,
                            showDaysInNextAndPreviousMonths: opts.showDaysInNextAndPreviousMonths,
                            enableSelectionDaysInNextAndPreviousMonths: opts.enableSelectionDaysInNextAndPreviousMonths
                        };

                    if (opts.pickWholeWeek && isSelected) {
                        isWeekSelected = true;
                    }

                    row.push(renderDay(dayConfig));

                    if (++r === 7) {
                        if (opts.showWeekNumber) {
                            row.unshift(renderWeek(i - before, month, year));
                        }
                        data.push(renderRow(row, opts.isRTL, opts.pickWholeWeek, isWeekSelected));
                        row = [];
                        r = 0;
                        isWeekSelected = false;
                    }
                }
                return renderTable(opts, data, randId);
            },

            isVisible: function()
            {
                return this._v;
            },

            show: function()
            {
                if (!this.isVisible()) {
                    this._v = true;
                    this.draw();
                    removeClass(this.el, 'is-hidden');
                    if (this._o.bound) {
                        addEvent(document, 'click', this._onClick);
                        this.adjustPosition();
                    }
                    if (typeof this._o.onOpen === 'function') {
                        this._o.onOpen.call(this);
                    }
                }
            },

            hide: function()
            {
                var v = this._v;
                if (v !== false) {
                    if (this._o.bound) {
                        removeEvent(document, 'click', this._onClick);
                    }
                    this.el.style.position = 'static'; // reset
                    this.el.style.left = 'auto';
                    this.el.style.top = 'auto';
                    addClass(this.el, 'is-hidden');
                    this._v = false;
                    if (v !== undefined && typeof this._o.onClose === 'function') {
                        this._o.onClose.call(this);
                    }
                }
            },

            /**
             * GAME OVER
             */
            destroy: function()
            {
                var opts = this._o;

                this.hide();
                removeEvent(this.el, 'mousedown', this._onMouseDown, true);
                removeEvent(this.el, 'touchend', this._onMouseDown, true);
                removeEvent(this.el, 'change', this._onChange);
                if (opts.keyboardInput) {
                    removeEvent(document, 'keydown', this._onKeyChange);
                }
                if (opts.field) {
                    removeEvent(opts.field, 'change', this._onInputChange);
                    if (opts.bound) {
                        removeEvent(opts.trigger, 'click', this._onInputClick);
                        removeEvent(opts.trigger, 'focus', this._onInputFocus);
                        removeEvent(opts.trigger, 'blur', this._onInputBlur);
                    }
                }
                if (this.el.parentNode) {
                    this.el.parentNode.removeChild(this.el);
                }
            }

        };

        return Pikaday;
    }));
    });

    /* src\core\ui\inputs\Date.html generated by Svelte v2.16.1 */

    function oncreate$4() {
    	const { field } = this.get();

    	// eslint-disable-next-line no-new
    	new pikaday({
    		field: this.refs.container,
    		format: "YYYY-MM-DD",
    		async onSelect(date) {
    			await field.init(date.toISOString());
    		}
    	});

    	const formElement = this.refs.container;
    	formElement.addEventListener("change", () => {
    		if (formElement.value === "") {
    			field.init(null);
    		}
    	});
    }
    const file$a = "src\\core\\ui\\inputs\\Date.html";

    function create_main_fragment$a(component, ctx) {
    	var input, input_updating = false, input_required_value;

    	function input_input_handler() {
    		input_updating = true;
    		ctx.field.valueAsText = input.value;
    		component.set({ field: ctx.field });
    		input_updating = false;
    	}

    	return {
    		c: function create() {
    			input = createElement("input");
    			addListener(input, "input", input_input_handler);
    			setAttribute(input, "type", "text");
    			input.id = ctx.id;
    			input.required = input_required_value = ctx.field.metadata.required;
    			input.tabIndex = ctx.tabindex;
    			input.autocomplete = "off";
    			input.className = "form-control";
    			addLoc(input, file$a, 0, 0, 0);
    		},

    		m: function mount(target, anchor) {
    			insert(target, input, anchor);
    			component.refs.container = input;

    			input.value = ctx.field.valueAsText;
    		},

    		p: function update(changed, _ctx) {
    			ctx = _ctx;
    			if (!input_updating && changed.field) input.value = ctx.field.valueAsText;
    			if (changed.id) {
    				input.id = ctx.id;
    			}

    			if ((changed.field) && input_required_value !== (input_required_value = ctx.field.metadata.required)) {
    				input.required = input_required_value;
    			}

    			if (changed.tabindex) {
    				input.tabIndex = ctx.tabindex;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(input);
    			}

    			removeListener(input, "input", input_input_handler);
    			if (component.refs.container === input) component.refs.container = null;
    		}
    	};
    }

    function SvelteComponent$a(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) {
    		throw new Error("'target' is a required option");
    	}

    	init(this, options);
    	this.refs = {};
    	this._state = assign({}, options.data);
    	if (!('id' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'id'");
    	if (!('field' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'field'");
    	if (!('tabindex' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'tabindex'");
    	this._intro = true;

    	this._fragment = create_main_fragment$a(this, this._state);

    	this.root._oncreate.push(() => {
    		oncreate$4.call(this);
    		this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
    	});

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);

    		flush(this);
    	}
    }

    assign(SvelteComponent$a.prototype, protoDev);

    SvelteComponent$a.prototype._checkReadOnly = function _checkReadOnly(newState) {
    };

    var pikaday$1 = createCommonjsModule(function (module, exports) {
    /*!
     * Pikaday
     *
     * Copyright © 2014 David Bushell | BSD & MIT license | https://github.com/dbushell/Pikaday
     */

    (function (root, factory)
    {

        var moment;
        {
            // CommonJS module
            // Load moment.js as an optional dependency
            try { moment = hooks; } catch (e) {}
            module.exports = factory(moment);
        }
    }(commonjsGlobal, function (moment)
    {

        /**
         * feature detection and helper functions
         */
        var hasMoment = typeof moment === 'function',

        hasEventListeners = !!window.addEventListener,

        document = window.document,

        sto = window.setTimeout,

        addEvent = function(el, e, callback, capture)
        {
            if (hasEventListeners) {
                el.addEventListener(e, callback, !!capture);
            } else {
                el.attachEvent('on' + e, callback);
            }
        },

        removeEvent = function(el, e, callback, capture)
        {
            if (hasEventListeners) {
                el.removeEventListener(e, callback, !!capture);
            } else {
                el.detachEvent('on' + e, callback);
            }
        },

        trim = function(str)
        {
            return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g,'');
        },

        hasClass = function(el, cn)
        {
            return (' ' + el.className + ' ').indexOf(' ' + cn + ' ') !== -1;
        },

        addClass = function(el, cn)
        {
            if (!hasClass(el, cn)) {
                el.className = (el.className === '') ? cn : el.className + ' ' + cn;
            }
        },

        removeClass = function(el, cn)
        {
            el.className = trim((' ' + el.className + ' ').replace(' ' + cn + ' ', ' '));
        },

        isArray = function(obj)
        {
            return (/Array/).test(Object.prototype.toString.call(obj));
        },

        isDate = function(obj)
        {
            return (/Date/).test(Object.prototype.toString.call(obj)) && !isNaN(obj.getTime());
        },

        isWeekend = function(date)
        {
            var day = date.getDay();
            return day === 0 || day === 6;
        },

        isLeapYear = function(year)
        {
            // solution by Matti Virkkunen: http://stackoverflow.com/a/4881951
            return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
        },

        getDaysInMonth = function(year, month)
        {
            return [31, isLeapYear(year) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month];
        },

        setToStartOfDay = function(date)
        {
            if (isDate(date)) date.setHours(0,0,0,0);
        },

        compareDates = function(a,b)
        {
            // Copy so we don't change the dates being passed in
            var _a = new Date(a.getTime());
            var _b = new Date(b.getTime());
            setToStartOfDay(_a);
            setToStartOfDay(_b);
            return _a.getTime() === _b.getTime();
        },

        extend = function(to, from, overwrite)
        {
            var prop, hasProp;
            for (prop in from) {
                hasProp = to[prop] !== undefined;
                if (hasProp && typeof from[prop] === 'object' && from[prop] !== null && from[prop].nodeName === undefined) {
                    if (isDate(from[prop])) {
                        if (overwrite) {
                            to[prop] = new Date(from[prop].getTime());
                        }
                    }
                    else if (isArray(from[prop])) {
                        if (overwrite) {
                            to[prop] = from[prop].slice(0);
                        }
                    } else {
                        to[prop] = extend({}, from[prop], overwrite);
                    }
                } else if (overwrite || !hasProp) {
                    to[prop] = from[prop];
                }
            }
            return to;
        },

        fireEvent = function(el, eventName, data)
        {
            var ev;

            if (document.createEvent) {
                ev = document.createEvent('HTMLEvents');
                ev.initEvent(eventName, true, false);
                ev = extend(ev, data);
                el.dispatchEvent(ev);
            } else if (document.createEventObject) {
                ev = document.createEventObject();
                ev = extend(ev, data);
                el.fireEvent('on' + eventName, ev);
            }
        },

        adjustCalendar = function(calendar) {
            if (calendar.month < 0) {
                calendar.year -= Math.ceil(Math.abs(calendar.month)/12);
                calendar.month += 12;
            }
            if (calendar.month > 11) {
                calendar.year += Math.floor(Math.abs(calendar.month)/12);
                calendar.month -= 12;
            }
            return calendar;
        },

        /**
         * defaults and localisation
         */
        defaults = {
            // bind the picker to a form field
            field: null,

            // automatically show/hide the picker on `field` focus (default `true` if `field` is set)
            bound: undefined,

            // data-attribute on the input field with an aria assistance tekst (only applied when `bound` is set)
            ariaLabel: 'Use the arrow keys to pick a date',

            // position of the datepicker, relative to the field (default to bottom & left)
            // ('bottom' & 'left' keywords are not used, 'top' & 'right' are modifier on the bottom/left position)
            position: 'bottom left',

            // automatically fit in the viewport even if it means repositioning from the position option
            reposition: true,

            // the default output format for `.toString()` and `field` value
            // set in `config` based on if showTime is set
            format: null,

            // an array giving the allowable input format(s).  As with moment,
            // the input formats may be either a single string or an array of strings.
            // Usually set in `config`
            inputFormats: null,

            // the toString function which gets passed a current date object and format
            // and returns a string
            toString: null,

            // used to create date object from current input string
            parse: null,

            // the initial date to view when first opened
            defaultDate: null,

            // make the `defaultDate` the initial selected value
            setDefaultDate: false,

            // first day of week (0: Sunday, 1: Monday etc)
            firstDay: 0,

            // the default flag for moment's strict date parsing
            formatStrict: false,

            // the minimum/earliest date that can be selected
            minDate: null,
            // the maximum/latest date that can be selected
            maxDate: null,

            // number of years either side, or array of upper/lower range
            yearRange: 10,

            // show week numbers at head of row
            showWeekNumber: false,

            // Week picker mode
            pickWholeWeek: false,

            // used internally (don't config outside)
            minYear: 0,
            maxYear: 9999,
            minMonth: undefined,
            maxMonth: undefined,

            startRange: null,
            endRange: null,

            isRTL: false,

            // Additional text to append to the year in the calendar title
            yearSuffix: '',

            // Render the month after year in the calendar title
            showMonthAfterYear: false,

            // Render days of the calendar grid that fall in the next or previous month
            showDaysInNextAndPreviousMonths: false,

            // Allows user to select days that fall in the next or previous month
            enableSelectionDaysInNextAndPreviousMonths: false,

            // how many months are visible
            numberOfMonths: 1,

            // time
            showTime: true,
            showMinutes: true,
            showSeconds: false,
            use24hour: false,
            incrementHourBy: 1,
            incrementMinuteBy: 1,
            incrementSecondBy: 1,
            timeLabel: null,

            // option to prevent calendar from auto-closing after date is selected
            autoClose: true,

            // when numberOfMonths is used, this will help you to choose where the main calendar will be (default `left`, can be set to `right`)
            // only used for the first display or when a selected date is not visible
            mainCalendar: 'left',

            // Specify a DOM element to render the calendar in
            container: undefined,

            // Blur field when date is selected
            blurFieldOnSelect : true,

            // internationalization
            i18n: {
                previousMonth : 'Previous Month',
                nextMonth     : 'Next Month',
                months        : ['January','February','March','April','May','June','July','August','September','October','November','December'],
                weekdays      : ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'],
                weekdaysShort : ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'],
                midnight      : 'Midnight',
                noon          : 'Noon'
            },

            // Theme Classname
            theme: null,

            // events array
            events: [],

            // callback function
            onSelect: null,
            onOpen: null,
            onClose: null,
            onDraw: null,

            // Enable keyboard input
            keyboardInput: true
        },


        /**
         * templating functions to abstract HTML rendering
         */
        renderDayName = function(opts, day, abbr)
        {
            day += opts.firstDay;
            while (day >= 7) {
                day -= 7;
            }
            return abbr ? opts.i18n.weekdaysShort[day] : opts.i18n.weekdays[day];
        },

        renderDay = function(opts)
        {
            var arr = [];
            var ariaSelected = 'false';
            if (opts.isEmpty) {
                if (opts.showDaysInNextAndPreviousMonths) {
                    arr.push('is-outside-current-month');

                    if(!opts.enableSelectionDaysInNextAndPreviousMonths) {
                        arr.push('is-selection-disabled');
                    }

                } else {
                    return '<td class="is-empty"></td>';
                }
            }
            if (opts.isDisabled) {
                arr.push('is-disabled');
            }
            if (opts.isToday) {
                arr.push('is-today');
            }
            if (opts.isSelected) {
                arr.push('is-selected');
                ariaSelected = 'true';
            }
            if (opts.hasEvent) {
                arr.push('has-event');
            }
            if (opts.isInRange) {
                arr.push('is-inrange');
            }
            if (opts.isStartRange) {
                arr.push('is-startrange');
            }
            if (opts.isEndRange) {
                arr.push('is-endrange');
            }
            return '<td data-day="' + opts.day + '" class="' + arr.join(' ') + '" aria-selected="' + ariaSelected + '">' +
                     '<button class="pika-button pika-day" type="button" ' +
                        'data-pika-year="' + opts.year + '" data-pika-month="' + opts.month + '" data-pika-day="' + opts.day + '">' +
                            opts.day +
                     '</button>' +
                   '</td>';
        },

        renderWeek = function (d, m, y) {
            // Lifted from http://javascript.about.com/library/blweekyear.htm, lightly modified.
            var onejan = new Date(y, 0, 1),
                weekNum = Math.ceil((((new Date(y, m, d) - onejan) / 86400000) + onejan.getDay()+1)/7);
            return '<td class="pika-week">' + weekNum + '</td>';
        },

        renderRow = function(days, isRTL, pickWholeWeek, isRowSelected)
        {
            return '<tr class="pika-row' + (pickWholeWeek ? ' pick-whole-week' : '') + (isRowSelected ? ' is-selected' : '') + '">' + (isRTL ? days.reverse() : days).join('') + '</tr>';
        },

        renderBody = function(rows)
        {
            return '<tbody>' + rows.join('') + '</tbody>';
        },

        renderHead = function(opts)
        {
            var i, arr = [];
            if (opts.showWeekNumber) {
                arr.push('<th></th>');
            }
            for (i = 0; i < 7; i++) {
                arr.push('<th scope="col"><abbr title="' + renderDayName(opts, i) + '">' + renderDayName(opts, i, true) + '</abbr></th>');
            }
            return '<thead><tr>' + (opts.isRTL ? arr.reverse() : arr).join('') + '</tr></thead>';
        },

        renderTitle = function(instance, c, year, month, refYear, randId)
        {
            var i, j, arr,
                opts = instance._o,
                isMinYear = year === opts.minYear,
                isMaxYear = year === opts.maxYear,
                html = '<div id="' + randId + '" class="pika-title" role="heading" aria-live="assertive">',
                monthHtml,
                yearHtml,
                prev = true,
                next = true;

            for (arr = [], i = 0; i < 12; i++) {
                arr.push('<option value="' + (year === refYear ? i - c : 12 + i - c) + '"' +
                    (i === month ? ' selected="selected"': '') +
                    ((isMinYear && i < opts.minMonth) || (isMaxYear && i > opts.maxMonth) ? 'disabled="disabled"' : '') + '>' +
                    opts.i18n.months[i] + '</option>');
            }

            monthHtml = '<div class="pika-label">' + opts.i18n.months[month] + '<select class="pika-select pika-select-month" tabindex="-1">' + arr.join('') + '</select></div>';

            if (isArray(opts.yearRange)) {
                i = opts.yearRange[0];
                j = opts.yearRange[1] + 1;
            } else {
                i = year - opts.yearRange;
                j = 1 + year + opts.yearRange;
            }

            for (arr = []; i < j && i <= opts.maxYear; i++) {
                if (i >= opts.minYear) {
                    arr.push('<option value="' + i + '"' + (i === year ? ' selected="selected"': '') + '>' + (i) + '</option>');
                }
            }
            yearHtml = '<div class="pika-label">' + year + opts.yearSuffix + '<select class="pika-select pika-select-year" tabindex="-1">' + arr.join('') + '</select></div>';

            if (opts.showMonthAfterYear) {
                html += yearHtml + monthHtml;
            } else {
                html += monthHtml + yearHtml;
            }

            if (isMinYear && (month === 0 || opts.minMonth >= month)) {
                prev = false;
            }

            if (isMaxYear && (month === 11 || opts.maxMonth <= month)) {
                next = false;
            }

            if (c === 0) {
                html += '<button class="pika-prev' + (prev ? '' : ' is-disabled') + '" type="button">' + opts.i18n.previousMonth + '</button>';
            }
            if (c === (instance._o.numberOfMonths - 1) ) {
                html += '<button class="pika-next' + (next ? '' : ' is-disabled') + '" type="button">' + opts.i18n.nextMonth + '</button>';
            }

            return html += '</div>';
        },

        renderTable = function(opts, data, randId)
        {
            return '<table cellpadding="0" cellspacing="0" class="pika-table" role="grid" aria-labelledby="' + randId + '">' + renderHead(opts) + renderBody(data) + '</table>';
        },

        renderTimePicker = function(num_options, selected_val, select_class, display_func, increment_by) {
            increment_by = increment_by || 1;
            var to_return = '<td><select class="pika-select '+select_class+'">';
            for (var i = 0; i < num_options; i += increment_by) {
                to_return += '<option value="'+i+'" '+(i==selected_val ? 'selected' : '')+'>'+display_func(i)+'</option>';
            }
            to_return += '</select></td>';
            return to_return;
        },

        renderTime = function(hh, mm, ss, opts)
        {
            var to_return = '<table cellpadding="0" cellspacing="0" class="pika-time"><tbody><tr>' +
                (opts.timeLabel !== null ? '<td class="pika-time-label">'+opts.timeLabel+'</td>' : '') +
                renderTimePicker(24, hh, 'pika-select-hour', function(i) {
                    if (opts.use24hour) {
                        return i;
                    } else {
                        var to_return = (i%12) + (i<12 ? ' AM' : ' PM');
                        if (to_return == '0 AM') {
                            return opts.i18n.midnight;
                        } else if (to_return == '0 PM') {
                            return opts.i18n.noon;
                        } else {
                            return to_return;
                        }
                    }
                },
                opts.incrementHourBy);

            if (opts.showMinutes) {
              to_return += '<td>:</td>' +
                  renderTimePicker(60, mm, 'pika-select-minute', function(i) { if (i < 10) return "0" + i; return i }, opts.incrementMinuteBy);
            }

            if (opts.showSeconds) {
                to_return += '<td>:</td>' +
                    renderTimePicker(60, ss, 'pika-select-second', function(i) { if (i < 10) return "0" + i; return i }, opts.incrementSecondBy);
            }
            return to_return + '</tr></tbody></table>';
        },



        /**
         * Pikaday constructor
         */
        Pikaday = function(options)
        {
            var self = this,
                opts = self.config(options);

            self._onMouseDown = function(e)
            {
                if (!self._v) {
                    return;
                }
                e = e || window.event;
                var target = e.target || e.srcElement;
                if (!target) {
                    return;
                }

                if (!hasClass(target, 'is-disabled')) {
                    if (hasClass(target, 'pika-button') && !hasClass(target, 'is-empty') && !hasClass(target.parentNode, 'is-disabled')) {
                        var newDate = new Date(
                                target.getAttribute('data-pika-year'),
                                target.getAttribute('data-pika-month'),
                                target.getAttribute('data-pika-day')
                            );
                        // Preserve time selection when date changed
                        var prevDate = self._d || opts.defaultDate;
                        if (prevDate && isDate(prevDate) && opts.showTime) {
                            newDate.setHours(prevDate.getHours());
                            newDate.setMinutes(prevDate.getMinutes());
                            if (opts.showSeconds) {
                                newDate.setSeconds(prevDate.getSeconds());
                            }
                        }
                        self.setDate(newDate);
                        if (opts.bound) {
                            sto(function() {
                                if (opts.autoClose) {
                                    self.hide();
                                }
                                if (opts.blurFieldOnSelect && opts.field) {
                                    opts.field.blur();
                                }
                            }, 100);
                        }
                    }
                    else if (hasClass(target, 'pika-prev')) {
                        self.prevMonth();
                    }
                    else if (hasClass(target, 'pika-next')) {
                        self.nextMonth();
                    }
                }
                if (!hasClass(target, 'pika-select')) {
                    // if this is touch event prevent mouse events emulation
                    if (e.preventDefault) {
                        e.preventDefault();
                    } else {
                        e.returnValue = false;
                        return false;
                    }
                } else {
                    self._c = true;
                }
            };

            self._onChange = function(e)
            {
                e = e || window.event;
                var target = e.target || e.srcElement;
                if (!target) {
                    return;
                }
                if (hasClass(target, 'pika-select-month')) {
                    self.gotoMonth(target.value);
                }
                else if (hasClass(target, 'pika-select-year')) {
                    self.gotoYear(target.value);
                }
                else if (hasClass(target, 'pika-select-hour')) {
                    self.setTime(target.value);
                }
                else if (hasClass(target, 'pika-select-minute')) {
                    self.setTime(null, target.value);
                }
                else if (hasClass(target, 'pika-select-second')) {
                    self.setTime(null, null, target.value);
                }
            };

            self._onKeyChange = function(e)
            {
                e = e || window.event;

                if (self.isVisible()) {

                    switch(e.keyCode){
                        case 13:
                        case 27:
                            if (opts.field) {
                                opts.field.blur();
                            }
                            break;
                        case 37:
                            e.preventDefault();
                            self.adjustDate('subtract', 1);
                            break;
                        case 38:
                            self.adjustDate('subtract', 7);
                            break;
                        case 39:
                            self.adjustDate('add', 1);
                            break;
                        case 40:
                            self.adjustDate('add', 7);
                            break;
                    }
                }
            };

            self._onInputChange = function(e)
            {
                var date;

                if (e.firedBy === self) {
                    return;
                }
                if (opts.parse) {
                    date = opts.parse(opts.field.value, opts.format || opts.inputFormats);
                } else if (hasMoment) {
                    date = moment(opts.field.value, opts.inputFormats, opts.formatStrict);
                    date = (date && date.isValid()) ? date.toDate() : null;
                }
                else {
                    date = new Date(Date.parse(opts.field.value));
                }
                if (isDate(date)) {
                  self.setDate(date);
                }
                if (!self._v) {
                    self.show();
                }
            };


            self._onInputFocus = function()
            {
                self.show();
            };

            self._onInputClick = function()
            {
                self.show();
            };

            self._onInputBlur = function()
            {
                // IE allows pika div to gain focus; catch blur the input field
                var pEl = document.activeElement;
                do {
                    if (hasClass(pEl, 'pika-single')) {
                        return;
                    }
                }
                while ((pEl = pEl.parentNode));

                if (opts.autoClose && !self._c) {
                    self._b = sto(function() {
                        self.hide();
                    }, 50);
                }
                self._c = false;
            };

            self._onClick = function(e)
            {
                e = e || window.event;
                var target = e.target || e.srcElement,
                    pEl = target;
                if (!target) {
                    return;
                }
                if (!hasEventListeners && hasClass(target, 'pika-select')) {
                    if (!target.onchange) {
                        target.setAttribute('onchange', 'return;');
                        addEvent(target, 'change', self._onChange);
                    }
                }
                do {
                    if (hasClass(pEl, 'pika-single') ||
                        pEl === opts.trigger ||
                        (opts.showTime && hasClass(pEl, 'pika-time-container'))) {
                        return;
                    }
                }
                while ((pEl = pEl.parentNode));
                if (self._v && target !== opts.trigger && pEl !== opts.trigger) {
                    self.hide();
                }
            };

            self.el = document.createElement('div');
            self.el.className = 'pika-single' + (opts.isRTL ? ' is-rtl' : '') + (opts.theme ? ' ' + opts.theme : '');

            addEvent(self.el, 'mousedown', self._onMouseDown, true);
            addEvent(self.el, 'touchend', self._onMouseDown, true);
            addEvent(self.el, 'change', self._onChange);

            if (opts.keyboardInput) {
                addEvent(document, 'keydown', self._onKeyChange);
            }

            if (opts.field) {
                if (opts.container) {
                    opts.container.appendChild(self.el);
                } else if (opts.bound) {
                    document.body.appendChild(self.el);
                } else {
                    opts.field.parentNode.insertBefore(self.el, opts.field.nextSibling);
                }
                addEvent(opts.field, 'change', self._onInputChange);

                if (!opts.defaultDate) {
                    if (hasMoment && opts.field.value) {
                        opts.defaultDate = moment(opts.field.value, opts.inputFormats).toDate();
                    } else {
                        opts.defaultDate = new Date(Date.parse(opts.field.value));
                    }
                    opts.setDefaultDate = true;
                }
            }

            var defDate = opts.defaultDate;

            if (isDate(defDate)) {
                if (opts.setDefaultDate) {
                    self.setDate(defDate, true);
                } else {
                    self.gotoDate(defDate);
                }
            } else {
                self.gotoDate(new Date());
            }

            if (opts.bound) {
                this.hide();
                self.el.className += ' is-bound';
                addEvent(opts.trigger, 'click', self._onInputClick);
                addEvent(opts.trigger, 'focus', self._onInputFocus);
                addEvent(opts.trigger, 'blur', self._onInputBlur);
            } else {
                this.show();
            }
        };


        /**
         * public Pikaday API
         */
        Pikaday.prototype = {
            /**
             * configure functionality
             */
            config: function(options)
            {
                if (!this._o) {
                    this._o = extend({}, defaults, true);
                }

                var opts = extend(this._o, options, true);

                opts.isRTL = !!opts.isRTL;

                opts.autoClose = !!opts.autoClose;

                opts.field = (opts.field && opts.field.nodeName) ? opts.field : null;

                opts.theme = (typeof opts.theme) === 'string' && opts.theme ? opts.theme : null;

                opts.bound = !!(opts.bound !== undefined ? opts.field && opts.bound : opts.field);

                opts.trigger = (opts.trigger && opts.trigger.nodeName) ? opts.trigger : opts.field;

                opts.disableWeekends = !!opts.disableWeekends;

                opts.disableDayFn = (typeof opts.disableDayFn) === 'function' ? opts.disableDayFn : null;

                var nom = parseInt(opts.numberOfMonths, 10) || 1;
                opts.numberOfMonths = nom > 4 ? 4 : nom;

                if (!isDate(opts.minDate)) {
                    opts.minDate = false;
                }
                if (!isDate(opts.maxDate)) {
                    opts.maxDate = false;
                }
                if ((opts.minDate && opts.maxDate) && opts.maxDate < opts.minDate) {
                    opts.maxDate = opts.minDate = false;
                }
                if (opts.minDate) {
                   this.setMinDate(opts.minDate);
                }
                if (opts.maxDate) {
                    this.setMaxDate(opts.maxDate);
                }

                if (isArray(opts.yearRange)) {
                    var fallback = new Date().getFullYear() - 10;
                    opts.yearRange[0] = parseInt(opts.yearRange[0], 10) || fallback;
                    opts.yearRange[1] = parseInt(opts.yearRange[1], 10) || fallback;
                } else {
                    opts.yearRange = Math.abs(parseInt(opts.yearRange, 10)) || defaults.yearRange;
                    if (opts.yearRange > 100) {
                        opts.yearRange = 100;
                    }
                }

                // If no format is given, set based on showTime
                if (opts.format === null) {
                    opts.format = 'YYYY-MM-DD';
                    if (opts.showTime) {
                        opts.format += ' HH:mm:ss';
                    }
                }

                if(!opts.inputFormats) {
                    opts.inputFormats = opts.format;
                }

                return opts;
            },

            /**
             * return a formatted string of the current selection (using Moment.js if available)
             */
            toString: function(format)
            {
                format = format || this._o.format;
                if (!isDate(this._d)) {
                    return '';
                }
                if (this._o.toString) {
                  return this._o.toString(this._d, format);
                }
                if (hasMoment) {
                  return moment(this._d).format(format);
                }
                if (this._o.showTime) {
                    return this._d.toString();
                }
                return this._d.toDateString();
            },

            /**
             * return a Moment.js object of the current selection (if available)
             */
            getMoment: function()
            {
                return hasMoment ? moment(this._d) : null;
            },

            /**
             * set the current selection from a Moment.js object (if available)
             */
            setMoment: function(date, preventOnSelect)
            {
                if (hasMoment && moment.isMoment(date)) {
                    this.setDate(date.toDate(), preventOnSelect);
                }
            },

            /**
             * return a Date object of the current selection
             */
            getDate: function()
            {
                return isDate(this._d) ? new Date(this._d.getTime()) : null;
            },

            /**
             * set time components
             * Currently defaulting to setting date to today if not set
             */
            setTime: function(hours, minutes, seconds) {
                if (!this._d) {
                    this._d = new Date();
                    this._d.setHours(0,0,0,0);
                }
                if (hours) {
                    this._d.setHours(hours);
                }
                if (minutes) {
                    this._d.setMinutes(minutes);
                }
                if (seconds) {
                    this._d.setSeconds(seconds);
                }
                this.setDate(this._d);
            },

            /**
             * set the current selection
             */
            setDate: function(date, preventOnSelect)
            {
                if (!date) {
                    this._d = null;

                    if (this._o.field) {
                        this._o.field.value = '';
                        fireEvent(this._o.field, 'change', { firedBy: this });
                    }

                    return this.draw();
                }
                if (typeof date === 'string') {
                    date = new Date(Date.parse(date));
                }
                if (!isDate(date)) {
                    return;
                }

                var min = this._o.minDate,
                    max = this._o.maxDate;

                if (isDate(min) && date < min) {
                    date = min;
                } else if (isDate(max) && date > max) {
                    date = max;
                }

                this._d = new Date(date.getTime());

                if (this._o.showTime && !this._o.showSeconds) {
                    this._d.setSeconds(0);
                } else if (!this._o.showTime) {
                    setToStartOfDay(this._d);
                }

                this.gotoDate(this._d);

                if (this._o.field) {
                    this._o.field.value = this.toString();
                    fireEvent(this._o.field, 'change', { firedBy: this });
                }
                if (!preventOnSelect && typeof this._o.onSelect === 'function') {
                    this._o.onSelect.call(this, this.getDate());
                }
            },

            /**
             * change view to a specific date
             */
            gotoDate: function(date)
            {
                var newCalendar = true;

                if (!isDate(date)) {
                    return;
                }

                if (this.calendars) {
                    var firstVisibleDate = new Date(this.calendars[0].year, this.calendars[0].month, 1),
                        lastVisibleDate = new Date(this.calendars[this.calendars.length-1].year, this.calendars[this.calendars.length-1].month, 1),
                        visibleDate = date.getTime();
                    // get the end of the month
                    lastVisibleDate.setMonth(lastVisibleDate.getMonth()+1);
                    lastVisibleDate.setDate(lastVisibleDate.getDate()-1);
                    newCalendar = (visibleDate < firstVisibleDate.getTime() || lastVisibleDate.getTime() < visibleDate);
                }

                if (newCalendar) {
                    this.calendars = [{
                        month: date.getMonth(),
                        year: date.getFullYear(),
                        hour: date.getHours(),
                        minute: date.getMinutes(),
                        second: date.getSeconds()
                    }];
                    if (this._o.mainCalendar === 'right') {
                        this.calendars[0].month += 1 - this._o.numberOfMonths;
                    }
                }

                this.adjustCalendars();
            },

            adjustDate: function(sign, days) {

                var day = this.getDate() || new Date();
                var difference = parseInt(days)*24*60*60*1000;

                var newDay;

                if (sign === 'add') {
                    newDay = new Date(day.valueOf() + difference);
                } else if (sign === 'subtract') {
                    newDay = new Date(day.valueOf() - difference);
                }

                this.setDate(newDay);
            },

            adjustCalendars: function() {
                this.calendars[0] = adjustCalendar(this.calendars[0]);
                for (var c = 1; c < this._o.numberOfMonths; c++) {
                    this.calendars[c] = adjustCalendar({
                        month: this.calendars[0].month + c,
                        year: this.calendars[0].year
                    });
                }
                this.draw();
            },

            gotoToday: function()
            {
                this.gotoDate(new Date());
            },

            /**
             * change view to a specific month (zero-index, e.g. 0: January)
             */
            gotoMonth: function(month)
            {
                if (!isNaN(month)) {
                    this.calendars[0].month = parseInt(month, 10);
                    this.adjustCalendars();
                }
            },

            nextMonth: function()
            {
                this.calendars[0].month++;
                this.adjustCalendars();
            },

            prevMonth: function()
            {
                this.calendars[0].month--;
                this.adjustCalendars();
            },

            /**
             * change view to a specific full year (e.g. "2012")
             */
            gotoYear: function(year)
            {
                if (!isNaN(year)) {
                    this.calendars[0].year = parseInt(year, 10);
                    this.adjustCalendars();
                }
            },

            /**
             * change the minDate
             */
            setMinDate: function(value)
            {
                if(value instanceof Date) {
                    if (!this._o.showTime) setToStartOfDay(value);
                    this._o.minDate = value;
                    this._o.minYear  = value.getFullYear();
                    this._o.minMonth = value.getMonth();
                } else {
                    this._o.minDate = defaults.minDate;
                    this._o.minYear  = defaults.minYear;
                    this._o.minMonth = defaults.minMonth;
                    this._o.startRange = defaults.startRange;
                }
                this.draw();
            },

            /**
             * change the maxDate
             */
            setMaxDate: function(value)
            {
                if(value instanceof Date) {
                    if (!this._o.showTime) setToStartOfDay(value);
                    this._o.maxDate = value;
                    this._o.maxYear = value.getFullYear();
                    this._o.maxMonth = value.getMonth();
                } else {
                    this._o.maxDate = defaults.maxDate;
                    this._o.maxYear = defaults.maxYear;
                    this._o.maxMonth = defaults.maxMonth;
                    this._o.endRange = defaults.endRange;
                }
                this.draw();
            },

            setStartRange: function(value)
            {
                this._o.startRange = value;
            },

            setEndRange: function(value)
            {
                this._o.endRange = value;
            },

            /**
             * refresh the HTML
             */
            draw: function(force)
            {
                if (!this._v && !force) {
                    return;
                }
                var opts = this._o,
                    minYear = opts.minYear,
                    maxYear = opts.maxYear,
                    minMonth = opts.minMonth,
                    maxMonth = opts.maxMonth,
                    html = '',
                    randId;

                if (this._y <= minYear) {
                    this._y = minYear;
                    if (!isNaN(minMonth) && this._m < minMonth) {
                        this._m = minMonth;
                    }
                }
                if (this._y >= maxYear) {
                    this._y = maxYear;
                    if (!isNaN(maxMonth) && this._m > maxMonth) {
                        this._m = maxMonth;
                    }
                }

                randId = 'pika-title-' + Math.random().toString(36).replace(/[^a-z]+/g, '').substr(0, 2);

                for (var c = 0; c < opts.numberOfMonths; c++) {
                    html += '<div class="pika-lendar">' + renderTitle(this, c, this.calendars[c].year, this.calendars[c].month, this.calendars[0].year, randId) + this.render(this.calendars[c].year, this.calendars[c].month, randId) + '</div>';
                }

                if (opts.showTime) {
                    var prevDate = this._d || this._o.defaultDate;
                    html += '<div class="pika-time-container">' +
                            renderTime(
                                prevDate && isDate(prevDate) ? prevDate.getHours() : 0,
                                prevDate && isDate(prevDate) ? prevDate.getMinutes() : 0,
                                prevDate && isDate(prevDate) ? prevDate.getSeconds() : 0,
                                opts)
                        + '</div>';
                }

                this.el.innerHTML = html;

                if (opts.bound) {
                    if(opts.field.type !== 'hidden') {
                        sto(function() {
                            opts.trigger.focus();
                        }, 1);
                    }
                }

                if (typeof this._o.onDraw === 'function') {
                    this._o.onDraw(this);
                }

                if (opts.bound) {
                    // let the screen reader user know to use arrow keys
                    opts.field.setAttribute('aria-label', opts.ariaLabel);
                }
            },

            adjustPosition: function()
            {
                var field, pEl, width, height, viewportWidth, viewportHeight, scrollTop, left, top, clientRect;

                if (this._o.container) return;

                this.el.style.position = 'absolute';

                field = this._o.trigger;
                pEl = field;
                width = this.el.offsetWidth;
                height = this.el.offsetHeight;
                viewportWidth = window.innerWidth || document.documentElement.clientWidth;
                viewportHeight = window.innerHeight || document.documentElement.clientHeight;
                scrollTop = window.pageYOffset || document.body.scrollTop || document.documentElement.scrollTop;

                if (typeof field.getBoundingClientRect === 'function') {
                    clientRect = field.getBoundingClientRect();
                    left = clientRect.left + window.pageXOffset;
                    top = clientRect.bottom + window.pageYOffset;
                } else {
                    left = pEl.offsetLeft;
                    top  = pEl.offsetTop + pEl.offsetHeight;
                    while((pEl = pEl.offsetParent)) {
                        left += pEl.offsetLeft;
                        top  += pEl.offsetTop;
                    }
                }

                // default position is bottom & left
                if ((this._o.reposition && left + width > viewportWidth) ||
                    (
                        this._o.position.indexOf('right') > -1 &&
                        left - width + field.offsetWidth > 0
                    )
                ) {
                    left = left - width + field.offsetWidth;
                }
                if ((this._o.reposition && top + height > viewportHeight + scrollTop) ||
                    (
                        this._o.position.indexOf('top') > -1 &&
                        top - height - field.offsetHeight > 0
                    )
                ) {
                    top = top - height - field.offsetHeight;
                }

                this.el.style.left = left + 'px';
                this.el.style.top = top + 'px';
            },

            /**
             * render HTML for a particular month
             */
            render: function(year, month, randId)
            {
                var opts   = this._o,
                    now    = new Date(),
                    days   = getDaysInMonth(year, month),
                    before = new Date(year, month, 1).getDay(),
                    data   = [],
                    row    = [];
                if (!opts.showTime) setToStartOfDay(now);
                if (opts.firstDay > 0) {
                    before -= opts.firstDay;
                    if (before < 0) {
                        before += 7;
                    }
                }
                var previousMonth = month === 0 ? 11 : month - 1,
                    nextMonth = month === 11 ? 0 : month + 1,
                    yearOfPreviousMonth = month === 0 ? year - 1 : year,
                    yearOfNextMonth = month === 11 ? year + 1 : year,
                    daysInPreviousMonth = getDaysInMonth(yearOfPreviousMonth, previousMonth);
                var cells = days + before,
                    after = cells;
                while(after > 7) {
                    after -= 7;
                }
                cells += 7 - after;

                // Ensure we only compare date portion when deciding to show a date in picker
                var minDate_date = opts.minDate ? new Date(opts.minDate.getFullYear(), opts.minDate.getMonth(), opts.minDate.getDate()) : null;
                var maxDate_date = opts.maxDate ? new Date(opts.maxDate.getFullYear(), opts.maxDate.getMonth(), opts.maxDate.getDate()) : null;

                var isWeekSelected = false;
                for (var i = 0, r = 0; i < cells; i++)
                {
                    var day = new Date(year, month, 1 + (i - before)),
                        isSelected = isDate(this._d) ? compareDates(day, this._d) : false,
                        isToday = compareDates(day, now),
                        hasEvent = opts.events.indexOf(day.toDateString()) !== -1 ? true : false,
                        isEmpty = i < before || i >= (days + before),
                        dayNumber = 1 + (i - before),
                        monthNumber = month,
                        yearNumber = year,
                        isStartRange = opts.startRange && compareDates(opts.startRange, day),
                        isEndRange = opts.endRange && compareDates(opts.endRange, day),
                        isInRange = opts.startRange && opts.endRange && opts.startRange < day && day < opts.endRange,
                        isDisabled = (minDate_date && day < minDate_date) ||
                                     (maxDate_date && day > maxDate_date) ||
                                     (opts.disableWeekends && isWeekend(day)) ||
                                     (opts.disableDayFn && opts.disableDayFn(day));

                    if (isEmpty) {
                        if (i < before) {
                            dayNumber = daysInPreviousMonth + dayNumber;
                            monthNumber = previousMonth;
                            yearNumber = yearOfPreviousMonth;
                        } else {
                            dayNumber = dayNumber - days;
                            monthNumber = nextMonth;
                            yearNumber = yearOfNextMonth;
                        }
                    }

                    var dayConfig = {
                            day: dayNumber,
                            month: monthNumber,
                            year: yearNumber,
                            hasEvent: hasEvent,
                            isSelected: isSelected,
                            isToday: isToday,
                            isDisabled: isDisabled,
                            isEmpty: isEmpty,
                            isStartRange: isStartRange,
                            isEndRange: isEndRange,
                            isInRange: isInRange,
                            showDaysInNextAndPreviousMonths: opts.showDaysInNextAndPreviousMonths,
                            enableSelectionDaysInNextAndPreviousMonths: opts.enableSelectionDaysInNextAndPreviousMonths
                        };

                    if (opts.pickWholeWeek && isSelected) {
                        isWeekSelected = true;
                    }

                    row.push(renderDay(dayConfig));

                    if (++r === 7) {
                        if (opts.showWeekNumber) {
                            row.unshift(renderWeek(i - before, month, year));
                        }
                        data.push(renderRow(row, opts.isRTL, opts.pickWholeWeek, isWeekSelected));
                        row = [];
                        r = 0;
                        isWeekSelected = false;
                    }
                }
                return renderTable(opts, data, randId);
            },

            isVisible: function()
            {
                return this._v;
            },

            show: function()
            {
                if (!this.isVisible()) {
                    this._v = true;
                    this.draw();
                    removeClass(this.el, 'is-hidden');
                    if (this._o.bound) {
                        addEvent(document, 'click', this._onClick);
                        this.adjustPosition();
                    }
                    if (typeof this._o.onOpen === 'function') {
                        this._o.onOpen.call(this);
                    }
                }
            },

            hide: function()
            {
                var v = this._v;
                if (v !== false) {
                    if (this._o.bound) {
                        removeEvent(document, 'click', this._onClick);
                    }
                    this.el.style.position = 'static'; // reset
                    this.el.style.left = 'auto';
                    this.el.style.top = 'auto';
                    addClass(this.el, 'is-hidden');
                    this._v = false;
                    if (v !== undefined && typeof this._o.onClose === 'function') {
                        this._o.onClose.call(this);
                    }
                }
            },

            /**
             * GAME OVER
             */
            destroy: function()
            {
                var opts = this._o;

                this.hide();
                removeEvent(this.el, 'mousedown', this._onMouseDown, true);
                removeEvent(this.el, 'touchend', this._onMouseDown, true);
                removeEvent(this.el, 'change', this._onChange);
                if (opts.keyboardInput) {
                    removeEvent(document, 'keydown', this._onKeyChange);
                }
                if (opts.field) {
                    removeEvent(opts.field, 'change', this._onInputChange);
                    if (opts.bound) {
                        removeEvent(opts.trigger, 'click', this._onInputClick);
                        removeEvent(opts.trigger, 'focus', this._onInputFocus);
                        removeEvent(opts.trigger, 'blur', this._onInputBlur);
                    }
                }
                if (this.el.parentNode) {
                    this.el.parentNode.removeChild(this.el);
                }
            }

        };

        return Pikaday;
    }));
    });

    /* src\core\ui\inputs\DateRange.html generated by Svelte v2.16.1 */

    function oncreate$5() {
    	const { field } = this.get();
    	const includeTime = field.metadata.getCustomProperty("includeTime") || false;

    	// eslint-disable-next-line no-new
    	new pikaday$1({
    		field: this.refs.minContainer,
    		format: includeTime ? "YYYY-MM-DD hh:mm A" : "YYYY-MM-DD",
    		showTime: includeTime,
    		showMinutes: true,
    		showSeconds: false,
    		use24hour: false,
    		incrementHourBy: 1,
    		incrementMinuteBy: 5,
    		incrementSecondBy: 1,
    		i18n: {
    			midnight: "0 AM", // Label for 0 AM
    			noon: "12 AM", // Label for 12 AM
    			previousMonth: "Previous Month",
    			nextMonth: "Next Month",
    			months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    			weekdays: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    			weekdaysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
    		},
    		timeLabel: "الوقت", // optional string added to left of time select
    		onSelect(date) {
    			field.value.min = date;
    		}
    	});

    	// eslint-disable-next-line no-new
    	new pikaday$1({
    		field: this.refs.maxContainer,
    		format: includeTime ? "YYYY-MM-DD hh:mm A" : "YYYY-MM-DD",
    		showTime: includeTime,
    		showMinutes: true,
    		showSeconds: false,
    		use24hour: false,
    		incrementHourBy: 1,
    		incrementMinuteBy: 5,
    		incrementSecondBy: 1,
    		i18n: {
    			midnight: "0 AM", // Label for 0 AM
    			noon: "12 AM", // Label for 12 AM
    			previousMonth: "Previous Month",
    			nextMonth: "Next Month",
    			months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    			weekdays: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    			weekdaysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
    		},
    		onSelect(date) {
    			field.value.max = date;
    		}
    	});

    	const minElement = this.refs.minContainer;
    	minElement.addEventListener("change", () => {
    		if (minElement.value === "") {
    			field.value.min = null;
    		}
    	});

    	const maxElement = this.refs.maxContainer;
    	maxElement.addEventListener("change", () => {
    		if (maxElement.value === "") {
    			field.value.max = null;
    		}
    	});
    }
    const file$b = "src\\core\\ui\\inputs\\DateRange.html";

    function add_css$6() {
    	var style = createElement("style");
    	style.id = 'svelte-6lg6r4-style';
    	style.textContent = ".input-group-addon.svelte-6lg6r4{font-size:0.8rem !important}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRGF0ZVJhbmdlLmh0bWwiLCJzb3VyY2VzIjpbIkRhdGVSYW5nZS5odG1sIl0sInNvdXJjZXNDb250ZW50IjpbIjxkaXYgY2xhc3M9XCJpbnB1dC1ncm91cFwiPlxyXG5cdDxzcGFuIGNsYXNzPVwiaW5wdXQtZ3JvdXAtYWRkb25cIj5NaW48L3NwYW4+XHJcblx0PGlucHV0IHR5cGU9XCJ0ZXh0XCJcclxuXHRcdGJpbmQ6dmFsdWU9XCJmaWVsZC5taW5WYWx1ZUFzVGV4dFwiXHJcblx0XHRyZXF1aXJlZD1cIntmaWVsZC5tZXRhZGF0YS5yZXF1aXJlZH1cIlxyXG5cdFx0dGFiaW5kZXg9XCJ7dGFiaW5kZXh9XCJcclxuXHRcdGF1dG9jb21wbGV0ZT1cIm9mZlwiXHJcblx0XHRjbGFzcz1cImZvcm0tY29udHJvbFwiXHJcblx0XHRyZWY6bWluQ29udGFpbmVyPlxyXG5cclxuICAgIDxzcGFuIGNsYXNzPVwiaW5wdXQtZ3JvdXAtYWRkb25cIj5NYXg8L3NwYW4+XHJcblx0PGlucHV0IHR5cGU9XCJ0ZXh0XCJcclxuXHRcdGJpbmQ6dmFsdWU9XCJmaWVsZC5tYXhWYWx1ZUFzVGV4dFwiXHJcblx0XHRyZXF1aXJlZD1cIntmaWVsZC5tZXRhZGF0YS5yZXF1aXJlZH1cIlxyXG5cdFx0dGFiaW5kZXg9XCJ7dGFiaW5kZXh9XCJcclxuXHRcdGF1dG9jb21wbGV0ZT1cIm9mZlwiXHJcblx0XHRjbGFzcz1cImZvcm0tY29udHJvbFwiXHJcblx0XHRyZWY6bWF4Q29udGFpbmVyPlxyXG48L2Rpdj5cclxuXHJcbjxzY3JpcHQ+XHJcblx0aW1wb3J0IFBpa2FkYXkgZnJvbSBcInBpa2FkYXktdGltZVwiO1xyXG5cclxuXHRleHBvcnQgZGVmYXVsdCB7XHJcblx0XHRvbmNyZWF0ZSgpIHtcclxuXHRcdFx0Y29uc3QgeyBmaWVsZCB9ID0gdGhpcy5nZXQoKTtcclxuXHRcdFx0Y29uc3QgaW5jbHVkZVRpbWUgPSBmaWVsZC5tZXRhZGF0YS5nZXRDdXN0b21Qcm9wZXJ0eShcImluY2x1ZGVUaW1lXCIpIHx8IGZhbHNlO1xyXG5cclxuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ld1xyXG5cdFx0XHRuZXcgUGlrYWRheSh7XHJcblx0XHRcdFx0ZmllbGQ6IHRoaXMucmVmcy5taW5Db250YWluZXIsXHJcblx0XHRcdFx0Zm9ybWF0OiBpbmNsdWRlVGltZSA/IFwiWVlZWS1NTS1ERCBoaDptbSBBXCIgOiBcIllZWVktTU0tRERcIixcclxuXHRcdFx0XHRzaG93VGltZTogaW5jbHVkZVRpbWUsXHJcblx0XHRcdFx0c2hvd01pbnV0ZXM6IHRydWUsXHJcblx0XHRcdFx0c2hvd1NlY29uZHM6IGZhbHNlLFxyXG5cdFx0XHRcdHVzZTI0aG91cjogZmFsc2UsXHJcblx0XHRcdFx0aW5jcmVtZW50SG91ckJ5OiAxLFxyXG5cdFx0XHRcdGluY3JlbWVudE1pbnV0ZUJ5OiA1LFxyXG5cdFx0XHRcdGluY3JlbWVudFNlY29uZEJ5OiAxLFxyXG5cdFx0XHRcdGkxOG46IHtcclxuXHRcdFx0XHRcdG1pZG5pZ2h0OiBcIjAgQU1cIiwgLy8gTGFiZWwgZm9yIDAgQU1cclxuXHRcdFx0XHRcdG5vb246IFwiMTIgQU1cIiwgLy8gTGFiZWwgZm9yIDEyIEFNXHJcblx0XHRcdFx0XHRwcmV2aW91c01vbnRoOiBcIlByZXZpb3VzIE1vbnRoXCIsXHJcblx0XHRcdFx0XHRuZXh0TW9udGg6IFwiTmV4dCBNb250aFwiLFxyXG5cdFx0XHRcdFx0bW9udGhzOiBbXCJKYW51YXJ5XCIsIFwiRmVicnVhcnlcIiwgXCJNYXJjaFwiLCBcIkFwcmlsXCIsIFwiTWF5XCIsIFwiSnVuZVwiLCBcIkp1bHlcIiwgXCJBdWd1c3RcIiwgXCJTZXB0ZW1iZXJcIiwgXCJPY3RvYmVyXCIsIFwiTm92ZW1iZXJcIiwgXCJEZWNlbWJlclwiXSxcclxuXHRcdFx0XHRcdHdlZWtkYXlzOiBbXCJTdW5kYXlcIiwgXCJNb25kYXlcIiwgXCJUdWVzZGF5XCIsIFwiV2VkbmVzZGF5XCIsIFwiVGh1cnNkYXlcIiwgXCJGcmlkYXlcIiwgXCJTYXR1cmRheVwiXSxcclxuXHRcdFx0XHRcdHdlZWtkYXlzU2hvcnQ6IFtcIlN1blwiLCBcIk1vblwiLCBcIlR1ZVwiLCBcIldlZFwiLCBcIlRodVwiLCBcIkZyaVwiLCBcIlNhdFwiXVxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0dGltZUxhYmVsOiBcItin2YTZiNmC2KpcIiwgLy8gb3B0aW9uYWwgc3RyaW5nIGFkZGVkIHRvIGxlZnQgb2YgdGltZSBzZWxlY3RcclxuXHRcdFx0XHRvblNlbGVjdChkYXRlKSB7XHJcblx0XHRcdFx0XHRmaWVsZC52YWx1ZS5taW4gPSBkYXRlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3XHJcblx0XHRcdG5ldyBQaWthZGF5KHtcclxuXHRcdFx0XHRmaWVsZDogdGhpcy5yZWZzLm1heENvbnRhaW5lcixcclxuXHRcdFx0XHRmb3JtYXQ6IGluY2x1ZGVUaW1lID8gXCJZWVlZLU1NLUREIGhoOm1tIEFcIiA6IFwiWVlZWS1NTS1ERFwiLFxyXG5cdFx0XHRcdHNob3dUaW1lOiBpbmNsdWRlVGltZSxcclxuXHRcdFx0XHRzaG93TWludXRlczogdHJ1ZSxcclxuXHRcdFx0XHRzaG93U2Vjb25kczogZmFsc2UsXHJcblx0XHRcdFx0dXNlMjRob3VyOiBmYWxzZSxcclxuXHRcdFx0XHRpbmNyZW1lbnRIb3VyQnk6IDEsXHJcblx0XHRcdFx0aW5jcmVtZW50TWludXRlQnk6IDUsXHJcblx0XHRcdFx0aW5jcmVtZW50U2Vjb25kQnk6IDEsXHJcblx0XHRcdFx0aTE4bjoge1xyXG5cdFx0XHRcdFx0bWlkbmlnaHQ6IFwiMCBBTVwiLCAvLyBMYWJlbCBmb3IgMCBBTVxyXG5cdFx0XHRcdFx0bm9vbjogXCIxMiBBTVwiLCAvLyBMYWJlbCBmb3IgMTIgQU1cclxuXHRcdFx0XHRcdHByZXZpb3VzTW9udGg6IFwiUHJldmlvdXMgTW9udGhcIixcclxuXHRcdFx0XHRcdG5leHRNb250aDogXCJOZXh0IE1vbnRoXCIsXHJcblx0XHRcdFx0XHRtb250aHM6IFtcIkphbnVhcnlcIiwgXCJGZWJydWFyeVwiLCBcIk1hcmNoXCIsIFwiQXByaWxcIiwgXCJNYXlcIiwgXCJKdW5lXCIsIFwiSnVseVwiLCBcIkF1Z3VzdFwiLCBcIlNlcHRlbWJlclwiLCBcIk9jdG9iZXJcIiwgXCJOb3ZlbWJlclwiLCBcIkRlY2VtYmVyXCJdLFxyXG5cdFx0XHRcdFx0d2Vla2RheXM6IFtcIlN1bmRheVwiLCBcIk1vbmRheVwiLCBcIlR1ZXNkYXlcIiwgXCJXZWRuZXNkYXlcIiwgXCJUaHVyc2RheVwiLCBcIkZyaWRheVwiLCBcIlNhdHVyZGF5XCJdLFxyXG5cdFx0XHRcdFx0d2Vla2RheXNTaG9ydDogW1wiU3VuXCIsIFwiTW9uXCIsIFwiVHVlXCIsIFwiV2VkXCIsIFwiVGh1XCIsIFwiRnJpXCIsIFwiU2F0XCJdXHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRvblNlbGVjdChkYXRlKSB7XHJcblx0XHRcdFx0XHRmaWVsZC52YWx1ZS5tYXggPSBkYXRlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHRjb25zdCBtaW5FbGVtZW50ID0gdGhpcy5yZWZzLm1pbkNvbnRhaW5lcjtcclxuXHRcdFx0bWluRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsICgpID0+IHtcclxuXHRcdFx0XHRpZiAobWluRWxlbWVudC52YWx1ZSA9PT0gXCJcIikge1xyXG5cdFx0XHRcdFx0ZmllbGQudmFsdWUubWluID0gbnVsbDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0Y29uc3QgbWF4RWxlbWVudCA9IHRoaXMucmVmcy5tYXhDb250YWluZXI7XHJcblx0XHRcdG1heEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCAoKSA9PiB7XHJcblx0XHRcdFx0aWYgKG1heEVsZW1lbnQudmFsdWUgPT09IFwiXCIpIHtcclxuXHRcdFx0XHRcdGZpZWxkLnZhbHVlLm1heCA9IG51bGw7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHR9O1xyXG48L3NjcmlwdD5cclxuXHJcbjxzdHlsZT5cclxuXHRcdC5pbnB1dC1ncm91cC1hZGRvbiB7XHJcblx0XHRcdGZvbnQtc2l6ZTogMC44cmVtICFpbXBvcnRhbnQ7XHJcblx0XHR9XHJcbjwvc3R5bGU+XHJcbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFpR0Usa0JBQWtCLGNBQUMsQ0FBQyxBQUNuQixTQUFTLENBQUUsTUFBTSxDQUFDLFVBQVUsQUFDN0IsQ0FBQyJ9 */";
    	append(document.head, style);
    }

    function create_main_fragment$b(component, ctx) {
    	var div, span0, text1, input0, input0_updating = false, input0_required_value, text2, span1, text4, input1, input1_updating = false, input1_required_value;

    	function input0_input_handler() {
    		input0_updating = true;
    		ctx.field.minValueAsText = input0.value;
    		component.set({ field: ctx.field });
    		input0_updating = false;
    	}

    	function input1_input_handler() {
    		input1_updating = true;
    		ctx.field.maxValueAsText = input1.value;
    		component.set({ field: ctx.field });
    		input1_updating = false;
    	}

    	return {
    		c: function create() {
    			div = createElement("div");
    			span0 = createElement("span");
    			span0.textContent = "Min";
    			text1 = createText("\r\n\t");
    			input0 = createElement("input");
    			text2 = createText("\r\n\r\n    ");
    			span1 = createElement("span");
    			span1.textContent = "Max";
    			text4 = createText("\r\n\t");
    			input1 = createElement("input");
    			span0.className = "input-group-addon svelte-6lg6r4";
    			addLoc(span0, file$b, 1, 1, 28);
    			addListener(input0, "input", input0_input_handler);
    			setAttribute(input0, "type", "text");
    			input0.required = input0_required_value = ctx.field.metadata.required;
    			input0.tabIndex = ctx.tabindex;
    			input0.autocomplete = "off";
    			input0.className = "form-control";
    			addLoc(input0, file$b, 2, 1, 73);
    			span1.className = "input-group-addon svelte-6lg6r4";
    			addLoc(span1, file$b, 10, 4, 268);
    			addListener(input1, "input", input1_input_handler);
    			setAttribute(input1, "type", "text");
    			input1.required = input1_required_value = ctx.field.metadata.required;
    			input1.tabIndex = ctx.tabindex;
    			input1.autocomplete = "off";
    			input1.className = "form-control";
    			addLoc(input1, file$b, 11, 1, 313);
    			div.className = "input-group";
    			addLoc(div, file$b, 0, 0, 0);
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);
    			append(div, span0);
    			append(div, text1);
    			append(div, input0);
    			component.refs.minContainer = input0;

    			input0.value = ctx.field.minValueAsText;

    			append(div, text2);
    			append(div, span1);
    			append(div, text4);
    			append(div, input1);
    			component.refs.maxContainer = input1;

    			input1.value = ctx.field.maxValueAsText;
    		},

    		p: function update(changed, _ctx) {
    			ctx = _ctx;
    			if (!input0_updating && changed.field) input0.value = ctx.field.minValueAsText;
    			if ((changed.field) && input0_required_value !== (input0_required_value = ctx.field.metadata.required)) {
    				input0.required = input0_required_value;
    			}

    			if (changed.tabindex) {
    				input0.tabIndex = ctx.tabindex;
    			}

    			if (!input1_updating && changed.field) input1.value = ctx.field.maxValueAsText;
    			if ((changed.field) && input1_required_value !== (input1_required_value = ctx.field.metadata.required)) {
    				input1.required = input1_required_value;
    			}

    			if (changed.tabindex) {
    				input1.tabIndex = ctx.tabindex;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(div);
    			}

    			removeListener(input0, "input", input0_input_handler);
    			if (component.refs.minContainer === input0) component.refs.minContainer = null;
    			removeListener(input1, "input", input1_input_handler);
    			if (component.refs.maxContainer === input1) component.refs.maxContainer = null;
    		}
    	};
    }

    function SvelteComponent$b(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) {
    		throw new Error("'target' is a required option");
    	}

    	init(this, options);
    	this.refs = {};
    	this._state = assign({}, options.data);
    	if (!('field' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'field'");
    	if (!('tabindex' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'tabindex'");
    	this._intro = true;

    	if (!document.getElementById("svelte-6lg6r4-style")) add_css$6();

    	this._fragment = create_main_fragment$b(this, this._state);

    	this.root._oncreate.push(() => {
    		oncreate$5.call(this);
    		this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
    	});

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);

    		flush(this);
    	}
    }

    assign(SvelteComponent$b.prototype, protoDev);

    SvelteComponent$b.prototype._checkReadOnly = function _checkReadOnly(newState) {
    };

    /* src\core\ui\inputs\Dropdown.html generated by Svelte v2.16.1 */

    function mapToTypeaheadItems(items) {
    	return items.map(t => ({
    		label: t.label,
    		value: t.value.toString()
    	}));
    }

    function buildFilter(parentForm, parameters) {
    	let promise;

    	const filter = {};
    	if (parameters != null && parameters.length > 0) {
    		promise = parentForm.get().form.getSerializedInputValues().then(data => {
    			for (const p of parameters) {
    				filter[p] = data[p];
    			}

    			return filter;
    		});
    	}
    	else {
    		promise = Promise.resolve(filter);
    	}

    	return promise;
    }

    var methods$4 = {
    	onChange() {
    		this.get().field.initFromSelected();
    		this.get().form.fireAndBubbleUp("input:changed", {
    			app: this.get().app,
    			form: this.get().form,
    			input: this
    		});
    	}
    };

    function oncreate$6() {
    	const { field } = this.get();
    	const { source, items } = field.metadata.customProperties;

    	if (items != null) {
    		this.set({ options: items });
    		if (field.selected != null) {
    			this.onChange();
    		}
    	}
    	else if (typeof (source) === "string") {
    		const { parameters } = field.metadata.customProperties;
    		const { app } = this.get();
    		const parentForm = this.get().form;

    		buildFilter(parentForm, parameters).then(filter => {
    			app.server.postForm(source, filter).then(data => {
    				this.set({ options: mapToTypeaheadItems(data.items) });
    				if (field.selected != null) {
    					this.onChange();
    				}
    			});
    		});
    	}
    }
    const file$c = "src\\core\\ui\\inputs\\Dropdown.html";

    function get_each_context$4(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.option = list[i];
    	return child_ctx;
    }

    function create_main_fragment$c(component, ctx) {
    	var if_block_anchor;

    	var if_block = (ctx.options != null) && create_if_block$9(component, ctx);

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (ctx.options != null) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block$9(component, ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (if_block) if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (1:0) {#if options != null }
    function create_if_block$9(component, ctx) {
    	var select, option, select_updating = false, select_required_value;

    	var each_value = ctx.options;

    	var each_blocks = [];

    	for (var i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$4(component, get_each_context$4(ctx, each_value, i));
    	}

    	function select_change_handler() {
    		select_updating = true;
    		ctx.field.selected = selectValue(select);
    		component.set({ field: ctx.field, options: ctx.options });
    		select_updating = false;
    	}

    	function change_handler(event) {
    		component.onChange();
    	}

    	return {
    		c: function create() {
    			select = createElement("select");
    			option = createElement("option");
    			option.textContent = "All";

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}
    			option.__value = "";
    			option.value = option.__value;
    			addLoc(option, file$c, 8, 1, 188);
    			addListener(select, "change", select_change_handler);
    			if (!('field' in ctx)) component.root._beforecreate.push(select_change_handler);
    			addListener(select, "change", change_handler);
    			select.id = ctx.id;
    			select.required = select_required_value = ctx.field.metadata.required;
    			select.tabIndex = ctx.tabindex;
    			select.className = "form-control";
    			addLoc(select, file$c, 1, 0, 24);
    		},

    		m: function mount(target, anchor) {
    			insert(target, select, anchor);
    			append(select, option);

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(select, null);
    			}

    			selectOption(select, ctx.field.selected);
    		},

    		p: function update(changed, _ctx) {
    			ctx = _ctx;
    			if (changed.options) {
    				each_value = ctx.options;

    				for (var i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$4(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    					} else {
    						each_blocks[i] = create_each_block$4(component, child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(select, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}
    				each_blocks.length = each_value.length;
    			}

    			if (!select_updating && changed.field) selectOption(select, ctx.field.selected);
    			if (changed.id) {
    				select.id = ctx.id;
    			}

    			if ((changed.field) && select_required_value !== (select_required_value = ctx.field.metadata.required)) {
    				select.required = select_required_value;
    			}

    			if (changed.tabindex) {
    				select.tabIndex = ctx.tabindex;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(select);
    			}

    			destroyEach(each_blocks, detach);

    			removeListener(select, "change", select_change_handler);
    			removeListener(select, "change", change_handler);
    		}
    	};
    }

    // (10:1) {#each options as option}
    function create_each_block$4(component, ctx) {
    	var option, raw_value = ctx.option.label, option_value_value;

    	return {
    		c: function create() {
    			option = createElement("option");
    			option.__value = option_value_value = ctx.option.value;
    			option.value = option.__value;
    			addLoc(option, file$c, 10, 1, 248);
    		},

    		m: function mount(target, anchor) {
    			insert(target, option, anchor);
    			option.innerHTML = raw_value;
    		},

    		p: function update(changed, ctx) {
    			if ((changed.options) && raw_value !== (raw_value = ctx.option.label)) {
    				option.innerHTML = raw_value;
    			}

    			if ((changed.options) && option_value_value !== (option_value_value = ctx.option.value)) {
    				option.__value = option_value_value;
    			}

    			option.value = option.__value;
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(option);
    			}
    		}
    	};
    }

    function SvelteComponent$c(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) {
    		throw new Error("'target' is a required option");
    	}

    	init(this, options);
    	this._state = assign({}, options.data);
    	if (!('options' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'options'");
    	if (!('id' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'id'");
    	if (!('field' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'field'");
    	if (!('tabindex' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'tabindex'");
    	this._intro = true;

    	this._fragment = create_main_fragment$c(this, this._state);

    	this.root._oncreate.push(() => {
    		oncreate$6.call(this);
    		this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
    	});

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);

    		flush(this);
    	}
    }

    assign(SvelteComponent$c.prototype, protoDev);
    assign(SvelteComponent$c.prototype, methods$4);

    SvelteComponent$c.prototype._checkReadOnly = function _checkReadOnly(newState) {
    };

    /* src\core\ui\inputs\Email.html generated by Svelte v2.16.1 */

    function oncreate$7() {
    	const { field } = this.get();
    	const formElement = this.refs.container;
    	formElement.addEventListener("change", () => {
    		field.init(field.selected);
    	});
    }
    const file$d = "src\\core\\ui\\inputs\\Email.html";

    function create_main_fragment$d(component, ctx) {
    	var input, input_updating = false, input_required_value;

    	function input_input_handler() {
    		input_updating = true;
    		ctx.field.selected = input.value;
    		component.set({ field: ctx.field });
    		input_updating = false;
    	}

    	return {
    		c: function create() {
    			input = createElement("input");
    			addListener(input, "input", input_input_handler);
    			setAttribute(input, "type", "Email");
    			input.id = ctx.id;
    			input.required = input_required_value = ctx.field.metadata.required;
    			input.tabIndex = ctx.tabindex;
    			input.className = "form-control";
    			addLoc(input, file$d, 1, 0, 2);
    		},

    		m: function mount(target, anchor) {
    			insert(target, input, anchor);
    			component.refs.container = input;

    			input.value = ctx.field.selected;
    		},

    		p: function update(changed, _ctx) {
    			ctx = _ctx;
    			if (!input_updating && changed.field) input.value = ctx.field.selected;
    			if (changed.id) {
    				input.id = ctx.id;
    			}

    			if ((changed.field) && input_required_value !== (input_required_value = ctx.field.metadata.required)) {
    				input.required = input_required_value;
    			}

    			if (changed.tabindex) {
    				input.tabIndex = ctx.tabindex;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(input);
    			}

    			removeListener(input, "input", input_input_handler);
    			if (component.refs.container === input) component.refs.container = null;
    		}
    	};
    }

    function SvelteComponent$d(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) {
    		throw new Error("'target' is a required option");
    	}

    	init(this, options);
    	this.refs = {};
    	this._state = assign({}, options.data);
    	if (!('id' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'id'");
    	if (!('field' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'field'");
    	if (!('tabindex' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'tabindex'");
    	this._intro = true;

    	this._fragment = create_main_fragment$d(this, this._state);

    	this.root._oncreate.push(() => {
    		oncreate$7.call(this);
    		this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
    	});

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);

    		flush(this);
    	}
    }

    assign(SvelteComponent$d.prototype, protoDev);

    SvelteComponent$d.prototype._checkReadOnly = function _checkReadOnly(newState) {
    };

    /* src\core\ui\inputs\FileUploader.html generated by Svelte v2.16.1 */

    function objectToArray(obj) {
    	if (obj) {
    		return Array.from(Object.keys(obj), k => obj[k]);
    	}

    	return [];
    }

    function getExtension(filename) {
    	return `.${filename.split(".").pop()}`;
    }

    function canFileBeAdded(filelist, file, allowedFileExtensions, app) {
    	const isFileExtensionAllowed =
    		allowedFileExtensions.indexOf("*") > -1 ||
    		allowedFileExtensions.indexOf(getExtension(file.name)) > -1;

    	const fileWasAlreadyAdded = filelist.find(f => f.name === file.name);

    	if (isFileExtensionAllowed && !fileWasAlreadyAdded) {
    		return true;
    	}

    	if (!isFileExtensionAllowed) {
    		app.showError(`File ${file.name} extension not allowed. Only ` +
    			`these file extensions are allowed: ${allowedFileExtensions}.`);
    	}

    	return false;
    }

    function getAllowedFileExtensions(component) {
    	let	allowedExtension = "*";
    	if (component.get().uploaderConfig && component.get().uploaderConfig.allowedFileExtensions) {
    		allowedExtension = component.get().uploaderConfig.allowedFileExtensions.split(",").map(item => item.trim());
    	}

    	return allowedExtension;
    }

    function addFiles(component, files) {
    	const { app } = component.get();
    	const filesToAdd = objectToArray(files);
    	let listedFiles = [];

    	if (component.get().selectedFiles) {
    		listedFiles = component.get().selectedFiles;
    	}

    	const allowedFileExtensions = getAllowedFileExtensions(component);
    	const filesThatCanBeAdded = filesToAdd
    		.filter(file => canFileBeAdded(listedFiles, file, allowedFileExtensions, app));

    	if (filesThatCanBeAdded.length > 0) {
    		if (!component.get().uploaderConfig.allowMultipleFiles) {
    			component.set({ selectedFiles: filesThatCanBeAdded.slice(0, 1) });
    		}
    		else {
    			component.set({ selectedFiles: filesThatCanBeAdded.concat(listedFiles) });
    		}
    	}
    }

    var methods$5 = {
    	addFiles(files) {
    		addFiles(this, files);
    		this.get().field.selected = this.get().selectedFiles;
    	},
    	removeFile(index) {
    		this.get().selectedFiles.splice(index, 1).splice(index, 1);
    		this.set({
    			selectedFiles: this.get().selectedFiles
    		});
    		this.get().field.selected = this.get().selectedFiles;
    		// eslint-disable-next-line no-restricted-globals
    		location.reload();
    	}
    };

    function oncreate$8() {
    	const { field } = this.get();

    	const uploaderConfig =
    		field.metadata.getCustomProperty("fileUploaderConfig") ||
    		{
    			allowMultipleFiles: false,
    			allowedFileExtensions: "*"
    		};

    	this.set({ uploaderConfig });

    	this.refs.dropzone.addEventListener("dragenter", () => {
    		this.refs.dropzone.classList.add("hover");
    	});

    	const self = this;
    	["dragleave", "drop"].forEach(t => {
    		self.refs.dropzone.addEventListener(t, () => {
    			self.refs.dropzone.classList.remove("hover");
    		});
    	});

    	this.refs.dropzone.ondragover = e => {
    		e.preventDefault();
    	};

    	this.refs.dropzone.ondrop = e => {
    		e.preventDefault();
    		self.addFiles(e.dataTransfer.files);
    		return false;
    	};
    }
    const file_1 = "src\\core\\ui\\inputs\\FileUploader.html";

    function add_css$7() {
    	var style = createElement("style");
    	style.id = 'svelte-6mad9x-style';
    	style.textContent = ".file-drop-area.svelte-6mad9x{text-align:center;border:dashed 2px #9c9c9c;min-height:60px;z-index:99999}.file-drop-area.svelte-6mad9x label.svelte-6mad9x{margin:auto;line-height:60px;display:block}.files-list.svelte-6mad9x i.svelte-6mad9x{margin-left:10px}.second-color.svelte-6mad9x{color:#f3818c}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRmlsZVVwbG9hZGVyLmh0bWwiLCJzb3VyY2VzIjpbIkZpbGVVcGxvYWRlci5odG1sIl0sInNvdXJjZXNDb250ZW50IjpbInsjaWYgc2VsZWN0ZWRGaWxlcyAhPSBudWxsICYmIHNlbGVjdGVkRmlsZXMubGVuZ3RoID4gMH1cclxuPHVsIGNsYXNzPVwiZmlsZXMtbGlzdFwiPlxyXG5cdHsjZWFjaCBzZWxlY3RlZEZpbGVzIGFzIGZpbGUsIGluZGV4fVxyXG5cdDxsaT57ZmlsZS5uYW1lfVxyXG5cdFx0PGkgY2xhc3M9XCJmYSBmYS10aW1lcyBzZWNvbmQtY29sb3JcIiBvbjpjbGljaz1cInJlbW92ZUZpbGUoaW5kZXgpXCI+PC9pPlxyXG5cdDwvbGk+XHJcblx0ey9lYWNofVxyXG48L3VsPlxyXG57L2lmfVxyXG48ZGl2IGNsYXNzPVwiZmlsZS1kcm9wLWFyZWFcIlx0cmVmOmRyb3B6b25lPlxyXG5cdHsjaWYgdXBsb2FkZXJDb25maWcgIT0gbnVsbCAmJiB1cGxvYWRlckNvbmZpZy5hbGxvd011bHRpcGxlRmlsZXN9XHJcblx0PGlucHV0IHR5cGU9XCJmaWxlXCJcclxuXHRcdGlkPVwie2lkfVwiXHJcblx0XHR0YWJpbmRleD1cInt0YWJpbmRleH1cIlxyXG5cdFx0b246Y2hhbmdlPVwiYWRkRmlsZXModGhpcy5maWxlcylcIlxyXG5cdFx0bXVsdGlwbGU9XCJtdWx0aXBsZVwiXHJcblx0XHRhY2NlcHQ9XCJ7dXBsb2FkZXJDb25maWcgPyB1cGxvYWRlckNvbmZpZy5hbGxvd2VkRmlsZUV4dGVuc2lvbnMgOiAnKid9XCIvPlxyXG5cdHs6ZWxzZX1cclxuXHQ8aW5wdXQgdHlwZT1cImZpbGVcIlxyXG5cdFx0aWQ9XCJ7aWR9XCJcclxuXHRcdHRhYmluZGV4PVwie3RhYmluZGV4fVwiXHJcblx0XHRvbjpjaGFuZ2U9XCJhZGRGaWxlcyh0aGlzLmZpbGVzKVwiXHJcblx0XHRhY2NlcHQ9XCJ7dXBsb2FkZXJDb25maWcgPyB1cGxvYWRlckNvbmZpZy5hbGxvd2VkRmlsZUV4dGVuc2lvbnMgOiAnKid9XCIvPlxyXG5cdHsvaWZ9XHJcblx0PGxhYmVsIGZvcj1cIntpZH1cIj5kcmFnIG9yIDxzdHJvbmcgY2xhc3M9J3NlY29uZC1jb2xvcic+dXBsb2FkPC9zdHJvbmc+IGZpbGVzPC9sYWJlbD5cclxuPC9kaXY+XHJcblxyXG48c2NyaXB0PlxyXG5cdGZ1bmN0aW9uIG9iamVjdFRvQXJyYXkob2JqKSB7XHJcblx0XHRpZiAob2JqKSB7XHJcblx0XHRcdHJldHVybiBBcnJheS5mcm9tKE9iamVjdC5rZXlzKG9iaiksIGsgPT4gb2JqW2tdKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gW107XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBnZXRFeHRlbnNpb24oZmlsZW5hbWUpIHtcclxuXHRcdHJldHVybiBgLiR7ZmlsZW5hbWUuc3BsaXQoXCIuXCIpLnBvcCgpfWA7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBjYW5GaWxlQmVBZGRlZChmaWxlbGlzdCwgZmlsZSwgYWxsb3dlZEZpbGVFeHRlbnNpb25zLCBhcHApIHtcclxuXHRcdGNvbnN0IGlzRmlsZUV4dGVuc2lvbkFsbG93ZWQgPVxyXG5cdFx0XHRhbGxvd2VkRmlsZUV4dGVuc2lvbnMuaW5kZXhPZihcIipcIikgPiAtMSB8fFxyXG5cdFx0XHRhbGxvd2VkRmlsZUV4dGVuc2lvbnMuaW5kZXhPZihnZXRFeHRlbnNpb24oZmlsZS5uYW1lKSkgPiAtMTtcclxuXHJcblx0XHRjb25zdCBmaWxlV2FzQWxyZWFkeUFkZGVkID0gZmlsZWxpc3QuZmluZChmID0+IGYubmFtZSA9PT0gZmlsZS5uYW1lKTtcclxuXHJcblx0XHRpZiAoaXNGaWxlRXh0ZW5zaW9uQWxsb3dlZCAmJiAhZmlsZVdhc0FscmVhZHlBZGRlZCkge1xyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIWlzRmlsZUV4dGVuc2lvbkFsbG93ZWQpIHtcclxuXHRcdFx0YXBwLnNob3dFcnJvcihgRmlsZSAke2ZpbGUubmFtZX0gZXh0ZW5zaW9uIG5vdCBhbGxvd2VkLiBPbmx5IGAgK1xyXG5cdFx0XHRcdGB0aGVzZSBmaWxlIGV4dGVuc2lvbnMgYXJlIGFsbG93ZWQ6ICR7YWxsb3dlZEZpbGVFeHRlbnNpb25zfS5gKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBnZXRBbGxvd2VkRmlsZUV4dGVuc2lvbnMoY29tcG9uZW50KSB7XHJcblx0XHRsZXRcdGFsbG93ZWRFeHRlbnNpb24gPSBcIipcIjtcclxuXHRcdGlmIChjb21wb25lbnQuZ2V0KCkudXBsb2FkZXJDb25maWcgJiYgY29tcG9uZW50LmdldCgpLnVwbG9hZGVyQ29uZmlnLmFsbG93ZWRGaWxlRXh0ZW5zaW9ucykge1xyXG5cdFx0XHRhbGxvd2VkRXh0ZW5zaW9uID0gY29tcG9uZW50LmdldCgpLnVwbG9hZGVyQ29uZmlnLmFsbG93ZWRGaWxlRXh0ZW5zaW9ucy5zcGxpdChcIixcIikubWFwKGl0ZW0gPT4gaXRlbS50cmltKCkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBhbGxvd2VkRXh0ZW5zaW9uO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gYWRkRmlsZXMoY29tcG9uZW50LCBmaWxlcykge1xyXG5cdFx0Y29uc3QgeyBhcHAgfSA9IGNvbXBvbmVudC5nZXQoKTtcclxuXHRcdGNvbnN0IGZpbGVzVG9BZGQgPSBvYmplY3RUb0FycmF5KGZpbGVzKTtcclxuXHRcdGxldCBsaXN0ZWRGaWxlcyA9IFtdO1xyXG5cclxuXHRcdGlmIChjb21wb25lbnQuZ2V0KCkuc2VsZWN0ZWRGaWxlcykge1xyXG5cdFx0XHRsaXN0ZWRGaWxlcyA9IGNvbXBvbmVudC5nZXQoKS5zZWxlY3RlZEZpbGVzO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IGFsbG93ZWRGaWxlRXh0ZW5zaW9ucyA9IGdldEFsbG93ZWRGaWxlRXh0ZW5zaW9ucyhjb21wb25lbnQpO1xyXG5cdFx0Y29uc3QgZmlsZXNUaGF0Q2FuQmVBZGRlZCA9IGZpbGVzVG9BZGRcclxuXHRcdFx0LmZpbHRlcihmaWxlID0+IGNhbkZpbGVCZUFkZGVkKGxpc3RlZEZpbGVzLCBmaWxlLCBhbGxvd2VkRmlsZUV4dGVuc2lvbnMsIGFwcCkpO1xyXG5cclxuXHRcdGlmIChmaWxlc1RoYXRDYW5CZUFkZGVkLmxlbmd0aCA+IDApIHtcclxuXHRcdFx0aWYgKCFjb21wb25lbnQuZ2V0KCkudXBsb2FkZXJDb25maWcuYWxsb3dNdWx0aXBsZUZpbGVzKSB7XHJcblx0XHRcdFx0Y29tcG9uZW50LnNldCh7IHNlbGVjdGVkRmlsZXM6IGZpbGVzVGhhdENhbkJlQWRkZWQuc2xpY2UoMCwgMSkgfSk7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0Y29tcG9uZW50LnNldCh7IHNlbGVjdGVkRmlsZXM6IGZpbGVzVGhhdENhbkJlQWRkZWQuY29uY2F0KGxpc3RlZEZpbGVzKSB9KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0ZXhwb3J0IGRlZmF1bHQge1xyXG5cdFx0bWV0aG9kczoge1xyXG5cdFx0XHRhZGRGaWxlcyhmaWxlcykge1xyXG5cdFx0XHRcdGFkZEZpbGVzKHRoaXMsIGZpbGVzKTtcclxuXHRcdFx0XHR0aGlzLmdldCgpLmZpZWxkLnNlbGVjdGVkID0gdGhpcy5nZXQoKS5zZWxlY3RlZEZpbGVzO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRyZW1vdmVGaWxlKGluZGV4KSB7XHJcblx0XHRcdFx0dGhpcy5nZXQoKS5zZWxlY3RlZEZpbGVzLnNwbGljZShpbmRleCwgMSkuc3BsaWNlKGluZGV4LCAxKTtcclxuXHRcdFx0XHR0aGlzLnNldCh7XHJcblx0XHRcdFx0XHRzZWxlY3RlZEZpbGVzOiB0aGlzLmdldCgpLnNlbGVjdGVkRmlsZXNcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0XHR0aGlzLmdldCgpLmZpZWxkLnNlbGVjdGVkID0gdGhpcy5nZXQoKS5zZWxlY3RlZEZpbGVzO1xyXG5cdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHNcclxuXHRcdFx0XHRsb2NhdGlvbi5yZWxvYWQoKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdG9uY3JlYXRlKCkge1xyXG5cdFx0XHRjb25zdCB7IGZpZWxkIH0gPSB0aGlzLmdldCgpO1xyXG5cclxuXHRcdFx0Y29uc3QgdXBsb2FkZXJDb25maWcgPVxyXG5cdFx0XHRcdGZpZWxkLm1ldGFkYXRhLmdldEN1c3RvbVByb3BlcnR5KFwiZmlsZVVwbG9hZGVyQ29uZmlnXCIpIHx8XHJcblx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0YWxsb3dNdWx0aXBsZUZpbGVzOiBmYWxzZSxcclxuXHRcdFx0XHRcdGFsbG93ZWRGaWxlRXh0ZW5zaW9uczogXCIqXCJcclxuXHRcdFx0XHR9O1xyXG5cclxuXHRcdFx0dGhpcy5zZXQoeyB1cGxvYWRlckNvbmZpZyB9KTtcclxuXHJcblx0XHRcdHRoaXMucmVmcy5kcm9wem9uZS5hZGRFdmVudExpc3RlbmVyKFwiZHJhZ2VudGVyXCIsICgpID0+IHtcclxuXHRcdFx0XHR0aGlzLnJlZnMuZHJvcHpvbmUuY2xhc3NMaXN0LmFkZChcImhvdmVyXCIpO1xyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdGNvbnN0IHNlbGYgPSB0aGlzO1xyXG5cdFx0XHRbXCJkcmFnbGVhdmVcIiwgXCJkcm9wXCJdLmZvckVhY2godCA9PiB7XHJcblx0XHRcdFx0c2VsZi5yZWZzLmRyb3B6b25lLmFkZEV2ZW50TGlzdGVuZXIodCwgKCkgPT4ge1xyXG5cdFx0XHRcdFx0c2VsZi5yZWZzLmRyb3B6b25lLmNsYXNzTGlzdC5yZW1vdmUoXCJob3ZlclwiKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHR0aGlzLnJlZnMuZHJvcHpvbmUub25kcmFnb3ZlciA9IGUgPT4ge1xyXG5cdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdHRoaXMucmVmcy5kcm9wem9uZS5vbmRyb3AgPSBlID0+IHtcclxuXHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XHJcblx0XHRcdFx0c2VsZi5hZGRGaWxlcyhlLmRhdGFUcmFuc2Zlci5maWxlcyk7XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHR9O1xyXG5cdFx0fVxyXG5cdH07XHJcbjwvc2NyaXB0PlxyXG5cclxuPHN0eWxlPlxyXG5cdC5maWxlLWRyb3AtYXJlYSB7XHJcblx0XHR0ZXh0LWFsaWduOiBjZW50ZXI7XHJcblx0XHRib3JkZXI6IGRhc2hlZCAycHggIzljOWM5YztcclxuXHRcdG1pbi1oZWlnaHQ6IDYwcHg7XHJcblx0XHR6LWluZGV4OiA5OTk5OTtcclxuXHR9XHJcblxyXG5cdC5maWxlLWRyb3AtYXJlYS5ob3ZlciB7XHJcblx0XHRiYWNrZ3JvdW5kOiAjZmZmZGU2O1xyXG5cdH1cclxuXHJcblx0LmZpbGUtZHJvcC1hcmVhIGxhYmVsIHtcclxuXHRcdG1hcmdpbjogYXV0bztcclxuXHRcdGxpbmUtaGVpZ2h0OiA2MHB4O1xyXG5cdFx0ZGlzcGxheTogYmxvY2s7XHJcblx0fVxyXG5cclxuXHQuZmlsZXMtbGlzdCBpIHtcclxuXHRcdG1hcmdpbi1sZWZ0OiAxMHB4O1xyXG5cdH1cclxuXHJcblx0LnNlY29uZC1jb2xvciB7XHJcblx0XHRjb2xvcjogI2YzODE4YztcclxuXHR9XHJcbjwvc3R5bGU+XHJcbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFnSkMsZUFBZSxjQUFDLENBQUMsQUFDaEIsVUFBVSxDQUFFLE1BQU0sQ0FDbEIsTUFBTSxDQUFFLE1BQU0sQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUMxQixVQUFVLENBQUUsSUFBSSxDQUNoQixPQUFPLENBQUUsS0FBSyxBQUNmLENBQUMsQUFNRCw2QkFBZSxDQUFDLEtBQUssY0FBQyxDQUFDLEFBQ3RCLE1BQU0sQ0FBRSxJQUFJLENBQ1osV0FBVyxDQUFFLElBQUksQ0FDakIsT0FBTyxDQUFFLEtBQUssQUFDZixDQUFDLEFBRUQseUJBQVcsQ0FBQyxDQUFDLGNBQUMsQ0FBQyxBQUNkLFdBQVcsQ0FBRSxJQUFJLEFBQ2xCLENBQUMsQUFFRCxhQUFhLGNBQUMsQ0FBQyxBQUNkLEtBQUssQ0FBRSxPQUFPLEFBQ2YsQ0FBQyJ9 */";
    	append(document.head, style);
    }

    function click_handler(event) {
    	const { component, ctx } = this._svelte;

    	component.removeFile(ctx.index);
    }

    function get_each_context$5(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.file = list[i];
    	child_ctx.index = i;
    	return child_ctx;
    }

    function create_main_fragment$e(component_1, ctx) {
    	var text0, div, text1, label, text2, strong, text4;

    	var if_block0 = (ctx.selectedFiles != null && ctx.selectedFiles.length > 0) && create_if_block_1$6(component_1, ctx);

    	function select_block_type(ctx) {
    		if (ctx.uploaderConfig != null && ctx.uploaderConfig.allowMultipleFiles) return create_if_block$a;
    		return create_else_block$5;
    	}

    	var current_block_type = select_block_type(ctx);
    	var if_block1 = current_block_type(component_1, ctx);

    	return {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			text0 = createText("\r\n");
    			div = createElement("div");
    			if_block1.c();
    			text1 = createText("\r\n\t");
    			label = createElement("label");
    			text2 = createText("drag or ");
    			strong = createElement("strong");
    			strong.textContent = "upload";
    			text4 = createText(" files");
    			strong.className = "second-color svelte-6mad9x";
    			addLoc(strong, file_1, 24, 27, 765);
    			label.htmlFor = ctx.id;
    			label.className = "svelte-6mad9x";
    			addLoc(label, file_1, 24, 1, 739);
    			div.className = "file-drop-area svelte-6mad9x";
    			addLoc(div, file_1, 9, 0, 244);
    		},

    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert(target, text0, anchor);
    			insert(target, div, anchor);
    			if_block1.m(div, null);
    			append(div, text1);
    			append(div, label);
    			append(label, text2);
    			append(label, strong);
    			append(label, text4);
    			component_1.refs.dropzone = div;
    		},

    		p: function update(changed, ctx) {
    			if (ctx.selectedFiles != null && ctx.selectedFiles.length > 0) {
    				if (if_block0) {
    					if_block0.p(changed, ctx);
    				} else {
    					if_block0 = create_if_block_1$6(component_1, ctx);
    					if_block0.c();
    					if_block0.m(text0.parentNode, text0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block1) {
    				if_block1.p(changed, ctx);
    			} else {
    				if_block1.d(1);
    				if_block1 = current_block_type(component_1, ctx);
    				if_block1.c();
    				if_block1.m(div, text1);
    			}

    			if (changed.id) {
    				label.htmlFor = ctx.id;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (if_block0) if_block0.d(detach);
    			if (detach) {
    				detachNode(text0);
    				detachNode(div);
    			}

    			if_block1.d();
    			if (component_1.refs.dropzone === div) component_1.refs.dropzone = null;
    		}
    	};
    }

    // (1:0) {#if selectedFiles != null && selectedFiles.length > 0}
    function create_if_block_1$6(component_1, ctx) {
    	var ul;

    	var each_value = ctx.selectedFiles;

    	var each_blocks = [];

    	for (var i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$5(component_1, get_each_context$5(ctx, each_value, i));
    	}

    	return {
    		c: function create() {
    			ul = createElement("ul");

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}
    			ul.className = "files-list svelte-6mad9x";
    			addLoc(ul, file_1, 1, 0, 57);
    		},

    		m: function mount(target, anchor) {
    			insert(target, ul, anchor);

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}
    		},

    		p: function update(changed, ctx) {
    			if (changed.selectedFiles) {
    				each_value = ctx.selectedFiles;

    				for (var i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$5(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    					} else {
    						each_blocks[i] = create_each_block$5(component_1, child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(ul, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}
    				each_blocks.length = each_value.length;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(ul);
    			}

    			destroyEach(each_blocks, detach);
    		}
    	};
    }

    // (3:1) {#each selectedFiles as file, index}
    function create_each_block$5(component_1, ctx) {
    	var li, text0_value = ctx.file.name, text0, text1, i;

    	return {
    		c: function create() {
    			li = createElement("li");
    			text0 = createText(text0_value);
    			text1 = createText("\r\n\t\t");
    			i = createElement("i");
    			i._svelte = { component: component_1, ctx };

    			addListener(i, "click", click_handler);
    			i.className = "fa fa-times second-color svelte-6mad9x";
    			addLoc(i, file_1, 4, 2, 141);
    			addLoc(li, file_1, 3, 1, 122);
    		},

    		m: function mount(target, anchor) {
    			insert(target, li, anchor);
    			append(li, text0);
    			append(li, text1);
    			append(li, i);
    		},

    		p: function update(changed, _ctx) {
    			ctx = _ctx;
    			if ((changed.selectedFiles) && text0_value !== (text0_value = ctx.file.name)) {
    				setData(text0, text0_value);
    			}

    			i._svelte.ctx = ctx;
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(li);
    			}

    			removeListener(i, "click", click_handler);
    		}
    	};
    }

    // (18:1) {:else}
    function create_else_block$5(component_1, ctx) {
    	var input, input_accept_value;

    	function change_handler(event) {
    		component_1.addFiles(this.files);
    	}

    	return {
    		c: function create() {
    			input = createElement("input");
    			addListener(input, "change", change_handler);
    			setAttribute(input, "type", "file");
    			input.id = ctx.id;
    			input.tabIndex = ctx.tabindex;
    			input.accept = input_accept_value = ctx.uploaderConfig ? ctx.uploaderConfig.allowedFileExtensions : '*';
    			addLoc(input, file_1, 18, 1, 560);
    		},

    		m: function mount(target, anchor) {
    			insert(target, input, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (changed.id) {
    				input.id = ctx.id;
    			}

    			if (changed.tabindex) {
    				input.tabIndex = ctx.tabindex;
    			}

    			if ((changed.uploaderConfig) && input_accept_value !== (input_accept_value = ctx.uploaderConfig ? ctx.uploaderConfig.allowedFileExtensions : '*')) {
    				input.accept = input_accept_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(input);
    			}

    			removeListener(input, "change", change_handler);
    		}
    	};
    }

    // (11:1) {#if uploaderConfig != null && uploaderConfig.allowMultipleFiles}
    function create_if_block$a(component_1, ctx) {
    	var input, input_accept_value;

    	function change_handler(event) {
    		component_1.addFiles(this.files);
    	}

    	return {
    		c: function create() {
    			input = createElement("input");
    			addListener(input, "change", change_handler);
    			setAttribute(input, "type", "file");
    			input.id = ctx.id;
    			input.tabIndex = ctx.tabindex;
    			input.multiple = "multiple";
    			input.accept = input_accept_value = ctx.uploaderConfig ? ctx.uploaderConfig.allowedFileExtensions : '*';
    			addLoc(input, file_1, 11, 1, 356);
    		},

    		m: function mount(target, anchor) {
    			insert(target, input, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (changed.id) {
    				input.id = ctx.id;
    			}

    			if (changed.tabindex) {
    				input.tabIndex = ctx.tabindex;
    			}

    			if ((changed.uploaderConfig) && input_accept_value !== (input_accept_value = ctx.uploaderConfig ? ctx.uploaderConfig.allowedFileExtensions : '*')) {
    				input.accept = input_accept_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(input);
    			}

    			removeListener(input, "change", change_handler);
    		}
    	};
    }

    function SvelteComponent$e(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) {
    		throw new Error("'target' is a required option");
    	}

    	init(this, options);
    	this.refs = {};
    	this._state = assign({}, options.data);
    	if (!('selectedFiles' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'selectedFiles'");
    	if (!('uploaderConfig' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'uploaderConfig'");
    	if (!('id' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'id'");
    	if (!('tabindex' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'tabindex'");
    	this._intro = true;

    	if (!document.getElementById("svelte-6mad9x-style")) add_css$7();

    	this._fragment = create_main_fragment$e(this, this._state);

    	this.root._oncreate.push(() => {
    		oncreate$8.call(this);
    		this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
    	});

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);

    		flush(this);
    	}
    }

    assign(SvelteComponent$e.prototype, protoDev);
    assign(SvelteComponent$e.prototype, methods$5);

    SvelteComponent$e.prototype._checkReadOnly = function _checkReadOnly(newState) {
    };

    var choices = createCommonjsModule(function (module, exports) {
    /*! choices.js v3.0.4 | (c) 2018 Josh Johnson | https://github.com/jshjohnson/Choices#readme */ 
    (function webpackUniversalModuleDefinition(root, factory) {
    	module.exports = factory();
    })(commonjsGlobal, function() {
    return /******/ (function(modules) { // webpackBootstrap
    /******/ 	// The module cache
    /******/ 	var installedModules = {};

    /******/ 	// The require function
    /******/ 	function __webpack_require__(moduleId) {

    /******/ 		// Check if module is in cache
    /******/ 		if(installedModules[moduleId])
    /******/ 			return installedModules[moduleId].exports;

    /******/ 		// Create a new module (and put it into the cache)
    /******/ 		var module = installedModules[moduleId] = {
    /******/ 			exports: {},
    /******/ 			id: moduleId,
    /******/ 			loaded: false
    /******/ 		};

    /******/ 		// Execute the module function
    /******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

    /******/ 		// Flag the module as loaded
    /******/ 		module.loaded = true;

    /******/ 		// Return the exports of the module
    /******/ 		return module.exports;
    /******/ 	}


    /******/ 	// expose the modules object (__webpack_modules__)
    /******/ 	__webpack_require__.m = modules;

    /******/ 	// expose the module cache
    /******/ 	__webpack_require__.c = installedModules;

    /******/ 	// __webpack_public_path__
    /******/ 	__webpack_require__.p = "/assets/scripts/dist/";

    /******/ 	// Load entry module and return exports
    /******/ 	return __webpack_require__(0);
    /******/ })
    /************************************************************************/
    /******/ ([
    /* 0 */
    /***/ (function(module, exports, __webpack_require__) {

    	module.exports = __webpack_require__(1);


    /***/ }),
    /* 1 */
    /***/ (function(module, exports, __webpack_require__) {

    	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

    	var _fuse = __webpack_require__(2);

    	var _fuse2 = _interopRequireDefault(_fuse);

    	var _classnames = __webpack_require__(3);

    	var _classnames2 = _interopRequireDefault(_classnames);

    	var _index = __webpack_require__(4);

    	var _index2 = _interopRequireDefault(_index);

    	var _index3 = __webpack_require__(31);

    	var _utils = __webpack_require__(32);

    	__webpack_require__(33);

    	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

    	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

    	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    	/**
    	 * Choices
    	 */
    	var Choices = function () {
    	  function Choices() {
    	    var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '[data-choice]';
    	    var userConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    	    _classCallCheck(this, Choices);

    	    // If there are multiple elements, create a new instance
    	    // for each element besides the first one (as that already has an instance)
    	    if ((0, _utils.isType)('String', element)) {
    	      var elements = document.querySelectorAll(element);
    	      if (elements.length > 1) {
    	        for (var i = 1; i < elements.length; i++) {
    	          var el = elements[i];
    	          new Choices(el, userConfig);
    	        }
    	      }
    	    }

    	    var defaultConfig = {
    	      silent: false,
    	      items: [],
    	      choices: [],
    	      renderChoiceLimit: -1,
    	      maxItemCount: -1,
    	      addItems: true,
    	      removeItems: true,
    	      removeItemButton: false,
    	      editItems: false,
    	      duplicateItems: true,
    	      delimiter: ',',
    	      paste: true,
    	      searchEnabled: true,
    	      searchChoices: true,
    	      searchFloor: 1,
    	      searchResultLimit: 4,
    	      searchFields: ['label', 'value'],
    	      position: 'auto',
    	      resetScrollPosition: true,
    	      regexFilter: null,
    	      shouldSort: true,
    	      shouldSortItems: false,
    	      sortFilter: _utils.sortByAlpha,
    	      placeholder: true,
    	      placeholderValue: null,
    	      searchPlaceholderValue: null,
    	      prependValue: null,
    	      appendValue: null,
    	      renderSelectedChoices: 'auto',
    	      loadingText: 'Loading...',
    	      noResultsText: 'No results found',
    	      noChoicesText: 'No choices to choose from',
    	      itemSelectText: 'Press to select',
    	      addItemText: function addItemText(value) {
    	        return 'Press Enter to add <b>"' + (0, _utils.stripHTML)(value) + '"</b>';
    	      },
    	      maxItemText: function maxItemText(maxItemCount) {
    	        return 'Only ' + maxItemCount + ' values can be added.';
    	      },
    	      itemComparer: function itemComparer(choice, item) {
    	        return choice === item;
    	      },
    	      uniqueItemText: 'Only unique values can be added.',
    	      classNames: {
    	        containerOuter: 'choices',
    	        containerInner: 'choices__inner',
    	        input: 'choices__input',
    	        inputCloned: 'choices__input--cloned',
    	        list: 'choices__list',
    	        listItems: 'choices__list--multiple',
    	        listSingle: 'choices__list--single',
    	        listDropdown: 'choices__list--dropdown',
    	        item: 'choices__item',
    	        itemSelectable: 'choices__item--selectable',
    	        itemDisabled: 'choices__item--disabled',
    	        itemChoice: 'choices__item--choice',
    	        placeholder: 'choices__placeholder',
    	        group: 'choices__group',
    	        groupHeading: 'choices__heading',
    	        button: 'choices__button',
    	        activeState: 'is-active',
    	        focusState: 'is-focused',
    	        openState: 'is-open',
    	        disabledState: 'is-disabled',
    	        highlightedState: 'is-highlighted',
    	        hiddenState: 'is-hidden',
    	        flippedState: 'is-flipped',
    	        loadingState: 'is-loading',
    	        noResults: 'has-no-results',
    	        noChoices: 'has-no-choices'
    	      },
    	      fuseOptions: {
    	        include: 'score'
    	      },
    	      callbackOnInit: null,
    	      callbackOnCreateTemplates: null
    	    };

    	    this.idNames = {
    	      itemChoice: 'item-choice'
    	    };

    	    // Merge options with user options
    	    this.config = (0, _utils.extend)(defaultConfig, userConfig);

    	    if (this.config.renderSelectedChoices !== 'auto' && this.config.renderSelectedChoices !== 'always') {
    	      if (!this.config.silent) {
    	        console.warn('renderSelectedChoices: Possible values are \'auto\' and \'always\'. Falling back to \'auto\'.');
    	      }
    	      this.config.renderSelectedChoices = 'auto';
    	    }

    	    // Create data store
    	    this.store = new _index2.default(this.render);

    	    // State tracking
    	    this.initialised = false;
    	    this.currentState = {};
    	    this.prevState = {};
    	    this.currentValue = '';

    	    // Retrieve triggering element (i.e. element with 'data-choice' trigger)
    	    this.element = element;
    	    this.passedElement = (0, _utils.isType)('String', element) ? document.querySelector(element) : element;

    	    if (!this.passedElement) {
    	      if (!this.config.silent) {
    	        console.error('Passed element not found');
    	      }
    	      return;
    	    }

    	    this.isTextElement = this.passedElement.type === 'text';
    	    this.isSelectOneElement = this.passedElement.type === 'select-one';
    	    this.isSelectMultipleElement = this.passedElement.type === 'select-multiple';
    	    this.isSelectElement = this.isSelectOneElement || this.isSelectMultipleElement;
    	    this.isValidElementType = this.isTextElement || this.isSelectElement;
    	    this.isIe11 = !!(navigator.userAgent.match(/Trident/) && navigator.userAgent.match(/rv[ :]11/));
    	    this.isScrollingOnIe = false;

    	    if (this.config.shouldSortItems === true && this.isSelectOneElement) {
    	      if (!this.config.silent) {
    	        console.warn('shouldSortElements: Type of passed element is \'select-one\', falling back to false.');
    	      }
    	    }

    	    this.highlightPosition = 0;
    	    this.canSearch = this.config.searchEnabled;

    	    this.placeholder = false;
    	    if (!this.isSelectOneElement) {
    	      this.placeholder = this.config.placeholder ? this.config.placeholderValue || this.passedElement.getAttribute('placeholder') : false;
    	    }

    	    // Assign preset choices from passed object
    	    this.presetChoices = this.config.choices;

    	    // Assign preset items from passed object first
    	    this.presetItems = this.config.items;

    	    // Then add any values passed from attribute
    	    if (this.passedElement.value) {
    	      this.presetItems = this.presetItems.concat(this.passedElement.value.split(this.config.delimiter));
    	    }

    	    // Set unique base Id
    	    this.baseId = (0, _utils.generateId)(this.passedElement, 'choices-');

    	    // Bind methods
    	    this.render = this.render.bind(this);

    	    // Bind event handlers
    	    this._onFocus = this._onFocus.bind(this);
    	    this._onBlur = this._onBlur.bind(this);
    	    this._onKeyUp = this._onKeyUp.bind(this);
    	    this._onKeyDown = this._onKeyDown.bind(this);
    	    this._onClick = this._onClick.bind(this);
    	    this._onTouchMove = this._onTouchMove.bind(this);
    	    this._onTouchEnd = this._onTouchEnd.bind(this);
    	    this._onMouseDown = this._onMouseDown.bind(this);
    	    this._onMouseOver = this._onMouseOver.bind(this);
    	    this._onPaste = this._onPaste.bind(this);
    	    this._onInput = this._onInput.bind(this);

    	    // Monitor touch taps/scrolls
    	    this.wasTap = true;

    	    // Cutting the mustard
    	    var cuttingTheMustard = 'classList' in document.documentElement;
    	    if (!cuttingTheMustard && !this.config.silent) {
    	      console.error('Choices: Your browser doesn\'t support Choices');
    	    }

    	    var canInit = (0, _utils.isElement)(this.passedElement) && this.isValidElementType;

    	    if (canInit) {
    	      // If element has already been initialised with Choices
    	      if (this.passedElement.getAttribute('data-choice') === 'active') {
    	        return;
    	      }

    	      // Let's go
    	      this.init();
    	    } else if (!this.config.silent) {
    	      console.error('Incompatible input passed');
    	    }
    	  }

    	  /*========================================
    	  =            Public functions            =
    	  ========================================*/

    	  /**
    	   * Initialise Choices
    	   * @return
    	   * @public
    	   */


    	  _createClass(Choices, [{
    	    key: 'init',
    	    value: function init() {
    	      if (this.initialised === true) {
    	        return;
    	      }

    	      var callback = this.config.callbackOnInit;

    	      // Set initialise flag
    	      this.initialised = true;
    	      // Create required elements
    	      this._createTemplates();
    	      // Generate input markup
    	      this._createInput();
    	      // Subscribe store to render method
    	      this.store.subscribe(this.render);
    	      // Render any items
    	      this.render();
    	      // Trigger event listeners
    	      this._addEventListeners();

    	      // Run callback if it is a function
    	      if (callback) {
    	        if ((0, _utils.isType)('Function', callback)) {
    	          callback.call(this);
    	        }
    	      }
    	    }

    	    /**
    	     * Destroy Choices and nullify values
    	     * @return
    	     * @public
    	     */

    	  }, {
    	    key: 'destroy',
    	    value: function destroy() {
    	      if (this.initialised === false) {
    	        return;
    	      }

    	      // Remove all event listeners
    	      this._removeEventListeners();

    	      // Reinstate passed element
    	      this.passedElement.classList.remove(this.config.classNames.input, this.config.classNames.hiddenState);
    	      this.passedElement.removeAttribute('tabindex');
    	      // Recover original styles if any
    	      var origStyle = this.passedElement.getAttribute('data-choice-orig-style');
    	      if (Boolean(origStyle)) {
    	        this.passedElement.removeAttribute('data-choice-orig-style');
    	        this.passedElement.setAttribute('style', origStyle);
    	      } else {
    	        this.passedElement.removeAttribute('style');
    	      }
    	      this.passedElement.removeAttribute('aria-hidden');
    	      this.passedElement.removeAttribute('data-choice');

    	      // Re-assign values - this is weird, I know
    	      this.passedElement.value = this.passedElement.value;

    	      // Move passed element back to original position
    	      this.containerOuter.parentNode.insertBefore(this.passedElement, this.containerOuter);
    	      // Remove added elements
    	      this.containerOuter.parentNode.removeChild(this.containerOuter);

    	      // Clear data store
    	      this.clearStore();

    	      // Nullify instance-specific data
    	      this.config.templates = null;

    	      // Uninitialise
    	      this.initialised = false;
    	    }

    	    /**
    	     * Render group choices into a DOM fragment and append to choice list
    	     * @param  {Array} groups    Groups to add to list
    	     * @param  {Array} choices   Choices to add to groups
    	     * @param  {DocumentFragment} fragment Fragment to add groups and options to (optional)
    	     * @return {DocumentFragment} Populated options fragment
    	     * @private
    	     */

    	  }, {
    	    key: 'renderGroups',
    	    value: function renderGroups(groups, choices, fragment) {
    	      var _this = this;

    	      var groupFragment = fragment || document.createDocumentFragment();
    	      var filter = this.config.sortFilter;

    	      // If sorting is enabled, filter groups
    	      if (this.config.shouldSort) {
    	        groups.sort(filter);
    	      }

    	      groups.forEach(function (group) {
    	        // Grab options that are children of this group
    	        var groupChoices = choices.filter(function (choice) {
    	          if (_this.isSelectOneElement) {
    	            return choice.groupId === group.id;
    	          }
    	          return choice.groupId === group.id && !choice.selected;
    	        });

    	        if (groupChoices.length >= 1) {
    	          var dropdownGroup = _this._getTemplate('choiceGroup', group);
    	          groupFragment.appendChild(dropdownGroup);
    	          _this.renderChoices(groupChoices, groupFragment, true);
    	        }
    	      });

    	      return groupFragment;
    	    }

    	    /**
    	     * Render choices into a DOM fragment and append to choice list
    	     * @param  {Array} choices    Choices to add to list
    	     * @param  {DocumentFragment} fragment Fragment to add choices to (optional)
    	     * @return {DocumentFragment} Populated choices fragment
    	     * @private
    	     */

    	  }, {
    	    key: 'renderChoices',
    	    value: function renderChoices(choices, fragment) {
    	      var _this2 = this;

    	      var withinGroup = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    	      // Create a fragment to store our list items (so we don't have to update the DOM for each item)
    	      var choicesFragment = fragment || document.createDocumentFragment();
    	      var _config = this.config,
    	          renderSelectedChoices = _config.renderSelectedChoices,
    	          searchResultLimit = _config.searchResultLimit,
    	          renderChoiceLimit = _config.renderChoiceLimit;

    	      var filter = this.isSearching ? _utils.sortByScore : this.config.sortFilter;
    	      var appendChoice = function appendChoice(choice) {
    	        var shouldRender = renderSelectedChoices === 'auto' ? _this2.isSelectOneElement || !choice.selected : true;
    	        if (shouldRender) {
    	          var dropdownItem = _this2._getTemplate('choice', choice);
    	          choicesFragment.appendChild(dropdownItem);
    	        }
    	      };

    	      var rendererableChoices = choices;

    	      if (renderSelectedChoices === 'auto' && !this.isSelectOneElement) {
    	        rendererableChoices = choices.filter(function (choice) {
    	          return !choice.selected;
    	        });
    	      }

    	      // Split array into placeholders and "normal" choices

    	      var _rendererableChoices$ = rendererableChoices.reduce(function (acc, choice) {
    	        if (choice.placeholder) {
    	          acc.placeholderChoices.push(choice);
    	        } else {
    	          acc.normalChoices.push(choice);
    	        }
    	        return acc;
    	      }, { placeholderChoices: [], normalChoices: [] }),
    	          placeholderChoices = _rendererableChoices$.placeholderChoices,
    	          normalChoices = _rendererableChoices$.normalChoices;

    	      // If sorting is enabled or the user is searching, filter choices


    	      if (this.config.shouldSort || this.isSearching) {
    	        normalChoices.sort(filter);
    	      }

    	      var choiceLimit = rendererableChoices.length;

    	      // Prepend placeholeder
    	      var sortedChoices = [].concat(_toConsumableArray(placeholderChoices), _toConsumableArray(normalChoices));

    	      if (this.isSearching) {
    	        choiceLimit = searchResultLimit;
    	      } else if (renderChoiceLimit > 0 && !withinGroup) {
    	        choiceLimit = renderChoiceLimit;
    	      }

    	      // Add each choice to dropdown within range
    	      for (var i = 0; i < choiceLimit; i++) {
    	        if (sortedChoices[i]) {
    	          appendChoice(sortedChoices[i]);
    	        }
    	      }
    	      return choicesFragment;
    	    }

    	    /**
    	     * Render items into a DOM fragment and append to items list
    	     * @param  {Array} items    Items to add to list
    	     * @param  {DocumentFragment} [fragment] Fragment to add items to (optional)
    	     * @return
    	     * @private
    	     */

    	  }, {
    	    key: 'renderItems',
    	    value: function renderItems(items) {
    	      var _this3 = this;

    	      var fragment = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    	      // Create fragment to add elements to
    	      var itemListFragment = fragment || document.createDocumentFragment();

    	      // If sorting is enabled, filter items
    	      if (this.config.shouldSortItems && !this.isSelectOneElement) {
    	        items.sort(this.config.sortFilter);
    	      }

    	      if (this.isTextElement) {
    	        // Simplify store data to just values
    	        var itemsFiltered = this.store.getItemsReducedToValues(items);
    	        var itemsFilteredString = itemsFiltered.join(this.config.delimiter);
    	        // Update the value of the hidden input
    	        this.passedElement.setAttribute('value', itemsFilteredString);
    	        this.passedElement.value = itemsFilteredString;
    	      } else {
    	        var selectedOptionsFragment = document.createDocumentFragment();

    	        // Add each list item to list
    	        items.forEach(function (item) {
    	          // Create a standard select option
    	          var option = _this3._getTemplate('option', item);
    	          // Append it to fragment
    	          selectedOptionsFragment.appendChild(option);
    	        });

    	        // Update selected choices
    	        this.passedElement.innerHTML = '';
    	        this.passedElement.appendChild(selectedOptionsFragment);
    	      }

    	      // Add each list item to list
    	      items.forEach(function (item) {
    	        // Create new list element
    	        var listItem = _this3._getTemplate('item', item);
    	        // Append it to list
    	        itemListFragment.appendChild(listItem);
    	      });

    	      return itemListFragment;
    	    }

    	    /**
    	     * Render DOM with values
    	     * @return
    	     * @private
    	     */

    	  }, {
    	    key: 'render',
    	    value: function render() {
    	      if (this.store.isLoading()) {
    	        return;
    	      }

    	      this.currentState = this.store.getState();

    	      // Only render if our state has actually changed
    	      if (this.currentState !== this.prevState) {
    	        // Choices
    	        if (this.currentState.choices !== this.prevState.choices || this.currentState.groups !== this.prevState.groups || this.currentState.items !== this.prevState.items) {
    	          if (this.isSelectElement) {
    	            // Get active groups/choices
    	            var activeGroups = this.store.getGroupsFilteredByActive();
    	            var activeChoices = this.store.getChoicesFilteredByActive();

    	            var choiceListFragment = document.createDocumentFragment();

    	            // Clear choices
    	            this.choiceList.innerHTML = '';

    	            // Scroll back to top of choices list
    	            if (this.config.resetScrollPosition) {
    	              this.choiceList.scrollTop = 0;
    	            }

    	            // If we have grouped options
    	            if (activeGroups.length >= 1 && this.isSearching !== true) {
    	              choiceListFragment = this.renderGroups(activeGroups, activeChoices, choiceListFragment);
    	            } else if (activeChoices.length >= 1) {
    	              choiceListFragment = this.renderChoices(activeChoices, choiceListFragment);
    	            }

    	            var activeItems = this.store.getItemsFilteredByActive();
    	            var canAddItem = this._canAddItem(activeItems, this.input.value);

    	            // If we have choices to show
    	            if (choiceListFragment.childNodes && choiceListFragment.childNodes.length > 0) {
    	              // ...and we can select them
    	              if (canAddItem.response) {
    	                // ...append them and highlight the first choice
    	                this.choiceList.appendChild(choiceListFragment);
    	                this._highlightChoice();
    	              } else {
    	                // ...otherwise show a notice
    	                this.choiceList.appendChild(this._getTemplate('notice', canAddItem.notice));
    	              }
    	            } else {
    	              // Otherwise show a notice
    	              var dropdownItem = void 0;
    	              var notice = void 0;

    	              if (this.isSearching) {
    	                notice = (0, _utils.isType)('Function', this.config.noResultsText) ? this.config.noResultsText() : this.config.noResultsText;

    	                dropdownItem = this._getTemplate('notice', notice, 'no-results');
    	              } else {
    	                notice = (0, _utils.isType)('Function', this.config.noChoicesText) ? this.config.noChoicesText() : this.config.noChoicesText;

    	                dropdownItem = this._getTemplate('notice', notice, 'no-choices');
    	              }

    	              this.choiceList.appendChild(dropdownItem);
    	            }
    	          }
    	        }

    	        // Items
    	        if (this.currentState.items !== this.prevState.items) {
    	          // Get active items (items that can be selected)
    	          var _activeItems = this.store.getItemsFilteredByActive();

    	          // Clear list
    	          this.itemList.innerHTML = '';

    	          if (_activeItems && _activeItems) {
    	            // Create a fragment to store our list items
    	            // (so we don't have to update the DOM for each item)
    	            var itemListFragment = this.renderItems(_activeItems);

    	            // If we have items to add
    	            if (itemListFragment.childNodes) {
    	              // Update list
    	              this.itemList.appendChild(itemListFragment);
    	            }
    	          }
    	        }

    	        this.prevState = this.currentState;
    	      }
    	    }

    	    /**
    	     * Select item (a selected item can be deleted)
    	     * @param  {Element} item Element to select
    	     * @param  {Boolean} [runEvent=true] Whether to trigger 'highlightItem' event
    	     * @return {Object} Class instance
    	     * @public
    	     */

    	  }, {
    	    key: 'highlightItem',
    	    value: function highlightItem(item) {
    	      var runEvent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

    	      if (!item) {
    	        return this;
    	      }

    	      var id = item.id;
    	      var groupId = item.groupId;
    	      var group = groupId >= 0 ? this.store.getGroupById(groupId) : null;

    	      this.store.dispatch((0, _index3.highlightItem)(id, true));

    	      if (runEvent) {
    	        if (group && group.value) {
    	          (0, _utils.triggerEvent)(this.passedElement, 'highlightItem', {
    	            id: id,
    	            value: item.value,
    	            label: item.label,
    	            groupValue: group.value
    	          });
    	        } else {
    	          (0, _utils.triggerEvent)(this.passedElement, 'highlightItem', {
    	            id: id,
    	            value: item.value,
    	            label: item.label
    	          });
    	        }
    	      }

    	      return this;
    	    }

    	    /**
    	     * Deselect item
    	     * @param  {Element} item Element to de-select
    	     * @return {Object} Class instance
    	     * @public
    	     */

    	  }, {
    	    key: 'unhighlightItem',
    	    value: function unhighlightItem(item) {
    	      if (!item) {
    	        return this;
    	      }

    	      var id = item.id;
    	      var groupId = item.groupId;
    	      var group = groupId >= 0 ? this.store.getGroupById(groupId) : null;

    	      this.store.dispatch((0, _index3.highlightItem)(id, false));

    	      if (group && group.value) {
    	        (0, _utils.triggerEvent)(this.passedElement, 'unhighlightItem', {
    	          id: id,
    	          value: item.value,
    	          label: item.label,
    	          groupValue: group.value
    	        });
    	      } else {
    	        (0, _utils.triggerEvent)(this.passedElement, 'unhighlightItem', {
    	          id: id,
    	          value: item.value,
    	          label: item.label
    	        });
    	      }

    	      return this;
    	    }

    	    /**
    	     * Highlight items within store
    	     * @return {Object} Class instance
    	     * @public
    	     */

    	  }, {
    	    key: 'highlightAll',
    	    value: function highlightAll() {
    	      var _this4 = this;

    	      var items = this.store.getItems();
    	      items.forEach(function (item) {
    	        _this4.highlightItem(item);
    	      });

    	      return this;
    	    }

    	    /**
    	     * Deselect items within store
    	     * @return {Object} Class instance
    	     * @public
    	     */

    	  }, {
    	    key: 'unhighlightAll',
    	    value: function unhighlightAll() {
    	      var _this5 = this;

    	      var items = this.store.getItems();
    	      items.forEach(function (item) {
    	        _this5.unhighlightItem(item);
    	      });

    	      return this;
    	    }

    	    /**
    	     * Remove an item from the store by its value
    	     * @param  {String} value Value to search for
    	     * @return {Object} Class instance
    	     * @public
    	     */

    	  }, {
    	    key: 'removeItemsByValue',
    	    value: function removeItemsByValue(value) {
    	      var _this6 = this;

    	      if (!value || !(0, _utils.isType)('String', value)) {
    	        return this;
    	      }

    	      var items = this.store.getItemsFilteredByActive();

    	      items.forEach(function (item) {
    	        if (item.value === value) {
    	          _this6._removeItem(item);
    	        }
    	      });

    	      return this;
    	    }

    	    /**
    	     * Remove all items from store array
    	     * @note Removed items are soft deleted
    	     * @param  {Number} excludedId Optionally exclude item by ID
    	     * @return {Object} Class instance
    	     * @public
    	     */

    	  }, {
    	    key: 'removeActiveItems',
    	    value: function removeActiveItems(excludedId) {
    	      var _this7 = this;

    	      var items = this.store.getItemsFilteredByActive();

    	      items.forEach(function (item) {
    	        if (item.active && excludedId !== item.id) {
    	          _this7._removeItem(item);
    	        }
    	      });

    	      return this;
    	    }

    	    /**
    	     * Remove all selected items from store
    	     * @note Removed items are soft deleted
    	     * @return {Object} Class instance
    	     * @public
    	     */

    	  }, {
    	    key: 'removeHighlightedItems',
    	    value: function removeHighlightedItems() {
    	      var _this8 = this;

    	      var runEvent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    	      var items = this.store.getItemsFilteredByActive();

    	      items.forEach(function (item) {
    	        if (item.highlighted && item.active) {
    	          _this8._removeItem(item);
    	          // If this action was performed by the user
    	          // trigger the event
    	          if (runEvent) {
    	            _this8._triggerChange(item.value);
    	          }
    	        }
    	      });

    	      return this;
    	    }

    	    /**
    	     * Show dropdown to user by adding active state class
    	     * @return {Object} Class instance
    	     * @public
    	     */

    	  }, {
    	    key: 'showDropdown',
    	    value: function showDropdown() {
    	      var focusInput = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    	      var body = document.body;
    	      var html = document.documentElement;
    	      var winHeight = Math.max(body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight);

    	      this.containerOuter.classList.add(this.config.classNames.openState);
    	      this.containerOuter.setAttribute('aria-expanded', 'true');
    	      this.dropdown.classList.add(this.config.classNames.activeState);
    	      this.dropdown.setAttribute('aria-expanded', 'true');

    	      var dimensions = this.dropdown.getBoundingClientRect();
    	      var dropdownPos = Math.ceil(dimensions.top + window.scrollY + this.dropdown.offsetHeight);

    	      // If flip is enabled and the dropdown bottom position is greater than the window height flip the dropdown.
    	      var shouldFlip = false;
    	      if (this.config.position === 'auto') {
    	        shouldFlip = dropdownPos >= winHeight;
    	      } else if (this.config.position === 'top') {
    	        shouldFlip = true;
    	      }

    	      if (shouldFlip) {
    	        this.containerOuter.classList.add(this.config.classNames.flippedState);
    	      }

    	      // Optionally focus the input if we have a search input
    	      if (focusInput && this.canSearch && document.activeElement !== this.input) {
    	        this.input.focus();
    	      }

    	      (0, _utils.triggerEvent)(this.passedElement, 'showDropdown', {});

    	      return this;
    	    }

    	    /**
    	     * Hide dropdown from user
    	     * @return {Object} Class instance
    	     * @public
    	     */

    	  }, {
    	    key: 'hideDropdown',
    	    value: function hideDropdown() {
    	      var blurInput = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    	      // A dropdown flips if it does not have space within the page
    	      var isFlipped = this.containerOuter.classList.contains(this.config.classNames.flippedState);

    	      this.containerOuter.classList.remove(this.config.classNames.openState);
    	      this.containerOuter.setAttribute('aria-expanded', 'false');
    	      this.dropdown.classList.remove(this.config.classNames.activeState);
    	      this.dropdown.setAttribute('aria-expanded', 'false');

    	      if (isFlipped) {
    	        this.containerOuter.classList.remove(this.config.classNames.flippedState);
    	      }

    	      // Optionally blur the input if we have a search input
    	      if (blurInput && this.canSearch && document.activeElement === this.input) {
    	        this.input.blur();
    	      }

    	      (0, _utils.triggerEvent)(this.passedElement, 'hideDropdown', {});

    	      return this;
    	    }

    	    /**
    	     * Determine whether to hide or show dropdown based on its current state
    	     * @return {Object} Class instance
    	     * @public
    	     */

    	  }, {
    	    key: 'toggleDropdown',
    	    value: function toggleDropdown() {
    	      var hasActiveDropdown = this.dropdown.classList.contains(this.config.classNames.activeState);
    	      if (hasActiveDropdown) {
    	        this.hideDropdown();
    	      } else {
    	        this.showDropdown(true);
    	      }

    	      return this;
    	    }

    	    /**
    	     * Get value(s) of input (i.e. inputted items (text) or selected choices (select))
    	     * @param {Boolean} valueOnly Get only values of selected items, otherwise return selected items
    	     * @return {Array/String} selected value (select-one) or array of selected items (inputs & select-multiple)
    	     * @public
    	     */

    	  }, {
    	    key: 'getValue',
    	    value: function getValue() {
    	      var _this9 = this;

    	      var valueOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    	      var items = this.store.getItemsFilteredByActive();
    	      var selectedItems = [];

    	      items.forEach(function (item) {
    	        if (_this9.isTextElement) {
    	          selectedItems.push(valueOnly ? item.value : item);
    	        } else if (item.active) {
    	          selectedItems.push(valueOnly ? item.value : item);
    	        }
    	      });

    	      if (this.isSelectOneElement) {
    	        return selectedItems[0];
    	      }

    	      return selectedItems;
    	    }

    	    /**
    	     * Set value of input. If the input is a select box, a choice will be created and selected otherwise
    	     * an item will created directly.
    	     * @param  {Array}   args  Array of value objects or value strings
    	     * @return {Object} Class instance
    	     * @public
    	     */

    	  }, {
    	    key: 'setValue',
    	    value: function setValue(args) {
    	      var _this10 = this;

    	      if (this.initialised === true) {
    	        // Convert args to an iterable array
    	        var values = [].concat(_toConsumableArray(args)),
    	            handleValue = function handleValue(item) {
    	          var itemType = (0, _utils.getType)(item);
    	          if (itemType === 'Object') {
    	            if (!item.value) {
    	              return;
    	            }

    	            // If we are dealing with a select input, we need to create an option first
    	            // that is then selected. For text inputs we can just add items normally.
    	            if (!_this10.isTextElement) {
    	              _this10._addChoice(item.value, item.label, true, false, -1, item.customProperties, item.placeholder);
    	            } else {
    	              _this10._addItem(item.value, item.label, item.id, undefined, item.customProperties, item.placeholder);
    	            }
    	          } else if (itemType === 'String') {
    	            if (!_this10.isTextElement) {
    	              _this10._addChoice(item, item, true, false, -1, null);
    	            } else {
    	              _this10._addItem(item);
    	            }
    	          }
    	        };

    	        if (values.length > 1) {
    	          values.forEach(function (value) {
    	            handleValue(value);
    	          });
    	        } else {
    	          handleValue(values[0]);
    	        }
    	      }
    	      return this;
    	    }

    	    /**
    	     * Select value of select box via the value of an existing choice
    	     * @param {Array/String} value An array of strings of a single string
    	     * @return {Object} Class instance
    	     * @public
    	     */

    	  }, {
    	    key: 'setValueByChoice',
    	    value: function setValueByChoice(value) {
    	      var _this11 = this;

    	      if (!this.isTextElement) {
    	        var choices = this.store.getChoices();
    	        // If only one value has been passed, convert to array
    	        var choiceValue = (0, _utils.isType)('Array', value) ? value : [value];

    	        // Loop through each value and
    	        choiceValue.forEach(function (val) {
    	          var foundChoice = choices.find(function (choice) {
    	            // Check 'value' property exists and the choice isn't already selected
    	            return _this11.config.itemComparer(choice.value, val);
    	          });

    	          if (foundChoice) {
    	            if (!foundChoice.selected) {
    	              _this11._addItem(foundChoice.value, foundChoice.label, foundChoice.id, foundChoice.groupId, foundChoice.customProperties, foundChoice.placeholder, foundChoice.keyCode);
    	            } else if (!_this11.config.silent) {
    	              console.warn('Attempting to select choice already selected');
    	            }
    	          } else if (!_this11.config.silent) {
    	            console.warn('Attempting to select choice that does not exist');
    	          }
    	        });
    	      }
    	      return this;
    	    }

    	    /**
    	     * Direct populate choices
    	     * @param  {Array} choices - Choices to insert
    	     * @param  {String} value - Name of 'value' property
    	     * @param  {String} label - Name of 'label' property
    	     * @param  {Boolean} replaceChoices Whether existing choices should be removed
    	     * @return {Object} Class instance
    	     * @public
    	     */

    	  }, {
    	    key: 'setChoices',
    	    value: function setChoices(choices, value, label) {
    	      var _this12 = this;

    	      var replaceChoices = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

    	      if (this.initialised === true) {
    	        if (this.isSelectElement) {
    	          if (!(0, _utils.isType)('Array', choices) || !value) {
    	            return this;
    	          }

    	          // Clear choices if needed
    	          if (replaceChoices) {
    	            this._clearChoices();
    	          }

    	          this._setLoading(true);

    	          // Add choices if passed
    	          if (choices && choices.length) {
    	            this.containerOuter.classList.remove(this.config.classNames.loadingState);
    	            choices.forEach(function (result) {
    	              if (result.choices) {
    	                _this12._addGroup(result, result.id || null, value, label);
    	              } else {
    	                _this12._addChoice(result[value], result[label], result.selected, result.disabled, undefined, result.customProperties, result.placeholder);
    	              }
    	            });
    	          }

    	          this._setLoading(false);
    	        }
    	      }
    	      return this;
    	    }

    	    /**
    	     * Clear items,choices and groups
    	     * @note Hard delete
    	     * @return {Object} Class instance
    	     * @public
    	     */

    	  }, {
    	    key: 'clearStore',
    	    value: function clearStore() {
    	      this.store.dispatch((0, _index3.clearAll)());
    	      return this;
    	    }

    	    /**
    	     * Set value of input to blank
    	     * @return {Object} Class instance
    	     * @public
    	     */

    	  }, {
    	    key: 'clearInput',
    	    value: function clearInput() {
    	      if (this.input.value) {
    	        this.input.value = '';
    	      }
    	      if (!this.isSelectOneElement) {
    	        this._setInputWidth();
    	      }
    	      if (!this.isTextElement && this.config.searchEnabled) {
    	        this.isSearching = false;
    	        this.store.dispatch((0, _index3.activateChoices)(true));
    	      }
    	      return this;
    	    }

    	    /**
    	     * Enable interaction with Choices
    	     * @return {Object} Class instance
    	     */

    	  }, {
    	    key: 'enable',
    	    value: function enable() {
    	      if (this.initialised) {
    	        this.passedElement.disabled = false;
    	        var isDisabled = this.containerOuter.classList.contains(this.config.classNames.disabledState);
    	        if (isDisabled) {
    	          this._addEventListeners();
    	          this.passedElement.removeAttribute('disabled');
    	          this.input.removeAttribute('disabled');
    	          this.containerOuter.classList.remove(this.config.classNames.disabledState);
    	          this.containerOuter.removeAttribute('aria-disabled');
    	          if (this.isSelectOneElement) {
    	            this.containerOuter.setAttribute('tabindex', '0');
    	          }
    	        }
    	      }
    	      return this;
    	    }

    	    /**
    	     * Disable interaction with Choices
    	     * @return {Object} Class instance
    	     * @public
    	     */

    	  }, {
    	    key: 'disable',
    	    value: function disable() {
    	      if (this.initialised) {
    	        this.passedElement.disabled = true;
    	        var isEnabled = !this.containerOuter.classList.contains(this.config.classNames.disabledState);
    	        if (isEnabled) {
    	          this._removeEventListeners();
    	          this.passedElement.setAttribute('disabled', '');
    	          this.input.setAttribute('disabled', '');
    	          this.containerOuter.classList.add(this.config.classNames.disabledState);
    	          this.containerOuter.setAttribute('aria-disabled', 'true');
    	          if (this.isSelectOneElement) {
    	            this.containerOuter.setAttribute('tabindex', '-1');
    	          }
    	        }
    	      }
    	      return this;
    	    }

    	    /**
    	     * Populate options via ajax callback
    	     * @param  {Function} fn Function that actually makes an AJAX request
    	     * @return {Object} Class instance
    	     * @public
    	     */

    	  }, {
    	    key: 'ajax',
    	    value: function ajax(fn) {
    	      var _this13 = this;

    	      if (this.initialised === true) {
    	        if (this.isSelectElement) {
    	          // Show loading text
    	          requestAnimationFrame(function () {
    	            _this13._handleLoadingState(true);
    	          });
    	          // Run callback
    	          fn(this._ajaxCallback());
    	        }
    	      }
    	      return this;
    	    }

    	    /*=====  End of Public functions  ======*/

    	    /*=============================================
    	    =                Private functions            =
    	    =============================================*/

    	    /**
    	     * Call change callback
    	     * @param  {String} value - last added/deleted/selected value
    	     * @return
    	     * @private
    	     */

    	  }, {
    	    key: '_triggerChange',
    	    value: function _triggerChange(value) {
    	      if (!value) {
    	        return;
    	      }

    	      (0, _utils.triggerEvent)(this.passedElement, 'change', {
    	        value: value
    	      });
    	    }

    	    /**
    	     * Process enter/click of an item button
    	     * @param {Array} activeItems The currently active items
    	     * @param  {Element} element Button being interacted with
    	     * @return
    	     * @private
    	     */

    	  }, {
    	    key: '_handleButtonAction',
    	    value: function _handleButtonAction(activeItems, element) {
    	      if (!activeItems || !element) {
    	        return;
    	      }

    	      // If we are clicking on a button
    	      if (this.config.removeItems && this.config.removeItemButton) {
    	        var itemId = element.parentNode.getAttribute('data-id');
    	        var itemToRemove = activeItems.find(function (item) {
    	          return item.id === parseInt(itemId, 10);
    	        });

    	        // Remove item associated with button
    	        this._removeItem(itemToRemove);
    	        this._triggerChange(itemToRemove.value);

    	        if (this.isSelectOneElement) {
    	          this._selectPlaceholderChoice();
    	        }
    	      }
    	    }

    	    /**
    	     * Select placeholder choice
    	     */

    	  }, {
    	    key: '_selectPlaceholderChoice',
    	    value: function _selectPlaceholderChoice() {
    	      var placeholderChoice = this.store.getPlaceholderChoice();

    	      if (placeholderChoice) {
    	        this._addItem(placeholderChoice.value, placeholderChoice.label, placeholderChoice.id, placeholderChoice.groupId, null, placeholderChoice.placeholder);
    	        this._triggerChange(placeholderChoice.value);
    	      }
    	    }

    	    /**
    	     * Process click of an item
    	     * @param {Array} activeItems The currently active items
    	     * @param  {Element} element Item being interacted with
    	     * @param  {Boolean} hasShiftKey Whether the user has the shift key active
    	     * @return
    	     * @private
    	     */

    	  }, {
    	    key: '_handleItemAction',
    	    value: function _handleItemAction(activeItems, element) {
    	      var _this14 = this;

    	      var hasShiftKey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    	      if (!activeItems || !element) {
    	        return;
    	      }

    	      // If we are clicking on an item
    	      if (this.config.removeItems && !this.isSelectOneElement) {
    	        var passedId = element.getAttribute('data-id');

    	        // We only want to select one item with a click
    	        // so we deselect any items that aren't the target
    	        // unless shift is being pressed
    	        activeItems.forEach(function (item) {
    	          if (item.id === parseInt(passedId, 10) && !item.highlighted) {
    	            _this14.highlightItem(item);
    	          } else if (!hasShiftKey) {
    	            if (item.highlighted) {
    	              _this14.unhighlightItem(item);
    	            }
    	          }
    	        });

    	        // Focus input as without focus, a user cannot do anything with a
    	        // highlighted item
    	        if (document.activeElement !== this.input) {
    	          this.input.focus();
    	        }
    	      }
    	    }

    	    /**
    	     * Process click of a choice
    	     * @param {Array} activeItems The currently active items
    	     * @param  {Element} element Choice being interacted with
    	     * @return
    	     */

    	  }, {
    	    key: '_handleChoiceAction',
    	    value: function _handleChoiceAction(activeItems, element) {
    	      if (!activeItems || !element) {
    	        return;
    	      }

    	      // If we are clicking on an option
    	      var id = element.getAttribute('data-id');
    	      var choice = this.store.getChoiceById(id);
    	      var passedKeyCode = activeItems[0] && activeItems[0].keyCode ? activeItems[0].keyCode : null;
    	      var hasActiveDropdown = this.dropdown.classList.contains(this.config.classNames.activeState);

    	      // Update choice keyCode
    	      choice.keyCode = passedKeyCode;

    	      (0, _utils.triggerEvent)(this.passedElement, 'choice', {
    	        choice: choice
    	      });

    	      if (choice && !choice.selected && !choice.disabled) {
    	        var canAddItem = this._canAddItem(activeItems, choice.value);

    	        if (canAddItem.response) {
    	          this._addItem(choice.value, choice.label, choice.id, choice.groupId, choice.customProperties, choice.placeholder, choice.keyCode);
    	          this._triggerChange(choice.value);
    	        }
    	      }

    	      this.clearInput();

    	      // We wont to close the dropdown if we are dealing with a single select box
    	      if (hasActiveDropdown && this.isSelectOneElement) {
    	        this.hideDropdown();
    	        this.containerOuter.focus();
    	      }
    	    }

    	    /**
    	     * Process back space event
    	     * @param  {Array} activeItems items
    	     * @return
    	     * @private
    	     */

    	  }, {
    	    key: '_handleBackspace',
    	    value: function _handleBackspace(activeItems) {
    	      if (this.config.removeItems && activeItems) {
    	        var lastItem = activeItems[activeItems.length - 1];
    	        var hasHighlightedItems = activeItems.some(function (item) {
    	          return item.highlighted;
    	        });

    	        // If editing the last item is allowed and there are not other selected items,
    	        // we can edit the item value. Otherwise if we can remove items, remove all selected items
    	        if (this.config.editItems && !hasHighlightedItems && lastItem) {
    	          this.input.value = lastItem.value;
    	          this._setInputWidth();
    	          this._removeItem(lastItem);
    	          this._triggerChange(lastItem.value);
    	        } else {
    	          if (!hasHighlightedItems) {
    	            this.highlightItem(lastItem, false);
    	          }
    	          this.removeHighlightedItems(true);
    	        }
    	      }
    	    }

    	    /**
    	     * Validates whether an item can be added by a user
    	     * @param {Array} activeItems The currently active items
    	     * @param  {String} value     Value of item to add
    	     * @return {Object}           Response: Whether user can add item
    	     *                            Notice: Notice show in dropdown
    	     */

    	  }, {
    	    key: '_canAddItem',
    	    value: function _canAddItem(activeItems, value) {
    	      var canAddItem = true;
    	      var notice = (0, _utils.isType)('Function', this.config.addItemText) ? this.config.addItemText(value) : this.config.addItemText;

    	      if (this.isSelectMultipleElement || this.isTextElement) {
    	        if (this.config.maxItemCount > 0 && this.config.maxItemCount <= activeItems.length) {
    	          // If there is a max entry limit and we have reached that limit
    	          // don't update
    	          canAddItem = false;
    	          notice = (0, _utils.isType)('Function', this.config.maxItemText) ? this.config.maxItemText(this.config.maxItemCount) : this.config.maxItemText;
    	        }
    	      }

    	      if (this.isTextElement && this.config.addItems && canAddItem) {
    	        // If a user has supplied a regular expression filter
    	        if (this.config.regexFilter) {
    	          // Determine whether we can update based on whether
    	          // our regular expression passes
    	          canAddItem = this._regexFilter(value);
    	        }
    	      }

    	      // If no duplicates are allowed, and the value already exists
    	      // in the array
    	      var isUnique = !activeItems.some(function (item) {
    	        if ((0, _utils.isType)('String', value)) {
    	          return item.value === value.trim();
    	        }

    	        return item.value === value;
    	      });

    	      if (!isUnique && !this.config.duplicateItems && !this.isSelectOneElement && canAddItem) {
    	        canAddItem = false;
    	        notice = (0, _utils.isType)('Function', this.config.uniqueItemText) ? this.config.uniqueItemText(value) : this.config.uniqueItemText;
    	      }

    	      return {
    	        response: canAddItem,
    	        notice: notice
    	      };
    	    }

    	    /**
    	     * Apply or remove a loading state to the component.
    	     * @param {Boolean} setLoading default value set to 'true'.
    	     * @return
    	     * @private
    	     */

    	  }, {
    	    key: '_handleLoadingState',
    	    value: function _handleLoadingState() {
    	      var setLoading = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

    	      var placeholderItem = this.itemList.querySelector('.' + this.config.classNames.placeholder);
    	      if (setLoading) {
    	        this.containerOuter.classList.add(this.config.classNames.loadingState);
    	        this.containerOuter.setAttribute('aria-busy', 'true');
    	        if (this.isSelectOneElement) {
    	          if (!placeholderItem) {
    	            placeholderItem = this._getTemplate('placeholder', this.config.loadingText);
    	            this.itemList.appendChild(placeholderItem);
    	          } else {
    	            placeholderItem.innerHTML = this.config.loadingText;
    	          }
    	        } else {
    	          this.input.placeholder = this.config.loadingText;
    	        }
    	      } else {
    	        // Remove loading states/text
    	        this.containerOuter.classList.remove(this.config.classNames.loadingState);

    	        if (this.isSelectOneElement) {
    	          placeholderItem.innerHTML = this.placeholder || '';
    	        } else {
    	          this.input.placeholder = this.placeholder || '';
    	        }
    	      }
    	    }

    	    /**
    	     * Retrieve the callback used to populate component's choices in an async way.
    	     * @returns {Function} The callback as a function.
    	     * @private
    	     */

    	  }, {
    	    key: '_ajaxCallback',
    	    value: function _ajaxCallback() {
    	      var _this15 = this;

    	      return function (results, value, label) {
    	        if (!results || !value) {
    	          return;
    	        }

    	        var parsedResults = (0, _utils.isType)('Object', results) ? [results] : results;

    	        if (parsedResults && (0, _utils.isType)('Array', parsedResults) && parsedResults.length) {
    	          // Remove loading states/text
    	          _this15._handleLoadingState(false);
    	          // Add each result as a choice

    	          _this15._setLoading(true);

    	          parsedResults.forEach(function (result) {
    	            if (result.choices) {
    	              var groupId = result.id || null;
    	              _this15._addGroup(result, groupId, value, label);
    	            } else {
    	              _this15._addChoice(result[value], result[label], result.selected, result.disabled, undefined, result.customProperties, result.placeholder);
    	            }
    	          });

    	          _this15._setLoading(false);

    	          if (_this15.isSelectOneElement) {
    	            _this15._selectPlaceholderChoice();
    	          }
    	        } else {
    	          // No results, remove loading state
    	          _this15._handleLoadingState(false);
    	        }

    	        _this15.containerOuter.removeAttribute('aria-busy');
    	      };
    	    }

    	    /**
    	     * Filter choices based on search value
    	     * @param  {String} value Value to filter by
    	     * @return
    	     * @private
    	     */

    	  }, {
    	    key: '_searchChoices',
    	    value: function _searchChoices(value) {
    	      var newValue = (0, _utils.isType)('String', value) ? value.trim() : value;
    	      var currentValue = (0, _utils.isType)('String', this.currentValue) ? this.currentValue.trim() : this.currentValue;

    	      // If new value matches the desired length and is not the same as the current value with a space
    	      if (newValue.length >= 1 && newValue !== currentValue + ' ') {
    	        var haystack = this.store.getSearchableChoices();
    	        var needle = newValue;
    	        var keys = (0, _utils.isType)('Array', this.config.searchFields) ? this.config.searchFields : [this.config.searchFields];
    	        var options = Object.assign(this.config.fuseOptions, { keys: keys });
    	        var fuse = new _fuse2.default(haystack, options);
    	        var results = fuse.search(needle);

    	        this.currentValue = newValue;
    	        this.highlightPosition = 0;
    	        this.isSearching = true;
    	        this.store.dispatch((0, _index3.filterChoices)(results));

    	        return results.length;
    	      }

    	      return 0;
    	    }

    	    /**
    	     * Determine the action when a user is searching
    	     * @param  {String} value Value entered by user
    	     * @return
    	     * @private
    	     */

    	  }, {
    	    key: '_handleSearch',
    	    value: function _handleSearch(value) {
    	      if (!value) {
    	        return;
    	      }

    	      var choices = this.store.getChoices();
    	      var hasUnactiveChoices = choices.some(function (option) {
    	        return !option.active;
    	      });

    	      // Run callback if it is a function
    	      if (this.input === document.activeElement) {
    	        // Check that we have a value to search and the input was an alphanumeric character
    	        if (value && value.length >= this.config.searchFloor) {
    	          var resultCount = 0;
    	          // Check flag to filter search input
    	          if (this.config.searchChoices) {
    	            // Filter available choices
    	            resultCount = this._searchChoices(value);
    	          }
    	          // Trigger search event
    	          (0, _utils.triggerEvent)(this.passedElement, 'search', {
    	            value: value,
    	            resultCount: resultCount
    	          });
    	        } else if (hasUnactiveChoices) {
    	          // Otherwise reset choices to active
    	          this.isSearching = false;
    	          this.store.dispatch((0, _index3.activateChoices)(true));
    	        }
    	      }
    	    }

    	    /**
    	     * Trigger event listeners
    	     * @return
    	     * @private
    	     */

    	  }, {
    	    key: '_addEventListeners',
    	    value: function _addEventListeners() {
    	      document.addEventListener('keyup', this._onKeyUp);
    	      document.addEventListener('keydown', this._onKeyDown);
    	      document.addEventListener('click', this._onClick);
    	      document.addEventListener('touchmove', this._onTouchMove);
    	      document.addEventListener('touchend', this._onTouchEnd);
    	      document.addEventListener('mousedown', this._onMouseDown);
    	      document.addEventListener('mouseover', this._onMouseOver);

    	      if (this.isSelectOneElement) {
    	        this.containerOuter.addEventListener('focus', this._onFocus);
    	        this.containerOuter.addEventListener('blur', this._onBlur);
    	      }

    	      this.input.addEventListener('input', this._onInput);
    	      this.input.addEventListener('paste', this._onPaste);
    	      this.input.addEventListener('focus', this._onFocus);
    	      this.input.addEventListener('blur', this._onBlur);
    	    }

    	    /**
    	     * Remove event listeners
    	     * @return
    	     * @private
    	     */

    	  }, {
    	    key: '_removeEventListeners',
    	    value: function _removeEventListeners() {
    	      document.removeEventListener('keyup', this._onKeyUp);
    	      document.removeEventListener('keydown', this._onKeyDown);
    	      document.removeEventListener('click', this._onClick);
    	      document.removeEventListener('touchmove', this._onTouchMove);
    	      document.removeEventListener('touchend', this._onTouchEnd);
    	      document.removeEventListener('mousedown', this._onMouseDown);
    	      document.removeEventListener('mouseover', this._onMouseOver);

    	      if (this.isSelectOneElement) {
    	        this.containerOuter.removeEventListener('focus', this._onFocus);
    	        this.containerOuter.removeEventListener('blur', this._onBlur);
    	      }

    	      this.input.removeEventListener('input', this._onInput);
    	      this.input.removeEventListener('paste', this._onPaste);
    	      this.input.removeEventListener('focus', this._onFocus);
    	      this.input.removeEventListener('blur', this._onBlur);
    	    }

    	    /**
    	     * Set the correct input width based on placeholder
    	     * value or input value
    	     * @return
    	     */

    	  }, {
    	    key: '_setInputWidth',
    	    value: function _setInputWidth() {
    	      if (this.placeholder) {
    	        // If there is a placeholder, we only want to set the width of the input when it is a greater
    	        // length than 75% of the placeholder. This stops the input jumping around.
    	        if (this.input.value && this.input.value.length >= this.placeholder.length / 1.25) {
    	          this.input.style.width = (0, _utils.getWidthOfInput)(this.input);
    	        }
    	      } else {
    	        // If there is no placeholder, resize input to contents
    	        this.input.style.width = (0, _utils.getWidthOfInput)(this.input);
    	      }
    	    }

    	    /**
    	     * Key down event
    	     * @param  {Object} e Event
    	     * @return
    	     */

    	  }, {
    	    key: '_onKeyDown',
    	    value: function _onKeyDown(e) {
    	      var _this16 = this,
    	          _keyDownActions;

    	      if (e.target !== this.input && !this.containerOuter.contains(e.target)) {
    	        return;
    	      }

    	      var target = e.target;
    	      var activeItems = this.store.getItemsFilteredByActive();
    	      var hasFocusedInput = this.input === document.activeElement;
    	      var hasActiveDropdown = this.dropdown.classList.contains(this.config.classNames.activeState);
    	      var hasItems = this.itemList && this.itemList.children;
    	      var keyString = String.fromCharCode(e.keyCode);

    	      var backKey = 46;
    	      var deleteKey = 8;
    	      var enterKey = 13;
    	      var aKey = 65;
    	      var escapeKey = 27;
    	      var upKey = 38;
    	      var downKey = 40;
    	      var pageUpKey = 33;
    	      var pageDownKey = 34;
    	      var ctrlDownKey = e.ctrlKey || e.metaKey;

    	      // If a user is typing and the dropdown is not active
    	      if (!this.isTextElement && /[a-zA-Z0-9-_ ]/.test(keyString) && !hasActiveDropdown) {
    	        this.showDropdown(true);
    	      }

    	      this.canSearch = this.config.searchEnabled;

    	      var onAKey = function onAKey() {
    	        // If CTRL + A or CMD + A have been pressed and there are items to select
    	        if (ctrlDownKey && hasItems) {
    	          _this16.canSearch = false;
    	          if (_this16.config.removeItems && !_this16.input.value && _this16.input === document.activeElement) {
    	            // Highlight items
    	            _this16.highlightAll();
    	          }
    	        }
    	      };

    	      var onEnterKey = function onEnterKey() {
    	        // If enter key is pressed and the input has a value
    	        if (_this16.isTextElement && target.value) {
    	          var value = _this16.input.value;
    	          var canAddItem = _this16._canAddItem(activeItems, value);

    	          // All is good, add
    	          if (canAddItem.response) {
    	            if (hasActiveDropdown) {
    	              _this16.hideDropdown();
    	            }
    	            _this16._addItem(value);
    	            _this16._triggerChange(value);
    	            _this16.clearInput();
    	          }
    	        }

    	        if (target.hasAttribute('data-button')) {
    	          _this16._handleButtonAction(activeItems, target);
    	          e.preventDefault();
    	        }

    	        if (hasActiveDropdown) {
    	          e.preventDefault();
    	          var highlighted = _this16.dropdown.querySelector('.' + _this16.config.classNames.highlightedState);

    	          // If we have a highlighted choice
    	          if (highlighted) {
    	            // add enter keyCode value
    	            if (activeItems[0]) {
    	              activeItems[0].keyCode = enterKey;
    	            }
    	            _this16._handleChoiceAction(activeItems, highlighted);
    	          }
    	        } else if (_this16.isSelectOneElement) {
    	          // Open single select dropdown if it's not active
    	          if (!hasActiveDropdown) {
    	            _this16.showDropdown(true);
    	            e.preventDefault();
    	          }
    	        }
    	      };

    	      var onEscapeKey = function onEscapeKey() {
    	        if (hasActiveDropdown) {
    	          _this16.toggleDropdown();
    	          _this16.containerOuter.focus();
    	        }
    	      };

    	      var onDirectionKey = function onDirectionKey() {
    	        // If up or down key is pressed, traverse through options
    	        if (hasActiveDropdown || _this16.isSelectOneElement) {
    	          // Show dropdown if focus
    	          if (!hasActiveDropdown) {
    	            _this16.showDropdown(true);
    	          }

    	          _this16.canSearch = false;

    	          var directionInt = e.keyCode === downKey || e.keyCode === pageDownKey ? 1 : -1;
    	          var skipKey = e.metaKey || e.keyCode === pageDownKey || e.keyCode === pageUpKey;

    	          var nextEl = void 0;
    	          if (skipKey) {
    	            if (directionInt > 0) {
    	              nextEl = Array.from(_this16.dropdown.querySelectorAll('[data-choice-selectable]')).pop();
    	            } else {
    	              nextEl = _this16.dropdown.querySelector('[data-choice-selectable]');
    	            }
    	          } else {
    	            var currentEl = _this16.dropdown.querySelector('.' + _this16.config.classNames.highlightedState);
    	            if (currentEl) {
    	              nextEl = (0, _utils.getAdjacentEl)(currentEl, '[data-choice-selectable]', directionInt);
    	            } else {
    	              nextEl = _this16.dropdown.querySelector('[data-choice-selectable]');
    	            }
    	          }

    	          if (nextEl) {
    	            // We prevent default to stop the cursor moving
    	            // when pressing the arrow
    	            if (!(0, _utils.isScrolledIntoView)(nextEl, _this16.choiceList, directionInt)) {
    	              _this16._scrollToChoice(nextEl, directionInt);
    	            }
    	            _this16._highlightChoice(nextEl);
    	          }

    	          // Prevent default to maintain cursor position whilst
    	          // traversing dropdown options
    	          e.preventDefault();
    	        }
    	      };

    	      var onDeleteKey = function onDeleteKey() {
    	        // If backspace or delete key is pressed and the input has no value
    	        if (hasFocusedInput && !e.target.value && !_this16.isSelectOneElement) {
    	          _this16._handleBackspace(activeItems);
    	          e.preventDefault();
    	        }
    	      };

    	      // Map keys to key actions
    	      var keyDownActions = (_keyDownActions = {}, _defineProperty(_keyDownActions, aKey, onAKey), _defineProperty(_keyDownActions, enterKey, onEnterKey), _defineProperty(_keyDownActions, escapeKey, onEscapeKey), _defineProperty(_keyDownActions, upKey, onDirectionKey), _defineProperty(_keyDownActions, pageUpKey, onDirectionKey), _defineProperty(_keyDownActions, downKey, onDirectionKey), _defineProperty(_keyDownActions, pageDownKey, onDirectionKey), _defineProperty(_keyDownActions, deleteKey, onDeleteKey), _defineProperty(_keyDownActions, backKey, onDeleteKey), _keyDownActions);

    	      // If keycode has a function, run it
    	      if (keyDownActions[e.keyCode]) {
    	        keyDownActions[e.keyCode]();
    	      }
    	    }

    	    /**
    	     * Key up event
    	     * @param  {Object} e Event
    	     * @return
    	     * @private
    	     */

    	  }, {
    	    key: '_onKeyUp',
    	    value: function _onKeyUp(e) {
    	      if (e.target !== this.input) {
    	        return;
    	      }

    	      var value = this.input.value;
    	      var activeItems = this.store.getItemsFilteredByActive();
    	      var canAddItem = this._canAddItem(activeItems, value);

    	      // We are typing into a text input and have a value, we want to show a dropdown
    	      // notice. Otherwise hide the dropdown
    	      if (this.isTextElement) {
    	        var hasActiveDropdown = this.dropdown.classList.contains(this.config.classNames.activeState);
    	        if (value) {

    	          if (canAddItem.notice) {
    	            var dropdownItem = this._getTemplate('notice', canAddItem.notice);
    	            this.dropdown.innerHTML = dropdownItem.outerHTML;
    	          }

    	          if (canAddItem.response === true) {
    	            if (!hasActiveDropdown) {
    	              this.showDropdown();
    	            }
    	          } else if (!canAddItem.notice && hasActiveDropdown) {
    	            this.hideDropdown();
    	          }
    	        } else if (hasActiveDropdown) {
    	          this.hideDropdown();
    	        }
    	      } else {
    	        var backKey = 46;
    	        var deleteKey = 8;

    	        // If user has removed value...
    	        if ((e.keyCode === backKey || e.keyCode === deleteKey) && !e.target.value) {
    	          // ...and it is a multiple select input, activate choices (if searching)
    	          if (!this.isTextElement && this.isSearching) {
    	            this.isSearching = false;
    	            this.store.dispatch((0, _index3.activateChoices)(true));
    	          }
    	        } else if (this.canSearch && canAddItem.response) {
    	          this._handleSearch(this.input.value);
    	        }
    	      }
    	      // Re-establish canSearch value from changes in _onKeyDown
    	      this.canSearch = this.config.searchEnabled;
    	    }

    	    /**
    	     * Input event
    	     * @return
    	     * @private
    	     */

    	  }, {
    	    key: '_onInput',
    	    value: function _onInput() {
    	      if (!this.isSelectOneElement) {
    	        this._setInputWidth();
    	      }
    	    }

    	    /**
    	     * Touch move event
    	     * @return
    	     * @private
    	     */

    	  }, {
    	    key: '_onTouchMove',
    	    value: function _onTouchMove() {
    	      if (this.wasTap === true) {
    	        this.wasTap = false;
    	      }
    	    }

    	    /**
    	     * Touch end event
    	     * @param  {Object} e Event
    	     * @return
    	     * @private
    	     */

    	  }, {
    	    key: '_onTouchEnd',
    	    value: function _onTouchEnd(e) {
    	      var target = e.target || e.touches[0].target;
    	      var hasActiveDropdown = this.dropdown.classList.contains(this.config.classNames.activeState);

    	      // If a user tapped within our container...
    	      if (this.wasTap === true && this.containerOuter.contains(target)) {
    	        // ...and we aren't dealing with a single select box, show dropdown/focus input
    	        if ((target === this.containerOuter || target === this.containerInner) && !this.isSelectOneElement) {
    	          if (this.isTextElement) {
    	            // If text element, we only want to focus the input (if it isn't already)
    	            if (document.activeElement !== this.input) {
    	              this.input.focus();
    	            }
    	          } else {
    	            if (!hasActiveDropdown) {
    	              // If a select box, we want to show the dropdown
    	              this.showDropdown(true);
    	            }
    	          }
    	        }
    	        // Prevents focus event firing
    	        e.stopPropagation();
    	      }

    	      this.wasTap = true;
    	    }

    	    /**
    	     * Mouse down event
    	     * @param  {Object} e Event
    	     * @return
    	     * @private
    	     */

    	  }, {
    	    key: '_onMouseDown',
    	    value: function _onMouseDown(e) {
    	      var target = e.target;

    	      // If we have our mouse down on the scrollbar and are on IE11...
    	      if (target === this.choiceList && this.isIe11) {
    	        this.isScrollingOnIe = true;
    	      }

    	      if (this.containerOuter.contains(target) && target !== this.input) {
    	        var foundTarget = void 0;
    	        var activeItems = this.store.getItemsFilteredByActive();
    	        var hasShiftKey = e.shiftKey;

    	        if (foundTarget = (0, _utils.findAncestorByAttrName)(target, 'data-button')) {
    	          this._handleButtonAction(activeItems, foundTarget);
    	        } else if (foundTarget = (0, _utils.findAncestorByAttrName)(target, 'data-item')) {
    	          this._handleItemAction(activeItems, foundTarget, hasShiftKey);
    	        } else if (foundTarget = (0, _utils.findAncestorByAttrName)(target, 'data-choice')) {
    	          this._handleChoiceAction(activeItems, foundTarget);
    	        }

    	        e.preventDefault();
    	      }
    	    }

    	    /**
    	     * Click event
    	     * @param  {Object} e Event
    	     * @return
    	     * @private
    	     */

    	  }, {
    	    key: '_onClick',
    	    value: function _onClick(e) {
    	      var target = e.target;
    	      var hasActiveDropdown = this.dropdown.classList.contains(this.config.classNames.activeState);
    	      var activeItems = this.store.getItemsFilteredByActive();

    	      // If target is something that concerns us
    	      if (this.containerOuter.contains(target)) {
    	        // Handle button delete
    	        if (target.hasAttribute('data-button')) {
    	          this._handleButtonAction(activeItems, target);
    	        }

    	        if (!hasActiveDropdown) {
    	          if (this.isTextElement) {
    	            if (document.activeElement !== this.input) {
    	              this.input.focus();
    	            }
    	          } else {
    	            if (this.canSearch) {
    	              this.showDropdown(true);
    	            } else {
    	              this.showDropdown();
    	              this.containerOuter.focus();
    	            }
    	          }
    	        } else if (this.isSelectOneElement && target !== this.input && !this.dropdown.contains(target)) {
    	          this.hideDropdown(true);
    	        }
    	      } else {
    	        var hasHighlightedItems = activeItems.some(function (item) {
    	          return item.highlighted;
    	        });

    	        // De-select any highlighted items
    	        if (hasHighlightedItems) {
    	          this.unhighlightAll();
    	        }

    	        // Remove focus state
    	        this.containerOuter.classList.remove(this.config.classNames.focusState);

    	        // Close all other dropdowns
    	        if (hasActiveDropdown) {
    	          this.hideDropdown();
    	        }
    	      }
    	    }

    	    /**
    	     * Mouse over (hover) event
    	     * @param  {Object} e Event
    	     * @return
    	     * @private
    	     */

    	  }, {
    	    key: '_onMouseOver',
    	    value: function _onMouseOver(e) {
    	      // If the dropdown is either the target or one of its children is the target
    	      if (e.target === this.dropdown || this.dropdown.contains(e.target)) {
    	        if (e.target.hasAttribute('data-choice')) this._highlightChoice(e.target);
    	      }
    	    }

    	    /**
    	     * Paste event
    	     * @param  {Object} e Event
    	     * @return
    	     * @private
    	     */

    	  }, {
    	    key: '_onPaste',
    	    value: function _onPaste(e) {
    	      // Disable pasting into the input if option has been set
    	      if (e.target === this.input && !this.config.paste) {
    	        e.preventDefault();
    	      }
    	    }

    	    /**
    	     * Focus event
    	     * @param  {Object} e Event
    	     * @return
    	     * @private
    	     */

    	  }, {
    	    key: '_onFocus',
    	    value: function _onFocus(e) {
    	      var _this17 = this;

    	      var target = e.target;
    	      // If target is something that concerns us
    	      if (this.containerOuter.contains(target)) {
    	        var hasActiveDropdown = this.dropdown.classList.contains(this.config.classNames.activeState);
    	        var focusActions = {
    	          text: function text() {
    	            if (target === _this17.input) {
    	              _this17.containerOuter.classList.add(_this17.config.classNames.focusState);
    	            }
    	          },
    	          'select-one': function selectOne() {
    	            _this17.containerOuter.classList.add(_this17.config.classNames.focusState);
    	            if (target === _this17.input) {
    	              // Show dropdown if it isn't already showing
    	              if (!hasActiveDropdown) {
    	                _this17.showDropdown();
    	              }
    	            }
    	          },
    	          'select-multiple': function selectMultiple() {
    	            if (target === _this17.input) {
    	              // If element is a select box, the focused element is the container and the dropdown
    	              // isn't already open, focus and show dropdown
    	              _this17.containerOuter.classList.add(_this17.config.classNames.focusState);

    	              if (!hasActiveDropdown) {
    	                _this17.showDropdown(true);
    	              }
    	            }
    	          }
    	        };

    	        focusActions[this.passedElement.type]();
    	      }
    	    }

    	    /**
    	     * Blur event
    	     * @param  {Object} e Event
    	     * @return
    	     * @private
    	     */

    	  }, {
    	    key: '_onBlur',
    	    value: function _onBlur(e) {
    	      var _this18 = this;

    	      var target = e.target;
    	      // If target is something that concerns us
    	      if (this.containerOuter.contains(target) && !this.isScrollingOnIe) {
    	        var activeItems = this.store.getItemsFilteredByActive();
    	        var hasActiveDropdown = this.dropdown.classList.contains(this.config.classNames.activeState);
    	        var hasHighlightedItems = activeItems.some(function (item) {
    	          return item.highlighted;
    	        });
    	        var blurActions = {
    	          text: function text() {
    	            if (target === _this18.input) {
    	              // Remove the focus state
    	              _this18.containerOuter.classList.remove(_this18.config.classNames.focusState);
    	              // De-select any highlighted items
    	              if (hasHighlightedItems) {
    	                _this18.unhighlightAll();
    	              }
    	              // Hide dropdown if it is showing
    	              if (hasActiveDropdown) {
    	                _this18.hideDropdown();
    	              }
    	            }
    	          },
    	          'select-one': function selectOne() {
    	            _this18.containerOuter.classList.remove(_this18.config.classNames.focusState);
    	            if (target === _this18.containerOuter) {
    	              // Hide dropdown if it is showing
    	              if (hasActiveDropdown && !_this18.canSearch) {
    	                _this18.hideDropdown();
    	              }
    	            }
    	            if (target === _this18.input && hasActiveDropdown) {
    	              // Hide dropdown if it is showing
    	              _this18.hideDropdown();
    	            }
    	          },
    	          'select-multiple': function selectMultiple() {
    	            if (target === _this18.input) {
    	              // Remove the focus state
    	              _this18.containerOuter.classList.remove(_this18.config.classNames.focusState);
    	              // Hide dropdown if it is showing
    	              if (hasActiveDropdown) {
    	                _this18.hideDropdown();
    	              }
    	              // De-select any highlighted items
    	              if (hasHighlightedItems) {
    	                _this18.unhighlightAll();
    	              }
    	            }
    	          }
    	        };

    	        blurActions[this.passedElement.type]();
    	      } else {
    	        // On IE11, clicking the scollbar blurs our input and thus
    	        // closes the dropdown. To stop this, we refocus our input
    	        // if we know we are on IE *and* are scrolling.
    	        this.isScrollingOnIe = false;
    	        this.input.focus();
    	      }
    	    }

    	    /**
    	     * Tests value against a regular expression
    	     * @param  {string} value   Value to test
    	     * @return {Boolean}        Whether test passed/failed
    	     * @private
    	     */

    	  }, {
    	    key: '_regexFilter',
    	    value: function _regexFilter(value) {
    	      if (!value) {
    	        return false;
    	      }

    	      var regex = this.config.regexFilter;
    	      var expression = new RegExp(regex.source, 'i');
    	      return expression.test(value);
    	    }

    	    /**
    	     * Scroll to an option element
    	     * @param  {HTMLElement} choice  Option to scroll to
    	     * @param  {Number} direction  Whether option is above or below
    	     * @return
    	     * @private
    	     */

    	  }, {
    	    key: '_scrollToChoice',
    	    value: function _scrollToChoice(choice, direction) {
    	      var _this19 = this;

    	      if (!choice) {
    	        return;
    	      }

    	      var dropdownHeight = this.choiceList.offsetHeight;
    	      var choiceHeight = choice.offsetHeight;
    	      // Distance from bottom of element to top of parent
    	      var choicePos = choice.offsetTop + choiceHeight;
    	      // Scroll position of dropdown
    	      var containerScrollPos = this.choiceList.scrollTop + dropdownHeight;
    	      // Difference between the choice and scroll position
    	      var endPoint = direction > 0 ? this.choiceList.scrollTop + choicePos - containerScrollPos : choice.offsetTop;

    	      var animateScroll = function animateScroll() {
    	        var strength = 4;
    	        var choiceListScrollTop = _this19.choiceList.scrollTop;
    	        var continueAnimation = false;
    	        var easing = void 0;
    	        var distance = void 0;

    	        if (direction > 0) {
    	          easing = (endPoint - choiceListScrollTop) / strength;
    	          distance = easing > 1 ? easing : 1;

    	          _this19.choiceList.scrollTop = choiceListScrollTop + distance;
    	          if (choiceListScrollTop < endPoint) {
    	            continueAnimation = true;
    	          }
    	        } else {
    	          easing = (choiceListScrollTop - endPoint) / strength;
    	          distance = easing > 1 ? easing : 1;

    	          _this19.choiceList.scrollTop = choiceListScrollTop - distance;
    	          if (choiceListScrollTop > endPoint) {
    	            continueAnimation = true;
    	          }
    	        }

    	        if (continueAnimation) {
    	          requestAnimationFrame(function (time) {
    	            animateScroll(time, endPoint, direction);
    	          });
    	        }
    	      };

    	      requestAnimationFrame(function (time) {
    	        animateScroll(time, endPoint, direction);
    	      });
    	    }

    	    /**
    	     * Highlight choice
    	     * @param  {HTMLElement} [el] Element to highlight
    	     * @return
    	     * @private
    	     */

    	  }, {
    	    key: '_highlightChoice',
    	    value: function _highlightChoice() {
    	      var _this20 = this;

    	      var el = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

    	      // Highlight first element in dropdown
    	      var choices = Array.from(this.dropdown.querySelectorAll('[data-choice-selectable]'));
    	      var passedEl = el;

    	      if (choices && choices.length) {
    	        var highlightedChoices = Array.from(this.dropdown.querySelectorAll('.' + this.config.classNames.highlightedState));

    	        // Remove any highlighted choices
    	        highlightedChoices.forEach(function (choice) {
    	          choice.classList.remove(_this20.config.classNames.highlightedState);
    	          choice.setAttribute('aria-selected', 'false');
    	        });

    	        if (passedEl) {
    	          this.highlightPosition = choices.indexOf(passedEl);
    	        } else {
    	          // Highlight choice based on last known highlight location
    	          if (choices.length > this.highlightPosition) {
    	            // If we have an option to highlight
    	            passedEl = choices[this.highlightPosition];
    	          } else {
    	            // Otherwise highlight the option before
    	            passedEl = choices[choices.length - 1];
    	          }

    	          if (!passedEl) {
    	            passedEl = choices[0];
    	          }
    	        }

    	        // Highlight given option, and set accessiblity attributes
    	        passedEl.classList.add(this.config.classNames.highlightedState);
    	        passedEl.setAttribute('aria-selected', 'true');
    	        this.containerOuter.setAttribute('aria-activedescendant', passedEl.id);
    	      }
    	    }

    	    /**
    	     * Add item to store with correct value
    	     * @param {String} value Value to add to store
    	     * @param {String} [label] Label to add to store
    	     * @param {Number} [choiceId=-1] ID of the associated choice that was selected
    	     * @param {Number} [groupId=-1] ID of group choice is within. Negative number indicates no group
    	     * @param {Object} [customProperties] Object containing user defined properties
    	     * @return {Object} Class instance
    	     * @public
    	     */

    	  }, {
    	    key: '_addItem',
    	    value: function _addItem(value) {
    	      var label = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    	      var choiceId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;
    	      var groupId = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : -1;
    	      var customProperties = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
    	      var placeholder = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
    	      var keyCode = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;

    	      var passedValue = (0, _utils.isType)('String', value) ? value.trim() : value;
    	      var passedKeyCode = keyCode;
    	      var items = this.store.getItems();
    	      var passedLabel = label || passedValue;
    	      var passedOptionId = parseInt(choiceId, 10) || -1;

    	      // Get group if group ID passed
    	      var group = groupId >= 0 ? this.store.getGroupById(groupId) : null;

    	      // Generate unique id
    	      var id = items ? items.length + 1 : 1;

    	      // If a prepended value has been passed, prepend it
    	      if (this.config.prependValue) {
    	        passedValue = this.config.prependValue + passedValue.toString();
    	      }

    	      // If an appended value has been passed, append it
    	      if (this.config.appendValue) {
    	        passedValue += this.config.appendValue.toString();
    	      }

    	      this.store.dispatch((0, _index3.addItem)(passedValue, passedLabel, id, passedOptionId, groupId, customProperties, placeholder, passedKeyCode));

    	      if (this.isSelectOneElement) {
    	        this.removeActiveItems(id);
    	      }

    	      // Trigger change event
    	      if (group && group.value) {
    	        (0, _utils.triggerEvent)(this.passedElement, 'addItem', {
    	          id: id,
    	          value: passedValue,
    	          label: passedLabel,
    	          groupValue: group.value,
    	          keyCode: passedKeyCode
    	        });
    	      } else {
    	        (0, _utils.triggerEvent)(this.passedElement, 'addItem', {
    	          id: id,
    	          value: passedValue,
    	          label: passedLabel,
    	          keyCode: passedKeyCode
    	        });
    	      }

    	      return this;
    	    }

    	    /**
    	     * Remove item from store
    	     * @param {Object} item Item to remove
    	     * @return {Object} Class instance
    	     * @public
    	     */

    	  }, {
    	    key: '_removeItem',
    	    value: function _removeItem(item) {
    	      if (!item || !(0, _utils.isType)('Object', item)) {
    	        return this;
    	      }

    	      var id = item.id;
    	      var value = item.value;
    	      var label = item.label;
    	      var choiceId = item.choiceId;
    	      var groupId = item.groupId;
    	      var group = groupId >= 0 ? this.store.getGroupById(groupId) : null;

    	      this.store.dispatch((0, _index3.removeItem)(id, choiceId));

    	      if (group && group.value) {
    	        (0, _utils.triggerEvent)(this.passedElement, 'removeItem', {
    	          id: id,
    	          value: value,
    	          label: label,
    	          groupValue: group.value
    	        });
    	      } else {
    	        (0, _utils.triggerEvent)(this.passedElement, 'removeItem', {
    	          id: id,
    	          value: value,
    	          label: label
    	        });
    	      }

    	      return this;
    	    }

    	    /**
    	     * Add choice to dropdown
    	     * @param {String} value Value of choice
    	     * @param {String} [label] Label of choice
    	     * @param {Boolean} [isSelected=false] Whether choice is selected
    	     * @param {Boolean} [isDisabled=false] Whether choice is disabled
    	     * @param {Number} [groupId=-1] ID of group choice is within. Negative number indicates no group
    	     * @param {Object} [customProperties] Object containing user defined properties
    	     * @return
    	     * @private
    	     */

    	  }, {
    	    key: '_addChoice',
    	    value: function _addChoice(value) {
    	      var label = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    	      var isSelected = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    	      var isDisabled = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    	      var groupId = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : -1;
    	      var customProperties = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
    	      var placeholder = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;
    	      var keyCode = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;

    	      if (typeof value === 'undefined' || value === null) {
    	        return;
    	      }

    	      // Generate unique id
    	      var choices = this.store.getChoices();
    	      var choiceLabel = label || value;
    	      var choiceId = choices ? choices.length + 1 : 1;
    	      var choiceElementId = this.baseId + '-' + this.idNames.itemChoice + '-' + choiceId;

    	      this.store.dispatch((0, _index3.addChoice)(value, choiceLabel, choiceId, groupId, isDisabled, choiceElementId, customProperties, placeholder, keyCode));

    	      if (isSelected) {
    	        this._addItem(value, choiceLabel, choiceId, undefined, customProperties, placeholder, keyCode);
    	      }
    	    }

    	    /**
    	     * Clear all choices added to the store.
    	     * @return
    	     * @private
    	     */

    	  }, {
    	    key: '_clearChoices',
    	    value: function _clearChoices() {
    	      this.store.dispatch((0, _index3.clearChoices)());
    	    }

    	    /**
    	     * Add group to dropdown
    	     * @param {Object} group Group to add
    	     * @param {Number} id Group ID
    	     * @param {String} [valueKey] name of the value property on the object
    	     * @param {String} [labelKey] name of the label property on the object
    	     * @return
    	     * @private
    	     */

    	  }, {
    	    key: '_addGroup',
    	    value: function _addGroup(group, id) {
    	      var _this21 = this;

    	      var valueKey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'value';
    	      var labelKey = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'label';

    	      var groupChoices = (0, _utils.isType)('Object', group) ? group.choices : Array.from(group.getElementsByTagName('OPTION'));
    	      var groupId = id ? id : Math.floor(new Date().valueOf() * Math.random());
    	      var isDisabled = group.disabled ? group.disabled : false;

    	      if (groupChoices) {
    	        this.store.dispatch((0, _index3.addGroup)(group.label, groupId, true, isDisabled));

    	        groupChoices.forEach(function (option) {
    	          var isOptDisabled = option.disabled || option.parentNode && option.parentNode.disabled;
    	          _this21._addChoice(option[valueKey], (0, _utils.isType)('Object', option) ? option[labelKey] : option.innerHTML, option.selected, isOptDisabled, groupId, option.customProperties, option.placeholder);
    	        });
    	      } else {
    	        this.store.dispatch((0, _index3.addGroup)(group.label, group.id, false, group.disabled));
    	      }
    	    }

    	    /**
    	     * Get template from name
    	     * @param  {String}    template Name of template to get
    	     * @param  {...}       args     Data to pass to template
    	     * @return {HTMLElement}        Template
    	     * @private
    	     */

    	  }, {
    	    key: '_getTemplate',
    	    value: function _getTemplate(template) {
    	      if (!template) {
    	        return null;
    	      }
    	      var templates = this.config.templates;

    	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    	        args[_key - 1] = arguments[_key];
    	      }

    	      return templates[template].apply(templates, args);
    	    }

    	    /**
    	     * Create HTML element based on type and arguments
    	     * @return
    	     * @private
    	     */

    	  }, {
    	    key: '_createTemplates',
    	    value: function _createTemplates() {
    	      var _this22 = this;

    	      var globalClasses = this.config.classNames;
    	      var templates = {
    	        containerOuter: function containerOuter(direction) {
    	          return (0, _utils.strToEl)('\n          <div\n            class="' + globalClasses.containerOuter + '"\n            ' + (_this22.isSelectElement ? _this22.config.searchEnabled ? 'role="combobox" aria-autocomplete="list"' : 'role="listbox"' : '') + '\n            data-type="' + _this22.passedElement.type + '"\n            ' + (_this22.isSelectOneElement ? 'tabindex="0"' : '') + '\n            aria-haspopup="true"\n            aria-expanded="false"\n            dir="' + direction + '"\n            >\n          </div>\n        ');
    	        },
    	        containerInner: function containerInner() {
    	          return (0, _utils.strToEl)('\n          <div class="' + globalClasses.containerInner + '"></div>\n        ');
    	        },
    	        itemList: function itemList() {
    	          var _classNames;

    	          var localClasses = (0, _classnames2.default)(globalClasses.list, (_classNames = {}, _defineProperty(_classNames, globalClasses.listSingle, _this22.isSelectOneElement), _defineProperty(_classNames, globalClasses.listItems, !_this22.isSelectOneElement), _classNames));

    	          return (0, _utils.strToEl)('\n          <div class="' + localClasses + '"></div>\n        ');
    	        },
    	        placeholder: function placeholder(value) {
    	          return (0, _utils.strToEl)('\n          <div class="' + globalClasses.placeholder + '">\n            ' + value + '\n          </div>\n        ');
    	        },
    	        item: function item(data) {
    	          var _classNames2;

    	          var localClasses = (0, _classnames2.default)(globalClasses.item, (_classNames2 = {}, _defineProperty(_classNames2, globalClasses.highlightedState, data.highlighted), _defineProperty(_classNames2, globalClasses.itemSelectable, !data.highlighted), _defineProperty(_classNames2, globalClasses.placeholder, data.placeholder), _classNames2));

    	          if (_this22.config.removeItemButton) {
    	            var _classNames3;

    	            localClasses = (0, _classnames2.default)(globalClasses.item, (_classNames3 = {}, _defineProperty(_classNames3, globalClasses.highlightedState, data.highlighted), _defineProperty(_classNames3, globalClasses.itemSelectable, !data.disabled), _defineProperty(_classNames3, globalClasses.placeholder, data.placeholder), _classNames3));

    	            return (0, _utils.strToEl)('\n            <div\n              class="' + localClasses + '"\n              data-item\n              data-id="' + data.id + '"\n              data-value="' + data.value + '"\n              data-deletable\n              ' + (data.active ? 'aria-selected="true"' : '') + '\n              ' + (data.disabled ? 'aria-disabled="true"' : '') + '\n              >\n              ' + data.label + '<!--\n           --><button\n                type="button"\n                class="' + globalClasses.button + '"\n                data-button\n                aria-label="Remove item: \'' + data.value + '\'"\n                >\n                Remove item\n              </button>\n            </div>\n          ');
    	          }

    	          return (0, _utils.strToEl)('\n          <div\n            class="' + localClasses + '"\n            data-item\n            data-id="' + data.id + '"\n            data-value="' + data.value + '"\n            ' + (data.active ? 'aria-selected="true"' : '') + '\n            ' + (data.disabled ? 'aria-disabled="true"' : '') + '\n            >\n            ' + data.label + '\n          </div>\n        ');
    	        },
    	        choiceList: function choiceList() {
    	          return (0, _utils.strToEl)('\n          <div\n            class="' + globalClasses.list + '"\n            dir="ltr"\n            role="listbox"\n            ' + (!_this22.isSelectOneElement ? 'aria-multiselectable="true"' : '') + '\n            >\n          </div>\n        ');
    	        },
    	        choiceGroup: function choiceGroup(data) {
    	          var localClasses = (0, _classnames2.default)(globalClasses.group, _defineProperty({}, globalClasses.itemDisabled, data.disabled));

    	          return (0, _utils.strToEl)('\n          <div\n            class="' + localClasses + '"\n            data-group\n            data-id="' + data.id + '"\n            data-value="' + data.value + '"\n            role="group"\n            ' + (data.disabled ? 'aria-disabled="true"' : '') + '\n            >\n            <div class="' + globalClasses.groupHeading + '">' + data.value + '</div>\n          </div>\n        ');
    	        },
    	        choice: function choice(data) {
    	          var _classNames5;

    	          var localClasses = (0, _classnames2.default)(globalClasses.item, globalClasses.itemChoice, (_classNames5 = {}, _defineProperty(_classNames5, globalClasses.itemDisabled, data.disabled), _defineProperty(_classNames5, globalClasses.itemSelectable, !data.disabled), _defineProperty(_classNames5, globalClasses.placeholder, data.placeholder), _classNames5));

    	          return (0, _utils.strToEl)('\n          <div\n            class="' + localClasses + '"\n            data-select-text="' + _this22.config.itemSelectText + '"\n            data-choice\n            data-id="' + data.id + '"\n            data-value="' + data.value + '"\n            ' + (data.disabled ? 'data-choice-disabled aria-disabled="true"' : 'data-choice-selectable') + '\n            id="' + data.elementId + '"\n            ' + (data.groupId > 0 ? 'role="treeitem"' : 'role="option"') + '\n            >\n            ' + data.label + '\n          </div>\n        ');
    	        },
    	        input: function input() {
    	          var localClasses = (0, _classnames2.default)(globalClasses.input, globalClasses.inputCloned);

    	          return (0, _utils.strToEl)('\n          <input\n            type="text"\n            class="' + localClasses + '"\n            autocomplete="off"\n            autocapitalize="off"\n            spellcheck="false"\n            role="textbox"\n            aria-autocomplete="list"\n            >\n        ');
    	        },
    	        dropdown: function dropdown() {
    	          var localClasses = (0, _classnames2.default)(globalClasses.list, globalClasses.listDropdown);

    	          return (0, _utils.strToEl)('\n          <div\n            class="' + localClasses + '"\n            aria-expanded="false"\n            >\n          </div>\n        ');
    	        },
    	        notice: function notice(label) {
    	          var _classNames6;

    	          var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

    	          var localClasses = (0, _classnames2.default)(globalClasses.item, globalClasses.itemChoice, (_classNames6 = {}, _defineProperty(_classNames6, globalClasses.noResults, type === 'no-results'), _defineProperty(_classNames6, globalClasses.noChoices, type === 'no-choices'), _classNames6));

    	          return (0, _utils.strToEl)('\n          <div class="' + localClasses + '">\n            ' + label + '\n          </div>\n        ');
    	        },
    	        option: function option(data) {
    	          return (0, _utils.strToEl)('\n          <option value="' + data.value + '" selected>' + data.label + '</option>\n        ');
    	        }
    	      };

    	      // User's custom templates
    	      var callbackTemplate = this.config.callbackOnCreateTemplates;
    	      var userTemplates = {};
    	      if (callbackTemplate && (0, _utils.isType)('Function', callbackTemplate)) {
    	        userTemplates = callbackTemplate.call(this, _utils.strToEl);
    	      }

    	      this.config.templates = (0, _utils.extend)(templates, userTemplates);
    	    }
    	  }, {
    	    key: '_setLoading',
    	    value: function _setLoading(isLoading) {
    	      this.store.dispatch((0, _index3.setIsLoading)(isLoading));
    	    }

    	    /**
    	     * Create DOM structure around passed select element
    	     * @return
    	     * @private
    	     */

    	  }, {
    	    key: '_createInput',
    	    value: function _createInput() {
    	      var _this23 = this;

    	      var direction = this.passedElement.getAttribute('dir') || 'ltr';
    	      var containerOuter = this._getTemplate('containerOuter', direction);
    	      var containerInner = this._getTemplate('containerInner');
    	      var itemList = this._getTemplate('itemList');
    	      var choiceList = this._getTemplate('choiceList');
    	      var input = this._getTemplate('input');
    	      var dropdown = this._getTemplate('dropdown');

    	      this.containerOuter = containerOuter;
    	      this.containerInner = containerInner;
    	      this.input = input;
    	      this.choiceList = choiceList;
    	      this.itemList = itemList;
    	      this.dropdown = dropdown;

    	      // Hide passed input
    	      this.passedElement.classList.add(this.config.classNames.input, this.config.classNames.hiddenState);

    	      // Remove element from tab index
    	      this.passedElement.tabIndex = '-1';

    	      // Backup original styles if any
    	      var origStyle = this.passedElement.getAttribute('style');

    	      if (Boolean(origStyle)) {
    	        this.passedElement.setAttribute('data-choice-orig-style', origStyle);
    	      }

    	      this.passedElement.setAttribute('style', 'display:none;');
    	      this.passedElement.setAttribute('aria-hidden', 'true');
    	      this.passedElement.setAttribute('data-choice', 'active');

    	      // Wrap input in container preserving DOM ordering
    	      (0, _utils.wrap)(this.passedElement, containerInner);

    	      // Wrapper inner container with outer container
    	      (0, _utils.wrap)(containerInner, containerOuter);

    	      if (this.isSelectOneElement) {
    	        input.placeholder = this.config.searchPlaceholderValue || '';
    	      } else if (this.placeholder) {
    	        input.placeholder = this.placeholder;
    	        input.style.width = (0, _utils.getWidthOfInput)(input);
    	      }

    	      if (!this.config.addItems) {
    	        this.disable();
    	      }

    	      containerOuter.appendChild(containerInner);
    	      containerOuter.appendChild(dropdown);
    	      containerInner.appendChild(itemList);

    	      if (!this.isTextElement) {
    	        dropdown.appendChild(choiceList);
    	      }

    	      if (this.isSelectMultipleElement || this.isTextElement) {
    	        containerInner.appendChild(input);
    	      } else if (this.canSearch) {
    	        dropdown.insertBefore(input, dropdown.firstChild);
    	      }

    	      if (this.isSelectElement) {
    	        var passedGroups = Array.from(this.passedElement.getElementsByTagName('OPTGROUP'));

    	        this.highlightPosition = 0;
    	        this.isSearching = false;

    	        this._setLoading(true);

    	        if (passedGroups && passedGroups.length) {
    	          passedGroups.forEach(function (group) {
    	            _this23._addGroup(group, group.id || null);
    	          });
    	        } else {
    	          var passedOptions = Array.from(this.passedElement.options);
    	          var filter = this.config.sortFilter;
    	          var allChoices = this.presetChoices;

    	          // Create array of options from option elements
    	          passedOptions.forEach(function (o) {
    	            allChoices.push({
    	              value: o.value,
    	              label: o.innerHTML,
    	              selected: o.selected,
    	              disabled: o.disabled || o.parentNode.disabled,
    	              placeholder: o.hasAttribute('placeholder')
    	            });
    	          });

    	          // If sorting is enabled or the user is searching, filter choices
    	          if (this.config.shouldSort) {
    	            allChoices.sort(filter);
    	          }

    	          // Determine whether there is a selected choice
    	          var hasSelectedChoice = allChoices.some(function (choice) {
    	            return choice.selected;
    	          });

    	          // Add each choice
    	          allChoices.forEach(function (choice, index) {
    	            // Pre-select first choice if it's a single select
    	            if (_this23.isSelectOneElement) {
    	              // If there is a selected choice already or the choice is not
    	              // the first in the array, add each choice normally
    	              // Otherwise pre-select the first choice in the array
    	              var shouldPreselect = hasSelectedChoice || !hasSelectedChoice && index > 0;
    	              _this23._addChoice(choice.value, choice.label, shouldPreselect ? choice.selected : true, shouldPreselect ? choice.disabled : false, undefined, choice.customProperties, choice.placeholder);
    	            } else {
    	              _this23._addChoice(choice.value, choice.label, choice.selected, choice.disabled, undefined, choice.customProperties, choice.placeholder);
    	            }
    	          });
    	        }

    	        this._setLoading(false);
    	      } else if (this.isTextElement) {
    	        // Add any preset values seperated by delimiter
    	        this.presetItems.forEach(function (item) {
    	          var itemType = (0, _utils.getType)(item);
    	          if (itemType === 'Object') {
    	            if (!item.value) {
    	              return;
    	            }
    	            _this23._addItem(item.value, item.label, item.id, undefined, item.customProperties, item.placeholder);
    	          } else if (itemType === 'String') {
    	            _this23._addItem(item);
    	          }
    	        });
    	      }
    	    }

    	    /*=====  End of Private functions  ======*/

    	  }]);

    	  return Choices;
    	}();

    		module.exports = Choices;

    /***/ }),
    /* 2 */
    /***/ (function(module, exports, __webpack_require__) {
    (function (global) {

    	  /** @type {function(...*)} */
    	  function log () {
    	    console.log.apply(console, arguments);
    	  }

    	  var defaultOptions = {
    	    // The name of the identifier property. If specified, the returned result will be a list
    	    // of the items' dentifiers, otherwise it will be a list of the items.
    	    id: null,

    	    // Indicates whether comparisons should be case sensitive.

    	    caseSensitive: false,

    	    // An array of values that should be included from the searcher's output. When this array
    	    // contains elements, each result in the list will be of the form `{ item: ..., include1: ..., include2: ... }`.
    	    // Values you can include are `score`, `matchedLocations`
    	    include: [],

    	    // Whether to sort the result list, by score
    	    shouldSort: true,

    	    // The search function to use
    	    // Note that the default search function ([[Function]]) must conform to the following API:
    	    //
    	    //  @param pattern The pattern string to search
    	    //  @param options The search option
    	    //  [[Function]].constructor = function(pattern, options)
    	    //
    	    //  @param text: the string to search in for the pattern
    	    //  @return Object in the form of:
    	    //    - isMatch: boolean
    	    //    - score: Int
    	    //  [[Function]].prototype.search = function(text)
    	    searchFn: BitapSearcher,

    	    // Default sort function
    	    sortFn: function (a, b) {
    	      return a.score - b.score
    	    },

    	    // The get function to use when fetching an object's properties.
    	    // The default will search nested paths *ie foo.bar.baz*
    	    getFn: deepValue,

    	    // List of properties that will be searched. This also supports nested properties.
    	    keys: [],

    	    // Will print to the console. Useful for debugging.
    	    verbose: false,

    	    // When true, the search algorithm will search individual words **and** the full string,
    	    // computing the final score as a function of both. Note that when `tokenize` is `true`,
    	    // the `threshold`, `distance`, and `location` are inconsequential for individual tokens.
    	    tokenize: false,

    	    // When true, the result set will only include records that match all tokens. Will only work
    	    // if `tokenize` is also true.
    	    matchAllTokens: false,

    	    // Regex used to separate words when searching. Only applicable when `tokenize` is `true`.
    	    tokenSeparator: / +/g,

    	    // Minimum number of characters that must be matched before a result is considered a match
    	    minMatchCharLength: 1,

    	    // When true, the algorithm continues searching to the end of the input even if a perfect
    	    // match is found before the end of the same input.
    	    findAllMatches: false
    	  };

    	  /**
    	   * @constructor
    	   * @param {!Array} list
    	   * @param {!Object<string, *>} options
    	   */
    	  function Fuse (list, options) {
    	    var key;

    	    this.list = list;
    	    this.options = options = options || {};

    	    for (key in defaultOptions) {
    	      if (!defaultOptions.hasOwnProperty(key)) {
    	        continue;
    	      }
    	      // Add boolean type options
    	      if (typeof defaultOptions[key] === 'boolean') {
    	        this.options[key] = key in options ? options[key] : defaultOptions[key];
    	      // Add all other options
    	      } else {
    	        this.options[key] = options[key] || defaultOptions[key];
    	      }
    	    }
    	  }

    	  Fuse.VERSION = '2.7.3';

    	  /**
    	   * Sets a new list for Fuse to match against.
    	   * @param {!Array} list
    	   * @return {!Array} The newly set list
    	   * @public
    	   */
    	  Fuse.prototype.set = function (list) {
    	    this.list = list;
    	    return list
    	  };

    	  Fuse.prototype.search = function (pattern) {
    	    if (this.options.verbose) log('\nSearch term:', pattern, '\n');

    	    this.pattern = pattern;
    	    this.results = [];
    	    this.resultMap = {};
    	    this._keyMap = null;

    	    this._prepareSearchers();
    	    this._startSearch();
    	    this._computeScore();
    	    this._sort();

    	    var output = this._format();
    	    return output
    	  };

    	  Fuse.prototype._prepareSearchers = function () {
    	    var options = this.options;
    	    var pattern = this.pattern;
    	    var searchFn = options.searchFn;
    	    var tokens = pattern.split(options.tokenSeparator);
    	    var i = 0;
    	    var len = tokens.length;

    	    if (this.options.tokenize) {
    	      this.tokenSearchers = [];
    	      for (; i < len; i++) {
    	        this.tokenSearchers.push(new searchFn(tokens[i], options));
    	      }
    	    }
    	    this.fullSeacher = new searchFn(pattern, options);
    	  };

    	  Fuse.prototype._startSearch = function () {
    	    var options = this.options;
    	    var getFn = options.getFn;
    	    var list = this.list;
    	    var listLen = list.length;
    	    var keys = this.options.keys;
    	    var keysLen = keys.length;
    	    var key;
    	    var weight;
    	    var item = null;
    	    var i;
    	    var j;

    	    // Check the first item in the list, if it's a string, then we assume
    	    // that every item in the list is also a string, and thus it's a flattened array.
    	    if (typeof list[0] === 'string') {
    	      // Iterate over every item
    	      for (i = 0; i < listLen; i++) {
    	        this._analyze('', list[i], i, i);
    	      }
    	    } else {
    	      this._keyMap = {};
    	      // Otherwise, the first item is an Object (hopefully), and thus the searching
    	      // is done on the values of the keys of each item.
    	      // Iterate over every item
    	      for (i = 0; i < listLen; i++) {
    	        item = list[i];
    	        // Iterate over every key
    	        for (j = 0; j < keysLen; j++) {
    	          key = keys[j];
    	          if (typeof key !== 'string') {
    	            weight = (1 - key.weight) || 1;
    	            this._keyMap[key.name] = {
    	              weight: weight
    	            };
    	            if (key.weight <= 0 || key.weight > 1) {
    	              throw new Error('Key weight has to be > 0 and <= 1')
    	            }
    	            key = key.name;
    	          } else {
    	            this._keyMap[key] = {
    	              weight: 1
    	            };
    	          }
    	          this._analyze(key, getFn(item, key, []), item, i);
    	        }
    	      }
    	    }
    	  };

    	  Fuse.prototype._analyze = function (key, text, entity, index) {
    	    var options = this.options;
    	    var words;
    	    var scores;
    	    var exists = false;
    	    var existingResult;
    	    var averageScore;
    	    var finalScore;
    	    var scoresLen;
    	    var mainSearchResult;
    	    var tokenSearcher;
    	    var termScores;
    	    var word;
    	    var tokenSearchResult;
    	    var hasMatchInText;
    	    var checkTextMatches;
    	    var i;
    	    var j;

    	    // Check if the text can be searched
    	    if (text === undefined || text === null) {
    	      return
    	    }

    	    scores = [];

    	    var numTextMatches = 0;

    	    if (typeof text === 'string') {
    	      words = text.split(options.tokenSeparator);

    	      if (options.verbose) log('---------\nKey:', key);

    	      if (this.options.tokenize) {
    	        for (i = 0; i < this.tokenSearchers.length; i++) {
    	          tokenSearcher = this.tokenSearchers[i];

    	          if (options.verbose) log('Pattern:', tokenSearcher.pattern);

    	          termScores = [];
    	          hasMatchInText = false;

    	          for (j = 0; j < words.length; j++) {
    	            word = words[j];
    	            tokenSearchResult = tokenSearcher.search(word);
    	            var obj = {};
    	            if (tokenSearchResult.isMatch) {
    	              obj[word] = tokenSearchResult.score;
    	              exists = true;
    	              hasMatchInText = true;
    	              scores.push(tokenSearchResult.score);
    	            } else {
    	              obj[word] = 1;
    	              if (!this.options.matchAllTokens) {
    	                scores.push(1);
    	              }
    	            }
    	            termScores.push(obj);
    	          }

    	          if (hasMatchInText) {
    	            numTextMatches++;
    	          }

    	          if (options.verbose) log('Token scores:', termScores);
    	        }

    	        averageScore = scores[0];
    	        scoresLen = scores.length;
    	        for (i = 1; i < scoresLen; i++) {
    	          averageScore += scores[i];
    	        }
    	        averageScore = averageScore / scoresLen;

    	        if (options.verbose) log('Token score average:', averageScore);
    	      }

    	      mainSearchResult = this.fullSeacher.search(text);
    	      if (options.verbose) log('Full text score:', mainSearchResult.score);

    	      finalScore = mainSearchResult.score;
    	      if (averageScore !== undefined) {
    	        finalScore = (finalScore + averageScore) / 2;
    	      }

    	      if (options.verbose) log('Score average:', finalScore);

    	      checkTextMatches = (this.options.tokenize && this.options.matchAllTokens) ? numTextMatches >= this.tokenSearchers.length : true;

    	      if (options.verbose) log('Check Matches', checkTextMatches);

    	      // If a match is found, add the item to <rawResults>, including its score
    	      if ((exists || mainSearchResult.isMatch) && checkTextMatches) {
    	        // Check if the item already exists in our results
    	        existingResult = this.resultMap[index];

    	        if (existingResult) {
    	          // Use the lowest score
    	          // existingResult.score, bitapResult.score
    	          existingResult.output.push({
    	            key: key,
    	            score: finalScore,
    	            matchedIndices: mainSearchResult.matchedIndices
    	          });
    	        } else {
    	          // Add it to the raw result list
    	          this.resultMap[index] = {
    	            item: entity,
    	            output: [{
    	              key: key,
    	              score: finalScore,
    	              matchedIndices: mainSearchResult.matchedIndices
    	            }]
    	          };

    	          this.results.push(this.resultMap[index]);
    	        }
    	      }
    	    } else if (isArray(text)) {
    	      for (i = 0; i < text.length; i++) {
    	        this._analyze(key, text[i], entity, index);
    	      }
    	    }
    	  };

    	  Fuse.prototype._computeScore = function () {
    	    var i;
    	    var j;
    	    var keyMap = this._keyMap;
    	    var totalScore;
    	    var output;
    	    var scoreLen;
    	    var score;
    	    var weight;
    	    var results = this.results;
    	    var bestScore;
    	    var nScore;

    	    if (this.options.verbose) log('\n\nComputing score:\n');

    	    for (i = 0; i < results.length; i++) {
    	      totalScore = 0;
    	      output = results[i].output;
    	      scoreLen = output.length;

    	      bestScore = 1;

    	      for (j = 0; j < scoreLen; j++) {
    	        score = output[j].score;
    	        weight = keyMap ? keyMap[output[j].key].weight : 1;

    	        nScore = score * weight;

    	        if (weight !== 1) {
    	          bestScore = Math.min(bestScore, nScore);
    	        } else {
    	          totalScore += nScore;
    	          output[j].nScore = nScore;
    	        }
    	      }

    	      if (bestScore === 1) {
    	        results[i].score = totalScore / scoreLen;
    	      } else {
    	        results[i].score = bestScore;
    	      }

    	      if (this.options.verbose) log(results[i]);
    	    }
    	  };

    	  Fuse.prototype._sort = function () {
    	    var options = this.options;
    	    if (options.shouldSort) {
    	      if (options.verbose) log('\n\nSorting....');
    	      this.results.sort(options.sortFn);
    	    }
    	  };

    	  Fuse.prototype._format = function () {
    	    var options = this.options;
    	    var getFn = options.getFn;
    	    var finalOutput = [];
    	    var i;
    	    var len;
    	    var results = this.results;
    	    var replaceValue;
    	    var getItemAtIndex;
    	    var include = options.include;

    	    if (options.verbose) log('\n\nOutput:\n\n', results);

    	    // Helper function, here for speed-up, which replaces the item with its value,
    	    // if the options specifies it,
    	    replaceValue = options.id ? function (index) {
    	      results[index].item = getFn(results[index].item, options.id, [])[0];
    	    } : function () {};

    	    getItemAtIndex = function (index) {
    	      var record = results[index];
    	      var data;
    	      var j;
    	      var output;
    	      var _item;
    	      var _result;

    	      // If `include` has values, put the item in the result
    	      if (include.length > 0) {
    	        data = {
    	          item: record.item
    	        };
    	        if (include.indexOf('matches') !== -1) {
    	          output = record.output;
    	          data.matches = [];
    	          for (j = 0; j < output.length; j++) {
    	            _item = output[j];
    	            _result = {
    	              indices: _item.matchedIndices
    	            };
    	            if (_item.key) {
    	              _result.key = _item.key;
    	            }
    	            data.matches.push(_result);
    	          }
    	        }

    	        if (include.indexOf('score') !== -1) {
    	          data.score = results[index].score;
    	        }

    	      } else {
    	        data = record.item;
    	      }

    	      return data
    	    };

    	    // From the results, push into a new array only the item identifier (if specified)
    	    // of the entire item.  This is because we don't want to return the <results>,
    	    // since it contains other metadata
    	    for (i = 0, len = results.length; i < len; i++) {
    	      replaceValue(i);
    	      finalOutput.push(getItemAtIndex(i));
    	    }

    	    return finalOutput
    	  };

    	  // Helpers

    	  function deepValue (obj, path, list) {
    	    var firstSegment;
    	    var remaining;
    	    var dotIndex;
    	    var value;
    	    var i;
    	    var len;

    	    if (!path) {
    	      // If there's no path left, we've gotten to the object we care about.
    	      list.push(obj);
    	    } else {
    	      dotIndex = path.indexOf('.');

    	      if (dotIndex !== -1) {
    	        firstSegment = path.slice(0, dotIndex);
    	        remaining = path.slice(dotIndex + 1);
    	      } else {
    	        firstSegment = path;
    	      }

    	      value = obj[firstSegment];
    	      if (value !== null && value !== undefined) {
    	        if (!remaining && (typeof value === 'string' || typeof value === 'number')) {
    	          list.push(value);
    	        } else if (isArray(value)) {
    	          // Search each item in the array.
    	          for (i = 0, len = value.length; i < len; i++) {
    	            deepValue(value[i], remaining, list);
    	          }
    	        } else if (remaining) {
    	          // An object. Recurse further.
    	          deepValue(value, remaining, list);
    	        }
    	      }
    	    }

    	    return list
    	  }

    	  function isArray (obj) {
    	    return Object.prototype.toString.call(obj) === '[object Array]'
    	  }

    	  /**
    	   * Adapted from "Diff, Match and Patch", by Google
    	   *
    	   *   http://code.google.com/p/google-diff-match-patch/
    	   *
    	   * Modified by: Kirollos Risk <kirollos@gmail.com>
    	   * -----------------------------------------------
    	   * Details: the algorithm and structure was modified to allow the creation of
    	   * <Searcher> instances with a <search> method which does the actual
    	   * bitap search. The <pattern> (the string that is searched for) is only defined
    	   * once per instance and thus it eliminates redundant re-creation when searching
    	   * over a list of strings.
    	   *
    	   * Licensed under the Apache License, Version 2.0 (the "License")
    	   * you may not use this file except in compliance with the License.
    	   *
    	   * @constructor
    	   */
    	  function BitapSearcher (pattern, options) {
    	    options = options || {};
    	    this.options = options;
    	    this.options.location = options.location || BitapSearcher.defaultOptions.location;
    	    this.options.distance = 'distance' in options ? options.distance : BitapSearcher.defaultOptions.distance;
    	    this.options.threshold = 'threshold' in options ? options.threshold : BitapSearcher.defaultOptions.threshold;
    	    this.options.maxPatternLength = options.maxPatternLength || BitapSearcher.defaultOptions.maxPatternLength;

    	    this.pattern = options.caseSensitive ? pattern : pattern.toLowerCase();
    	    this.patternLen = pattern.length;

    	    if (this.patternLen <= this.options.maxPatternLength) {
    	      this.matchmask = 1 << (this.patternLen - 1);
    	      this.patternAlphabet = this._calculatePatternAlphabet();
    	    }
    	  }

    	  BitapSearcher.defaultOptions = {
    	    // Approximately where in the text is the pattern expected to be found?
    	    location: 0,

    	    // Determines how close the match must be to the fuzzy location (specified above).
    	    // An exact letter match which is 'distance' characters away from the fuzzy location
    	    // would score as a complete mismatch. A distance of '0' requires the match be at
    	    // the exact location specified, a threshold of '1000' would require a perfect match
    	    // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.
    	    distance: 100,

    	    // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match
    	    // (of both letters and location), a threshold of '1.0' would match anything.
    	    threshold: 0.6,

    	    // Machine word size
    	    maxPatternLength: 32
    	  };

    	  /**
    	   * Initialize the alphabet for the Bitap algorithm.
    	   * @return {Object} Hash of character locations.
    	   * @private
    	   */
    	  BitapSearcher.prototype._calculatePatternAlphabet = function () {
    	    var mask = {},
    	      i = 0;

    	    for (i = 0; i < this.patternLen; i++) {
    	      mask[this.pattern.charAt(i)] = 0;
    	    }

    	    for (i = 0; i < this.patternLen; i++) {
    	      mask[this.pattern.charAt(i)] |= 1 << (this.pattern.length - i - 1);
    	    }

    	    return mask
    	  };

    	  /**
    	   * Compute and return the score for a match with `e` errors and `x` location.
    	   * @param {number} errors Number of errors in match.
    	   * @param {number} location Location of match.
    	   * @return {number} Overall score for match (0.0 = good, 1.0 = bad).
    	   * @private
    	   */
    	  BitapSearcher.prototype._bitapScore = function (errors, location) {
    	    var accuracy = errors / this.patternLen,
    	      proximity = Math.abs(this.options.location - location);

    	    if (!this.options.distance) {
    	      // Dodge divide by zero error.
    	      return proximity ? 1.0 : accuracy
    	    }
    	    return accuracy + (proximity / this.options.distance)
    	  };

    	  /**
    	   * Compute and return the result of the search
    	   * @param {string} text The text to search in
    	   * @return {{isMatch: boolean, score: number}} Literal containing:
    	   *                          isMatch - Whether the text is a match or not
    	   *                          score - Overall score for the match
    	   * @public
    	   */
    	  BitapSearcher.prototype.search = function (text) {
    	    var options = this.options;
    	    var i;
    	    var j;
    	    var textLen;
    	    var findAllMatches;
    	    var location;
    	    var threshold;
    	    var bestLoc;
    	    var binMin;
    	    var binMid;
    	    var binMax;
    	    var start, finish;
    	    var bitArr;
    	    var lastBitArr;
    	    var charMatch;
    	    var score;
    	    var locations;
    	    var matches;
    	    var isMatched;
    	    var matchMask;
    	    var matchedIndices;
    	    var matchesLen;
    	    var match;

    	    text = options.caseSensitive ? text : text.toLowerCase();

    	    if (this.pattern === text) {
    	      // Exact match
    	      return {
    	        isMatch: true,
    	        score: 0,
    	        matchedIndices: [[0, text.length - 1]]
    	      }
    	    }

    	    // When pattern length is greater than the machine word length, just do a a regex comparison
    	    if (this.patternLen > options.maxPatternLength) {
    	      matches = text.match(new RegExp(this.pattern.replace(options.tokenSeparator, '|')));
    	      isMatched = !!matches;

    	      if (isMatched) {
    	        matchedIndices = [];
    	        for (i = 0, matchesLen = matches.length; i < matchesLen; i++) {
    	          match = matches[i];
    	          matchedIndices.push([text.indexOf(match), match.length - 1]);
    	        }
    	      }

    	      return {
    	        isMatch: isMatched,
    	        // TODO: revisit this score
    	        score: isMatched ? 0.5 : 1,
    	        matchedIndices: matchedIndices
    	      }
    	    }

    	    findAllMatches = options.findAllMatches;

    	    location = options.location;
    	    // Set starting location at beginning text and initialize the alphabet.
    	    textLen = text.length;
    	    // Highest score beyond which we give up.
    	    threshold = options.threshold;
    	    // Is there a nearby exact match? (speedup)
    	    bestLoc = text.indexOf(this.pattern, location);

    	    // a mask of the matches
    	    matchMask = [];
    	    for (i = 0; i < textLen; i++) {
    	      matchMask[i] = 0;
    	    }

    	    if (bestLoc != -1) {
    	      threshold = Math.min(this._bitapScore(0, bestLoc), threshold);
    	      // What about in the other direction? (speed up)
    	      bestLoc = text.lastIndexOf(this.pattern, location + this.patternLen);

    	      if (bestLoc != -1) {
    	        threshold = Math.min(this._bitapScore(0, bestLoc), threshold);
    	      }
    	    }

    	    bestLoc = -1;
    	    score = 1;
    	    locations = [];
    	    binMax = this.patternLen + textLen;

    	    for (i = 0; i < this.patternLen; i++) {
    	      // Scan for the best match; each iteration allows for one more error.
    	      // Run a binary search to determine how far from the match location we can stray
    	      // at this error level.
    	      binMin = 0;
    	      binMid = binMax;
    	      while (binMin < binMid) {
    	        if (this._bitapScore(i, location + binMid) <= threshold) {
    	          binMin = binMid;
    	        } else {
    	          binMax = binMid;
    	        }
    	        binMid = Math.floor((binMax - binMin) / 2 + binMin);
    	      }

    	      // Use the result from this iteration as the maximum for the next.
    	      binMax = binMid;
    	      start = Math.max(1, location - binMid + 1);
    	      if (findAllMatches) {
    	        finish = textLen;
    	      } else {
    	        finish = Math.min(location + binMid, textLen) + this.patternLen;
    	      }

    	      // Initialize the bit array
    	      bitArr = Array(finish + 2);

    	      bitArr[finish + 1] = (1 << i) - 1;

    	      for (j = finish; j >= start; j--) {
    	        charMatch = this.patternAlphabet[text.charAt(j - 1)];

    	        if (charMatch) {
    	          matchMask[j - 1] = 1;
    	        }

    	        bitArr[j] = ((bitArr[j + 1] << 1) | 1) & charMatch;

    	        if (i !== 0) {
    	          // Subsequent passes: fuzzy match.
    	          bitArr[j] |= (((lastBitArr[j + 1] | lastBitArr[j]) << 1) | 1) | lastBitArr[j + 1];
    	        }
    	        if (bitArr[j] & this.matchmask) {
    	          score = this._bitapScore(i, j - 1);

    	          // This match will almost certainly be better than any existing match.
    	          // But check anyway.
    	          if (score <= threshold) {
    	            // Indeed it is
    	            threshold = score;
    	            bestLoc = j - 1;
    	            locations.push(bestLoc);

    	            // Already passed loc, downhill from here on in.
    	            if (bestLoc <= location) {
    	              break
    	            }

    	            // When passing loc, don't exceed our current distance from loc.
    	            start = Math.max(1, 2 * location - bestLoc);
    	          }
    	        }
    	      }

    	      // No hope for a (better) match at greater error levels.
    	      if (this._bitapScore(i + 1, location) > threshold) {
    	        break
    	      }
    	      lastBitArr = bitArr;
    	    }

    	    matchedIndices = this._getMatchedIndices(matchMask);

    	    // Count exact matches (those with a score of 0) to be "almost" exact
    	    return {
    	      isMatch: bestLoc >= 0,
    	      score: score === 0 ? 0.001 : score,
    	      matchedIndices: matchedIndices
    	    }
    	  };

    	  BitapSearcher.prototype._getMatchedIndices = function (matchMask) {
    	    var matchedIndices = [];
    	    var start = -1;
    	    var end = -1;
    	    var i = 0;
    	    var match;
    	    var len = matchMask.length;
    	    for (; i < len; i++) {
    	      match = matchMask[i];
    	      if (match && start === -1) {
    	        start = i;
    	      } else if (!match && start !== -1) {
    	        end = i - 1;
    	        if ((end - start) + 1 >= this.options.minMatchCharLength) {
    	            matchedIndices.push([start, end]);
    	        }
    	        start = -1;
    	      }
    	    }
    	    if (matchMask[i - 1]) {
    	      if ((i-1 - start) + 1 >= this.options.minMatchCharLength) {
    	        matchedIndices.push([start, i - 1]);
    	      }
    	    }
    	    return matchedIndices
    	  };

    	  // Export to Common JS Loader
    	  {
    	    // Node. Does not work with strict CommonJS, but
    	    // only CommonJS-like environments that support module.exports,
    	    // like Node.
    	    module.exports = Fuse;
    	  }

    	})(this);


    /***/ }),
    /* 3 */
    /***/ (function(module, exports, __webpack_require__) {

    	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
    	  Copyright (c) 2016 Jed Watson.
    	  Licensed under the MIT License (MIT), see
    	  http://jedwatson.github.io/classnames
    	*/
    	/* global define */

    	(function () {

    		var hasOwn = {}.hasOwnProperty;

    		function classNames () {
    			var classes = [];

    			for (var i = 0; i < arguments.length; i++) {
    				var arg = arguments[i];
    				if (!arg) continue;

    				var argType = typeof arg;

    				if (argType === 'string' || argType === 'number') {
    					classes.push(arg);
    				} else if (Array.isArray(arg)) {
    					classes.push(classNames.apply(null, arg));
    				} else if (argType === 'object') {
    					for (var key in arg) {
    						if (hasOwn.call(arg, key) && arg[key]) {
    							classes.push(key);
    						}
    					}
    				}
    			}

    			return classes.join(' ');
    		}

    		if (typeof module !== 'undefined' && module.exports) {
    			module.exports = classNames;
    		} else {
    			// register as 'classnames', consistent with npm package name
    			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
    				return classNames;
    			}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    		}
    	}());


    /***/ }),
    /* 4 */
    /***/ (function(module, exports, __webpack_require__) {

    	Object.defineProperty(exports, "__esModule", {
    	  value: true
    	});

    	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

    	var _redux = __webpack_require__(5);

    	var _index = __webpack_require__(26);

    	var _index2 = _interopRequireDefault(_index);

    	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

    	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    	var Store = function () {
    	  function Store() {
    	    _classCallCheck(this, Store);

    	    this.store = (0, _redux.createStore)(_index2.default, window.devToolsExtension ? window.devToolsExtension() : undefined);
    	  }

    	  /**
    	   * Get store object (wrapping Redux method)
    	   * @return {Object} State
    	   */


    	  _createClass(Store, [{
    	    key: 'getState',
    	    value: function getState() {
    	      return this.store.getState();
    	    }

    	    /**
    	     * Dispatch event to store (wrapped Redux method)
    	     * @param  {Function} action Action function to trigger
    	     * @return
    	     */

    	  }, {
    	    key: 'dispatch',
    	    value: function dispatch(action) {
    	      this.store.dispatch(action);
    	    }

    	    /**
    	     * Subscribe store to function call (wrapped Redux method)
    	     * @param  {Function} onChange Function to trigger when state changes
    	     * @return
    	     */

    	  }, {
    	    key: 'subscribe',
    	    value: function subscribe(onChange) {
    	      this.store.subscribe(onChange);
    	    }

    	    /**
    	     * Get loading state from store
    	     * @return {Boolean} Loading State
    	     */

    	  }, {
    	    key: 'isLoading',
    	    value: function isLoading() {
    	      var state = this.store.getState();
    	      return state.general.loading;
    	    }

    	    /**
    	     * Get items from store
    	     * @return {Array} Item objects
    	     */

    	  }, {
    	    key: 'getItems',
    	    value: function getItems() {
    	      var state = this.store.getState();
    	      return state.items;
    	    }

    	    /**
    	     * Get active items from store
    	     * @return {Array} Item objects
    	     */

    	  }, {
    	    key: 'getItemsFilteredByActive',
    	    value: function getItemsFilteredByActive() {
    	      var items = this.getItems();
    	      var values = items.filter(function (item) {
    	        return item.active === true;
    	      }, []);

    	      return values;
    	    }

    	    /**
    	     * Get items from store reduced to just their values
    	     * @return {Array} Item objects
    	     */

    	  }, {
    	    key: 'getItemsReducedToValues',
    	    value: function getItemsReducedToValues() {
    	      var items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getItems();

    	      var values = items.reduce(function (prev, current) {
    	        prev.push(current.value);
    	        return prev;
    	      }, []);

    	      return values;
    	    }

    	    /**
    	     * Get choices from store
    	     * @return {Array} Option objects
    	     */

    	  }, {
    	    key: 'getChoices',
    	    value: function getChoices() {
    	      var state = this.store.getState();
    	      return state.choices;
    	    }

    	    /**
    	     * Get active choices from store
    	     * @return {Array} Option objects
    	     */

    	  }, {
    	    key: 'getChoicesFilteredByActive',
    	    value: function getChoicesFilteredByActive() {
    	      var choices = this.getChoices();
    	      var values = choices.filter(function (choice) {
    	        return choice.active === true;
    	      });

    	      return values;
    	    }

    	    /**
    	     * Get selectable choices from store
    	     * @return {Array} Option objects
    	     */

    	  }, {
    	    key: 'getChoicesFilteredBySelectable',
    	    value: function getChoicesFilteredBySelectable() {
    	      var choices = this.getChoices();
    	      var values = choices.filter(function (choice) {
    	        return choice.disabled !== true;
    	      });

    	      return values;
    	    }

    	    /**
    	     * Get choices that can be searched (excluding placeholders)
    	     * @return {Array} Option objects
    	     */

    	  }, {
    	    key: 'getSearchableChoices',
    	    value: function getSearchableChoices() {
    	      var filtered = this.getChoicesFilteredBySelectable();
    	      return filtered.filter(function (choice) {
    	        return choice.placeholder !== true;
    	      });
    	    }

    	    /**
    	     * Get single choice by it's ID
    	     * @return {Object} Found choice
    	     */

    	  }, {
    	    key: 'getChoiceById',
    	    value: function getChoiceById(id) {
    	      if (id) {
    	        var choices = this.getChoicesFilteredByActive();
    	        var foundChoice = choices.find(function (choice) {
    	          return choice.id === parseInt(id, 10);
    	        });
    	        return foundChoice;
    	      }
    	      return false;
    	    }

    	    /**
    	     * Get groups from store
    	     * @return {Array} Group objects
    	     */

    	  }, {
    	    key: 'getGroups',
    	    value: function getGroups() {
    	      var state = this.store.getState();
    	      return state.groups;
    	    }

    	    /**
    	     * Get active groups from store
    	     * @return {Array} Group objects
    	     */

    	  }, {
    	    key: 'getGroupsFilteredByActive',
    	    value: function getGroupsFilteredByActive() {
    	      var groups = this.getGroups();
    	      var choices = this.getChoices();

    	      var values = groups.filter(function (group) {
    	        var isActive = group.active === true && group.disabled === false;
    	        var hasActiveOptions = choices.some(function (choice) {
    	          return choice.active === true && choice.disabled === false;
    	        });
    	        return isActive && hasActiveOptions;
    	      }, []);

    	      return values;
    	    }

    	    /**
    	     * Get group by group id
    	     * @param  {Number} id Group ID
    	     * @return {Object}    Group data
    	     */

    	  }, {
    	    key: 'getGroupById',
    	    value: function getGroupById(id) {
    	      var groups = this.getGroups();
    	      var foundGroup = groups.find(function (group) {
    	        return group.id === id;
    	      });

    	      return foundGroup;
    	    }

    	    /**
    	     * Get placeholder choice from store
    	     * @return {Object} Found placeholder
    	     */

    	  }, {
    	    key: 'getPlaceholderChoice',
    	    value: function getPlaceholderChoice() {
    	      var choices = this.getChoices();
    	      var placeholderChoice = [].concat(_toConsumableArray(choices)).reverse().find(function (choice) {
    	        return choice.placeholder === true;
    	      });

    	      return placeholderChoice;
    	    }
    	  }]);

    	  return Store;
    	}();

    	exports.default = Store;


    		module.exports = Store;

    /***/ }),
    /* 5 */
    /***/ (function(module, exports, __webpack_require__) {

    	exports.__esModule = true;
    	exports.compose = exports.applyMiddleware = exports.bindActionCreators = exports.combineReducers = exports.createStore = undefined;

    	var _createStore = __webpack_require__(6);

    	var _createStore2 = _interopRequireDefault(_createStore);

    	var _combineReducers = __webpack_require__(21);

    	var _combineReducers2 = _interopRequireDefault(_combineReducers);

    	var _bindActionCreators = __webpack_require__(23);

    	var _bindActionCreators2 = _interopRequireDefault(_bindActionCreators);

    	var _applyMiddleware = __webpack_require__(24);

    	var _applyMiddleware2 = _interopRequireDefault(_applyMiddleware);

    	var _compose = __webpack_require__(25);

    	var _compose2 = _interopRequireDefault(_compose);

    	var _warning = __webpack_require__(22);

    	var _warning2 = _interopRequireDefault(_warning);

    	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

    	exports.createStore = _createStore2['default'];
    	exports.combineReducers = _combineReducers2['default'];
    	exports.bindActionCreators = _bindActionCreators2['default'];
    	exports.applyMiddleware = _applyMiddleware2['default'];
    	exports.compose = _compose2['default'];

    /***/ }),
    /* 6 */
    /***/ (function(module, exports, __webpack_require__) {

    	exports.__esModule = true;
    	exports.ActionTypes = undefined;
    	exports['default'] = createStore;

    	var _isPlainObject = __webpack_require__(7);

    	var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

    	var _symbolObservable = __webpack_require__(17);

    	var _symbolObservable2 = _interopRequireDefault(_symbolObservable);

    	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

    	/**
    	 * These are private action types reserved by Redux.
    	 * For any unknown actions, you must return the current state.
    	 * If the current state is undefined, you must return the initial state.
    	 * Do not reference these action types directly in your code.
    	 */
    	var ActionTypes = exports.ActionTypes = {
    	  INIT: '@@redux/INIT'

    	  /**
    	   * Creates a Redux store that holds the state tree.
    	   * The only way to change the data in the store is to call `dispatch()` on it.
    	   *
    	   * There should only be a single store in your app. To specify how different
    	   * parts of the state tree respond to actions, you may combine several reducers
    	   * into a single reducer function by using `combineReducers`.
    	   *
    	   * @param {Function} reducer A function that returns the next state tree, given
    	   * the current state tree and the action to handle.
    	   *
    	   * @param {any} [preloadedState] The initial state. You may optionally specify it
    	   * to hydrate the state from the server in universal apps, or to restore a
    	   * previously serialized user session.
    	   * If you use `combineReducers` to produce the root reducer function, this must be
    	   * an object with the same shape as `combineReducers` keys.
    	   *
    	   * @param {Function} [enhancer] The store enhancer. You may optionally specify it
    	   * to enhance the store with third-party capabilities such as middleware,
    	   * time travel, persistence, etc. The only store enhancer that ships with Redux
    	   * is `applyMiddleware()`.
    	   *
    	   * @returns {Store} A Redux store that lets you read the state, dispatch actions
    	   * and subscribe to changes.
    	   */
    	};function createStore(reducer, preloadedState, enhancer) {
    	  var _ref2;

    	  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {
    	    enhancer = preloadedState;
    	    preloadedState = undefined;
    	  }

    	  if (typeof enhancer !== 'undefined') {
    	    if (typeof enhancer !== 'function') {
    	      throw new Error('Expected the enhancer to be a function.');
    	    }

    	    return enhancer(createStore)(reducer, preloadedState);
    	  }

    	  if (typeof reducer !== 'function') {
    	    throw new Error('Expected the reducer to be a function.');
    	  }

    	  var currentReducer = reducer;
    	  var currentState = preloadedState;
    	  var currentListeners = [];
    	  var nextListeners = currentListeners;
    	  var isDispatching = false;

    	  function ensureCanMutateNextListeners() {
    	    if (nextListeners === currentListeners) {
    	      nextListeners = currentListeners.slice();
    	    }
    	  }

    	  /**
    	   * Reads the state tree managed by the store.
    	   *
    	   * @returns {any} The current state tree of your application.
    	   */
    	  function getState() {
    	    return currentState;
    	  }

    	  /**
    	   * Adds a change listener. It will be called any time an action is dispatched,
    	   * and some part of the state tree may potentially have changed. You may then
    	   * call `getState()` to read the current state tree inside the callback.
    	   *
    	   * You may call `dispatch()` from a change listener, with the following
    	   * caveats:
    	   *
    	   * 1. The subscriptions are snapshotted just before every `dispatch()` call.
    	   * If you subscribe or unsubscribe while the listeners are being invoked, this
    	   * will not have any effect on the `dispatch()` that is currently in progress.
    	   * However, the next `dispatch()` call, whether nested or not, will use a more
    	   * recent snapshot of the subscription list.
    	   *
    	   * 2. The listener should not expect to see all state changes, as the state
    	   * might have been updated multiple times during a nested `dispatch()` before
    	   * the listener is called. It is, however, guaranteed that all subscribers
    	   * registered before the `dispatch()` started will be called with the latest
    	   * state by the time it exits.
    	   *
    	   * @param {Function} listener A callback to be invoked on every dispatch.
    	   * @returns {Function} A function to remove this change listener.
    	   */
    	  function subscribe(listener) {
    	    if (typeof listener !== 'function') {
    	      throw new Error('Expected listener to be a function.');
    	    }

    	    var isSubscribed = true;

    	    ensureCanMutateNextListeners();
    	    nextListeners.push(listener);

    	    return function unsubscribe() {
    	      if (!isSubscribed) {
    	        return;
    	      }

    	      isSubscribed = false;

    	      ensureCanMutateNextListeners();
    	      var index = nextListeners.indexOf(listener);
    	      nextListeners.splice(index, 1);
    	    };
    	  }

    	  /**
    	   * Dispatches an action. It is the only way to trigger a state change.
    	   *
    	   * The `reducer` function, used to create the store, will be called with the
    	   * current state tree and the given `action`. Its return value will
    	   * be considered the **next** state of the tree, and the change listeners
    	   * will be notified.
    	   *
    	   * The base implementation only supports plain object actions. If you want to
    	   * dispatch a Promise, an Observable, a thunk, or something else, you need to
    	   * wrap your store creating function into the corresponding middleware. For
    	   * example, see the documentation for the `redux-thunk` package. Even the
    	   * middleware will eventually dispatch plain object actions using this method.
    	   *
    	   * @param {Object} action A plain object representing “what changed”. It is
    	   * a good idea to keep actions serializable so you can record and replay user
    	   * sessions, or use the time travelling `redux-devtools`. An action must have
    	   * a `type` property which may not be `undefined`. It is a good idea to use
    	   * string constants for action types.
    	   *
    	   * @returns {Object} For convenience, the same action object you dispatched.
    	   *
    	   * Note that, if you use a custom middleware, it may wrap `dispatch()` to
    	   * return something else (for example, a Promise you can await).
    	   */
    	  function dispatch(action) {
    	    if (!(0, _isPlainObject2['default'])(action)) {
    	      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');
    	    }

    	    if (typeof action.type === 'undefined') {
    	      throw new Error('Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?');
    	    }

    	    if (isDispatching) {
    	      throw new Error('Reducers may not dispatch actions.');
    	    }

    	    try {
    	      isDispatching = true;
    	      currentState = currentReducer(currentState, action);
    	    } finally {
    	      isDispatching = false;
    	    }

    	    var listeners = currentListeners = nextListeners;
    	    for (var i = 0; i < listeners.length; i++) {
    	      var listener = listeners[i];
    	      listener();
    	    }

    	    return action;
    	  }

    	  /**
    	   * Replaces the reducer currently used by the store to calculate the state.
    	   *
    	   * You might need this if your app implements code splitting and you want to
    	   * load some of the reducers dynamically. You might also need this if you
    	   * implement a hot reloading mechanism for Redux.
    	   *
    	   * @param {Function} nextReducer The reducer for the store to use instead.
    	   * @returns {void}
    	   */
    	  function replaceReducer(nextReducer) {
    	    if (typeof nextReducer !== 'function') {
    	      throw new Error('Expected the nextReducer to be a function.');
    	    }

    	    currentReducer = nextReducer;
    	    dispatch({ type: ActionTypes.INIT });
    	  }

    	  /**
    	   * Interoperability point for observable/reactive libraries.
    	   * @returns {observable} A minimal observable of state changes.
    	   * For more information, see the observable proposal:
    	   * https://github.com/tc39/proposal-observable
    	   */
    	  function observable() {
    	    var _ref;

    	    var outerSubscribe = subscribe;
    	    return _ref = {
    	      /**
    	       * The minimal observable subscription method.
    	       * @param {Object} observer Any object that can be used as an observer.
    	       * The observer object should have a `next` method.
    	       * @returns {subscription} An object with an `unsubscribe` method that can
    	       * be used to unsubscribe the observable from the store, and prevent further
    	       * emission of values from the observable.
    	       */
    	      subscribe: function subscribe(observer) {
    	        if (typeof observer !== 'object') {
    	          throw new TypeError('Expected the observer to be an object.');
    	        }

    	        function observeState() {
    	          if (observer.next) {
    	            observer.next(getState());
    	          }
    	        }

    	        observeState();
    	        var unsubscribe = outerSubscribe(observeState);
    	        return { unsubscribe: unsubscribe };
    	      }
    	    }, _ref[_symbolObservable2['default']] = function () {
    	      return this;
    	    }, _ref;
    	  }

    	  // When a store is created, an "INIT" action is dispatched so that every
    	  // reducer returns their initial state. This effectively populates
    	  // the initial state tree.
    	  dispatch({ type: ActionTypes.INIT });

    	  return _ref2 = {
    	    dispatch: dispatch,
    	    subscribe: subscribe,
    	    getState: getState,
    	    replaceReducer: replaceReducer
    	  }, _ref2[_symbolObservable2['default']] = observable, _ref2;
    	}

    /***/ }),
    /* 7 */
    /***/ (function(module, exports, __webpack_require__) {

    	var baseGetTag = __webpack_require__(8),
    	    getPrototype = __webpack_require__(14),
    	    isObjectLike = __webpack_require__(16);

    	/** `Object#toString` result references. */
    	var objectTag = '[object Object]';

    	/** Used for built-in method references. */
    	var funcProto = Function.prototype,
    	    objectProto = Object.prototype;

    	/** Used to resolve the decompiled source of functions. */
    	var funcToString = funcProto.toString;

    	/** Used to check objects for own properties. */
    	var hasOwnProperty = objectProto.hasOwnProperty;

    	/** Used to infer the `Object` constructor. */
    	var objectCtorString = funcToString.call(Object);

    	/**
    	 * Checks if `value` is a plain object, that is, an object created by the
    	 * `Object` constructor or one with a `[[Prototype]]` of `null`.
    	 *
    	 * @static
    	 * @memberOf _
    	 * @since 0.8.0
    	 * @category Lang
    	 * @param {*} value The value to check.
    	 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
    	 * @example
    	 *
    	 * function Foo() {
    	 *   this.a = 1;
    	 * }
    	 *
    	 * _.isPlainObject(new Foo);
    	 * // => false
    	 *
    	 * _.isPlainObject([1, 2, 3]);
    	 * // => false
    	 *
    	 * _.isPlainObject({ 'x': 0, 'y': 0 });
    	 * // => true
    	 *
    	 * _.isPlainObject(Object.create(null));
    	 * // => true
    	 */
    	function isPlainObject(value) {
    	  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    	    return false;
    	  }
    	  var proto = getPrototype(value);
    	  if (proto === null) {
    	    return true;
    	  }
    	  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
    	  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    	    funcToString.call(Ctor) == objectCtorString;
    	}

    	module.exports = isPlainObject;


    /***/ }),
    /* 8 */
    /***/ (function(module, exports, __webpack_require__) {

    	var Symbol = __webpack_require__(9),
    	    getRawTag = __webpack_require__(12),
    	    objectToString = __webpack_require__(13);

    	/** `Object#toString` result references. */
    	var nullTag = '[object Null]',
    	    undefinedTag = '[object Undefined]';

    	/** Built-in value references. */
    	var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

    	/**
    	 * The base implementation of `getTag` without fallbacks for buggy environments.
    	 *
    	 * @private
    	 * @param {*} value The value to query.
    	 * @returns {string} Returns the `toStringTag`.
    	 */
    	function baseGetTag(value) {
    	  if (value == null) {
    	    return value === undefined ? undefinedTag : nullTag;
    	  }
    	  return (symToStringTag && symToStringTag in Object(value))
    	    ? getRawTag(value)
    	    : objectToString(value);
    	}

    	module.exports = baseGetTag;


    /***/ }),
    /* 9 */
    /***/ (function(module, exports, __webpack_require__) {

    	var root = __webpack_require__(10);

    	/** Built-in value references. */
    	var Symbol = root.Symbol;

    	module.exports = Symbol;


    /***/ }),
    /* 10 */
    /***/ (function(module, exports, __webpack_require__) {

    	var freeGlobal = __webpack_require__(11);

    	/** Detect free variable `self`. */
    	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

    	/** Used as a reference to the global object. */
    	var root = freeGlobal || freeSelf || Function('return this')();

    	module.exports = root;


    /***/ }),
    /* 11 */
    /***/ (function(module, exports) {

    	/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */
    	var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

    	module.exports = freeGlobal;

    	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())));

    /***/ }),
    /* 12 */
    /***/ (function(module, exports, __webpack_require__) {

    	var Symbol = __webpack_require__(9);

    	/** Used for built-in method references. */
    	var objectProto = Object.prototype;

    	/** Used to check objects for own properties. */
    	var hasOwnProperty = objectProto.hasOwnProperty;

    	/**
    	 * Used to resolve the
    	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
    	 * of values.
    	 */
    	var nativeObjectToString = objectProto.toString;

    	/** Built-in value references. */
    	var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

    	/**
    	 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
    	 *
    	 * @private
    	 * @param {*} value The value to query.
    	 * @returns {string} Returns the raw `toStringTag`.
    	 */
    	function getRawTag(value) {
    	  var isOwn = hasOwnProperty.call(value, symToStringTag),
    	      tag = value[symToStringTag];

    	  try {
    	    value[symToStringTag] = undefined;
    	  } catch (e) {}

    	  var result = nativeObjectToString.call(value);
    	  {
    	    if (isOwn) {
    	      value[symToStringTag] = tag;
    	    } else {
    	      delete value[symToStringTag];
    	    }
    	  }
    	  return result;
    	}

    	module.exports = getRawTag;


    /***/ }),
    /* 13 */
    /***/ (function(module, exports) {

    	/** Used for built-in method references. */
    	var objectProto = Object.prototype;

    	/**
    	 * Used to resolve the
    	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
    	 * of values.
    	 */
    	var nativeObjectToString = objectProto.toString;

    	/**
    	 * Converts `value` to a string using `Object.prototype.toString`.
    	 *
    	 * @private
    	 * @param {*} value The value to convert.
    	 * @returns {string} Returns the converted string.
    	 */
    	function objectToString(value) {
    	  return nativeObjectToString.call(value);
    	}

    	module.exports = objectToString;


    /***/ }),
    /* 14 */
    /***/ (function(module, exports, __webpack_require__) {

    	var overArg = __webpack_require__(15);

    	/** Built-in value references. */
    	var getPrototype = overArg(Object.getPrototypeOf, Object);

    	module.exports = getPrototype;


    /***/ }),
    /* 15 */
    /***/ (function(module, exports) {

    	/**
    	 * Creates a unary function that invokes `func` with its argument transformed.
    	 *
    	 * @private
    	 * @param {Function} func The function to wrap.
    	 * @param {Function} transform The argument transform.
    	 * @returns {Function} Returns the new function.
    	 */
    	function overArg(func, transform) {
    	  return function(arg) {
    	    return func(transform(arg));
    	  };
    	}

    	module.exports = overArg;


    /***/ }),
    /* 16 */
    /***/ (function(module, exports) {

    	/**
    	 * Checks if `value` is object-like. A value is object-like if it's not `null`
    	 * and has a `typeof` result of "object".
    	 *
    	 * @static
    	 * @memberOf _
    	 * @since 4.0.0
    	 * @category Lang
    	 * @param {*} value The value to check.
    	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
    	 * @example
    	 *
    	 * _.isObjectLike({});
    	 * // => true
    	 *
    	 * _.isObjectLike([1, 2, 3]);
    	 * // => true
    	 *
    	 * _.isObjectLike(_.noop);
    	 * // => false
    	 *
    	 * _.isObjectLike(null);
    	 * // => false
    	 */
    	function isObjectLike(value) {
    	  return value != null && typeof value == 'object';
    	}

    	module.exports = isObjectLike;


    /***/ }),
    /* 17 */
    /***/ (function(module, exports, __webpack_require__) {

    	module.exports = __webpack_require__(18);


    /***/ }),
    /* 18 */
    /***/ (function(module, exports, __webpack_require__) {

    	/* WEBPACK VAR INJECTION */(function(global, module) {
    	Object.defineProperty(exports, "__esModule", {
    	  value: true
    	});

    	var _ponyfill = __webpack_require__(20);

    	var _ponyfill2 = _interopRequireDefault(_ponyfill);

    	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

    	var root; /* global window */


    	if (typeof self !== 'undefined') {
    	  root = self;
    	} else if (typeof window !== 'undefined') {
    	  root = window;
    	} else if (typeof global !== 'undefined') {
    	  root = global;
    	} else {
    	  root = module;
    	}

    	var result = (0, _ponyfill2['default'])(root);
    	exports['default'] = result;
    	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(19)(module)));

    /***/ }),
    /* 19 */
    /***/ (function(module, exports) {

    	module.exports = function(module) {
    		if(!module.webpackPolyfill) {
    			module.deprecate = function() {};
    			module.paths = [];
    			// module.parent = undefined by default
    			module.children = [];
    			module.webpackPolyfill = 1;
    		}
    		return module;
    	};


    /***/ }),
    /* 20 */
    /***/ (function(module, exports) {

    	Object.defineProperty(exports, "__esModule", {
    		value: true
    	});
    	exports['default'] = symbolObservablePonyfill;
    	function symbolObservablePonyfill(root) {
    		var result;
    		var _Symbol = root.Symbol;

    		if (typeof _Symbol === 'function') {
    			if (_Symbol.observable) {
    				result = _Symbol.observable;
    			} else {
    				result = _Symbol('observable');
    				_Symbol.observable = result;
    			}
    		} else {
    			result = '@@observable';
    		}

    		return result;
    	}
    /***/ }),
    /* 21 */
    /***/ (function(module, exports, __webpack_require__) {

    	exports.__esModule = true;
    	exports['default'] = combineReducers;

    	var _createStore = __webpack_require__(6);

    	var _isPlainObject = __webpack_require__(7);

    	var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

    	var _warning = __webpack_require__(22);

    	var _warning2 = _interopRequireDefault(_warning);

    	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

    	function getUndefinedStateErrorMessage(key, action) {
    	  var actionType = action && action.type;
    	  var actionName = actionType && '"' + actionType.toString() + '"' || 'an action';

    	  return 'Given action ' + actionName + ', reducer "' + key + '" returned undefined. ' + 'To ignore an action, you must explicitly return the previous state. ' + 'If you want this reducer to hold no value, you can return null instead of undefined.';
    	}

    	function assertReducerShape(reducers) {
    	  Object.keys(reducers).forEach(function (key) {
    	    var reducer = reducers[key];
    	    var initialState = reducer(undefined, { type: _createStore.ActionTypes.INIT });

    	    if (typeof initialState === 'undefined') {
    	      throw new Error('Reducer "' + key + '" returned undefined during initialization. ' + 'If the state passed to the reducer is undefined, you must ' + 'explicitly return the initial state. The initial state may ' + 'not be undefined. If you don\'t want to set a value for this reducer, ' + 'you can use null instead of undefined.');
    	    }

    	    var type = '@@redux/PROBE_UNKNOWN_ACTION_' + Math.random().toString(36).substring(7).split('').join('.');
    	    if (typeof reducer(undefined, { type: type }) === 'undefined') {
    	      throw new Error('Reducer "' + key + '" returned undefined when probed with a random type. ' + ('Don\'t try to handle ' + _createStore.ActionTypes.INIT + ' or other actions in "redux/*" ') + 'namespace. They are considered private. Instead, you must return the ' + 'current state for any unknown actions, unless it is undefined, ' + 'in which case you must return the initial state, regardless of the ' + 'action type. The initial state may not be undefined, but can be null.');
    	    }
    	  });
    	}

    	/**
    	 * Turns an object whose values are different reducer functions, into a single
    	 * reducer function. It will call every child reducer, and gather their results
    	 * into a single state object, whose keys correspond to the keys of the passed
    	 * reducer functions.
    	 *
    	 * @param {Object} reducers An object whose values correspond to different
    	 * reducer functions that need to be combined into one. One handy way to obtain
    	 * it is to use ES6 `import * as reducers` syntax. The reducers may never return
    	 * undefined for any action. Instead, they should return their initial state
    	 * if the state passed to them was undefined, and the current state for any
    	 * unrecognized action.
    	 *
    	 * @returns {Function} A reducer function that invokes every reducer inside the
    	 * passed object, and builds a state object with the same shape.
    	 */
    	function combineReducers(reducers) {
    	  var reducerKeys = Object.keys(reducers);
    	  var finalReducers = {};
    	  for (var i = 0; i < reducerKeys.length; i++) {
    	    var key = reducerKeys[i];

    	    if (typeof reducers[key] === 'function') {
    	      finalReducers[key] = reducers[key];
    	    }
    	  }
    	  var finalReducerKeys = Object.keys(finalReducers);

    	  var shapeAssertionError = void 0;
    	  try {
    	    assertReducerShape(finalReducers);
    	  } catch (e) {
    	    shapeAssertionError = e;
    	  }

    	  return function combination() {
    	    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    	    var action = arguments[1];

    	    if (shapeAssertionError) {
    	      throw shapeAssertionError;
    	    }

    	    var hasChanged = false;
    	    var nextState = {};
    	    for (var _i = 0; _i < finalReducerKeys.length; _i++) {
    	      var _key = finalReducerKeys[_i];
    	      var reducer = finalReducers[_key];
    	      var previousStateForKey = state[_key];
    	      var nextStateForKey = reducer(previousStateForKey, action);
    	      if (typeof nextStateForKey === 'undefined') {
    	        var errorMessage = getUndefinedStateErrorMessage(_key, action);
    	        throw new Error(errorMessage);
    	      }
    	      nextState[_key] = nextStateForKey;
    	      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
    	    }
    	    return hasChanged ? nextState : state;
    	  };
    	}

    /***/ }),
    /* 22 */
    /***/ (function(module, exports) {

    	exports.__esModule = true;
    	exports['default'] = warning;
    	/**
    	 * Prints a warning in the console if it exists.
    	 *
    	 * @param {String} message The warning message.
    	 * @returns {void}
    	 */
    	function warning(message) {
    	  /* eslint-disable no-console */
    	  if (typeof console !== 'undefined' && typeof console.error === 'function') {
    	    console.error(message);
    	  }
    	  /* eslint-enable no-console */
    	  try {
    	    // This error was thrown as a convenience so that if you enable
    	    // "break on all exceptions" in your console,
    	    // it would pause the execution at this line.
    	    throw new Error(message);
    	    /* eslint-disable no-empty */
    	  } catch (e) {}
    	  /* eslint-enable no-empty */
    	}

    /***/ }),
    /* 23 */
    /***/ (function(module, exports) {

    	exports.__esModule = true;
    	exports['default'] = bindActionCreators;
    	function bindActionCreator(actionCreator, dispatch) {
    	  return function () {
    	    return dispatch(actionCreator.apply(undefined, arguments));
    	  };
    	}

    	/**
    	 * Turns an object whose values are action creators, into an object with the
    	 * same keys, but with every function wrapped into a `dispatch` call so they
    	 * may be invoked directly. This is just a convenience method, as you can call
    	 * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.
    	 *
    	 * For convenience, you can also pass a single function as the first argument,
    	 * and get a function in return.
    	 *
    	 * @param {Function|Object} actionCreators An object whose values are action
    	 * creator functions. One handy way to obtain it is to use ES6 `import * as`
    	 * syntax. You may also pass a single function.
    	 *
    	 * @param {Function} dispatch The `dispatch` function available on your Redux
    	 * store.
    	 *
    	 * @returns {Function|Object} The object mimicking the original object, but with
    	 * every action creator wrapped into the `dispatch` call. If you passed a
    	 * function as `actionCreators`, the return value will also be a single
    	 * function.
    	 */
    	function bindActionCreators(actionCreators, dispatch) {
    	  if (typeof actionCreators === 'function') {
    	    return bindActionCreator(actionCreators, dispatch);
    	  }

    	  if (typeof actionCreators !== 'object' || actionCreators === null) {
    	    throw new Error('bindActionCreators expected an object or a function, instead received ' + (actionCreators === null ? 'null' : typeof actionCreators) + '. ' + 'Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?');
    	  }

    	  var keys = Object.keys(actionCreators);
    	  var boundActionCreators = {};
    	  for (var i = 0; i < keys.length; i++) {
    	    var key = keys[i];
    	    var actionCreator = actionCreators[key];
    	    if (typeof actionCreator === 'function') {
    	      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
    	    }
    	  }
    	  return boundActionCreators;
    	}

    /***/ }),
    /* 24 */
    /***/ (function(module, exports, __webpack_require__) {

    	exports.__esModule = true;

    	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

    	exports['default'] = applyMiddleware;

    	var _compose = __webpack_require__(25);

    	var _compose2 = _interopRequireDefault(_compose);

    	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

    	/**
    	 * Creates a store enhancer that applies middleware to the dispatch method
    	 * of the Redux store. This is handy for a variety of tasks, such as expressing
    	 * asynchronous actions in a concise manner, or logging every action payload.
    	 *
    	 * See `redux-thunk` package as an example of the Redux middleware.
    	 *
    	 * Because middleware is potentially asynchronous, this should be the first
    	 * store enhancer in the composition chain.
    	 *
    	 * Note that each middleware will be given the `dispatch` and `getState` functions
    	 * as named arguments.
    	 *
    	 * @param {...Function} middlewares The middleware chain to be applied.
    	 * @returns {Function} A store enhancer applying the middleware.
    	 */
    	function applyMiddleware() {
    	  for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {
    	    middlewares[_key] = arguments[_key];
    	  }

    	  return function (createStore) {
    	    return function (reducer, preloadedState, enhancer) {
    	      var store = createStore(reducer, preloadedState, enhancer);
    	      var _dispatch = store.dispatch;
    	      var chain = [];

    	      var middlewareAPI = {
    	        getState: store.getState,
    	        dispatch: function dispatch(action) {
    	          return _dispatch(action);
    	        }
    	      };
    	      chain = middlewares.map(function (middleware) {
    	        return middleware(middlewareAPI);
    	      });
    	      _dispatch = _compose2['default'].apply(undefined, chain)(store.dispatch);

    	      return _extends({}, store, {
    	        dispatch: _dispatch
    	      });
    	    };
    	  };
    	}

    /***/ }),
    /* 25 */
    /***/ (function(module, exports) {

    	exports.__esModule = true;
    	exports["default"] = compose;
    	/**
    	 * Composes single-argument functions from right to left. The rightmost
    	 * function can take multiple arguments as it provides the signature for
    	 * the resulting composite function.
    	 *
    	 * @param {...Function} funcs The functions to compose.
    	 * @returns {Function} A function obtained by composing the argument functions
    	 * from right to left. For example, compose(f, g, h) is identical to doing
    	 * (...args) => f(g(h(...args))).
    	 */

    	function compose() {
    	  for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {
    	    funcs[_key] = arguments[_key];
    	  }

    	  if (funcs.length === 0) {
    	    return function (arg) {
    	      return arg;
    	    };
    	  }

    	  if (funcs.length === 1) {
    	    return funcs[0];
    	  }

    	  return funcs.reduce(function (a, b) {
    	    return function () {
    	      return a(b.apply(undefined, arguments));
    	    };
    	  });
    	}

    /***/ }),
    /* 26 */
    /***/ (function(module, exports, __webpack_require__) {

    	Object.defineProperty(exports, "__esModule", {
    	  value: true
    	});

    	var _redux = __webpack_require__(5);

    	var _items = __webpack_require__(27);

    	var _items2 = _interopRequireDefault(_items);

    	var _groups = __webpack_require__(28);

    	var _groups2 = _interopRequireDefault(_groups);

    	var _choices = __webpack_require__(29);

    	var _choices2 = _interopRequireDefault(_choices);

    	var _general = __webpack_require__(30);

    	var _general2 = _interopRequireDefault(_general);

    	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    	var appReducer = (0, _redux.combineReducers)({
    	  items: _items2.default,
    	  groups: _groups2.default,
    	  choices: _choices2.default,
    	  general: _general2.default
    	});

    	var rootReducer = function rootReducer(passedState, action) {
    	  var state = passedState;
    	  // If we are clearing all items, groups and options we reassign
    	  // state and then pass that state to our proper reducer. This isn't
    	  // mutating our actual state
    	  // See: http://stackoverflow.com/a/35641992
    	  if (action.type === 'CLEAR_ALL') {
    	    state = undefined;
    	  }

    	  return appReducer(state, action);
    	};

    	exports.default = rootReducer;

    /***/ }),
    /* 27 */
    /***/ (function(module, exports) {

    	Object.defineProperty(exports, "__esModule", {
    	  value: true
    	});

    	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

    	var items = function items() {
    	  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    	  var action = arguments[1];

    	  switch (action.type) {
    	    case 'ADD_ITEM':
    	      {
    	        // Add object to items array
    	        var newState = [].concat(_toConsumableArray(state), [{
    	          id: action.id,
    	          choiceId: action.choiceId,
    	          groupId: action.groupId,
    	          value: action.value,
    	          label: action.label,
    	          active: true,
    	          highlighted: false,
    	          customProperties: action.customProperties,
    	          placeholder: action.placeholder || false,
    	          keyCode: null
    	        }]);

    	        return newState.map(function (item) {
    	          if (item.highlighted) {
    	            item.highlighted = false;
    	          }
    	          return item;
    	        });
    	      }

    	    case 'REMOVE_ITEM':
    	      {
    	        // Set item to inactive
    	        return state.map(function (item) {
    	          if (item.id === action.id) {
    	            item.active = false;
    	          }
    	          return item;
    	        });
    	      }

    	    case 'HIGHLIGHT_ITEM':
    	      {
    	        return state.map(function (item) {
    	          if (item.id === action.id) {
    	            item.highlighted = action.highlighted;
    	          }
    	          return item;
    	        });
    	      }

    	    default:
    	      {
    	        return state;
    	      }
    	  }
    	};

    	exports.default = items;

    /***/ }),
    /* 28 */
    /***/ (function(module, exports) {

    	Object.defineProperty(exports, "__esModule", {
    	  value: true
    	});

    	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

    	var groups = function groups() {
    	  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    	  var action = arguments[1];

    	  switch (action.type) {
    	    case 'ADD_GROUP':
    	      {
    	        return [].concat(_toConsumableArray(state), [{
    	          id: action.id,
    	          value: action.value,
    	          active: action.active,
    	          disabled: action.disabled
    	        }]);
    	      }

    	    case 'CLEAR_CHOICES':
    	      {
    	        return state.groups = [];
    	      }

    	    default:
    	      {
    	        return state;
    	      }
    	  }
    	};

    	exports.default = groups;

    /***/ }),
    /* 29 */
    /***/ (function(module, exports) {

    	Object.defineProperty(exports, "__esModule", {
    	  value: true
    	});

    	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

    	var choices = function choices() {
    	  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    	  var action = arguments[1];

    	  switch (action.type) {
    	    case 'ADD_CHOICE':
    	      {
    	        /*
    	            A disabled choice appears in the choice dropdown but cannot be selected
    	            A selected choice has been added to the passed input's value (added as an item)
    	            An active choice appears within the choice dropdown
    	         */
    	        return [].concat(_toConsumableArray(state), [{
    	          id: action.id,
    	          elementId: action.elementId,
    	          groupId: action.groupId,
    	          value: action.value,
    	          label: action.label || action.value,
    	          disabled: action.disabled || false,
    	          selected: false,
    	          active: true,
    	          score: 9999,
    	          customProperties: action.customProperties,
    	          placeholder: action.placeholder || false,
    	          keyCode: null
    	        }]);
    	      }

    	    case 'ADD_ITEM':
    	      {
    	        var newState = state;

    	        // If all choices need to be activated
    	        if (action.activateOptions) {
    	          newState = state.map(function (choice) {
    	            choice.active = action.active;
    	            return choice;
    	          });
    	        }
    	        // When an item is added and it has an associated choice,
    	        // we want to disable it so it can't be chosen again
    	        if (action.choiceId > -1) {
    	          newState = state.map(function (choice) {
    	            if (choice.id === parseInt(action.choiceId, 10)) {
    	              choice.selected = true;
    	            }
    	            return choice;
    	          });
    	        }

    	        return newState;
    	      }

    	    case 'REMOVE_ITEM':
    	      {
    	        // When an item is removed and it has an associated choice,
    	        // we want to re-enable it so it can be chosen again
    	        if (action.choiceId > -1) {
    	          return state.map(function (choice) {
    	            if (choice.id === parseInt(action.choiceId, 10)) {
    	              choice.selected = false;
    	            }
    	            return choice;
    	          });
    	        }

    	        return state;
    	      }

    	    case 'FILTER_CHOICES':
    	      {
    	        var filteredResults = action.results;
    	        var filteredState = state.map(function (choice) {
    	          // Set active state based on whether choice is
    	          // within filtered results

    	          choice.active = filteredResults.some(function (result) {
    	            if (result.item.id === choice.id) {
    	              choice.score = result.score;
    	              return true;
    	            }
    	            return false;
    	          });

    	          return choice;
    	        });

    	        return filteredState;
    	      }

    	    case 'ACTIVATE_CHOICES':
    	      {
    	        return state.map(function (choice) {
    	          choice.active = action.active;
    	          return choice;
    	        });
    	      }

    	    case 'CLEAR_CHOICES':
    	      {
    	        return state.choices = [];
    	      }

    	    default:
    	      {
    	        return state;
    	      }
    	  }
    	};

    	exports.default = choices;

    /***/ }),
    /* 30 */
    /***/ (function(module, exports) {

    	Object.defineProperty(exports, "__esModule", {
    	  value: true
    	});
    	var general = function general() {
    	  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { loading: false };
    	  var action = arguments[1];

    	  switch (action.type) {
    	    case 'LOADING':
    	      {
    	        return {
    	          loading: action.isLoading
    	        };
    	      }

    	    default:
    	      {
    	        return state;
    	      }
    	  }
    	};

    	exports.default = general;

    /***/ }),
    /* 31 */
    /***/ (function(module, exports) {

    	Object.defineProperty(exports, "__esModule", {
    	  value: true
    	});
    	var addItem = exports.addItem = function addItem(value, label, id, choiceId, groupId, customProperties, placeholder, keyCode) {
    	  return {
    	    type: 'ADD_ITEM',
    	    value: value,
    	    label: label,
    	    id: id,
    	    choiceId: choiceId,
    	    groupId: groupId,
    	    customProperties: customProperties,
    	    placeholder: placeholder,
    	    keyCode: keyCode
    	  };
    	};

    	var removeItem = exports.removeItem = function removeItem(id, choiceId) {
    	  return {
    	    type: 'REMOVE_ITEM',
    	    id: id,
    	    choiceId: choiceId
    	  };
    	};

    	var highlightItem = exports.highlightItem = function highlightItem(id, highlighted) {
    	  return {
    	    type: 'HIGHLIGHT_ITEM',
    	    id: id,
    	    highlighted: highlighted
    	  };
    	};

    	var addChoice = exports.addChoice = function addChoice(value, label, id, groupId, disabled, elementId, customProperties, placeholder, keyCode) {
    	  return {
    	    type: 'ADD_CHOICE',
    	    value: value,
    	    label: label,
    	    id: id,
    	    groupId: groupId,
    	    disabled: disabled,
    	    elementId: elementId,
    	    customProperties: customProperties,
    	    placeholder: placeholder,
    	    keyCode: keyCode
    	  };
    	};

    	var filterChoices = exports.filterChoices = function filterChoices(results) {
    	  return {
    	    type: 'FILTER_CHOICES',
    	    results: results
    	  };
    	};

    	var activateChoices = exports.activateChoices = function activateChoices() {
    	  var active = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

    	  return {
    	    type: 'ACTIVATE_CHOICES',
    	    active: active
    	  };
    	};

    	var clearChoices = exports.clearChoices = function clearChoices() {
    	  return {
    	    type: 'CLEAR_CHOICES'
    	  };
    	};

    	var addGroup = exports.addGroup = function addGroup(value, id, active, disabled) {
    	  return {
    	    type: 'ADD_GROUP',
    	    value: value,
    	    id: id,
    	    active: active,
    	    disabled: disabled
    	  };
    	};

    	var clearAll = exports.clearAll = function clearAll() {
    	  return {
    	    type: 'CLEAR_ALL'
    	  };
    	};

    	var setIsLoading = exports.setIsLoading = function setIsLoading(isLoading) {
    	  return {
    	    type: 'LOADING',
    	    isLoading: isLoading
    	  };
    		};

    /***/ }),
    /* 32 */
    /***/ (function(module, exports) {

    	Object.defineProperty(exports, "__esModule", {
    	  value: true
    	});

    	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

    	/* eslint-disable */
    	/**
    	 * Capitalises the first letter of each word in a string
    	 * @param  {String} str String to capitalise
    	 * @return {String}     Capitalised string
    	 */
    	var capitalise = exports.capitalise = function capitalise(str) {
    	  return str.replace(/\w\S*/g, function (txt) {
    	    return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
    	  });
    	};

    	/**
    	 * Generates a string of random chars
    	 * @param  {Number} length Length of the string to generate
    	 * @return {String} String of random chars
    	 */
    	var generateChars = exports.generateChars = function generateChars(length) {
    	  var chars = '';

    	  for (var i = 0; i < length; i++) {
    	    var randomChar = getRandomNumber(0, 36);
    	    chars += randomChar.toString(36);
    	  }

    	  return chars;
    	};

    	/**
    	 * Generates a unique id based on an element
    	 * @param  {HTMLElement} element Element to generate the id from
    	 * @param  {String} Prefix for the Id
    	 * @return {String} Unique Id
    	 */
    	var generateId = exports.generateId = function generateId(element, prefix) {
    	  var id = element.id || element.name && element.name + '-' + generateChars(2) || generateChars(4);
    	  id = id.replace(/(:|\.|\[|\]|,)/g, '');
    	  id = prefix + id;

    	  return id;
    	};

    	/**
    	 * Tests the type of an object
    	 * @param  {String}  type Type to test object against
    	 * @param  {Object}  obj  Object to be tested
    	 * @return {Boolean}
    	 */
    	var getType = exports.getType = function getType(obj) {
    	  return Object.prototype.toString.call(obj).slice(8, -1);
    	};

    	/**
    	 * Tests the type of an object
    	 * @param  {String}  type Type to test object against
    	 * @param  {Object}  obj  Object to be tested
    	 * @return {Boolean}
    	 */
    	var isType = exports.isType = function isType(type, obj) {
    	  var clas = getType(obj);
    	  return obj !== undefined && obj !== null && clas === type;
    	};

    	/**
    	 * Tests to see if a passed object is a node
    	 * @param  {Object}  obj  Object to be tested
    	 * @return {Boolean}
    	 */
    	var isNode = exports.isNode = function isNode(o) {
    	  return (typeof Node === 'undefined' ? 'undefined' : _typeof(Node)) === "object" ? o instanceof Node : o && (typeof o === 'undefined' ? 'undefined' : _typeof(o)) === "object" && typeof o.nodeType === "number" && typeof o.nodeName === "string";
    	};

    	/**
    	 * Tests to see if a passed object is an element
    	 * @param  {Object}  obj  Object to be tested
    	 * @return {Boolean}
    	 */
    	var isElement = exports.isElement = function isElement(o) {
    	  return (typeof HTMLElement === 'undefined' ? 'undefined' : _typeof(HTMLElement)) === "object" ? o instanceof HTMLElement : //DOM2
    	  o && (typeof o === 'undefined' ? 'undefined' : _typeof(o)) === "object" && o !== null && o.nodeType === 1 && typeof o.nodeName === "string";
    	};

    	/**
    	 * Merges unspecified amount of objects into new object
    	 * @private
    	 * @return {Object} Merged object of arguments
    	 */
    	var extend = exports.extend = function extend() {
    	  var extended = {};
    	  var length = arguments.length;

    	  /**
    	   * Merge one object into another
    	   * @param  {Object} obj  Object to merge into extended object
    	   */
    	  var merge = function merge(obj) {
    	    for (var prop in obj) {
    	      if (Object.prototype.hasOwnProperty.call(obj, prop)) {
    	        // If deep merge and property is an object, merge properties
    	        if (isType('Object', obj[prop])) {
    	          extended[prop] = extend(true, extended[prop], obj[prop]);
    	        } else {
    	          extended[prop] = obj[prop];
    	        }
    	      }
    	    }
    	  };

    	  // Loop through each passed argument
    	  for (var i = 0; i < length; i++) {
    	    // store argument at position i
    	    var obj = arguments[i];

    	    // If we are in fact dealing with an object, merge it.
    	    if (isType('Object', obj)) {
    	      merge(obj);
    	    }
    	  }

    	  return extended;
    	};

    	/**
    	 * CSS transition end event listener
    	 * @return
    	 */
    	var whichTransitionEvent = exports.whichTransitionEvent = function whichTransitionEvent() {
    	  var t,
    	      el = document.createElement('fakeelement');

    	  var transitions = {
    	    'transition': 'transitionend',
    	    'OTransition': 'oTransitionEnd',
    	    'MozTransition': 'transitionend',
    	    'WebkitTransition': 'webkitTransitionEnd'
    	  };

    	  for (t in transitions) {
    	    if (el.style[t] !== undefined) {
    	      return transitions[t];
    	    }
    	  }
    	};

    	/**
    	 * CSS animation end event listener
    	 * @return
    	 */
    	var whichAnimationEvent = exports.whichAnimationEvent = function whichAnimationEvent() {
    	  var t,
    	      el = document.createElement('fakeelement');

    	  var animations = {
    	    'animation': 'animationend',
    	    'OAnimation': 'oAnimationEnd',
    	    'MozAnimation': 'animationend',
    	    'WebkitAnimation': 'webkitAnimationEnd'
    	  };

    	  for (t in animations) {
    	    if (el.style[t] !== undefined) {
    	      return animations[t];
    	    }
    	  }
    	};

    	/**
    	 *  Get the ancestors of each element in the current set of matched elements,
    	 *  up to but not including the element matched by the selector
    	 * @param  {NodeElement} elem     Element to begin search from
    	 * @param  {NodeElement} parent   Parent to find
    	 * @param  {String} selector Class to find
    	 * @return {Array}          Array of parent elements
    	 */
    	var getParentsUntil = exports.getParentsUntil = function getParentsUntil(elem, parent, selector) {
    	  var parents = [];
    	  // Get matches
    	  for (; elem && elem !== document; elem = elem.parentNode) {

    	    // Check if parent has been reached
    	    if (parent) {

    	      var parentType = parent.charAt(0);

    	      // If parent is a class
    	      if (parentType === '.') {
    	        if (elem.classList.contains(parent.substr(1))) {
    	          break;
    	        }
    	      }

    	      // If parent is an ID
    	      if (parentType === '#') {
    	        if (elem.id === parent.substr(1)) {
    	          break;
    	        }
    	      }

    	      // If parent is a data attribute
    	      if (parentType === '[') {
    	        if (elem.hasAttribute(parent.substr(1, parent.length - 1))) {
    	          break;
    	        }
    	      }

    	      // If parent is a tag
    	      if (elem.tagName.toLowerCase() === parent) {
    	        break;
    	      }
    	    }
    	    if (selector) {
    	      var selectorType = selector.charAt(0);

    	      // If selector is a class
    	      if (selectorType === '.') {
    	        if (elem.classList.contains(selector.substr(1))) {
    	          parents.push(elem);
    	        }
    	      }

    	      // If selector is an ID
    	      if (selectorType === '#') {
    	        if (elem.id === selector.substr(1)) {
    	          parents.push(elem);
    	        }
    	      }

    	      // If selector is a data attribute
    	      if (selectorType === '[') {
    	        if (elem.hasAttribute(selector.substr(1, selector.length - 1))) {
    	          parents.push(elem);
    	        }
    	      }

    	      // If selector is a tag
    	      if (elem.tagName.toLowerCase() === selector) {
    	        parents.push(elem);
    	      }
    	    } else {
    	      parents.push(elem);
    	    }
    	  }

    	  // Return parents if any exist
    	  if (parents.length === 0) {
    	    return null;
    	  } else {
    	    return parents;
    	  }
    	};

    	var wrap = exports.wrap = function wrap(element, wrapper) {
    	  wrapper = wrapper || document.createElement('div');
    	  if (element.nextSibling) {
    	    element.parentNode.insertBefore(wrapper, element.nextSibling);
    	  } else {
    	    element.parentNode.appendChild(wrapper);
    	  }
    	  return wrapper.appendChild(element);
    	};

    	var getSiblings = exports.getSiblings = function getSiblings(elem) {
    	  var siblings = [];
    	  var sibling = elem.parentNode.firstChild;
    	  for (; sibling; sibling = sibling.nextSibling) {
    	    if (sibling.nodeType === 1 && sibling !== elem) {
    	      siblings.push(sibling);
    	    }
    	  }
    	  return siblings;
    	};

    	/**
    	 * Find ancestor in DOM tree
    	 * @param  {NodeElement} el  Element to start search from
    	 * @param  {[type]} cls Class of parent
    	 * @return {NodeElement}     Found parent element
    	 */
    	var findAncestor = exports.findAncestor = function findAncestor(el, cls) {
    	  while ((el = el.parentElement) && !el.classList.contains(cls)) {}
    	  return el;
    	};

    	/**
    	 * Find ancestor in DOM tree by attribute name
    	 * @param  {NodeElement} el  Element to start search from
    	 * @param  {string} attr Attribute name of parent
    	 * @return {?NodeElement}     Found parent element or null
    	 */
    	var findAncestorByAttrName = exports.findAncestorByAttrName = function findAncestorByAttrName(el, attr) {
    	  var target = el;

    	  while (target) {
    	    if (target.hasAttribute(attr)) {
    	      return target;
    	    }

    	    target = target.parentElement;
    	  }

    	  return null;
    	};

    	/**
    	 * Debounce an event handler.
    	 * @param  {Function} func      Function to run after wait
    	 * @param  {Number} wait      The delay before the function is executed
    	 * @param  {Boolean} immediate  If  passed, trigger the function on the leading edge, instead of the trailing.
    	 * @return {Function}           A function will be called after it stops being called for a given delay
    	 */
    	var debounce = exports.debounce = function debounce(func, wait, immediate) {
    	  var timeout;
    	  return function () {
    	    var context = this,
    	        args = arguments;
    	    var later = function later() {
    	      timeout = null;
    	      if (!immediate) func.apply(context, args);
    	    };
    	    var callNow = immediate && !timeout;
    	    clearTimeout(timeout);
    	    timeout = setTimeout(later, wait);
    	    if (callNow) func.apply(context, args);
    	  };
    	};

    	/**
    	 * Get an element's distance from the top of the page
    	 * @private
    	 * @param  {NodeElement} el Element to test for
    	 * @return {Number} Elements Distance from top of page
    	 */
    	var getElemDistance = exports.getElemDistance = function getElemDistance(el) {
    	  var location = 0;
    	  if (el.offsetParent) {
    	    do {
    	      location += el.offsetTop;
    	      el = el.offsetParent;
    	    } while (el);
    	  }
    	  return location >= 0 ? location : 0;
    	};

    	/**
    	 * Determine element height multiplied by any offsets
    	 * @private
    	 * @param  {HTMLElement} el Element to test for
    	 * @return {Number}    Height of element
    	 */
    	var getElementOffset = exports.getElementOffset = function getElementOffset(el, offset) {
    	  var elOffset = offset;
    	  if (elOffset > 1) elOffset = 1;
    	  if (elOffset > 0) elOffset = 0;

    	  return Math.max(el.offsetHeight * elOffset);
    	};

    	/**
    	 * Get the next or previous element from a given start point
    	 * @param  {HTMLElement} startEl    Element to start position from
    	 * @param  {String}      className  The class we will look through
    	 * @param  {Number}      direction  Positive next element, negative previous element
    	 * @return {[HTMLElement}           Found element
    	 */
    	var getAdjacentEl = exports.getAdjacentEl = function getAdjacentEl(startEl, className) {
    	  var direction = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;

    	  if (!startEl || !className) return;

    	  var parent = startEl.parentNode.parentNode;
    	  var children = Array.from(parent.querySelectorAll(className));

    	  var startPos = children.indexOf(startEl);
    	  var operatorDirection = direction > 0 ? 1 : -1;

    	  return children[startPos + operatorDirection];
    	};

    	/**
    	 * Get scroll position based on top/bottom position
    	 * @private
    	 * @return {String} Position of scroll
    	 */
    	var getScrollPosition = exports.getScrollPosition = function getScrollPosition(position) {
    	  if (position === 'bottom') {
    	    // Scroll position from the bottom of the viewport
    	    return Math.max((window.scrollY || window.pageYOffset) + (window.innerHeight || document.documentElement.clientHeight));
    	  } else {
    	    // Scroll position from the top of the viewport
    	    return window.scrollY || window.pageYOffset;
    	  }
    	};

    	/**
    	 * Determine whether an element is within the viewport
    	 * @param  {HTMLElement}  el Element to test
    	 * @return {String} Position of scroll
    	 * @return {Boolean}
    	 */
    	var isInView = exports.isInView = function isInView(el, position, offset) {
    	  // If the user has scrolled further than the distance from the element to the top of its parent
    	  return this.getScrollPosition(position) > this.getElemDistance(el) + this.getElementOffset(el, offset) ? true : false;
    	};

    	/**
    	 * Determine whether an element is within
    	 * @param  {HTMLElement} el        Element to test
    	 * @param  {HTMLElement} parent    Scrolling parent
    	 * @param  {Number} direction      Whether element is visible from above or below
    	 * @return {Boolean}
    	 */
    	var isScrolledIntoView = exports.isScrolledIntoView = function isScrolledIntoView(el, parent) {
    	  var direction = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;

    	  if (!el) return;

    	  var isVisible = void 0;

    	  if (direction > 0) {
    	    // In view from bottom
    	    isVisible = parent.scrollTop + parent.offsetHeight >= el.offsetTop + el.offsetHeight;
    	  } else {
    	    // In view from top
    	    isVisible = el.offsetTop >= parent.scrollTop;
    	  }

    	  return isVisible;
    	};

    	/**
    	 * Escape html in a string
    	 * @param  {String} html  Initial string/html
    	 * @return {String}  Sanitised string
    	 */
    	var stripHTML = exports.stripHTML = function stripHTML(html) {
    	  return html.replace(/&/g, '&amp;').replace(/>/g, '&rt;').replace(/</g, '&lt;').replace(/"/g, '&quot;');
    	};

    	/**
    	 * Adds animation to an element and removes it upon animation completion
    	 * @param  {Element} el        Element to add animation to
    	 * @param  {String} animation Animation class to add to element
    	 * @return
    	 */
    	var addAnimation = exports.addAnimation = function addAnimation(el, animation) {
    	  var animationEvent = whichAnimationEvent();

    	  var removeAnimation = function removeAnimation() {
    	    el.classList.remove(animation);
    	    el.removeEventListener(animationEvent, removeAnimation, false);
    	  };

    	  el.classList.add(animation);
    	  el.addEventListener(animationEvent, removeAnimation, false);
    	};

    	/**
    	 * Get a random number between a range
    	 * @param  {Number} min Minimum range
    	 * @param  {Number} max Maximum range
    	 * @return {Number}     Random number
    	 */
    	var getRandomNumber = exports.getRandomNumber = function getRandomNumber(min, max) {
    	  return Math.floor(Math.random() * (max - min) + min);
    	};

    	/**
    	 * Turn a string into a node
    	 * @param  {String} String to convert
    	 * @return {HTMLElement}   Converted node element
    	 */
    	var strToEl = exports.strToEl = function () {
    	  var tmpEl = document.createElement('div');
    	  return function (str) {
    	    var cleanedInput = str.trim();
    	    var r = void 0;
    	    tmpEl.innerHTML = cleanedInput;
    	    r = tmpEl.children[0];

    	    while (tmpEl.firstChild) {
    	      tmpEl.removeChild(tmpEl.firstChild);
    	    }

    	    return r;
    	  };
    	}();

    	/**
    	 * Sets the width of a passed input based on its value
    	 * @return {Number} Width of input
    	 */
    	var getWidthOfInput = exports.getWidthOfInput = function getWidthOfInput(input) {
    	  var value = input.value || input.placeholder;
    	  var width = input.offsetWidth;

    	  if (value) {
    	    var testEl = strToEl('<span>' + stripHTML(value) + '</span>');
    	    testEl.style.position = 'absolute';
    	    testEl.style.padding = '0';
    	    testEl.style.top = '-9999px';
    	    testEl.style.left = '-9999px';
    	    testEl.style.width = 'auto';
    	    testEl.style.whiteSpace = 'pre';

    	    if (document.body.contains(input) && window.getComputedStyle) {
    	      var inputStyle = window.getComputedStyle(input);

    	      if (inputStyle) {
    	        testEl.style.fontSize = inputStyle.fontSize;
    	        testEl.style.fontFamily = inputStyle.fontFamily;
    	        testEl.style.fontWeight = inputStyle.fontWeight;
    	        testEl.style.fontStyle = inputStyle.fontStyle;
    	        testEl.style.letterSpacing = inputStyle.letterSpacing;
    	        testEl.style.textTransform = inputStyle.textTransform;
    	        testEl.style.padding = inputStyle.padding;
    	      }
    	    }

    	    document.body.appendChild(testEl);

    	    if (value && testEl.offsetWidth !== input.offsetWidth) {
    	      width = testEl.offsetWidth + 4;
    	    }

    	    document.body.removeChild(testEl);
    	  }

    	  return width + 'px';
    	};

    	/**
    	 * Sorting function for current and previous string
    	 * @param  {String} a Current value
    	 * @param  {String} b Next value
    	 * @return {Number}   -1 for after previous,
    	 *                    1 for before,
    	 *                    0 for same location
    	 */
    	var sortByAlpha = exports.sortByAlpha = function sortByAlpha(a, b) {
    	  var labelA = (a.label || a.value).toLowerCase();
    	  var labelB = (b.label || b.value).toLowerCase();

    	  if (labelA < labelB) return -1;
    	  if (labelA > labelB) return 1;
    	  return 0;
    	};

    	/**
    	 * Sort by numeric score
    	 * @param  {Object} a Current value
    	 * @param  {Object} b Next value
    	 * @return {Number}   -1 for after previous,
    	 *                    1 for before,
    	 *                    0 for same location
    	 */
    	var sortByScore = exports.sortByScore = function sortByScore(a, b) {
    	  return a.score - b.score;
    	};

    	/**
    	 * Trigger native event
    	 * @param  {NodeElement} element Element to trigger event on
    	 * @param  {String} type         Type of event to trigger
    	 * @param  {Object} customArgs   Data to pass with event
    	 * @return {Object}              Triggered event
    	 */
    	var triggerEvent = exports.triggerEvent = function triggerEvent(element, type) {
    	  var customArgs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

    	  var event = new CustomEvent(type, {
    	    detail: customArgs,
    	    bubbles: true,
    	    cancelable: true
    	  });

    	  return element.dispatchEvent(event);
    	};

    /***/ }),
    /* 33 */
    /***/ (function(module, exports) {

    	/* eslint-disable */
    	(function () {
    	  // Production steps of ECMA-262, Edition 6, 22.1.2.1
    	  // Reference: https://people.mozilla.org/~jorendorff/es6-draft.html#sec-array.from
    	  if (!Array.from) {
    	    Array.from = function () {
    	      var toStr = Object.prototype.toString;

    	      var isCallable = function isCallable(fn) {
    	        return typeof fn === 'function' || toStr.call(fn) === '[object Function]';
    	      };

    	      var toInteger = function toInteger(value) {
    	        var number = Number(value);
    	        if (isNaN(number)) {
    	          return 0;
    	        }
    	        if (number === 0 || !isFinite(number)) {
    	          return number;
    	        }
    	        return (number > 0 ? 1 : -1) * Math.floor(Math.abs(number));
    	      };

    	      var maxSafeInteger = Math.pow(2, 53) - 1;

    	      var toLength = function toLength(value) {
    	        var len = toInteger(value);
    	        return Math.min(Math.max(len, 0), maxSafeInteger);
    	      };

    	      // The length property of the from method is 1.
    	      return function from(arrayLike /*, mapFn, thisArg */) {
    	        // 1. Let C be the this value.
    	        var C = this;

    	        // 2. Let items be ToObject(arrayLike).
    	        var items = Object(arrayLike);

    	        // 3. ReturnIfAbrupt(items).
    	        if (arrayLike == null) {
    	          throw new TypeError("Array.from requires an array-like object - not null or undefined");
    	        }

    	        // 4. If mapfn is undefined, then let mapping be false.
    	        var mapFn = arguments.length > 1 ? arguments[1] : void undefined;
    	        var T;
    	        if (typeof mapFn !== 'undefined') {
    	          // 5. else
    	          // 5. a If IsCallable(mapfn) is false, throw a TypeError exception.
    	          if (!isCallable(mapFn)) {
    	            throw new TypeError('Array.from: when provided, the second argument must be a function');
    	          }

    	          // 5. b. If thisArg was supplied, let T be thisArg; else let T be undefined.
    	          if (arguments.length > 2) {
    	            T = arguments[2];
    	          }
    	        }

    	        // 10. Let lenValue be Get(items, "length").
    	        // 11. Let len be ToLength(lenValue).
    	        var len = toLength(items.length);

    	        // 13. If IsConstructor(C) is true, then
    	        // 13. a. Let A be the result of calling the [[Construct]] internal method of C with an argument list containing the single item len.
    	        // 14. a. Else, Let A be ArrayCreate(len).
    	        var A = isCallable(C) ? Object(new C(len)) : new Array(len);

    	        // 16. Let k be 0.
    	        var k = 0;
    	        // 17. Repeat, while k < len… (also steps a - h)
    	        var kValue;
    	        while (k < len) {
    	          kValue = items[k];
    	          if (mapFn) {
    	            A[k] = typeof T === 'undefined' ? mapFn(kValue, k) : mapFn.call(T, kValue, k);
    	          } else {
    	            A[k] = kValue;
    	          }
    	          k += 1;
    	        }
    	        // 18. Let putStatus be Put(A, "length", len, true).
    	        A.length = len;
    	        // 20. Return A.
    	        return A;
    	      };
    	    }();
    	  }

    	  // Reference: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/find
    	  if (!Array.prototype.find) {
    	    Array.prototype.find = function (predicate) {

    	      if (this == null) {
    	        throw new TypeError('Array.prototype.find called on null or undefined');
    	      }
    	      if (typeof predicate !== 'function') {
    	        throw new TypeError('predicate must be a function');
    	      }
    	      var list = Object(this);
    	      var length = list.length >>> 0;
    	      var thisArg = arguments[1];
    	      var value;

    	      for (var i = 0; i < length; i++) {
    	        value = list[i];
    	        if (predicate.call(thisArg, value, i, list)) {
    	          return value;
    	        }
    	      }
    	      return undefined;
    	    };
    	  }

    	  function CustomEvent(event, params) {
    	    params = params || {
    	      bubbles: false,
    	      cancelable: false,
    	      detail: undefined
    	    };
    	    var evt = document.createEvent('CustomEvent');
    	    evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
    	    return evt;
    	  }

    	  CustomEvent.prototype = window.Event.prototype;

    	  window.CustomEvent = CustomEvent;
    	})();

    /***/ })
    /******/ ])
    });

    });

    var Choices = unwrapExports(choices);

    /* src\core\ui\inputs\MultiSelect.html generated by Svelte v2.16.1 */

    function mapToTypeaheadItems$1(items) {
    	return items.map(t => ({
    		label: t.label,
    		value: t.value.toString()
    	}));
    }
    function calculateFieldValue(field, value) {
    	if (field.maxItemCount === 1) {
    		let result = field.value;
    		result = {
    			value: value[0] != null ? value[0].value : null
    		};
    		// We need to convert the value to string, otherwise it doesn't work.
    		// This is due to the way UmfApp deals with url parameters (or something
    		// along those lines).
    		if (result.value != null) {
    			result.value = result.value.toString();
    		}
    		return result;
    	}
    	return {
    		items: value.map(t => t.value)
    	};
    }
    function setInputValue(a, field) {
    	if (field.maxItemCount === 1) {
    		const v = (field.value || {}).value || null;
    		if (v != null) {
    			a.setValueByChoice(v.toString());
    		}
    	}
    	else {
    		const v = ((field.value || {}).items || []).map(t => t.toString());
    		a.setValueByChoice(v);
    	}
    }
    function getIdsQuery(field) {
    	let currentValue = field.maxItemCount === 1 ?
    		[(field.value || {}).value || ""] :
    		(field.value || {}).items || [];
    	// Put values into an array.
    	if (currentValue[0] === "") {
    		currentValue = [];
    	}
    	return currentValue;
    }
    function buildFilter$1(parentForm, parameters, query) {
    	let promise;
    	const filter = { query };
    	if (parameters != null && parameters.length > 0) {
    		promise = parentForm.get().form.getSerializedInputValues().then(data => {
    			for (const p of parameters) {
    				filter[p] = data[p];
    			}
    			return filter;
    		});
    	}
    	else {
    		promise = Promise.resolve(filter);
    	}
    	return promise;
    }

    function populateChoicesWithAjax(choicesComponent, multiSelectComponent, existingChoices, query, selectedItemIds) {
    	const componentData = multiSelectComponent.get();
    	const { parameters, source, typeaheadAllowNew } = componentData.field.metadata.customProperties;
    	const parentForm = componentData.form;
    	const { app } = componentData;

    	// eslint-disable-next-line no-param-reassign
    	return new Promise(resolve => {
    		choicesComponent.ajax(callback => buildFilter$1(parentForm, parameters, query).then(filter => {
    			if (selectedItemIds != null) {
    				// eslint-disable-next-line no-param-reassign
    				filter.ids = { items: selectedItemIds };
    			}
    			return app.server.postForm(source, filter).then(data => {
    				choicesComponent.setChoices(mapToTypeaheadItems$1([]), "value", "label", true);
    				// Mark items as added as "choices".
    				if (typeaheadAllowNew) {
    					if (data.items.length === 0) {
    						if (selectedItemIds != null) {
    							const newItems = [];
    							selectedItemIds.forEach(e => {
    								newItems.push({ label: `${e} <small>New</small>`, value: e });
    							});
    							callback(mapToTypeaheadItems$1(newItems), "value", "label", true);
    							resolve();
    						}
    						else {
    							const newLabel = `${query} <small>New</small>`;
    							const newItem = { label: newLabel, value: query };
    							callback(mapToTypeaheadItems$1([newItem]), "value", "label", true);
    							resolve();
    						}
    					}
    					else {
    						callback(mapToTypeaheadItems$1(data.items), "value", "label", true);
    						resolve();
    					}
    				}
    				else {
    					callback(mapToTypeaheadItems$1(data.items), "value", "label", true);
    					resolve();
    				}
    			});
    		}));
    	});
    }
    var methods$6 = {
    	onChange() {
    		this.get().form.fireAndBubbleUp("input:changed", {
    			app: this.get().app,
    			form: this.get().form,
    			input: this
    		});
    	}
    };

    function oncreate$9() {
    	const { field } = this.get();
    	const { source } = field.metadata.customProperties;
    	const a = new Choices(this.refs.input, {
    		duplicateItems: true,
    		addItems: true,
    		searchResultLimit: 10,
    		removeItemButton: true,
    		maxItemCount: field.maxItemCount,
    		noChoicesText: "Start type",
    		noResultsText: "No result found",
    		itemSelectText: "Select item",
    		loadingText: "downloading ...",
    		// placeholderValue: "All",
    		// searchPlaceholderValue: "Search",
    		maxItemText: maxItemCount => `Cannot add more than ${maxItemCount} item`
    	});

    	const formElement = this.refs.input.closest("form");

    	if (typeof field.value.value === "undefined" && field.metadata.required) {
    		this.refs.input.closest("div").classList.add("divError");
    	}
    	
    	const self = this;
    	formElement.addEventListener("submit", e => {
    		if (field.metadata.required && a.getValue().length === 0) {
    			e.preventDefault();
    		}
    	});

    	let timer = null;
    	const parent = this.refs.input.closest("div");
    	const parentInputElements = parent.getElementsByTagName("input");

    	if (typeof (source) === "string" && parentInputElements != null && parentInputElements.length > 0) {
    		parentInputElements[0].addEventListener("keydown", e => {
    			if (e.keyCode === 8 && (e.target.value.length === 1)) {
    				if (timer != null) {
    					clearTimeout(timer);
    				}
    				timer = setTimeout(() => {
    					populateChoicesWithAjax(a, self, {}, "");
    				}, 300);
    			}
    		});
    		parentInputElements[0].addEventListener("keyup", e => {
    			if (e.keyCode === 8 && (e.target.value === "" || e.target.value == null)) {
    				if (timer != null) {
    					clearTimeout(timer);
    				}
    				timer = setTimeout(() => {
    					populateChoicesWithAjax(a, self, {}, "");
    				}, 300);
    			}
    		});
    	}

    	a.passedElement.addEventListener("removeItem", event => {
    		if (field.metadata.required && a.getValue().length === 0) {
    			self.refs.input.closest("div").classList.add("divError");
    		}
    	});

    	a.passedElement.addEventListener("addItem", event => {
    		if (field.metadata.required) {
    			self.refs.input.closest("div").classList.remove("divError");
    		}
    	});

    	if (typeof (source) === "string") {
    		const addedItems = {};
    		let query = "";
    		a.passedElement.addEventListener("search", value => {
    			query = value.detail.value;
    	
    			if (timer != null) {
    				// Cancel previous timer, thus extending the delay until user has stopped typing.
    				clearTimeout(timer);
    			}
    			// Search when user types something, but introduce a short delay
    			// to avoid excessive http requests.
    			timer = setTimeout(() => {
    				populateChoicesWithAjax(a, self, addedItems, query);
    			}, 300);
    		});
    		const currentValue = getIdsQuery(field);
    		populateChoicesWithAjax(a, self, addedItems, "");
    		// If the field has a value, we need to load it.
    		if (currentValue.length > 0) {
    			populateChoicesWithAjax(a, self, addedItems, query, currentValue)
    				.then(() => {
    					setInputValue(a, field);
    					self.onChange();
    				});
    		}
    	}
    	else {
    		a.setChoices(mapToTypeaheadItems$1(source), "value", "label", true);
    		this.set({ inlineChoices: a });
    	}
    	a.passedElement.addEventListener("change", () => {
    		field.value = calculateFieldValue(field, a.getValue());
    	});
    }
    function onstate$1({ changed, current, previous }) {
    	if (changed.inlineChoices) {
    		if (!current.initialized && current.inlineChoices != null) {
    			// eslint-disable-next-line no-param-reassign
    			current.initialized = true;
    			setInputValue(current.inlineChoices, current.field);
    		}
    	}
    }
    const file$e = "src\\core\\ui\\inputs\\MultiSelect.html";

    function create_main_fragment$f(component, ctx) {
    	var select, select_required_value;

    	function change_handler(event) {
    		component.onChange();
    	}

    	return {
    		c: function create() {
    			select = createElement("select");
    			addListener(select, "change", change_handler);
    			select.required = select_required_value = ctx.field.metadata.required;
    			select.className = "multi-select form-control";
    			select.id = ctx.id;
    			select.tabIndex = ctx.tabindex;
    			select.multiple = true;
    			addLoc(select, file$e, 0, 0, 0);
    		},

    		m: function mount(target, anchor) {
    			insert(target, select, anchor);
    			component.refs.input = select;
    		},

    		p: function update(changed, ctx) {
    			if ((changed.field) && select_required_value !== (select_required_value = ctx.field.metadata.required)) {
    				select.required = select_required_value;
    			}

    			if (changed.id) {
    				select.id = ctx.id;
    			}

    			if (changed.tabindex) {
    				select.tabIndex = ctx.tabindex;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(select);
    			}

    			removeListener(select, "change", change_handler);
    			if (component.refs.input === select) component.refs.input = null;
    		}
    	};
    }

    function SvelteComponent$f(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) {
    		throw new Error("'target' is a required option");
    	}

    	init(this, options);
    	this.refs = {};
    	this._state = assign({}, options.data);
    	if (!('field' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'field'");
    	if (!('id' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'id'");
    	if (!('tabindex' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'tabindex'");
    	this._intro = true;

    	this._handlers.state = [onstate$1];

    	onstate$1.call(this, { changed: assignTrue({}, this._state), current: this._state });

    	this._fragment = create_main_fragment$f(this, this._state);

    	this.root._oncreate.push(() => {
    		oncreate$9.call(this);
    		this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
    	});

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);

    		flush(this);
    	}
    }

    assign(SvelteComponent$f.prototype, protoDev);
    assign(SvelteComponent$f.prototype, methods$6);

    SvelteComponent$f.prototype._checkReadOnly = function _checkReadOnly(newState) {
    };

    /* src\core\ui\inputs\Number.html generated by Svelte v2.16.1 */

    function data$7() {
    	return {
    		config: {
    			disabled: false
    		}
    	};
    }
    function oncreate$a() {
    	const { field } = this.get();
    	const config = field.metadata.customProperties || {};
    	const numberConfig = field.metadata.getCustomProperty("numberConfig") ||
    		{
    			minValue: null,
    			maxValue: null,
    			step: 1
    		};

    	this.set({
    		numberConfig,
    		config: config || {
    			disabled: false
    		}
    	});
    }
    const file$f = "src\\core\\ui\\inputs\\Number.html";

    function create_main_fragment$g(component, ctx) {
    	var if_block_anchor;

    	var if_block = (ctx.numberConfig != null) && create_if_block$b(component, ctx);

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (ctx.numberConfig != null) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block$b(component, ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (if_block) if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (1:0) {#if numberConfig != null}
    function create_if_block$b(component, ctx) {
    	var input, input_updating = false, input_required_value, input_disabled_value, input_step_value, input_min_value, input_max_value;

    	function input_input_handler() {
    		input_updating = true;
    		ctx.field.value = toNumber(input.value);
    		component.set({ field: ctx.field });
    		input_updating = false;
    	}

    	return {
    		c: function create() {
    			input = createElement("input");
    			addListener(input, "input", input_input_handler);
    			setAttribute(input, "type", "number");
    			input.id = ctx.id;
    			input.required = input_required_value = ctx.field.metadata.required;
    			input.tabIndex = ctx.tabindex;
    			input.className = "form-control";
    			input.disabled = input_disabled_value = ctx.config.disabled;
    			input.step = input_step_value = ctx.numberConfig.step;
    			input.min = input_min_value = ctx.numberConfig.minValue;
    			input.max = input_max_value = ctx.numberConfig.maxValue;
    			addLoc(input, file$f, 1, 0, 28);
    		},

    		m: function mount(target, anchor) {
    			insert(target, input, anchor);

    			input.value = ctx.field.value;
    		},

    		p: function update(changed, _ctx) {
    			ctx = _ctx;
    			if (!input_updating && changed.field) input.value = ctx.field.value;
    			if (changed.id) {
    				input.id = ctx.id;
    			}

    			if ((changed.field) && input_required_value !== (input_required_value = ctx.field.metadata.required)) {
    				input.required = input_required_value;
    			}

    			if (changed.tabindex) {
    				input.tabIndex = ctx.tabindex;
    			}

    			if ((changed.config) && input_disabled_value !== (input_disabled_value = ctx.config.disabled)) {
    				input.disabled = input_disabled_value;
    			}

    			if ((changed.numberConfig) && input_step_value !== (input_step_value = ctx.numberConfig.step)) {
    				input.step = input_step_value;
    			}

    			if ((changed.numberConfig) && input_min_value !== (input_min_value = ctx.numberConfig.minValue)) {
    				input.min = input_min_value;
    			}

    			if ((changed.numberConfig) && input_max_value !== (input_max_value = ctx.numberConfig.maxValue)) {
    				input.max = input_max_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(input);
    			}

    			removeListener(input, "input", input_input_handler);
    		}
    	};
    }

    function SvelteComponent$g(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) {
    		throw new Error("'target' is a required option");
    	}

    	init(this, options);
    	this._state = assign(data$7(), options.data);
    	if (!('numberConfig' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'numberConfig'");
    	if (!('id' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'id'");
    	if (!('field' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'field'");
    	if (!('tabindex' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'tabindex'");
    	if (!('config' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'config'");
    	this._intro = true;

    	this._fragment = create_main_fragment$g(this, this._state);

    	this.root._oncreate.push(() => {
    		oncreate$a.call(this);
    		this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
    	});

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);

    		flush(this);
    	}
    }

    assign(SvelteComponent$g.prototype, protoDev);

    SvelteComponent$g.prototype._checkReadOnly = function _checkReadOnly(newState) {
    };

    /* src\core\ui\inputs\NumberRange.html generated by Svelte v2.16.1 */

    function oncreate$b() {
    	const { field } = this.get();

    	if (field == null) {
    		return;
    	}

    	const numberConfig = (field.metadata.customProperties || {}).numberConfig || {
    		minValue: null,
    		maxValue: null,
    		step: 1
    	};

    	this.set({
    		numberConfig
    	});
    }
    const file$g = "src\\core\\ui\\inputs\\NumberRange.html";

    function add_css$8() {
    	var style = createElement("style");
    	style.id = 'svelte-6lg6r4-style';
    	style.textContent = ".input-group-addon.svelte-6lg6r4{font-size:0.8rem !important}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTnVtYmVyUmFuZ2UuaHRtbCIsInNvdXJjZXMiOlsiTnVtYmVyUmFuZ2UuaHRtbCJdLCJzb3VyY2VzQ29udGVudCI6WyJ7I2lmIG51bWJlckNvbmZpZyAhPSBudWxsfVxyXG48ZGl2IGNsYXNzPVwiaW5wdXQtZ3JvdXBcIj5cclxuICAgIDxzcGFuIGNsYXNzPVwiaW5wdXQtZ3JvdXAtYWRkb25cIj5NaW48L3NwYW4+XHJcblx0PGlucHV0IHR5cGU9XCJudW1iZXJcIlxyXG5cdFx0YmluZDp2YWx1ZT1cImZpZWxkLnZhbHVlLm1pblwiXHJcblx0XHRyZXF1aXJlZD1cIntmaWVsZC5tZXRhZGF0YS5yZXF1aXJlZH1cIlxyXG5cdFx0dGFiaW5kZXg9XCJ7dGFiaW5kZXh9XCJcclxuXHRcdGF1dG9jb21wbGV0ZT1cIm9mZlwiXHJcbiAgICAgICAgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIlxyXG4gICAgICAgIHN0ZXA9XCJ7bnVtYmVyQ29uZmlnLnN0ZXB9XCJcclxuICAgICAgICBtaW49XCJ7bnVtYmVyQ29uZmlnLm1pblZhbHVlfVwiXHJcbiAgICAgICAgbWF4PVwie251bWJlckNvbmZpZy5tYXhWYWx1ZX1cIj5cclxuXHJcbiAgICA8c3BhbiBjbGFzcz1cImlucHV0LWdyb3VwLWFkZG9uXCI+TWF4PC9zcGFuPlxyXG5cdDxpbnB1dCB0eXBlPVwibnVtYmVyXCJcclxuXHRcdGJpbmQ6dmFsdWU9XCJmaWVsZC52YWx1ZS5tYXhcIlxyXG5cdFx0cmVxdWlyZWQ9XCJ7ZmllbGQubWV0YWRhdGEucmVxdWlyZWR9XCJcclxuXHRcdHRhYmluZGV4PVwie3RhYmluZGV4fVwiXHJcblx0XHRhdXRvY29tcGxldGU9XCJvZmZcIlxyXG4gICAgICAgIGNsYXNzPVwiZm9ybS1jb250cm9sXCJcclxuICAgICAgICBzdGVwPVwie251bWJlckNvbmZpZy5zdGVwfVwiXHJcbiAgICAgICAgbWluPVwie251bWJlckNvbmZpZy5taW5WYWx1ZX1cIlxyXG4gICAgICAgIG1heD1cIntudW1iZXJDb25maWcubWF4VmFsdWV9XCI+XHJcbjwvZGl2PlxyXG57L2lmfVxyXG5cclxuPHNjcmlwdD5cclxuXHRleHBvcnQgZGVmYXVsdCB7XHJcblx0XHRvbmNyZWF0ZSgpIHtcclxuXHRcdFx0Y29uc3QgeyBmaWVsZCB9ID0gdGhpcy5nZXQoKTtcclxuXHJcblx0XHRcdGlmIChmaWVsZCA9PSBudWxsKSB7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRjb25zdCBudW1iZXJDb25maWcgPSAoZmllbGQubWV0YWRhdGEuY3VzdG9tUHJvcGVydGllcyB8fCB7fSkubnVtYmVyQ29uZmlnIHx8IHtcclxuXHRcdFx0XHRtaW5WYWx1ZTogbnVsbCxcclxuXHRcdFx0XHRtYXhWYWx1ZTogbnVsbCxcclxuXHRcdFx0XHRzdGVwOiAxXHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHR0aGlzLnNldCh7XHJcblx0XHRcdFx0bnVtYmVyQ29uZmlnXHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cdH07XHJcbjwvc2NyaXB0PlxyXG5cclxuPHN0eWxlPlxyXG5cdFx0LmlucHV0LWdyb3VwLWFkZG9uIHtcclxuXHRcdFx0Zm9udC1zaXplOiAwLjhyZW0gIWltcG9ydGFudDtcclxuXHRcdH1cclxuPC9zdHlsZT5cclxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQWlERSxrQkFBa0IsY0FBQyxDQUFDLEFBQ25CLFNBQVMsQ0FBRSxNQUFNLENBQUMsVUFBVSxBQUM3QixDQUFDIn0= */";
    	append(document.head, style);
    }

    function create_main_fragment$h(component, ctx) {
    	var if_block_anchor;

    	var if_block = (ctx.numberConfig != null) && create_if_block$c(component, ctx);

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (ctx.numberConfig != null) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block$c(component, ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (if_block) if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (1:0) {#if numberConfig != null}
    function create_if_block$c(component, ctx) {
    	var div, span0, text1, input0, input0_updating = false, input0_required_value, input0_step_value, input0_min_value, input0_max_value, text2, span1, text4, input1, input1_updating = false, input1_required_value, input1_step_value, input1_min_value, input1_max_value;

    	function input0_input_handler() {
    		input0_updating = true;
    		ctx.field.value.min = toNumber(input0.value);
    		component.set({ field: ctx.field });
    		input0_updating = false;
    	}

    	function input1_input_handler() {
    		input1_updating = true;
    		ctx.field.value.max = toNumber(input1.value);
    		component.set({ field: ctx.field });
    		input1_updating = false;
    	}

    	return {
    		c: function create() {
    			div = createElement("div");
    			span0 = createElement("span");
    			span0.textContent = "Min";
    			text1 = createText("\r\n\t");
    			input0 = createElement("input");
    			text2 = createText("\r\n\r\n    ");
    			span1 = createElement("span");
    			span1.textContent = "Max";
    			text4 = createText("\r\n\t");
    			input1 = createElement("input");
    			span0.className = "input-group-addon svelte-6lg6r4";
    			addLoc(span0, file$g, 2, 4, 59);
    			addListener(input0, "input", input0_input_handler);
    			setAttribute(input0, "type", "number");
    			input0.required = input0_required_value = ctx.field.metadata.required;
    			input0.tabIndex = ctx.tabindex;
    			input0.autocomplete = "off";
    			input0.className = "form-control";
    			input0.step = input0_step_value = ctx.numberConfig.step;
    			input0.min = input0_min_value = ctx.numberConfig.minValue;
    			input0.max = input0_max_value = ctx.numberConfig.maxValue;
    			addLoc(input0, file$g, 3, 1, 104);
    			span1.className = "input-group-addon svelte-6lg6r4";
    			addLoc(span1, file$g, 13, 4, 396);
    			addListener(input1, "input", input1_input_handler);
    			setAttribute(input1, "type", "number");
    			input1.required = input1_required_value = ctx.field.metadata.required;
    			input1.tabIndex = ctx.tabindex;
    			input1.autocomplete = "off";
    			input1.className = "form-control";
    			input1.step = input1_step_value = ctx.numberConfig.step;
    			input1.min = input1_min_value = ctx.numberConfig.minValue;
    			input1.max = input1_max_value = ctx.numberConfig.maxValue;
    			addLoc(input1, file$g, 14, 1, 441);
    			div.className = "input-group";
    			addLoc(div, file$g, 1, 0, 28);
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);
    			append(div, span0);
    			append(div, text1);
    			append(div, input0);

    			input0.value = ctx.field.value.min;

    			append(div, text2);
    			append(div, span1);
    			append(div, text4);
    			append(div, input1);

    			input1.value = ctx.field.value.max;
    		},

    		p: function update(changed, _ctx) {
    			ctx = _ctx;
    			if (!input0_updating && changed.field) input0.value = ctx.field.value.min;
    			if ((changed.field) && input0_required_value !== (input0_required_value = ctx.field.metadata.required)) {
    				input0.required = input0_required_value;
    			}

    			if (changed.tabindex) {
    				input0.tabIndex = ctx.tabindex;
    			}

    			if ((changed.numberConfig) && input0_step_value !== (input0_step_value = ctx.numberConfig.step)) {
    				input0.step = input0_step_value;
    			}

    			if ((changed.numberConfig) && input0_min_value !== (input0_min_value = ctx.numberConfig.minValue)) {
    				input0.min = input0_min_value;
    			}

    			if ((changed.numberConfig) && input0_max_value !== (input0_max_value = ctx.numberConfig.maxValue)) {
    				input0.max = input0_max_value;
    			}

    			if (!input1_updating && changed.field) input1.value = ctx.field.value.max;
    			if ((changed.field) && input1_required_value !== (input1_required_value = ctx.field.metadata.required)) {
    				input1.required = input1_required_value;
    			}

    			if (changed.tabindex) {
    				input1.tabIndex = ctx.tabindex;
    			}

    			if ((changed.numberConfig) && input1_step_value !== (input1_step_value = ctx.numberConfig.step)) {
    				input1.step = input1_step_value;
    			}

    			if ((changed.numberConfig) && input1_min_value !== (input1_min_value = ctx.numberConfig.minValue)) {
    				input1.min = input1_min_value;
    			}

    			if ((changed.numberConfig) && input1_max_value !== (input1_max_value = ctx.numberConfig.maxValue)) {
    				input1.max = input1_max_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(div);
    			}

    			removeListener(input0, "input", input0_input_handler);
    			removeListener(input1, "input", input1_input_handler);
    		}
    	};
    }

    function SvelteComponent$h(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) {
    		throw new Error("'target' is a required option");
    	}

    	init(this, options);
    	this._state = assign({}, options.data);
    	if (!('numberConfig' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'numberConfig'");
    	if (!('field' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'field'");
    	if (!('tabindex' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'tabindex'");
    	this._intro = true;

    	if (!document.getElementById("svelte-6lg6r4-style")) add_css$8();

    	this._fragment = create_main_fragment$h(this, this._state);

    	this.root._oncreate.push(() => {
    		oncreate$b.call(this);
    		this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
    	});

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);

    		flush(this);
    	}
    }

    assign(SvelteComponent$h.prototype, protoDev);

    SvelteComponent$h.prototype._checkReadOnly = function _checkReadOnly(newState) {
    };

    /* src\core\ui\inputs\ONumber.html generated by Svelte v2.16.1 */

    function oncreate$c() {
    	const { field } = this.get();
    	const numberConfig = field.metadata.getCustomProperty("numberConfig") ||
    		{
    			minValue: null,
    			maxValue: null,
    			step: 1
    		};

    	this.set({
    		numberConfig
    	});
    }
    const file$h = "src\\core\\ui\\inputs\\ONumber.html";

    function create_main_fragment$i(component, ctx) {
    	var if_block_anchor;

    	var if_block = (ctx.numberConfig != null) && create_if_block$d(component, ctx);

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (ctx.numberConfig != null) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block$d(component, ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (if_block) if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (1:0) {#if numberConfig != null}
    function create_if_block$d(component, ctx) {
    	var input, input_updating = false, input_required_value, input_step_value, input_min_value, input_max_value;

    	function input_input_handler() {
    		input_updating = true;
    		ctx.field.selected = toNumber(input.value);
    		component.set({ field: ctx.field });
    		input_updating = false;
    	}

    	return {
    		c: function create() {
    			input = createElement("input");
    			addListener(input, "input", input_input_handler);
    			setAttribute(input, "type", "number");
    			input.id = ctx.id;
    			input.required = input_required_value = ctx.field.metadata.required;
    			input.tabIndex = ctx.tabindex;
    			input.className = "form-control";
    			input.step = input_step_value = ctx.numberConfig.step;
    			input.min = input_min_value = ctx.numberConfig.minValue;
    			input.max = input_max_value = ctx.numberConfig.maxValue;
    			addLoc(input, file$h, 1, 0, 28);
    		},

    		m: function mount(target, anchor) {
    			insert(target, input, anchor);

    			input.value = ctx.field.selected;
    		},

    		p: function update(changed, _ctx) {
    			ctx = _ctx;
    			if (!input_updating && changed.field) input.value = ctx.field.selected;
    			if (changed.id) {
    				input.id = ctx.id;
    			}

    			if ((changed.field) && input_required_value !== (input_required_value = ctx.field.metadata.required)) {
    				input.required = input_required_value;
    			}

    			if (changed.tabindex) {
    				input.tabIndex = ctx.tabindex;
    			}

    			if ((changed.numberConfig) && input_step_value !== (input_step_value = ctx.numberConfig.step)) {
    				input.step = input_step_value;
    			}

    			if ((changed.numberConfig) && input_min_value !== (input_min_value = ctx.numberConfig.minValue)) {
    				input.min = input_min_value;
    			}

    			if ((changed.numberConfig) && input_max_value !== (input_max_value = ctx.numberConfig.maxValue)) {
    				input.max = input_max_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(input);
    			}

    			removeListener(input, "input", input_input_handler);
    		}
    	};
    }

    function SvelteComponent$i(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) {
    		throw new Error("'target' is a required option");
    	}

    	init(this, options);
    	this._state = assign({}, options.data);
    	if (!('numberConfig' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'numberConfig'");
    	if (!('id' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'id'");
    	if (!('field' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'field'");
    	if (!('tabindex' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'tabindex'");
    	this._intro = true;

    	this._fragment = create_main_fragment$i(this, this._state);

    	this.root._oncreate.push(() => {
    		oncreate$c.call(this);
    		this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
    	});

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);

    		flush(this);
    	}
    }

    assign(SvelteComponent$i.prototype, protoDev);

    SvelteComponent$i.prototype._checkReadOnly = function _checkReadOnly(newState) {
    };

    /* src\core\ui\inputs\Password.html generated by Svelte v2.16.1 */

    var methods$7 = {
    	onChange(confirmPassword) {
    		if (this.get().field.selected !== confirmPassword.value) {
    			confirmPassword
    				.setCustomValidity("Passwords do not match. Please make sure they are exactly the same.");
    		}
    		else {
    			confirmPassword.setCustomValidity("");
    		}
    	}
    };

    function oncreate$d() {
    	const { field } = this.get();
    	const config = (field.metadata.customProperties || {}).passwordInputConfig;

    	this.set({
    		passwordConfig: config || {
    			regex: null,
    			requireConfirmation: null
    		}
    	});
    }
    const file$i = "src\\core\\ui\\inputs\\Password.html";

    function add_css$9() {
    	var style = createElement("style");
    	style.id = 'svelte-1igx5hi-style';
    	style.textContent = "span.svelte-1igx5hi{color:#9a9a9a;font-size:13px;margin-bottom:5px;display:block}.confirmation-password.svelte-1igx5hi{padding-top:10px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUGFzc3dvcmQuaHRtbCIsInNvdXJjZXMiOlsiUGFzc3dvcmQuaHRtbCJdLCJzb3VyY2VzQ29udGVudCI6WyJ7I2lmIHBhc3N3b3JkQ29uZmlnICE9IG51bGx9XHJcbiAgICB7I2lmIHBhc3N3b3JkQ29uZmlnLnJlZ2V4fVxyXG4gICAgICAgIDxzcGFuPntwYXNzd29yZENvbmZpZy5yZWdleERlc2NyaXB0aW9ufTwvc3Bhbj5cclxuXHRcdDxpbnB1dCB0eXBlPVwicGFzc3dvcmRcIlxyXG5cdFx0XHRpZD1cIntpZH1cIlxyXG5cdFx0XHRiaW5kOnZhbHVlPVwiZmllbGQuc2VsZWN0ZWRcIlxyXG5cdFx0XHRwYXR0ZXJuPVwie3Bhc3N3b3JkQ29uZmlnLnJlZ2V4fVwiXHJcblx0XHRcdHJlcXVpcmVkPVwie2ZpZWxkLm1ldGFkYXRhLnJlcXVpcmVkfVwiXHJcblx0XHRcdHRhYmluZGV4PVwie3RhYmluZGV4fVwiXHJcblx0XHRcdGNsYXNzPVwiZm9ybS1jb250cm9sXCI+XHJcbiAgICB7OmVsc2V9XHJcblx0PGlucHV0IHR5cGU9XCJwYXNzd29yZFwiXHJcblx0XHRpZD1cIntpZH1cIlxyXG5cdFx0YmluZDp2YWx1ZT1cImZpZWxkLnNlbGVjdGVkXCJcclxuXHRcdHJlcXVpcmVkPVwie2ZpZWxkLm1ldGFkYXRhLnJlcXVpcmVkfVwiXHJcblx0XHR0YWJpbmRleD1cInt0YWJpbmRleH1cIlxyXG5cdFx0Y2xhc3M9XCJmb3JtLWNvbnRyb2xcIj5cclxuICAgIHsvaWZ9XHJcbiAgICB7I2lmIHBhc3N3b3JkQ29uZmlnLnJlcXVpcmVDb25maXJtYXRpb259XHJcbiAgICA8ZGl2IGNsYXNzPVwiY29uZmlybWF0aW9uLXBhc3N3b3JkXCI+XHJcblx0XHQ8aW5wdXQgcGxhY2Vob2xkZXI9XCJDb25maXJtIHBhc3N3b3JkXCJcclxuXHRcdFx0dHlwZT1cInBhc3N3b3JkXCJcclxuXHRcdFx0b246Y2hhbmdlPVwib25DaGFuZ2UodGhpcylcIlxyXG5cdFx0XHRyZXF1aXJlZD1cIntmaWVsZC5tZXRhZGF0YS5yZXF1aXJlZH1cIlxyXG5cdFx0XHR0YWJpbmRleD1cInt0YWJpbmRleCArIDF9XCJcclxuXHRcdFx0Y2xhc3M9XCJmb3JtLWNvbnRyb2xcIj5cclxuICAgIDwvZGl2PlxyXG4gICAgey9pZn1cclxuey9pZn1cclxuXHJcblxyXG48c2NyaXB0PlxyXG5cdGV4cG9ydCBkZWZhdWx0IHtcclxuXHRcdG9uY3JlYXRlKCkge1xyXG5cdFx0XHRjb25zdCB7IGZpZWxkIH0gPSB0aGlzLmdldCgpO1xyXG5cdFx0XHRjb25zdCBjb25maWcgPSAoZmllbGQubWV0YWRhdGEuY3VzdG9tUHJvcGVydGllcyB8fCB7fSkucGFzc3dvcmRJbnB1dENvbmZpZztcclxuXHJcblx0XHRcdHRoaXMuc2V0KHtcclxuXHRcdFx0XHRwYXNzd29yZENvbmZpZzogY29uZmlnIHx8IHtcclxuXHRcdFx0XHRcdHJlZ2V4OiBudWxsLFxyXG5cdFx0XHRcdFx0cmVxdWlyZUNvbmZpcm1hdGlvbjogbnVsbFxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblx0XHR9LFxyXG5cdFx0bWV0aG9kczoge1xyXG5cdFx0XHRvbkNoYW5nZShjb25maXJtUGFzc3dvcmQpIHtcclxuXHRcdFx0XHRpZiAodGhpcy5nZXQoKS5maWVsZC5zZWxlY3RlZCAhPT0gY29uZmlybVBhc3N3b3JkLnZhbHVlKSB7XHJcblx0XHRcdFx0XHRjb25maXJtUGFzc3dvcmRcclxuXHRcdFx0XHRcdFx0LnNldEN1c3RvbVZhbGlkaXR5KFwiUGFzc3dvcmRzIGRvIG5vdCBtYXRjaC4gUGxlYXNlIG1ha2Ugc3VyZSB0aGV5IGFyZSBleGFjdGx5IHRoZSBzYW1lLlwiKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHRjb25maXJtUGFzc3dvcmQuc2V0Q3VzdG9tVmFsaWRpdHkoXCJcIik7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fTtcclxuPC9zY3JpcHQ+XHJcblxyXG48c3R5bGU+XHJcblx0XHRzcGFuIHtcclxuXHRcdFx0Y29sb3I6ICM5YTlhOWE7XHJcblx0XHRcdGZvbnQtc2l6ZTogMTNweDtcclxuXHRcdFx0bWFyZ2luLWJvdHRvbTogNXB4O1xyXG5cdFx0XHRkaXNwbGF5OiBibG9jaztcclxuXHRcdH1cclxuXHJcblx0XHQuY29uZmlybWF0aW9uLXBhc3N3b3JkIHtcclxuXHRcdFx0cGFkZGluZy10b3A6IDEwcHg7XHJcblx0XHR9XHJcbjwvc3R5bGU+XHJcbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUEyREUsSUFBSSxlQUFDLENBQUMsQUFDTCxLQUFLLENBQUUsT0FBTyxDQUNkLFNBQVMsQ0FBRSxJQUFJLENBQ2YsYUFBYSxDQUFFLEdBQUcsQ0FDbEIsT0FBTyxDQUFFLEtBQUssQUFDZixDQUFDLEFBRUQsc0JBQXNCLGVBQUMsQ0FBQyxBQUN2QixXQUFXLENBQUUsSUFBSSxBQUNsQixDQUFDIn0= */";
    	append(document.head, style);
    }

    function create_main_fragment$j(component, ctx) {
    	var if_block_anchor;

    	var if_block = (ctx.passwordConfig != null) && create_if_block$e(component, ctx);

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (ctx.passwordConfig != null) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block$e(component, ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (if_block) if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (1:0) {#if passwordConfig != null}
    function create_if_block$e(component, ctx) {
    	var text, if_block1_anchor;

    	function select_block_type(ctx) {
    		if (ctx.passwordConfig.regex) return create_if_block_2$4;
    		return create_else_block$6;
    	}

    	var current_block_type = select_block_type(ctx);
    	var if_block0 = current_block_type(component, ctx);

    	var if_block1 = (ctx.passwordConfig.requireConfirmation) && create_if_block_1$7(component, ctx);

    	return {
    		c: function create() {
    			if_block0.c();
    			text = createText("\r\n    ");
    			if (if_block1) if_block1.c();
    			if_block1_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if_block0.m(target, anchor);
    			insert(target, text, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert(target, if_block1_anchor, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
    				if_block0.p(changed, ctx);
    			} else {
    				if_block0.d(1);
    				if_block0 = current_block_type(component, ctx);
    				if_block0.c();
    				if_block0.m(text.parentNode, text);
    			}

    			if (ctx.passwordConfig.requireConfirmation) {
    				if (if_block1) {
    					if_block1.p(changed, ctx);
    				} else {
    					if_block1 = create_if_block_1$7(component, ctx);
    					if_block1.c();
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if_block0.d(detach);
    			if (detach) {
    				detachNode(text);
    			}

    			if (if_block1) if_block1.d(detach);
    			if (detach) {
    				detachNode(if_block1_anchor);
    			}
    		}
    	};
    }

    // (11:4) {:else}
    function create_else_block$6(component, ctx) {
    	var input, input_updating = false, input_required_value;

    	function input_input_handler() {
    		input_updating = true;
    		ctx.field.selected = input.value;
    		component.set({ field: ctx.field });
    		input_updating = false;
    	}

    	return {
    		c: function create() {
    			input = createElement("input");
    			addListener(input, "input", input_input_handler);
    			setAttribute(input, "type", "password");
    			input.id = ctx.id;
    			input.required = input_required_value = ctx.field.metadata.required;
    			input.tabIndex = ctx.tabindex;
    			input.className = "form-control";
    			addLoc(input, file$i, 11, 1, 334);
    		},

    		m: function mount(target, anchor) {
    			insert(target, input, anchor);

    			input.value = ctx.field.selected;
    		},

    		p: function update(changed, _ctx) {
    			ctx = _ctx;
    			if (!input_updating && changed.field) input.value = ctx.field.selected;
    			if (changed.id) {
    				input.id = ctx.id;
    			}

    			if ((changed.field) && input_required_value !== (input_required_value = ctx.field.metadata.required)) {
    				input.required = input_required_value;
    			}

    			if (changed.tabindex) {
    				input.tabIndex = ctx.tabindex;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(input);
    			}

    			removeListener(input, "input", input_input_handler);
    		}
    	};
    }

    // (2:4) {#if passwordConfig.regex}
    function create_if_block_2$4(component, ctx) {
    	var span, text0_value = ctx.passwordConfig.regexDescription, text0, text1, input, input_updating = false, input_pattern_value, input_required_value;

    	function input_input_handler() {
    		input_updating = true;
    		ctx.field.selected = input.value;
    		component.set({ field: ctx.field });
    		input_updating = false;
    	}

    	return {
    		c: function create() {
    			span = createElement("span");
    			text0 = createText(text0_value);
    			text1 = createText("\r\n\t\t");
    			input = createElement("input");
    			span.className = "svelte-1igx5hi";
    			addLoc(span, file$i, 2, 8, 70);
    			addListener(input, "input", input_input_handler);
    			setAttribute(input, "type", "password");
    			input.id = ctx.id;
    			input.pattern = input_pattern_value = ctx.passwordConfig.regex;
    			input.required = input_required_value = ctx.field.metadata.required;
    			input.tabIndex = ctx.tabindex;
    			input.className = "form-control";
    			addLoc(input, file$i, 3, 2, 120);
    		},

    		m: function mount(target, anchor) {
    			insert(target, span, anchor);
    			append(span, text0);
    			insert(target, text1, anchor);
    			insert(target, input, anchor);

    			input.value = ctx.field.selected;
    		},

    		p: function update(changed, _ctx) {
    			ctx = _ctx;
    			if ((changed.passwordConfig) && text0_value !== (text0_value = ctx.passwordConfig.regexDescription)) {
    				setData(text0, text0_value);
    			}

    			if (!input_updating && changed.field) input.value = ctx.field.selected;
    			if (changed.id) {
    				input.id = ctx.id;
    			}

    			if ((changed.passwordConfig) && input_pattern_value !== (input_pattern_value = ctx.passwordConfig.regex)) {
    				input.pattern = input_pattern_value;
    			}

    			if ((changed.field) && input_required_value !== (input_required_value = ctx.field.metadata.required)) {
    				input.required = input_required_value;
    			}

    			if (changed.tabindex) {
    				input.tabIndex = ctx.tabindex;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(span);
    				detachNode(text1);
    				detachNode(input);
    			}

    			removeListener(input, "input", input_input_handler);
    		}
    	};
    }

    // (19:4) {#if passwordConfig.requireConfirmation}
    function create_if_block_1$7(component, ctx) {
    	var div, input, input_required_value, input_tabindex_value;

    	function change_handler(event) {
    		component.onChange(this);
    	}

    	return {
    		c: function create() {
    			div = createElement("div");
    			input = createElement("input");
    			addListener(input, "change", change_handler);
    			input.placeholder = "Confirm password";
    			setAttribute(input, "type", "password");
    			input.required = input_required_value = ctx.field.metadata.required;
    			input.tabIndex = input_tabindex_value = ctx.tabindex + 1;
    			input.className = "form-control";
    			addLoc(input, file$i, 20, 2, 592);
    			div.className = "confirmation-password svelte-1igx5hi";
    			addLoc(div, file$i, 19, 4, 553);
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);
    			append(div, input);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.field) && input_required_value !== (input_required_value = ctx.field.metadata.required)) {
    				input.required = input_required_value;
    			}

    			if ((changed.tabindex) && input_tabindex_value !== (input_tabindex_value = ctx.tabindex + 1)) {
    				input.tabIndex = input_tabindex_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(div);
    			}

    			removeListener(input, "change", change_handler);
    		}
    	};
    }

    function SvelteComponent$j(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) {
    		throw new Error("'target' is a required option");
    	}

    	init(this, options);
    	this._state = assign({}, options.data);
    	if (!('passwordConfig' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'passwordConfig'");
    	if (!('id' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'id'");
    	if (!('field' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'field'");
    	if (!('tabindex' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'tabindex'");
    	this._intro = true;

    	if (!document.getElementById("svelte-1igx5hi-style")) add_css$9();

    	this._fragment = create_main_fragment$j(this, this._state);

    	this.root._oncreate.push(() => {
    		oncreate$d.call(this);
    		this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
    	});

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);

    		flush(this);
    	}
    }

    assign(SvelteComponent$j.prototype, protoDev);
    assign(SvelteComponent$j.prototype, methods$7);

    SvelteComponent$j.prototype._checkReadOnly = function _checkReadOnly(newState) {
    };

    /* src\core\ui\inputs\ReceiptList.html generated by Svelte v2.16.1 */

    function mapToTypeaheadItems$2(items) {
    	return items.map(t => ({
    		label: t.label,
    		value: t.value.toString()
    	}));
    }
    function calculateFieldValue$1(field, value) {
    	if (field.maxItemCount === 1) {
    		let result = field.value;
    		result = {
    			value: value[0] != null ? value[0].value : null
    		};
    		// We need to convert the value to string, otherwise it doesn't work.
    		// This is due to the way UmfApp deals with url parameters (or something
    		// along those lines).
    		if (result.value != null) {
    			result.value = result.value.toString();
    		}
    		return result;
    	}
    	return {
    		items: value.map(t => t.value)
    	};
    }
    function setInputValue$1(a, field) {
    	if (field.maxItemCount === 1) {
    		const v = (field.value || {}).value || null;
    		if (v != null) {
    			a.setValueByChoice(v.toString());
    		}
    	}
    	else {
    		const v = ((field.value || {}).items || []).map(t => t.toString());
    		a.setValueByChoice(v);
    	}
    }
    function getIdsQuery$1(field) {
    	let currentValue = field.maxItemCount === 1 ?
    		[(field.value || {}).value || ""] :
    		(field.value || {}).items || [];
    	// Put values into an array.
    	if (currentValue[0] === "") {
    		currentValue = [];
    	}
    	return currentValue;
    }
    function buildFilter$2(parentForm, parameters, query) {
    	let promise;
    	const filter = { query };
    	if (parameters != null && parameters.length > 0) {
    		promise = parentForm.get().form.getSerializedInputValues().then(data => {
    			for (const p of parameters) {
    				filter[p] = data[p];
    			}
    			return filter;
    		});
    	}
    	else {
    		promise = Promise.resolve(filter);
    	}
    	return promise;
    }
    function populateChoicesWithAjax$1(choicesComponent, multiSelectComponent, existingChoices, query, selectedItemIds) {
    	const componentData = multiSelectComponent.get();
    	const { parameters, source } = componentData.field.metadata.customProperties;
    	const parentForm = componentData.form;
    	const { app } = componentData;
    	return new Promise(resolve => {
    		choicesComponent.ajax(callback => buildFilter$2(parentForm, parameters, query).then(filter => {
    			if (selectedItemIds != null) {
    				// eslint-disable-next-line no-param-reassign
    				filter.ids = { items: selectedItemIds };
    			}
    			return app.server.postForm(source, filter).then(data => {
    				// Mark items as added as "choices".
    				const toAdd = data.items.filter(t => {
    					const key = JSON.stringify(t.value);
    					if (existingChoices[key] == null) {
    						// eslint-disable-next-line no-param-reassign
    						existingChoices[key] = true;
    						// Add item.
    						return true;
    					}
    					// Don't add item.
    					return false;
    				});
    				callback(mapToTypeaheadItems$2(toAdd), "value", "label");
    				resolve();
    			});
    		}));
    	});
    }

    var methods$8 = {
    	onChange() {
    		this.get().form.fireAndBubbleUp("input:changed", {
    			app: this.get().app,
    			form: this.get().form,
    			input: this
    		});
    	}
    };

    function oncreate$e() {
    	const { field } = this.get();

    	// eslint-disable-next-line no-console
    	console.log(field);
    	// const numberConfig = field.metadata.getCustomProperty("numberConfig") ||
    	// 	{
    	// 		minValue: null,
    	// 		maxValue: null,
    	// 		step: 1
    	// 	};

    	// this.set({
    	// 	numberConfig
    	// });

    	const { source } = field.metadata.customProperties.receiptListConfig;
    	const a = new Choices(this.refs.input, {
    		duplicateItems: true,
    		searchResultLimit: 10,
    		removeItemButton: true,
    		maxItemCount: field.maxItemCount,
    		noChoicesText: "اكتب اسم مستخدم التطبيق للبحث",
    		noResultsText: "لا يوجد نتائج",
    		itemSelectText: "اضغط للإختيار",
    		loadingText: "جاري التحميل ..."
    	});
    	const formElement = this.refs.input.closest("form");
    	const self = this;
    	formElement.addEventListener("submit", () => {
    		if (typeof field.value.value === "undefined" && field.metadata.required) {
    			self.refs.input.parentElement.classList.add("divError");
    		}
    	});
    	if (typeof (source) === "string") {
    		const addedItems = {};
    		let query = "";
    		let timer = null;
    		a.passedElement.addEventListener("search", value => {
    			query = value.detail.value;
    			if (timer != null) {
    				// Cancel previous timer, thus extending the delay until user has stopped typing.
    				clearTimeout(timer);
    			}
    			// Search when user types something, but introduce a short delay
    			// to avoid excessive http requests.
    			timer = setTimeout(() => {
    				populateChoicesWithAjax$1(a, self, addedItems, query);
    			}, 300);
    		});
    		const currentValue = getIdsQuery$1(field);
    		populateChoicesWithAjax$1(a, self, addedItems, "");
    		// If the field has a value, we need to load it.
    		if (currentValue.length > 0) {
    			populateChoicesWithAjax$1(a, self, addedItems, query, currentValue)
    				.then(() => setInputValue$1(a, field));
    		}
    	}
    	else {
    		a.setChoices(mapToTypeaheadItems$2(source), "value", "label", true);
    		this.set({ inlineChoices: a });
    	}
    	a.passedElement.addEventListener("change", () => {
    		field.value = calculateFieldValue$1(field, a.getValue());
    	});
    }
    function onstate$2({ changed, current, previous }) {
    	if (changed.inlineChoices) {
    		if (!current.initialized && current.inlineChoices != null) {
    			// eslint-disable-next-line no-param-reassign
    			current.initialized = true;
    			setInputValue$1(current.inlineChoices, current.field);
    		}
    	}
    }
    const file$j = "src\\core\\ui\\inputs\\ReceiptList.html";

    function create_main_fragment$k(component, ctx) {
    	var table, tbody, tr, td0, select, text0, td1, text1, td2;

    	function change_handler(event) {
    		component.onChange();
    	}

    	return {
    		c: function create() {
    			table = createElement("table");
    			tbody = createElement("tbody");
    			tr = createElement("tr");
    			td0 = createElement("td");
    			select = createElement("select");
    			text0 = createText("\r\n\t\t\t");
    			td1 = createElement("td");
    			text1 = createText("\r\n\t\t\t");
    			td2 = createElement("td");
    			addListener(select, "change", change_handler);
    			select.dir = "rtl";
    			select.className = "multi-select form-control";
    			select.tabIndex = ctx.tabindex;
    			addLoc(select, file$j, 5, 4, 96);
    			addLoc(td0, file$j, 3, 3, 30);
    			addLoc(td1, file$j, 7, 3, 227);
    			addLoc(td2, file$j, 8, 3, 241);
    			addLoc(tr, file$j, 2, 2, 21);
    			addLoc(tbody, file$j, 1, 1, 10);
    			addLoc(table, file$j, 0, 0, 0);
    		},

    		m: function mount(target, anchor) {
    			insert(target, table, anchor);
    			append(table, tbody);
    			append(tbody, tr);
    			append(tr, td0);
    			append(td0, select);
    			component.refs.input = select;
    			append(tr, text0);
    			append(tr, td1);
    			append(tr, text1);
    			append(tr, td2);
    		},

    		p: function update(changed, ctx) {
    			if (changed.tabindex) {
    				select.tabIndex = ctx.tabindex;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(table);
    			}

    			removeListener(select, "change", change_handler);
    			if (component.refs.input === select) component.refs.input = null;
    		}
    	};
    }

    function SvelteComponent$k(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) {
    		throw new Error("'target' is a required option");
    	}

    	init(this, options);
    	this.refs = {};
    	this._state = assign({}, options.data);
    	if (!('tabindex' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'tabindex'");
    	this._intro = true;

    	this._handlers.state = [onstate$2];

    	onstate$2.call(this, { changed: assignTrue({}, this._state), current: this._state });

    	this._fragment = create_main_fragment$k(this, this._state);

    	this.root._oncreate.push(() => {
    		oncreate$e.call(this);
    		this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
    	});

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);

    		flush(this);
    	}
    }

    assign(SvelteComponent$k.prototype, protoDev);
    assign(SvelteComponent$k.prototype, methods$8);

    SvelteComponent$k.prototype._checkReadOnly = function _checkReadOnly(newState) {
    };

    /* src\core\ui\inputs\Text.html generated by Svelte v2.16.1 */

    function data$8() {
    	return {
    		config: {
    			disabled: false
    		}
    	};
    }
    function oncreate$f() {
    	const { field } = this.get();
    	const config = field.metadata.customProperties || {};
    	this.set({
    		config: config || {
    			disabled: false
    		}
    	});
    }
    const file$k = "src\\core\\ui\\inputs\\Text.html";

    function create_main_fragment$l(component, ctx) {
    	var input, input_updating = false, input_required_value, input_disabled_value;

    	function input_input_handler() {
    		input_updating = true;
    		ctx.field.value = input.value;
    		component.set({ field: ctx.field });
    		input_updating = false;
    	}

    	return {
    		c: function create() {
    			input = createElement("input");
    			addListener(input, "input", input_input_handler);
    			setAttribute(input, "type", "text");
    			input.id = ctx.id;
    			input.required = input_required_value = ctx.field.metadata.required;
    			input.disabled = input_disabled_value = ctx.config.disabled;
    			input.tabIndex = ctx.tabindex;
    			input.className = "form-control";
    			addLoc(input, file$k, 0, 0, 0);
    		},

    		m: function mount(target, anchor) {
    			insert(target, input, anchor);

    			input.value = ctx.field.value;
    		},

    		p: function update(changed, _ctx) {
    			ctx = _ctx;
    			if (!input_updating && changed.field) input.value = ctx.field.value;
    			if (changed.id) {
    				input.id = ctx.id;
    			}

    			if ((changed.field) && input_required_value !== (input_required_value = ctx.field.metadata.required)) {
    				input.required = input_required_value;
    			}

    			if ((changed.config) && input_disabled_value !== (input_disabled_value = ctx.config.disabled)) {
    				input.disabled = input_disabled_value;
    			}

    			if (changed.tabindex) {
    				input.tabIndex = ctx.tabindex;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(input);
    			}

    			removeListener(input, "input", input_input_handler);
    		}
    	};
    }

    function SvelteComponent$l(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) {
    		throw new Error("'target' is a required option");
    	}

    	init(this, options);
    	this._state = assign(data$8(), options.data);
    	if (!('id' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'id'");
    	if (!('field' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'field'");
    	if (!('config' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'config'");
    	if (!('tabindex' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'tabindex'");
    	this._intro = true;

    	this._fragment = create_main_fragment$l(this, this._state);

    	this.root._oncreate.push(() => {
    		oncreate$f.call(this);
    		this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
    	});

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);

    		flush(this);
    	}
    }

    assign(SvelteComponent$l.prototype, protoDev);

    SvelteComponent$l.prototype._checkReadOnly = function _checkReadOnly(newState) {
    };

    /* src\core\ui\inputs\Textarea.html generated by Svelte v2.16.1 */

    const file$l = "src\\core\\ui\\inputs\\Textarea.html";

    function add_css$a() {
    	var style = createElement("style");
    	style.id = 'svelte-wch87u-style';
    	style.textContent = "textarea.svelte-wch87u{width:100%;height:100px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGV4dGFyZWEuaHRtbCIsInNvdXJjZXMiOlsiVGV4dGFyZWEuaHRtbCJdLCJzb3VyY2VzQ29udGVudCI6WyI8dGV4dGFyZWFcclxuXHRpZD1cIntpZH1cIlxyXG5cdGJpbmQ6dmFsdWU9XCJmaWVsZC5zZWxlY3RlZFwiXHJcblx0cmVxdWlyZWQ9XCJ7ZmllbGQubWV0YWRhdGEucmVxdWlyZWR9XCJcclxuXHR0YWJpbmRleD1cInt0YWJpbmRleH1cIlxyXG5cdGNsYXNzPVwiZm9ybS1jb250cm9sXCIgLz5cclxuXHJcbjxzdHlsZT5cclxuXHR0ZXh0YXJlYSB7XHJcblx0XHR3aWR0aDogMTAwJTtcclxuXHRcdGhlaWdodDogMTAwcHg7XHJcblx0fVxyXG48L3N0eWxlPlxyXG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBUUMsUUFBUSxjQUFDLENBQUMsQUFDVCxLQUFLLENBQUUsSUFBSSxDQUNYLE1BQU0sQ0FBRSxLQUFLLEFBQ2QsQ0FBQyJ9 */";
    	append(document.head, style);
    }

    function create_main_fragment$m(component, ctx) {
    	var textarea, textarea_updating = false, textarea_required_value;

    	function textarea_input_handler() {
    		textarea_updating = true;
    		ctx.field.selected = textarea.value;
    		component.set({ field: ctx.field });
    		textarea_updating = false;
    	}

    	return {
    		c: function create() {
    			textarea = createElement("textarea");
    			addListener(textarea, "input", textarea_input_handler);
    			textarea.id = ctx.id;
    			textarea.required = textarea_required_value = ctx.field.metadata.required;
    			textarea.tabIndex = ctx.tabindex;
    			textarea.className = "form-control svelte-wch87u";
    			addLoc(textarea, file$l, 0, 0, 0);
    		},

    		m: function mount(target, anchor) {
    			insert(target, textarea, anchor);

    			textarea.value = ctx.field.selected;
    		},

    		p: function update(changed, _ctx) {
    			ctx = _ctx;
    			if (!textarea_updating && changed.field) textarea.value = ctx.field.selected;
    			if (changed.id) {
    				textarea.id = ctx.id;
    			}

    			if ((changed.field) && textarea_required_value !== (textarea_required_value = ctx.field.metadata.required)) {
    				textarea.required = textarea_required_value;
    			}

    			if (changed.tabindex) {
    				textarea.tabIndex = ctx.tabindex;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(textarea);
    			}

    			removeListener(textarea, "input", textarea_input_handler);
    		}
    	};
    }

    function SvelteComponent$m(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) {
    		throw new Error("'target' is a required option");
    	}

    	init(this, options);
    	this._state = assign({}, options.data);
    	if (!('id' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'id'");
    	if (!('field' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'field'");
    	if (!('tabindex' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'tabindex'");
    	this._intro = true;

    	if (!document.getElementById("svelte-wch87u-style")) add_css$a();

    	this._fragment = create_main_fragment$m(this, this._state);

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);
    	}
    }

    assign(SvelteComponent$m.prototype, protoDev);

    SvelteComponent$m.prototype._checkReadOnly = function _checkReadOnly(newState) {
    };

    function ascending(a, b) {
      return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
    }

    function bisector(compare) {
      if (compare.length === 1) compare = ascendingComparator(compare);
      return {
        left: function(a, x, lo, hi) {
          if (lo == null) lo = 0;
          if (hi == null) hi = a.length;
          while (lo < hi) {
            var mid = lo + hi >>> 1;
            if (compare(a[mid], x) < 0) lo = mid + 1;
            else hi = mid;
          }
          return lo;
        },
        right: function(a, x, lo, hi) {
          if (lo == null) lo = 0;
          if (hi == null) hi = a.length;
          while (lo < hi) {
            var mid = lo + hi >>> 1;
            if (compare(a[mid], x) > 0) hi = mid;
            else lo = mid + 1;
          }
          return lo;
        }
      };
    }

    function ascendingComparator(f) {
      return function(d, x) {
        return ascending(f(d), x);
      };
    }

    var ascendingBisect = bisector(ascending);

    function sum(values, valueof) {
      var n = values.length,
          i = -1,
          value,
          sum = 0;

      if (valueof == null) {
        while (++i < n) {
          if (value = +values[i]) sum += value; // Note: zero and null are equivalent.
        }
      }

      else {
        while (++i < n) {
          if (value = +valueof(values[i], i, values)) sum += value;
        }
      }

      return sum;
    }

    var noop$2 = {value: function() {}};

    function dispatch() {
      for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
        if (!(t = arguments[i] + "") || (t in _) || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
        _[t] = [];
      }
      return new Dispatch(_);
    }

    function Dispatch(_) {
      this._ = _;
    }

    function parseTypenames(typenames, types) {
      return typenames.trim().split(/^|\s+/).map(function(t) {
        var name = "", i = t.indexOf(".");
        if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
        if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
        return {type: t, name: name};
      });
    }

    Dispatch.prototype = dispatch.prototype = {
      constructor: Dispatch,
      on: function(typename, callback) {
        var _ = this._,
            T = parseTypenames(typename + "", _),
            t,
            i = -1,
            n = T.length;

        // If no callback was specified, return the callback of the given type and name.
        if (arguments.length < 2) {
          while (++i < n) if ((t = (typename = T[i]).type) && (t = get$3(_[t], typename.name))) return t;
          return;
        }

        // If a type was specified, set the callback for the given type and name.
        // Otherwise, if a null callback was specified, remove callbacks of the given name.
        if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
        while (++i < n) {
          if (t = (typename = T[i]).type) _[t] = set$2(_[t], typename.name, callback);
          else if (callback == null) for (t in _) _[t] = set$2(_[t], typename.name, null);
        }

        return this;
      },
      copy: function() {
        var copy = {}, _ = this._;
        for (var t in _) copy[t] = _[t].slice();
        return new Dispatch(copy);
      },
      call: function(type, that) {
        if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
        if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
        for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
      },
      apply: function(type, that, args) {
        if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
        for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
      }
    };

    function get$3(type, name) {
      for (var i = 0, n = type.length, c; i < n; ++i) {
        if ((c = type[i]).name === name) {
          return c.value;
        }
      }
    }

    function set$2(type, name, callback) {
      for (var i = 0, n = type.length; i < n; ++i) {
        if (type[i].name === name) {
          type[i] = noop$2, type = type.slice(0, i).concat(type.slice(i + 1));
          break;
        }
      }
      if (callback != null) type.push({name: name, value: callback});
      return type;
    }

    var xhtml = "http://www.w3.org/1999/xhtml";

    var namespaces = {
      svg: "http://www.w3.org/2000/svg",
      xhtml: xhtml,
      xlink: "http://www.w3.org/1999/xlink",
      xml: "http://www.w3.org/XML/1998/namespace",
      xmlns: "http://www.w3.org/2000/xmlns/"
    };

    function namespace(name) {
      var prefix = name += "", i = prefix.indexOf(":");
      if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
      return namespaces.hasOwnProperty(prefix) ? {space: namespaces[prefix], local: name} : name;
    }

    function creatorInherit(name) {
      return function() {
        var document = this.ownerDocument,
            uri = this.namespaceURI;
        return uri === xhtml && document.documentElement.namespaceURI === xhtml
            ? document.createElement(name)
            : document.createElementNS(uri, name);
      };
    }

    function creatorFixed(fullname) {
      return function() {
        return this.ownerDocument.createElementNS(fullname.space, fullname.local);
      };
    }

    function creator(name) {
      var fullname = namespace(name);
      return (fullname.local
          ? creatorFixed
          : creatorInherit)(fullname);
    }

    function none() {}

    function selector(selector) {
      return selector == null ? none : function() {
        return this.querySelector(selector);
      };
    }

    function selection_select(select) {
      if (typeof select !== "function") select = selector(select);

      for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
          if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
            if ("__data__" in node) subnode.__data__ = node.__data__;
            subgroup[i] = subnode;
          }
        }
      }

      return new Selection(subgroups, this._parents);
    }

    function empty() {
      return [];
    }

    function selectorAll(selector) {
      return selector == null ? empty : function() {
        return this.querySelectorAll(selector);
      };
    }

    function selection_selectAll(select) {
      if (typeof select !== "function") select = selectorAll(select);

      for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            subgroups.push(select.call(node, node.__data__, i, group));
            parents.push(node);
          }
        }
      }

      return new Selection(subgroups, parents);
    }

    function matcher(selector) {
      return function() {
        return this.matches(selector);
      };
    }

    function selection_filter(match) {
      if (typeof match !== "function") match = matcher(match);

      for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
          if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
            subgroup.push(node);
          }
        }
      }

      return new Selection(subgroups, this._parents);
    }

    function sparse(update) {
      return new Array(update.length);
    }

    function selection_enter() {
      return new Selection(this._enter || this._groups.map(sparse), this._parents);
    }

    function EnterNode(parent, datum) {
      this.ownerDocument = parent.ownerDocument;
      this.namespaceURI = parent.namespaceURI;
      this._next = null;
      this._parent = parent;
      this.__data__ = datum;
    }

    EnterNode.prototype = {
      constructor: EnterNode,
      appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
      insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
      querySelector: function(selector) { return this._parent.querySelector(selector); },
      querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
    };

    function constant$1(x) {
      return function() {
        return x;
      };
    }

    var keyPrefix = "$"; // Protect against keys like “__proto__”.

    function bindIndex(parent, group, enter, update, exit, data) {
      var i = 0,
          node,
          groupLength = group.length,
          dataLength = data.length;

      // Put any non-null nodes that fit into update.
      // Put any null nodes into enter.
      // Put any remaining data into enter.
      for (; i < dataLength; ++i) {
        if (node = group[i]) {
          node.__data__ = data[i];
          update[i] = node;
        } else {
          enter[i] = new EnterNode(parent, data[i]);
        }
      }

      // Put any non-null nodes that don’t fit into exit.
      for (; i < groupLength; ++i) {
        if (node = group[i]) {
          exit[i] = node;
        }
      }
    }

    function bindKey(parent, group, enter, update, exit, data, key) {
      var i,
          node,
          nodeByKeyValue = {},
          groupLength = group.length,
          dataLength = data.length,
          keyValues = new Array(groupLength),
          keyValue;

      // Compute the key for each node.
      // If multiple nodes have the same key, the duplicates are added to exit.
      for (i = 0; i < groupLength; ++i) {
        if (node = group[i]) {
          keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);
          if (keyValue in nodeByKeyValue) {
            exit[i] = node;
          } else {
            nodeByKeyValue[keyValue] = node;
          }
        }
      }

      // Compute the key for each datum.
      // If there a node associated with this key, join and add it to update.
      // If there is not (or the key is a duplicate), add it to enter.
      for (i = 0; i < dataLength; ++i) {
        keyValue = keyPrefix + key.call(parent, data[i], i, data);
        if (node = nodeByKeyValue[keyValue]) {
          update[i] = node;
          node.__data__ = data[i];
          nodeByKeyValue[keyValue] = null;
        } else {
          enter[i] = new EnterNode(parent, data[i]);
        }
      }

      // Add any remaining nodes that were not bound to data to exit.
      for (i = 0; i < groupLength; ++i) {
        if ((node = group[i]) && (nodeByKeyValue[keyValues[i]] === node)) {
          exit[i] = node;
        }
      }
    }

    function selection_data(value, key) {
      if (!value) {
        data = new Array(this.size()), j = -1;
        this.each(function(d) { data[++j] = d; });
        return data;
      }

      var bind = key ? bindKey : bindIndex,
          parents = this._parents,
          groups = this._groups;

      if (typeof value !== "function") value = constant$1(value);

      for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
        var parent = parents[j],
            group = groups[j],
            groupLength = group.length,
            data = value.call(parent, parent && parent.__data__, j, parents),
            dataLength = data.length,
            enterGroup = enter[j] = new Array(dataLength),
            updateGroup = update[j] = new Array(dataLength),
            exitGroup = exit[j] = new Array(groupLength);

        bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

        // Now connect the enter nodes to their following update node, such that
        // appendChild can insert the materialized enter node before this node,
        // rather than at the end of the parent node.
        for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
          if (previous = enterGroup[i0]) {
            if (i0 >= i1) i1 = i0 + 1;
            while (!(next = updateGroup[i1]) && ++i1 < dataLength);
            previous._next = next || null;
          }
        }
      }

      update = new Selection(update, parents);
      update._enter = enter;
      update._exit = exit;
      return update;
    }

    function selection_exit() {
      return new Selection(this._exit || this._groups.map(sparse), this._parents);
    }

    function selection_join(onenter, onupdate, onexit) {
      var enter = this.enter(), update = this, exit = this.exit();
      enter = typeof onenter === "function" ? onenter(enter) : enter.append(onenter + "");
      if (onupdate != null) update = onupdate(update);
      if (onexit == null) exit.remove(); else onexit(exit);
      return enter && update ? enter.merge(update).order() : update;
    }

    function selection_merge(selection$$1) {

      for (var groups0 = this._groups, groups1 = selection$$1._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
        for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
          if (node = group0[i] || group1[i]) {
            merge[i] = node;
          }
        }
      }

      for (; j < m0; ++j) {
        merges[j] = groups0[j];
      }

      return new Selection(merges, this._parents);
    }

    function selection_order() {

      for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
        for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
          if (node = group[i]) {
            if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
            next = node;
          }
        }
      }

      return this;
    }

    function selection_sort(compare) {
      if (!compare) compare = ascending$1;

      function compareNode(a, b) {
        return a && b ? compare(a.__data__, b.__data__) : !a - !b;
      }

      for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            sortgroup[i] = node;
          }
        }
        sortgroup.sort(compareNode);
      }

      return new Selection(sortgroups, this._parents).order();
    }

    function ascending$1(a, b) {
      return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
    }

    function selection_call() {
      var callback = arguments[0];
      arguments[0] = this;
      callback.apply(null, arguments);
      return this;
    }

    function selection_nodes() {
      var nodes = new Array(this.size()), i = -1;
      this.each(function() { nodes[++i] = this; });
      return nodes;
    }

    function selection_node() {

      for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
        for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
          var node = group[i];
          if (node) return node;
        }
      }

      return null;
    }

    function selection_size() {
      var size = 0;
      this.each(function() { ++size; });
      return size;
    }

    function selection_empty() {
      return !this.node();
    }

    function selection_each(callback) {

      for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
        for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
          if (node = group[i]) callback.call(node, node.__data__, i, group);
        }
      }

      return this;
    }

    function attrRemove(name) {
      return function() {
        this.removeAttribute(name);
      };
    }

    function attrRemoveNS(fullname) {
      return function() {
        this.removeAttributeNS(fullname.space, fullname.local);
      };
    }

    function attrConstant(name, value) {
      return function() {
        this.setAttribute(name, value);
      };
    }

    function attrConstantNS(fullname, value) {
      return function() {
        this.setAttributeNS(fullname.space, fullname.local, value);
      };
    }

    function attrFunction(name, value) {
      return function() {
        var v = value.apply(this, arguments);
        if (v == null) this.removeAttribute(name);
        else this.setAttribute(name, v);
      };
    }

    function attrFunctionNS(fullname, value) {
      return function() {
        var v = value.apply(this, arguments);
        if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
        else this.setAttributeNS(fullname.space, fullname.local, v);
      };
    }

    function selection_attr(name, value) {
      var fullname = namespace(name);

      if (arguments.length < 2) {
        var node = this.node();
        return fullname.local
            ? node.getAttributeNS(fullname.space, fullname.local)
            : node.getAttribute(fullname);
      }

      return this.each((value == null
          ? (fullname.local ? attrRemoveNS : attrRemove) : (typeof value === "function"
          ? (fullname.local ? attrFunctionNS : attrFunction)
          : (fullname.local ? attrConstantNS : attrConstant)))(fullname, value));
    }

    function defaultView(node) {
      return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
          || (node.document && node) // node is a Window
          || node.defaultView; // node is a Document
    }

    function styleRemove(name) {
      return function() {
        this.style.removeProperty(name);
      };
    }

    function styleConstant(name, value, priority) {
      return function() {
        this.style.setProperty(name, value, priority);
      };
    }

    function styleFunction(name, value, priority) {
      return function() {
        var v = value.apply(this, arguments);
        if (v == null) this.style.removeProperty(name);
        else this.style.setProperty(name, v, priority);
      };
    }

    function selection_style(name, value, priority) {
      return arguments.length > 1
          ? this.each((value == null
                ? styleRemove : typeof value === "function"
                ? styleFunction
                : styleConstant)(name, value, priority == null ? "" : priority))
          : styleValue(this.node(), name);
    }

    function styleValue(node, name) {
      return node.style.getPropertyValue(name)
          || defaultView(node).getComputedStyle(node, null).getPropertyValue(name);
    }

    function propertyRemove(name) {
      return function() {
        delete this[name];
      };
    }

    function propertyConstant(name, value) {
      return function() {
        this[name] = value;
      };
    }

    function propertyFunction(name, value) {
      return function() {
        var v = value.apply(this, arguments);
        if (v == null) delete this[name];
        else this[name] = v;
      };
    }

    function selection_property(name, value) {
      return arguments.length > 1
          ? this.each((value == null
              ? propertyRemove : typeof value === "function"
              ? propertyFunction
              : propertyConstant)(name, value))
          : this.node()[name];
    }

    function classArray(string) {
      return string.trim().split(/^|\s+/);
    }

    function classList(node) {
      return node.classList || new ClassList(node);
    }

    function ClassList(node) {
      this._node = node;
      this._names = classArray(node.getAttribute("class") || "");
    }

    ClassList.prototype = {
      add: function(name) {
        var i = this._names.indexOf(name);
        if (i < 0) {
          this._names.push(name);
          this._node.setAttribute("class", this._names.join(" "));
        }
      },
      remove: function(name) {
        var i = this._names.indexOf(name);
        if (i >= 0) {
          this._names.splice(i, 1);
          this._node.setAttribute("class", this._names.join(" "));
        }
      },
      contains: function(name) {
        return this._names.indexOf(name) >= 0;
      }
    };

    function classedAdd(node, names) {
      var list = classList(node), i = -1, n = names.length;
      while (++i < n) list.add(names[i]);
    }

    function classedRemove(node, names) {
      var list = classList(node), i = -1, n = names.length;
      while (++i < n) list.remove(names[i]);
    }

    function classedTrue(names) {
      return function() {
        classedAdd(this, names);
      };
    }

    function classedFalse(names) {
      return function() {
        classedRemove(this, names);
      };
    }

    function classedFunction(names, value) {
      return function() {
        (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
      };
    }

    function selection_classed(name, value) {
      var names = classArray(name + "");

      if (arguments.length < 2) {
        var list = classList(this.node()), i = -1, n = names.length;
        while (++i < n) if (!list.contains(names[i])) return false;
        return true;
      }

      return this.each((typeof value === "function"
          ? classedFunction : value
          ? classedTrue
          : classedFalse)(names, value));
    }

    function textRemove() {
      this.textContent = "";
    }

    function textConstant(value) {
      return function() {
        this.textContent = value;
      };
    }

    function textFunction(value) {
      return function() {
        var v = value.apply(this, arguments);
        this.textContent = v == null ? "" : v;
      };
    }

    function selection_text(value) {
      return arguments.length
          ? this.each(value == null
              ? textRemove : (typeof value === "function"
              ? textFunction
              : textConstant)(value))
          : this.node().textContent;
    }

    function htmlRemove() {
      this.innerHTML = "";
    }

    function htmlConstant(value) {
      return function() {
        this.innerHTML = value;
      };
    }

    function htmlFunction(value) {
      return function() {
        var v = value.apply(this, arguments);
        this.innerHTML = v == null ? "" : v;
      };
    }

    function selection_html(value) {
      return arguments.length
          ? this.each(value == null
              ? htmlRemove : (typeof value === "function"
              ? htmlFunction
              : htmlConstant)(value))
          : this.node().innerHTML;
    }

    function raise() {
      if (this.nextSibling) this.parentNode.appendChild(this);
    }

    function selection_raise() {
      return this.each(raise);
    }

    function lower() {
      if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
    }

    function selection_lower() {
      return this.each(lower);
    }

    function selection_append(name) {
      var create = typeof name === "function" ? name : creator(name);
      return this.select(function() {
        return this.appendChild(create.apply(this, arguments));
      });
    }

    function constantNull() {
      return null;
    }

    function selection_insert(name, before) {
      var create = typeof name === "function" ? name : creator(name),
          select = before == null ? constantNull : typeof before === "function" ? before : selector(before);
      return this.select(function() {
        return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
      });
    }

    function remove() {
      var parent = this.parentNode;
      if (parent) parent.removeChild(this);
    }

    function selection_remove() {
      return this.each(remove);
    }

    function selection_cloneShallow() {
      var clone = this.cloneNode(false), parent = this.parentNode;
      return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
    }

    function selection_cloneDeep() {
      var clone = this.cloneNode(true), parent = this.parentNode;
      return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
    }

    function selection_clone(deep) {
      return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
    }

    function selection_datum(value) {
      return arguments.length
          ? this.property("__data__", value)
          : this.node().__data__;
    }

    var filterEvents = {};

    var event = null;

    if (typeof document !== "undefined") {
      var element = document.documentElement;
      if (!("onmouseenter" in element)) {
        filterEvents = {mouseenter: "mouseover", mouseleave: "mouseout"};
      }
    }

    function filterContextListener(listener, index, group) {
      listener = contextListener(listener, index, group);
      return function(event) {
        var related = event.relatedTarget;
        if (!related || (related !== this && !(related.compareDocumentPosition(this) & 8))) {
          listener.call(this, event);
        }
      };
    }

    function contextListener(listener, index, group) {
      return function(event1) {
        var event0 = event; // Events can be reentrant (e.g., focus).
        event = event1;
        try {
          listener.call(this, this.__data__, index, group);
        } finally {
          event = event0;
        }
      };
    }

    function parseTypenames$1(typenames) {
      return typenames.trim().split(/^|\s+/).map(function(t) {
        var name = "", i = t.indexOf(".");
        if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
        return {type: t, name: name};
      });
    }

    function onRemove(typename) {
      return function() {
        var on = this.__on;
        if (!on) return;
        for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
          if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
            this.removeEventListener(o.type, o.listener, o.capture);
          } else {
            on[++i] = o;
          }
        }
        if (++i) on.length = i;
        else delete this.__on;
      };
    }

    function onAdd(typename, value, capture) {
      var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;
      return function(d, i, group) {
        var on = this.__on, o, listener = wrap(value, i, group);
        if (on) for (var j = 0, m = on.length; j < m; ++j) {
          if ((o = on[j]).type === typename.type && o.name === typename.name) {
            this.removeEventListener(o.type, o.listener, o.capture);
            this.addEventListener(o.type, o.listener = listener, o.capture = capture);
            o.value = value;
            return;
          }
        }
        this.addEventListener(typename.type, listener, capture);
        o = {type: typename.type, name: typename.name, value: value, listener: listener, capture: capture};
        if (!on) this.__on = [o];
        else on.push(o);
      };
    }

    function selection_on(typename, value, capture) {
      var typenames = parseTypenames$1(typename + ""), i, n = typenames.length, t;

      if (arguments.length < 2) {
        var on = this.node().__on;
        if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
          for (i = 0, o = on[j]; i < n; ++i) {
            if ((t = typenames[i]).type === o.type && t.name === o.name) {
              return o.value;
            }
          }
        }
        return;
      }

      on = value ? onAdd : onRemove;
      if (capture == null) capture = false;
      for (i = 0; i < n; ++i) this.each(on(typenames[i], value, capture));
      return this;
    }

    function dispatchEvent(node, type, params) {
      var window = defaultView(node),
          event = window.CustomEvent;

      if (typeof event === "function") {
        event = new event(type, params);
      } else {
        event = window.document.createEvent("Event");
        if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
        else event.initEvent(type, false, false);
      }

      node.dispatchEvent(event);
    }

    function dispatchConstant(type, params) {
      return function() {
        return dispatchEvent(this, type, params);
      };
    }

    function dispatchFunction(type, params) {
      return function() {
        return dispatchEvent(this, type, params.apply(this, arguments));
      };
    }

    function selection_dispatch(type, params) {
      return this.each((typeof params === "function"
          ? dispatchFunction
          : dispatchConstant)(type, params));
    }

    var root = [null];

    function Selection(groups, parents) {
      this._groups = groups;
      this._parents = parents;
    }

    function selection() {
      return new Selection([[document.documentElement]], root);
    }

    Selection.prototype = selection.prototype = {
      constructor: Selection,
      select: selection_select,
      selectAll: selection_selectAll,
      filter: selection_filter,
      data: selection_data,
      enter: selection_enter,
      exit: selection_exit,
      join: selection_join,
      merge: selection_merge,
      order: selection_order,
      sort: selection_sort,
      call: selection_call,
      nodes: selection_nodes,
      node: selection_node,
      size: selection_size,
      empty: selection_empty,
      each: selection_each,
      attr: selection_attr,
      style: selection_style,
      property: selection_property,
      classed: selection_classed,
      text: selection_text,
      html: selection_html,
      raise: selection_raise,
      lower: selection_lower,
      append: selection_append,
      insert: selection_insert,
      remove: selection_remove,
      clone: selection_clone,
      datum: selection_datum,
      on: selection_on,
      dispatch: selection_dispatch
    };

    function select(selector) {
      return typeof selector === "string"
          ? new Selection([[document.querySelector(selector)]], [document.documentElement])
          : new Selection([[selector]], root);
    }

    function define$1(constructor, factory, prototype) {
      constructor.prototype = factory.prototype = prototype;
      prototype.constructor = constructor;
    }

    function extend$3(parent, definition) {
      var prototype = Object.create(parent.prototype);
      for (var key in definition) prototype[key] = definition[key];
      return prototype;
    }

    function Color() {}

    var darker = 0.7;
    var brighter = 1 / darker;

    var reI = "\\s*([+-]?\\d+)\\s*",
        reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",
        reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
        reHex = /^#([0-9a-f]{3,8})$/,
        reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"),
        reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"),
        reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"),
        reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"),
        reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"),
        reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");

    var named = {
      aliceblue: 0xf0f8ff,
      antiquewhite: 0xfaebd7,
      aqua: 0x00ffff,
      aquamarine: 0x7fffd4,
      azure: 0xf0ffff,
      beige: 0xf5f5dc,
      bisque: 0xffe4c4,
      black: 0x000000,
      blanchedalmond: 0xffebcd,
      blue: 0x0000ff,
      blueviolet: 0x8a2be2,
      brown: 0xa52a2a,
      burlywood: 0xdeb887,
      cadetblue: 0x5f9ea0,
      chartreuse: 0x7fff00,
      chocolate: 0xd2691e,
      coral: 0xff7f50,
      cornflowerblue: 0x6495ed,
      cornsilk: 0xfff8dc,
      crimson: 0xdc143c,
      cyan: 0x00ffff,
      darkblue: 0x00008b,
      darkcyan: 0x008b8b,
      darkgoldenrod: 0xb8860b,
      darkgray: 0xa9a9a9,
      darkgreen: 0x006400,
      darkgrey: 0xa9a9a9,
      darkkhaki: 0xbdb76b,
      darkmagenta: 0x8b008b,
      darkolivegreen: 0x556b2f,
      darkorange: 0xff8c00,
      darkorchid: 0x9932cc,
      darkred: 0x8b0000,
      darksalmon: 0xe9967a,
      darkseagreen: 0x8fbc8f,
      darkslateblue: 0x483d8b,
      darkslategray: 0x2f4f4f,
      darkslategrey: 0x2f4f4f,
      darkturquoise: 0x00ced1,
      darkviolet: 0x9400d3,
      deeppink: 0xff1493,
      deepskyblue: 0x00bfff,
      dimgray: 0x696969,
      dimgrey: 0x696969,
      dodgerblue: 0x1e90ff,
      firebrick: 0xb22222,
      floralwhite: 0xfffaf0,
      forestgreen: 0x228b22,
      fuchsia: 0xff00ff,
      gainsboro: 0xdcdcdc,
      ghostwhite: 0xf8f8ff,
      gold: 0xffd700,
      goldenrod: 0xdaa520,
      gray: 0x808080,
      green: 0x008000,
      greenyellow: 0xadff2f,
      grey: 0x808080,
      honeydew: 0xf0fff0,
      hotpink: 0xff69b4,
      indianred: 0xcd5c5c,
      indigo: 0x4b0082,
      ivory: 0xfffff0,
      khaki: 0xf0e68c,
      lavender: 0xe6e6fa,
      lavenderblush: 0xfff0f5,
      lawngreen: 0x7cfc00,
      lemonchiffon: 0xfffacd,
      lightblue: 0xadd8e6,
      lightcoral: 0xf08080,
      lightcyan: 0xe0ffff,
      lightgoldenrodyellow: 0xfafad2,
      lightgray: 0xd3d3d3,
      lightgreen: 0x90ee90,
      lightgrey: 0xd3d3d3,
      lightpink: 0xffb6c1,
      lightsalmon: 0xffa07a,
      lightseagreen: 0x20b2aa,
      lightskyblue: 0x87cefa,
      lightslategray: 0x778899,
      lightslategrey: 0x778899,
      lightsteelblue: 0xb0c4de,
      lightyellow: 0xffffe0,
      lime: 0x00ff00,
      limegreen: 0x32cd32,
      linen: 0xfaf0e6,
      magenta: 0xff00ff,
      maroon: 0x800000,
      mediumaquamarine: 0x66cdaa,
      mediumblue: 0x0000cd,
      mediumorchid: 0xba55d3,
      mediumpurple: 0x9370db,
      mediumseagreen: 0x3cb371,
      mediumslateblue: 0x7b68ee,
      mediumspringgreen: 0x00fa9a,
      mediumturquoise: 0x48d1cc,
      mediumvioletred: 0xc71585,
      midnightblue: 0x191970,
      mintcream: 0xf5fffa,
      mistyrose: 0xffe4e1,
      moccasin: 0xffe4b5,
      navajowhite: 0xffdead,
      navy: 0x000080,
      oldlace: 0xfdf5e6,
      olive: 0x808000,
      olivedrab: 0x6b8e23,
      orange: 0xffa500,
      orangered: 0xff4500,
      orchid: 0xda70d6,
      palegoldenrod: 0xeee8aa,
      palegreen: 0x98fb98,
      paleturquoise: 0xafeeee,
      palevioletred: 0xdb7093,
      papayawhip: 0xffefd5,
      peachpuff: 0xffdab9,
      peru: 0xcd853f,
      pink: 0xffc0cb,
      plum: 0xdda0dd,
      powderblue: 0xb0e0e6,
      purple: 0x800080,
      rebeccapurple: 0x663399,
      red: 0xff0000,
      rosybrown: 0xbc8f8f,
      royalblue: 0x4169e1,
      saddlebrown: 0x8b4513,
      salmon: 0xfa8072,
      sandybrown: 0xf4a460,
      seagreen: 0x2e8b57,
      seashell: 0xfff5ee,
      sienna: 0xa0522d,
      silver: 0xc0c0c0,
      skyblue: 0x87ceeb,
      slateblue: 0x6a5acd,
      slategray: 0x708090,
      slategrey: 0x708090,
      snow: 0xfffafa,
      springgreen: 0x00ff7f,
      steelblue: 0x4682b4,
      tan: 0xd2b48c,
      teal: 0x008080,
      thistle: 0xd8bfd8,
      tomato: 0xff6347,
      turquoise: 0x40e0d0,
      violet: 0xee82ee,
      wheat: 0xf5deb3,
      white: 0xffffff,
      whitesmoke: 0xf5f5f5,
      yellow: 0xffff00,
      yellowgreen: 0x9acd32
    };

    define$1(Color, color, {
      copy: function(channels) {
        return Object.assign(new this.constructor, this, channels);
      },
      displayable: function() {
        return this.rgb().displayable();
      },
      hex: color_formatHex, // Deprecated! Use color.formatHex.
      formatHex: color_formatHex,
      formatHsl: color_formatHsl,
      formatRgb: color_formatRgb,
      toString: color_formatRgb
    });

    function color_formatHex() {
      return this.rgb().formatHex();
    }

    function color_formatHsl() {
      return hslConvert(this).formatHsl();
    }

    function color_formatRgb() {
      return this.rgb().formatRgb();
    }

    function color(format) {
      var m, l;
      format = (format + "").trim().toLowerCase();
      return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
          : l === 3 ? new Rgb((m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1) // #f00
          : l === 8 ? rgba(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
          : l === 4 ? rgba((m >> 12 & 0xf) | (m >> 8 & 0xf0), (m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), (((m & 0xf) << 4) | (m & 0xf)) / 0xff) // #f000
          : null) // invalid hex
          : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
          : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
          : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
          : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
          : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
          : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
          : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
          : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
          : null;
    }

    function rgbn(n) {
      return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
    }

    function rgba(r, g, b, a) {
      if (a <= 0) r = g = b = NaN;
      return new Rgb(r, g, b, a);
    }

    function rgbConvert(o) {
      if (!(o instanceof Color)) o = color(o);
      if (!o) return new Rgb;
      o = o.rgb();
      return new Rgb(o.r, o.g, o.b, o.opacity);
    }

    function rgb(r, g, b, opacity) {
      return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
    }

    function Rgb(r, g, b, opacity) {
      this.r = +r;
      this.g = +g;
      this.b = +b;
      this.opacity = +opacity;
    }

    define$1(Rgb, rgb, extend$3(Color, {
      brighter: function(k) {
        k = k == null ? brighter : Math.pow(brighter, k);
        return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
      },
      darker: function(k) {
        k = k == null ? darker : Math.pow(darker, k);
        return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
      },
      rgb: function() {
        return this;
      },
      displayable: function() {
        return (-0.5 <= this.r && this.r < 255.5)
            && (-0.5 <= this.g && this.g < 255.5)
            && (-0.5 <= this.b && this.b < 255.5)
            && (0 <= this.opacity && this.opacity <= 1);
      },
      hex: rgb_formatHex, // Deprecated! Use color.formatHex.
      formatHex: rgb_formatHex,
      formatRgb: rgb_formatRgb,
      toString: rgb_formatRgb
    }));

    function rgb_formatHex() {
      return "#" + hex(this.r) + hex(this.g) + hex(this.b);
    }

    function rgb_formatRgb() {
      var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
      return (a === 1 ? "rgb(" : "rgba(")
          + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", "
          + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", "
          + Math.max(0, Math.min(255, Math.round(this.b) || 0))
          + (a === 1 ? ")" : ", " + a + ")");
    }

    function hex(value) {
      value = Math.max(0, Math.min(255, Math.round(value) || 0));
      return (value < 16 ? "0" : "") + value.toString(16);
    }

    function hsla(h, s, l, a) {
      if (a <= 0) h = s = l = NaN;
      else if (l <= 0 || l >= 1) h = s = NaN;
      else if (s <= 0) h = NaN;
      return new Hsl(h, s, l, a);
    }

    function hslConvert(o) {
      if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
      if (!(o instanceof Color)) o = color(o);
      if (!o) return new Hsl;
      if (o instanceof Hsl) return o;
      o = o.rgb();
      var r = o.r / 255,
          g = o.g / 255,
          b = o.b / 255,
          min = Math.min(r, g, b),
          max = Math.max(r, g, b),
          h = NaN,
          s = max - min,
          l = (max + min) / 2;
      if (s) {
        if (r === max) h = (g - b) / s + (g < b) * 6;
        else if (g === max) h = (b - r) / s + 2;
        else h = (r - g) / s + 4;
        s /= l < 0.5 ? max + min : 2 - max - min;
        h *= 60;
      } else {
        s = l > 0 && l < 1 ? 0 : h;
      }
      return new Hsl(h, s, l, o.opacity);
    }

    function hsl(h, s, l, opacity) {
      return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
    }

    function Hsl(h, s, l, opacity) {
      this.h = +h;
      this.s = +s;
      this.l = +l;
      this.opacity = +opacity;
    }

    define$1(Hsl, hsl, extend$3(Color, {
      brighter: function(k) {
        k = k == null ? brighter : Math.pow(brighter, k);
        return new Hsl(this.h, this.s, this.l * k, this.opacity);
      },
      darker: function(k) {
        k = k == null ? darker : Math.pow(darker, k);
        return new Hsl(this.h, this.s, this.l * k, this.opacity);
      },
      rgb: function() {
        var h = this.h % 360 + (this.h < 0) * 360,
            s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
            l = this.l,
            m2 = l + (l < 0.5 ? l : 1 - l) * s,
            m1 = 2 * l - m2;
        return new Rgb(
          hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
          hsl2rgb(h, m1, m2),
          hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
          this.opacity
        );
      },
      displayable: function() {
        return (0 <= this.s && this.s <= 1 || isNaN(this.s))
            && (0 <= this.l && this.l <= 1)
            && (0 <= this.opacity && this.opacity <= 1);
      },
      formatHsl: function() {
        var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
        return (a === 1 ? "hsl(" : "hsla(")
            + (this.h || 0) + ", "
            + (this.s || 0) * 100 + "%, "
            + (this.l || 0) * 100 + "%"
            + (a === 1 ? ")" : ", " + a + ")");
      }
    }));

    /* From FvD 13.37, CSS Color Module Level 3 */
    function hsl2rgb(h, m1, m2) {
      return (h < 60 ? m1 + (m2 - m1) * h / 60
          : h < 180 ? m2
          : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
          : m1) * 255;
    }

    var deg2rad = Math.PI / 180;
    var rad2deg = 180 / Math.PI;

    // https://observablehq.com/@mbostock/lab-and-rgb
    var K = 18,
        Xn = 0.96422,
        Yn = 1,
        Zn = 0.82521,
        t0 = 4 / 29,
        t1 = 6 / 29,
        t2 = 3 * t1 * t1,
        t3 = t1 * t1 * t1;

    function labConvert(o) {
      if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
      if (o instanceof Hcl) return hcl2lab(o);
      if (!(o instanceof Rgb)) o = rgbConvert(o);
      var r = rgb2lrgb(o.r),
          g = rgb2lrgb(o.g),
          b = rgb2lrgb(o.b),
          y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x, z;
      if (r === g && g === b) x = z = y; else {
        x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
        z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
      }
      return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
    }

    function lab(l, a, b, opacity) {
      return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
    }

    function Lab(l, a, b, opacity) {
      this.l = +l;
      this.a = +a;
      this.b = +b;
      this.opacity = +opacity;
    }

    define$1(Lab, lab, extend$3(Color, {
      brighter: function(k) {
        return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
      },
      darker: function(k) {
        return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
      },
      rgb: function() {
        var y = (this.l + 16) / 116,
            x = isNaN(this.a) ? y : y + this.a / 500,
            z = isNaN(this.b) ? y : y - this.b / 200;
        x = Xn * lab2xyz(x);
        y = Yn * lab2xyz(y);
        z = Zn * lab2xyz(z);
        return new Rgb(
          lrgb2rgb( 3.1338561 * x - 1.6168667 * y - 0.4906146 * z),
          lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.0334540 * z),
          lrgb2rgb( 0.0719453 * x - 0.2289914 * y + 1.4052427 * z),
          this.opacity
        );
      }
    }));

    function xyz2lab(t) {
      return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
    }

    function lab2xyz(t) {
      return t > t1 ? t * t * t : t2 * (t - t0);
    }

    function lrgb2rgb(x) {
      return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
    }

    function rgb2lrgb(x) {
      return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
    }

    function hclConvert(o) {
      if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
      if (!(o instanceof Lab)) o = labConvert(o);
      if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
      var h = Math.atan2(o.b, o.a) * rad2deg;
      return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
    }

    function hcl(h, c, l, opacity) {
      return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
    }

    function Hcl(h, c, l, opacity) {
      this.h = +h;
      this.c = +c;
      this.l = +l;
      this.opacity = +opacity;
    }

    function hcl2lab(o) {
      if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
      var h = o.h * deg2rad;
      return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
    }

    define$1(Hcl, hcl, extend$3(Color, {
      brighter: function(k) {
        return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
      },
      darker: function(k) {
        return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
      },
      rgb: function() {
        return hcl2lab(this).rgb();
      }
    }));

    var A = -0.14861,
        B = +1.78277,
        C = -0.29227,
        D = -0.90649,
        E$1 = +1.97294,
        ED = E$1 * D,
        EB = E$1 * B,
        BC_DA = B * C - D * A;

    function cubehelixConvert(o) {
      if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
      if (!(o instanceof Rgb)) o = rgbConvert(o);
      var r = o.r / 255,
          g = o.g / 255,
          b = o.b / 255,
          l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
          bl = b - l,
          k = (E$1 * (g - l) - C * bl) / D,
          s = Math.sqrt(k * k + bl * bl) / (E$1 * l * (1 - l)), // NaN if l=0 or l=1
          h = s ? Math.atan2(k, bl) * rad2deg - 120 : NaN;
      return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
    }

    function cubehelix(h, s, l, opacity) {
      return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
    }

    function Cubehelix(h, s, l, opacity) {
      this.h = +h;
      this.s = +s;
      this.l = +l;
      this.opacity = +opacity;
    }

    define$1(Cubehelix, cubehelix, extend$3(Color, {
      brighter: function(k) {
        k = k == null ? brighter : Math.pow(brighter, k);
        return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
      },
      darker: function(k) {
        k = k == null ? darker : Math.pow(darker, k);
        return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
      },
      rgb: function() {
        var h = isNaN(this.h) ? 0 : (this.h + 120) * deg2rad,
            l = +this.l,
            a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
            cosh = Math.cos(h),
            sinh = Math.sin(h);
        return new Rgb(
          255 * (l + a * (A * cosh + B * sinh)),
          255 * (l + a * (C * cosh + D * sinh)),
          255 * (l + a * (E$1 * cosh)),
          this.opacity
        );
      }
    }));

    function basis(t1, v0, v1, v2, v3) {
      var t2 = t1 * t1, t3 = t2 * t1;
      return ((1 - 3 * t1 + 3 * t2 - t3) * v0
          + (4 - 6 * t2 + 3 * t3) * v1
          + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2
          + t3 * v3) / 6;
    }

    function basis$1(values) {
      var n = values.length - 1;
      return function(t) {
        var i = t <= 0 ? (t = 0) : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
            v1 = values[i],
            v2 = values[i + 1],
            v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
            v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
        return basis((t - i / n) * n, v0, v1, v2, v3);
      };
    }

    function constant$3(x) {
      return function() {
        return x;
      };
    }

    function linear$1(a, d) {
      return function(t) {
        return a + t * d;
      };
    }

    function exponential(a, b, y) {
      return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
        return Math.pow(a + t * b, y);
      };
    }

    function hue(a, b) {
      var d = b - a;
      return d ? linear$1(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant$3(isNaN(a) ? b : a);
    }

    function gamma(y) {
      return (y = +y) === 1 ? nogamma : function(a, b) {
        return b - a ? exponential(a, b, y) : constant$3(isNaN(a) ? b : a);
      };
    }

    function nogamma(a, b) {
      var d = b - a;
      return d ? linear$1(a, d) : constant$3(isNaN(a) ? b : a);
    }

    var interpolateRgb = (function rgbGamma(y) {
      var color$$1 = gamma(y);

      function rgb$$1(start, end) {
        var r = color$$1((start = rgb(start)).r, (end = rgb(end)).r),
            g = color$$1(start.g, end.g),
            b = color$$1(start.b, end.b),
            opacity = nogamma(start.opacity, end.opacity);
        return function(t) {
          start.r = r(t);
          start.g = g(t);
          start.b = b(t);
          start.opacity = opacity(t);
          return start + "";
        };
      }

      rgb$$1.gamma = rgbGamma;

      return rgb$$1;
    })(1);

    function rgbSpline(spline) {
      return function(colors) {
        var n = colors.length,
            r = new Array(n),
            g = new Array(n),
            b = new Array(n),
            i, color$$1;
        for (i = 0; i < n; ++i) {
          color$$1 = rgb(colors[i]);
          r[i] = color$$1.r || 0;
          g[i] = color$$1.g || 0;
          b[i] = color$$1.b || 0;
        }
        r = spline(r);
        g = spline(g);
        b = spline(b);
        color$$1.opacity = 1;
        return function(t) {
          color$$1.r = r(t);
          color$$1.g = g(t);
          color$$1.b = b(t);
          return color$$1 + "";
        };
      };
    }

    var rgbBasis = rgbSpline(basis$1);

    function numberArray(a, b) {
      if (!b) b = [];
      var n = a ? Math.min(b.length, a.length) : 0,
          c = b.slice(),
          i;
      return function(t) {
        for (i = 0; i < n; ++i) c[i] = a[i] * (1 - t) + b[i] * t;
        return c;
      };
    }

    function isNumberArray(x) {
      return ArrayBuffer.isView(x) && !(x instanceof DataView);
    }

    function genericArray(a, b) {
      var nb = b ? b.length : 0,
          na = a ? Math.min(nb, a.length) : 0,
          x = new Array(na),
          c = new Array(nb),
          i;

      for (i = 0; i < na; ++i) x[i] = interpolateValue(a[i], b[i]);
      for (; i < nb; ++i) c[i] = b[i];

      return function(t) {
        for (i = 0; i < na; ++i) c[i] = x[i](t);
        return c;
      };
    }

    function date(a, b) {
      var d = new Date;
      return a = +a, b = +b, function(t) {
        return d.setTime(a * (1 - t) + b * t), d;
      };
    }

    function interpolateNumber(a, b) {
      return a = +a, b = +b, function(t) {
        return a * (1 - t) + b * t;
      };
    }

    function object(a, b) {
      var i = {},
          c = {},
          k;

      if (a === null || typeof a !== "object") a = {};
      if (b === null || typeof b !== "object") b = {};

      for (k in b) {
        if (k in a) {
          i[k] = interpolateValue(a[k], b[k]);
        } else {
          c[k] = b[k];
        }
      }

      return function(t) {
        for (k in i) c[k] = i[k](t);
        return c;
      };
    }

    var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
        reB = new RegExp(reA.source, "g");

    function zero(b) {
      return function() {
        return b;
      };
    }

    function one(b) {
      return function(t) {
        return b(t) + "";
      };
    }

    function interpolateString(a, b) {
      var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
          am, // current match in a
          bm, // current match in b
          bs, // string preceding current number in b, if any
          i = -1, // index in s
          s = [], // string constants and placeholders
          q = []; // number interpolators

      // Coerce inputs to strings.
      a = a + "", b = b + "";

      // Interpolate pairs of numbers in a & b.
      while ((am = reA.exec(a))
          && (bm = reB.exec(b))) {
        if ((bs = bm.index) > bi) { // a string precedes the next number in b
          bs = b.slice(bi, bs);
          if (s[i]) s[i] += bs; // coalesce with previous string
          else s[++i] = bs;
        }
        if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
          if (s[i]) s[i] += bm; // coalesce with previous string
          else s[++i] = bm;
        } else { // interpolate non-matching numbers
          s[++i] = null;
          q.push({i: i, x: interpolateNumber(am, bm)});
        }
        bi = reB.lastIndex;
      }

      // Add remains of b.
      if (bi < b.length) {
        bs = b.slice(bi);
        if (s[i]) s[i] += bs; // coalesce with previous string
        else s[++i] = bs;
      }

      // Special optimization for only a single match.
      // Otherwise, interpolate each of the numbers and rejoin the string.
      return s.length < 2 ? (q[0]
          ? one(q[0].x)
          : zero(b))
          : (b = q.length, function(t) {
              for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
              return s.join("");
            });
    }

    function interpolateValue(a, b) {
      var t = typeof b, c;
      return b == null || t === "boolean" ? constant$3(b)
          : (t === "number" ? interpolateNumber
          : t === "string" ? ((c = color(b)) ? (b = c, interpolateRgb) : interpolateString)
          : b instanceof color ? interpolateRgb
          : b instanceof Date ? date
          : isNumberArray(b) ? numberArray
          : Array.isArray(b) ? genericArray
          : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object
          : interpolateNumber)(a, b);
    }

    var degrees = 180 / Math.PI;

    var identity$2 = {
      translateX: 0,
      translateY: 0,
      rotate: 0,
      skewX: 0,
      scaleX: 1,
      scaleY: 1
    };

    function decompose(a, b, c, d, e, f) {
      var scaleX, scaleY, skewX;
      if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
      if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
      if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
      if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
      return {
        translateX: e,
        translateY: f,
        rotate: Math.atan2(b, a) * degrees,
        skewX: Math.atan(skewX) * degrees,
        scaleX: scaleX,
        scaleY: scaleY
      };
    }

    var cssNode,
        cssRoot,
        cssView,
        svgNode;

    function parseCss(value) {
      if (value === "none") return identity$2;
      if (!cssNode) cssNode = document.createElement("DIV"), cssRoot = document.documentElement, cssView = document.defaultView;
      cssNode.style.transform = value;
      value = cssView.getComputedStyle(cssRoot.appendChild(cssNode), null).getPropertyValue("transform");
      cssRoot.removeChild(cssNode);
      value = value.slice(7, -1).split(",");
      return decompose(+value[0], +value[1], +value[2], +value[3], +value[4], +value[5]);
    }

    function parseSvg(value) {
      if (value == null) return identity$2;
      if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
      svgNode.setAttribute("transform", value);
      if (!(value = svgNode.transform.baseVal.consolidate())) return identity$2;
      value = value.matrix;
      return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
    }

    function interpolateTransform(parse, pxComma, pxParen, degParen) {

      function pop(s) {
        return s.length ? s.pop() + " " : "";
      }

      function translate(xa, ya, xb, yb, s, q) {
        if (xa !== xb || ya !== yb) {
          var i = s.push("translate(", null, pxComma, null, pxParen);
          q.push({i: i - 4, x: interpolateNumber(xa, xb)}, {i: i - 2, x: interpolateNumber(ya, yb)});
        } else if (xb || yb) {
          s.push("translate(" + xb + pxComma + yb + pxParen);
        }
      }

      function rotate(a, b, s, q) {
        if (a !== b) {
          if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path
          q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: interpolateNumber(a, b)});
        } else if (b) {
          s.push(pop(s) + "rotate(" + b + degParen);
        }
      }

      function skewX(a, b, s, q) {
        if (a !== b) {
          q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: interpolateNumber(a, b)});
        } else if (b) {
          s.push(pop(s) + "skewX(" + b + degParen);
        }
      }

      function scale(xa, ya, xb, yb, s, q) {
        if (xa !== xb || ya !== yb) {
          var i = s.push(pop(s) + "scale(", null, ",", null, ")");
          q.push({i: i - 4, x: interpolateNumber(xa, xb)}, {i: i - 2, x: interpolateNumber(ya, yb)});
        } else if (xb !== 1 || yb !== 1) {
          s.push(pop(s) + "scale(" + xb + "," + yb + ")");
        }
      }

      return function(a, b) {
        var s = [], // string constants and placeholders
            q = []; // number interpolators
        a = parse(a), b = parse(b);
        translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
        rotate(a.rotate, b.rotate, s, q);
        skewX(a.skewX, b.skewX, s, q);
        scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
        a = b = null; // gc
        return function(t) {
          var i = -1, n = q.length, o;
          while (++i < n) s[(o = q[i]).i] = o.x(t);
          return s.join("");
        };
      };
    }

    var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
    var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

    var rho = Math.SQRT2;

    function cubehelix$1(hue$$1) {
      return (function cubehelixGamma(y) {
        y = +y;

        function cubehelix$$1(start, end) {
          var h = hue$$1((start = cubehelix(start)).h, (end = cubehelix(end)).h),
              s = nogamma(start.s, end.s),
              l = nogamma(start.l, end.l),
              opacity = nogamma(start.opacity, end.opacity);
          return function(t) {
            start.h = h(t);
            start.s = s(t);
            start.l = l(Math.pow(t, y));
            start.opacity = opacity(t);
            return start + "";
          };
        }

        cubehelix$$1.gamma = cubehelixGamma;

        return cubehelix$$1;
      })(1);
    }

    cubehelix$1(hue);
    var cubehelixLong = cubehelix$1(nogamma);

    var frame = 0, // is an animation frame pending?
        timeout = 0, // is a timeout pending?
        interval = 0, // are any timers active?
        pokeDelay = 1000, // how frequently we check for clock skew
        taskHead,
        taskTail,
        clockLast = 0,
        clockNow = 0,
        clockSkew = 0,
        clock = typeof performance === "object" && performance.now ? performance : Date,
        setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };

    function now$1() {
      return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
    }

    function clearNow() {
      clockNow = 0;
    }

    function Timer() {
      this._call =
      this._time =
      this._next = null;
    }

    Timer.prototype = timer.prototype = {
      constructor: Timer,
      restart: function(callback, delay, time) {
        if (typeof callback !== "function") throw new TypeError("callback is not a function");
        time = (time == null ? now$1() : +time) + (delay == null ? 0 : +delay);
        if (!this._next && taskTail !== this) {
          if (taskTail) taskTail._next = this;
          else taskHead = this;
          taskTail = this;
        }
        this._call = callback;
        this._time = time;
        sleep();
      },
      stop: function() {
        if (this._call) {
          this._call = null;
          this._time = Infinity;
          sleep();
        }
      }
    };

    function timer(callback, delay, time) {
      var t = new Timer;
      t.restart(callback, delay, time);
      return t;
    }

    function timerFlush() {
      now$1(); // Get the current time, if not already set.
      ++frame; // Pretend we’ve set an alarm, if we haven’t already.
      var t = taskHead, e;
      while (t) {
        if ((e = clockNow - t._time) >= 0) t._call.call(null, e);
        t = t._next;
      }
      --frame;
    }

    function wake() {
      clockNow = (clockLast = clock.now()) + clockSkew;
      frame = timeout = 0;
      try {
        timerFlush();
      } finally {
        frame = 0;
        nap();
        clockNow = 0;
      }
    }

    function poke() {
      var now = clock.now(), delay = now - clockLast;
      if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
    }

    function nap() {
      var t0, t1 = taskHead, t2, time = Infinity;
      while (t1) {
        if (t1._call) {
          if (time > t1._time) time = t1._time;
          t0 = t1, t1 = t1._next;
        } else {
          t2 = t1._next, t1._next = null;
          t1 = t0 ? t0._next = t2 : taskHead = t2;
        }
      }
      taskTail = t0;
      sleep(time);
    }

    function sleep(time) {
      if (frame) return; // Soonest alarm already set, or will be.
      if (timeout) timeout = clearTimeout(timeout);
      var delay = time - clockNow; // Strictly less than if we recomputed clockNow.
      if (delay > 24) {
        if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
        if (interval) interval = clearInterval(interval);
      } else {
        if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
        frame = 1, setFrame(wake);
      }
    }

    function timeout$1(callback, delay, time) {
      var t = new Timer;
      delay = delay == null ? 0 : +delay;
      t.restart(function(elapsed) {
        t.stop();
        callback(elapsed + delay);
      }, delay, time);
      return t;
    }

    var emptyOn = dispatch("start", "end", "cancel", "interrupt");
    var emptyTween = [];

    var CREATED = 0;
    var SCHEDULED = 1;
    var STARTING = 2;
    var STARTED = 3;
    var RUNNING = 4;
    var ENDING = 5;
    var ENDED = 6;

    function schedule(node, name, id, index, group, timing) {
      var schedules = node.__transition;
      if (!schedules) node.__transition = {};
      else if (id in schedules) return;
      create$1(node, id, {
        name: name,
        index: index, // For context during callback.
        group: group, // For context during callback.
        on: emptyOn,
        tween: emptyTween,
        time: timing.time,
        delay: timing.delay,
        duration: timing.duration,
        ease: timing.ease,
        timer: null,
        state: CREATED
      });
    }

    function init$1(node, id) {
      var schedule = get$4(node, id);
      if (schedule.state > CREATED) throw new Error("too late; already scheduled");
      return schedule;
    }

    function set$3(node, id) {
      var schedule = get$4(node, id);
      if (schedule.state > STARTED) throw new Error("too late; already running");
      return schedule;
    }

    function get$4(node, id) {
      var schedule = node.__transition;
      if (!schedule || !(schedule = schedule[id])) throw new Error("transition not found");
      return schedule;
    }

    function create$1(node, id, self) {
      var schedules = node.__transition,
          tween;

      // Initialize the self timer when the transition is created.
      // Note the actual delay is not known until the first callback!
      schedules[id] = self;
      self.timer = timer(schedule, 0, self.time);

      function schedule(elapsed) {
        self.state = SCHEDULED;
        self.timer.restart(start, self.delay, self.time);

        // If the elapsed delay is less than our first sleep, start immediately.
        if (self.delay <= elapsed) start(elapsed - self.delay);
      }

      function start(elapsed) {
        var i, j, n, o;

        // If the state is not SCHEDULED, then we previously errored on start.
        if (self.state !== SCHEDULED) return stop();

        for (i in schedules) {
          o = schedules[i];
          if (o.name !== self.name) continue;

          // While this element already has a starting transition during this frame,
          // defer starting an interrupting transition until that transition has a
          // chance to tick (and possibly end); see d3/d3-transition#54!
          if (o.state === STARTED) return timeout$1(start);

          // Interrupt the active transition, if any.
          if (o.state === RUNNING) {
            o.state = ENDED;
            o.timer.stop();
            o.on.call("interrupt", node, node.__data__, o.index, o.group);
            delete schedules[i];
          }

          // Cancel any pre-empted transitions.
          else if (+i < id) {
            o.state = ENDED;
            o.timer.stop();
            o.on.call("cancel", node, node.__data__, o.index, o.group);
            delete schedules[i];
          }
        }

        // Defer the first tick to end of the current frame; see d3/d3#1576.
        // Note the transition may be canceled after start and before the first tick!
        // Note this must be scheduled before the start event; see d3/d3-transition#16!
        // Assuming this is successful, subsequent callbacks go straight to tick.
        timeout$1(function() {
          if (self.state === STARTED) {
            self.state = RUNNING;
            self.timer.restart(tick, self.delay, self.time);
            tick(elapsed);
          }
        });

        // Dispatch the start event.
        // Note this must be done before the tween are initialized.
        self.state = STARTING;
        self.on.call("start", node, node.__data__, self.index, self.group);
        if (self.state !== STARTING) return; // interrupted
        self.state = STARTED;

        // Initialize the tween, deleting null tween.
        tween = new Array(n = self.tween.length);
        for (i = 0, j = -1; i < n; ++i) {
          if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
            tween[++j] = o;
          }
        }
        tween.length = j + 1;
      }

      function tick(elapsed) {
        var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
            i = -1,
            n = tween.length;

        while (++i < n) {
          tween[i].call(node, t);
        }

        // Dispatch the end event.
        if (self.state === ENDING) {
          self.on.call("end", node, node.__data__, self.index, self.group);
          stop();
        }
      }

      function stop() {
        self.state = ENDED;
        self.timer.stop();
        delete schedules[id];
        for (var i in schedules) return; // eslint-disable-line no-unused-vars
        delete node.__transition;
      }
    }

    function interrupt(node, name) {
      var schedules = node.__transition,
          schedule$$1,
          active,
          empty = true,
          i;

      if (!schedules) return;

      name = name == null ? null : name + "";

      for (i in schedules) {
        if ((schedule$$1 = schedules[i]).name !== name) { empty = false; continue; }
        active = schedule$$1.state > STARTING && schedule$$1.state < ENDING;
        schedule$$1.state = ENDED;
        schedule$$1.timer.stop();
        schedule$$1.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule$$1.index, schedule$$1.group);
        delete schedules[i];
      }

      if (empty) delete node.__transition;
    }

    function selection_interrupt(name) {
      return this.each(function() {
        interrupt(this, name);
      });
    }

    function tweenRemove(id, name) {
      var tween0, tween1;
      return function() {
        var schedule$$1 = set$3(this, id),
            tween = schedule$$1.tween;

        // If this node shared tween with the previous node,
        // just assign the updated shared tween and we’re done!
        // Otherwise, copy-on-write.
        if (tween !== tween0) {
          tween1 = tween0 = tween;
          for (var i = 0, n = tween1.length; i < n; ++i) {
            if (tween1[i].name === name) {
              tween1 = tween1.slice();
              tween1.splice(i, 1);
              break;
            }
          }
        }

        schedule$$1.tween = tween1;
      };
    }

    function tweenFunction(id, name, value) {
      var tween0, tween1;
      if (typeof value !== "function") throw new Error;
      return function() {
        var schedule$$1 = set$3(this, id),
            tween = schedule$$1.tween;

        // If this node shared tween with the previous node,
        // just assign the updated shared tween and we’re done!
        // Otherwise, copy-on-write.
        if (tween !== tween0) {
          tween1 = (tween0 = tween).slice();
          for (var t = {name: name, value: value}, i = 0, n = tween1.length; i < n; ++i) {
            if (tween1[i].name === name) {
              tween1[i] = t;
              break;
            }
          }
          if (i === n) tween1.push(t);
        }

        schedule$$1.tween = tween1;
      };
    }

    function transition_tween(name, value) {
      var id = this._id;

      name += "";

      if (arguments.length < 2) {
        var tween = get$4(this.node(), id).tween;
        for (var i = 0, n = tween.length, t; i < n; ++i) {
          if ((t = tween[i]).name === name) {
            return t.value;
          }
        }
        return null;
      }

      return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
    }

    function tweenValue(transition, name, value) {
      var id = transition._id;

      transition.each(function() {
        var schedule$$1 = set$3(this, id);
        (schedule$$1.value || (schedule$$1.value = {}))[name] = value.apply(this, arguments);
      });

      return function(node) {
        return get$4(node, id).value[name];
      };
    }

    function interpolate(a, b) {
      var c;
      return (typeof b === "number" ? interpolateNumber
          : b instanceof color ? interpolateRgb
          : (c = color(b)) ? (b = c, interpolateRgb)
          : interpolateString)(a, b);
    }

    function attrRemove$1(name) {
      return function() {
        this.removeAttribute(name);
      };
    }

    function attrRemoveNS$1(fullname) {
      return function() {
        this.removeAttributeNS(fullname.space, fullname.local);
      };
    }

    function attrConstant$1(name, interpolate$$1, value1) {
      var string00,
          string1 = value1 + "",
          interpolate0;
      return function() {
        var string0 = this.getAttribute(name);
        return string0 === string1 ? null
            : string0 === string00 ? interpolate0
            : interpolate0 = interpolate$$1(string00 = string0, value1);
      };
    }

    function attrConstantNS$1(fullname, interpolate$$1, value1) {
      var string00,
          string1 = value1 + "",
          interpolate0;
      return function() {
        var string0 = this.getAttributeNS(fullname.space, fullname.local);
        return string0 === string1 ? null
            : string0 === string00 ? interpolate0
            : interpolate0 = interpolate$$1(string00 = string0, value1);
      };
    }

    function attrFunction$1(name, interpolate$$1, value) {
      var string00,
          string10,
          interpolate0;
      return function() {
        var string0, value1 = value(this), string1;
        if (value1 == null) return void this.removeAttribute(name);
        string0 = this.getAttribute(name);
        string1 = value1 + "";
        return string0 === string1 ? null
            : string0 === string00 && string1 === string10 ? interpolate0
            : (string10 = string1, interpolate0 = interpolate$$1(string00 = string0, value1));
      };
    }

    function attrFunctionNS$1(fullname, interpolate$$1, value) {
      var string00,
          string10,
          interpolate0;
      return function() {
        var string0, value1 = value(this), string1;
        if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
        string0 = this.getAttributeNS(fullname.space, fullname.local);
        string1 = value1 + "";
        return string0 === string1 ? null
            : string0 === string00 && string1 === string10 ? interpolate0
            : (string10 = string1, interpolate0 = interpolate$$1(string00 = string0, value1));
      };
    }

    function transition_attr(name, value) {
      var fullname = namespace(name), i = fullname === "transform" ? interpolateTransformSvg : interpolate;
      return this.attrTween(name, typeof value === "function"
          ? (fullname.local ? attrFunctionNS$1 : attrFunction$1)(fullname, i, tweenValue(this, "attr." + name, value))
          : value == null ? (fullname.local ? attrRemoveNS$1 : attrRemove$1)(fullname)
          : (fullname.local ? attrConstantNS$1 : attrConstant$1)(fullname, i, value));
    }

    function attrInterpolate(name, i) {
      return function(t) {
        this.setAttribute(name, i.call(this, t));
      };
    }

    function attrInterpolateNS(fullname, i) {
      return function(t) {
        this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
      };
    }

    function attrTweenNS(fullname, value) {
      var t0, i0;
      function tween() {
        var i = value.apply(this, arguments);
        if (i !== i0) t0 = (i0 = i) && attrInterpolateNS(fullname, i);
        return t0;
      }
      tween._value = value;
      return tween;
    }

    function attrTween(name, value) {
      var t0, i0;
      function tween() {
        var i = value.apply(this, arguments);
        if (i !== i0) t0 = (i0 = i) && attrInterpolate(name, i);
        return t0;
      }
      tween._value = value;
      return tween;
    }

    function transition_attrTween(name, value) {
      var key = "attr." + name;
      if (arguments.length < 2) return (key = this.tween(key)) && key._value;
      if (value == null) return this.tween(key, null);
      if (typeof value !== "function") throw new Error;
      var fullname = namespace(name);
      return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
    }

    function delayFunction(id, value) {
      return function() {
        init$1(this, id).delay = +value.apply(this, arguments);
      };
    }

    function delayConstant(id, value) {
      return value = +value, function() {
        init$1(this, id).delay = value;
      };
    }

    function transition_delay(value) {
      var id = this._id;

      return arguments.length
          ? this.each((typeof value === "function"
              ? delayFunction
              : delayConstant)(id, value))
          : get$4(this.node(), id).delay;
    }

    function durationFunction(id, value) {
      return function() {
        set$3(this, id).duration = +value.apply(this, arguments);
      };
    }

    function durationConstant(id, value) {
      return value = +value, function() {
        set$3(this, id).duration = value;
      };
    }

    function transition_duration(value) {
      var id = this._id;

      return arguments.length
          ? this.each((typeof value === "function"
              ? durationFunction
              : durationConstant)(id, value))
          : get$4(this.node(), id).duration;
    }

    function easeConstant(id, value) {
      if (typeof value !== "function") throw new Error;
      return function() {
        set$3(this, id).ease = value;
      };
    }

    function transition_ease(value) {
      var id = this._id;

      return arguments.length
          ? this.each(easeConstant(id, value))
          : get$4(this.node(), id).ease;
    }

    function transition_filter(match) {
      if (typeof match !== "function") match = matcher(match);

      for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
          if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
            subgroup.push(node);
          }
        }
      }

      return new Transition(subgroups, this._parents, this._name, this._id);
    }

    function transition_merge(transition$$1) {
      if (transition$$1._id !== this._id) throw new Error;

      for (var groups0 = this._groups, groups1 = transition$$1._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
        for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
          if (node = group0[i] || group1[i]) {
            merge[i] = node;
          }
        }
      }

      for (; j < m0; ++j) {
        merges[j] = groups0[j];
      }

      return new Transition(merges, this._parents, this._name, this._id);
    }

    function start(name) {
      return (name + "").trim().split(/^|\s+/).every(function(t) {
        var i = t.indexOf(".");
        if (i >= 0) t = t.slice(0, i);
        return !t || t === "start";
      });
    }

    function onFunction(id, name, listener) {
      var on0, on1, sit = start(name) ? init$1 : set$3;
      return function() {
        var schedule$$1 = sit(this, id),
            on = schedule$$1.on;

        // If this node shared a dispatch with the previous node,
        // just assign the updated shared dispatch and we’re done!
        // Otherwise, copy-on-write.
        if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);

        schedule$$1.on = on1;
      };
    }

    function transition_on(name, listener) {
      var id = this._id;

      return arguments.length < 2
          ? get$4(this.node(), id).on.on(name)
          : this.each(onFunction(id, name, listener));
    }

    function removeFunction(id) {
      return function() {
        var parent = this.parentNode;
        for (var i in this.__transition) if (+i !== id) return;
        if (parent) parent.removeChild(this);
      };
    }

    function transition_remove() {
      return this.on("end.remove", removeFunction(this._id));
    }

    function transition_select(select$$1) {
      var name = this._name,
          id = this._id;

      if (typeof select$$1 !== "function") select$$1 = selector(select$$1);

      for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
          if ((node = group[i]) && (subnode = select$$1.call(node, node.__data__, i, group))) {
            if ("__data__" in node) subnode.__data__ = node.__data__;
            subgroup[i] = subnode;
            schedule(subgroup[i], name, id, i, subgroup, get$4(node, id));
          }
        }
      }

      return new Transition(subgroups, this._parents, name, id);
    }

    function transition_selectAll(select$$1) {
      var name = this._name,
          id = this._id;

      if (typeof select$$1 !== "function") select$$1 = selectorAll(select$$1);

      for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            for (var children = select$$1.call(node, node.__data__, i, group), child, inherit = get$4(node, id), k = 0, l = children.length; k < l; ++k) {
              if (child = children[k]) {
                schedule(child, name, id, k, children, inherit);
              }
            }
            subgroups.push(children);
            parents.push(node);
          }
        }
      }

      return new Transition(subgroups, parents, name, id);
    }

    var Selection$1 = selection.prototype.constructor;

    function transition_selection() {
      return new Selection$1(this._groups, this._parents);
    }

    function styleNull(name, interpolate$$1) {
      var string00,
          string10,
          interpolate0;
      return function() {
        var string0 = styleValue(this, name),
            string1 = (this.style.removeProperty(name), styleValue(this, name));
        return string0 === string1 ? null
            : string0 === string00 && string1 === string10 ? interpolate0
            : interpolate0 = interpolate$$1(string00 = string0, string10 = string1);
      };
    }

    function styleRemove$1(name) {
      return function() {
        this.style.removeProperty(name);
      };
    }

    function styleConstant$1(name, interpolate$$1, value1) {
      var string00,
          string1 = value1 + "",
          interpolate0;
      return function() {
        var string0 = styleValue(this, name);
        return string0 === string1 ? null
            : string0 === string00 ? interpolate0
            : interpolate0 = interpolate$$1(string00 = string0, value1);
      };
    }

    function styleFunction$1(name, interpolate$$1, value) {
      var string00,
          string10,
          interpolate0;
      return function() {
        var string0 = styleValue(this, name),
            value1 = value(this),
            string1 = value1 + "";
        if (value1 == null) string1 = value1 = (this.style.removeProperty(name), styleValue(this, name));
        return string0 === string1 ? null
            : string0 === string00 && string1 === string10 ? interpolate0
            : (string10 = string1, interpolate0 = interpolate$$1(string00 = string0, value1));
      };
    }

    function styleMaybeRemove(id, name) {
      var on0, on1, listener0, key = "style." + name, event$$1 = "end." + key, remove;
      return function() {
        var schedule$$1 = set$3(this, id),
            on = schedule$$1.on,
            listener = schedule$$1.value[key] == null ? remove || (remove = styleRemove$1(name)) : undefined;

        // If this node shared a dispatch with the previous node,
        // just assign the updated shared dispatch and we’re done!
        // Otherwise, copy-on-write.
        if (on !== on0 || listener0 !== listener) (on1 = (on0 = on).copy()).on(event$$1, listener0 = listener);

        schedule$$1.on = on1;
      };
    }

    function transition_style(name, value, priority) {
      var i = (name += "") === "transform" ? interpolateTransformCss : interpolate;
      return value == null ? this
          .styleTween(name, styleNull(name, i))
          .on("end.style." + name, styleRemove$1(name))
        : typeof value === "function" ? this
          .styleTween(name, styleFunction$1(name, i, tweenValue(this, "style." + name, value)))
          .each(styleMaybeRemove(this._id, name))
        : this
          .styleTween(name, styleConstant$1(name, i, value), priority)
          .on("end.style." + name, null);
    }

    function styleInterpolate(name, i, priority) {
      return function(t) {
        this.style.setProperty(name, i.call(this, t), priority);
      };
    }

    function styleTween(name, value, priority) {
      var t, i0;
      function tween() {
        var i = value.apply(this, arguments);
        if (i !== i0) t = (i0 = i) && styleInterpolate(name, i, priority);
        return t;
      }
      tween._value = value;
      return tween;
    }

    function transition_styleTween(name, value, priority) {
      var key = "style." + (name += "");
      if (arguments.length < 2) return (key = this.tween(key)) && key._value;
      if (value == null) return this.tween(key, null);
      if (typeof value !== "function") throw new Error;
      return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
    }

    function textConstant$1(value) {
      return function() {
        this.textContent = value;
      };
    }

    function textFunction$1(value) {
      return function() {
        var value1 = value(this);
        this.textContent = value1 == null ? "" : value1;
      };
    }

    function transition_text(value) {
      return this.tween("text", typeof value === "function"
          ? textFunction$1(tweenValue(this, "text", value))
          : textConstant$1(value == null ? "" : value + ""));
    }

    function textInterpolate(i) {
      return function(t) {
        this.textContent = i.call(this, t);
      };
    }

    function textTween(value) {
      var t0, i0;
      function tween() {
        var i = value.apply(this, arguments);
        if (i !== i0) t0 = (i0 = i) && textInterpolate(i);
        return t0;
      }
      tween._value = value;
      return tween;
    }

    function transition_textTween(value) {
      var key = "text";
      if (arguments.length < 1) return (key = this.tween(key)) && key._value;
      if (value == null) return this.tween(key, null);
      if (typeof value !== "function") throw new Error;
      return this.tween(key, textTween(value));
    }

    function transition_transition() {
      var name = this._name,
          id0 = this._id,
          id1 = newId();

      for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            var inherit = get$4(node, id0);
            schedule(node, name, id1, i, group, {
              time: inherit.time + inherit.delay + inherit.duration,
              delay: 0,
              duration: inherit.duration,
              ease: inherit.ease
            });
          }
        }
      }

      return new Transition(groups, this._parents, name, id1);
    }

    function transition_end() {
      var on0, on1, that = this, id = that._id, size = that.size();
      return new Promise(function(resolve, reject) {
        var cancel = {value: reject},
            end = {value: function() { if (--size === 0) resolve(); }};

        that.each(function() {
          var schedule$$1 = set$3(this, id),
              on = schedule$$1.on;

          // If this node shared a dispatch with the previous node,
          // just assign the updated shared dispatch and we’re done!
          // Otherwise, copy-on-write.
          if (on !== on0) {
            on1 = (on0 = on).copy();
            on1._.cancel.push(cancel);
            on1._.interrupt.push(cancel);
            on1._.end.push(end);
          }

          schedule$$1.on = on1;
        });
      });
    }

    var id = 0;

    function Transition(groups, parents, name, id) {
      this._groups = groups;
      this._parents = parents;
      this._name = name;
      this._id = id;
    }

    function transition(name) {
      return selection().transition(name);
    }

    function newId() {
      return ++id;
    }

    var selection_prototype = selection.prototype;

    Transition.prototype = transition.prototype = {
      constructor: Transition,
      select: transition_select,
      selectAll: transition_selectAll,
      filter: transition_filter,
      merge: transition_merge,
      selection: transition_selection,
      transition: transition_transition,
      call: selection_prototype.call,
      nodes: selection_prototype.nodes,
      node: selection_prototype.node,
      size: selection_prototype.size,
      empty: selection_prototype.empty,
      each: selection_prototype.each,
      on: transition_on,
      attr: transition_attr,
      attrTween: transition_attrTween,
      style: transition_style,
      styleTween: transition_styleTween,
      text: transition_text,
      textTween: transition_textTween,
      remove: transition_remove,
      tween: transition_tween,
      delay: transition_delay,
      duration: transition_duration,
      ease: transition_ease,
      end: transition_end
    };

    function cubicInOut(t) {
      return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
    }

    var pi = Math.PI;

    // tpmt is two power minus ten times t scaled to [0,1]

    var tau = 2 * Math.PI;

    var defaultTiming = {
      time: null, // Set on use.
      delay: 0,
      duration: 250,
      ease: cubicInOut
    };

    function inherit(node, id) {
      var timing;
      while (!(timing = node.__transition) || !(timing = timing[id])) {
        if (!(node = node.parentNode)) {
          return defaultTiming.time = now$1(), defaultTiming;
        }
      }
      return timing;
    }

    function selection_transition(name) {
      var id,
          timing;

      if (name instanceof Transition) {
        id = name._id, name = name._name;
      } else {
        id = newId(), (timing = defaultTiming).time = now$1(), name = name == null ? null : name + "";
      }

      for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            schedule(node, name, id, i, group, timing || inherit(node, id));
          }
        }
      }

      return new Transition(groups, this._parents, name, id);
    }

    selection.prototype.interrupt = selection_interrupt;
    selection.prototype.transition = selection_transition;

    var pi$1 = Math.PI;

    var pi$2 = Math.PI,
        tau$2 = 2 * pi$2,
        epsilon$1 = 1e-6,
        tauEpsilon = tau$2 - epsilon$1;

    function Path() {
      this._x0 = this._y0 = // start of current subpath
      this._x1 = this._y1 = null; // end of current subpath
      this._ = "";
    }

    function path() {
      return new Path;
    }

    Path.prototype = path.prototype = {
      constructor: Path,
      moveTo: function(x, y) {
        this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y);
      },
      closePath: function() {
        if (this._x1 !== null) {
          this._x1 = this._x0, this._y1 = this._y0;
          this._ += "Z";
        }
      },
      lineTo: function(x, y) {
        this._ += "L" + (this._x1 = +x) + "," + (this._y1 = +y);
      },
      quadraticCurveTo: function(x1, y1, x, y) {
        this._ += "Q" + (+x1) + "," + (+y1) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
      },
      bezierCurveTo: function(x1, y1, x2, y2, x, y) {
        this._ += "C" + (+x1) + "," + (+y1) + "," + (+x2) + "," + (+y2) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
      },
      arcTo: function(x1, y1, x2, y2, r) {
        x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
        var x0 = this._x1,
            y0 = this._y1,
            x21 = x2 - x1,
            y21 = y2 - y1,
            x01 = x0 - x1,
            y01 = y0 - y1,
            l01_2 = x01 * x01 + y01 * y01;

        // Is the radius negative? Error.
        if (r < 0) throw new Error("negative radius: " + r);

        // Is this path empty? Move to (x1,y1).
        if (this._x1 === null) {
          this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
        }

        // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
        else if (!(l01_2 > epsilon$1));

        // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
        // Equivalently, is (x1,y1) coincident with (x2,y2)?
        // Or, is the radius zero? Line to (x1,y1).
        else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon$1) || !r) {
          this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
        }

        // Otherwise, draw an arc!
        else {
          var x20 = x2 - x0,
              y20 = y2 - y0,
              l21_2 = x21 * x21 + y21 * y21,
              l20_2 = x20 * x20 + y20 * y20,
              l21 = Math.sqrt(l21_2),
              l01 = Math.sqrt(l01_2),
              l = r * Math.tan((pi$2 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
              t01 = l / l01,
              t21 = l / l21;

          // If the start tangent is not coincident with (x0,y0), line to.
          if (Math.abs(t01 - 1) > epsilon$1) {
            this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
          }

          this._ += "A" + r + "," + r + ",0,0," + (+(y01 * x20 > x01 * y20)) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
        }
      },
      arc: function(x, y, r, a0, a1, ccw) {
        x = +x, y = +y, r = +r, ccw = !!ccw;
        var dx = r * Math.cos(a0),
            dy = r * Math.sin(a0),
            x0 = x + dx,
            y0 = y + dy,
            cw = 1 ^ ccw,
            da = ccw ? a0 - a1 : a1 - a0;

        // Is the radius negative? Error.
        if (r < 0) throw new Error("negative radius: " + r);

        // Is this path empty? Move to (x0,y0).
        if (this._x1 === null) {
          this._ += "M" + x0 + "," + y0;
        }

        // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
        else if (Math.abs(this._x1 - x0) > epsilon$1 || Math.abs(this._y1 - y0) > epsilon$1) {
          this._ += "L" + x0 + "," + y0;
        }

        // Is this arc empty? We’re done.
        if (!r) return;

        // Does the angle go the wrong way? Flip the direction.
        if (da < 0) da = da % tau$2 + tau$2;

        // Is this a complete circle? Draw two arcs to complete the circle.
        if (da > tauEpsilon) {
          this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x - dx) + "," + (y - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
        }

        // Is this arc non-empty? Draw an arc!
        else if (da > epsilon$1) {
          this._ += "A" + r + "," + r + ",0," + (+(da >= pi$2)) + "," + cw + "," + (this._x1 = x + r * Math.cos(a1)) + "," + (this._y1 = y + r * Math.sin(a1));
        }
      },
      rect: function(x, y, w, h) {
        this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y) + "h" + (+w) + "v" + (+h) + "h" + (-w) + "Z";
      },
      toString: function() {
        return this._;
      }
    };

    var prefix = "$";

    function Map() {}

    Map.prototype = map$2.prototype = {
      constructor: Map,
      has: function(key) {
        return (prefix + key) in this;
      },
      get: function(key) {
        return this[prefix + key];
      },
      set: function(key, value) {
        this[prefix + key] = value;
        return this;
      },
      remove: function(key) {
        var property = prefix + key;
        return property in this && delete this[property];
      },
      clear: function() {
        for (var property in this) if (property[0] === prefix) delete this[property];
      },
      keys: function() {
        var keys = [];
        for (var property in this) if (property[0] === prefix) keys.push(property.slice(1));
        return keys;
      },
      values: function() {
        var values = [];
        for (var property in this) if (property[0] === prefix) values.push(this[property]);
        return values;
      },
      entries: function() {
        var entries = [];
        for (var property in this) if (property[0] === prefix) entries.push({key: property.slice(1), value: this[property]});
        return entries;
      },
      size: function() {
        var size = 0;
        for (var property in this) if (property[0] === prefix) ++size;
        return size;
      },
      empty: function() {
        for (var property in this) if (property[0] === prefix) return false;
        return true;
      },
      each: function(f) {
        for (var property in this) if (property[0] === prefix) f(this[property], property.slice(1), this);
      }
    };

    function map$2(object, f) {
      var map = new Map;

      // Copy constructor.
      if (object instanceof Map) object.each(function(value, key) { map.set(key, value); });

      // Index array by numeric index or specified key function.
      else if (Array.isArray(object)) {
        var i = -1,
            n = object.length,
            o;

        if (f == null) while (++i < n) map.set(i, object[i]);
        else while (++i < n) map.set(f(o = object[i], i, object), o);
      }

      // Convert object to map.
      else if (object) for (var key in object) map.set(key, object[key]);

      return map;
    }

    function Set() {}

    var proto$3 = map$2.prototype;

    Set.prototype = set$4.prototype = {
      constructor: Set,
      has: proto$3.has,
      add: function(value) {
        value += "";
        this[prefix + value] = value;
        return this;
      },
      remove: proto$3.remove,
      clear: proto$3.clear,
      values: proto$3.keys,
      size: proto$3.size,
      empty: proto$3.empty,
      each: proto$3.each
    };

    function set$4(object, f) {
      var set = new Set;

      // Copy constructor.
      if (object instanceof Set) object.each(function(value) { set.add(value); });

      // Otherwise, assume it’s an array.
      else if (object) {
        var i = -1, n = object.length;
        if (f == null) while (++i < n) set.add(object[i]);
        else while (++i < n) set.add(f(object[i], i, object));
      }

      return set;
    }

    // TODO Optimize edge cases.

    var EOL = {},
        EOF = {},
        QUOTE = 34,
        NEWLINE = 10,
        RETURN = 13;

    function objectConverter(columns) {
      return new Function("d", "return {" + columns.map(function(name, i) {
        return JSON.stringify(name) + ": d[" + i + "] || \"\"";
      }).join(",") + "}");
    }

    function customConverter(columns, f) {
      var object = objectConverter(columns);
      return function(row, i) {
        return f(object(row), i, columns);
      };
    }

    // Compute unique columns in order of discovery.
    function inferColumns(rows) {
      var columnSet = Object.create(null),
          columns = [];

      rows.forEach(function(row) {
        for (var column in row) {
          if (!(column in columnSet)) {
            columns.push(columnSet[column] = column);
          }
        }
      });

      return columns;
    }

    function pad(value, width) {
      var s = value + "", length = s.length;
      return length < width ? new Array(width - length + 1).join(0) + s : s;
    }

    function formatYear(year) {
      return year < 0 ? "-" + pad(-year, 6)
        : year > 9999 ? "+" + pad(year, 6)
        : pad(year, 4);
    }

    function formatDate(date) {
      var hours = date.getUTCHours(),
          minutes = date.getUTCMinutes(),
          seconds = date.getUTCSeconds(),
          milliseconds = date.getUTCMilliseconds();
      return isNaN(date) ? "Invalid Date"
          : formatYear(date.getUTCFullYear(), 4) + "-" + pad(date.getUTCMonth() + 1, 2) + "-" + pad(date.getUTCDate(), 2)
          + (milliseconds ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "." + pad(milliseconds, 3) + "Z"
          : seconds ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "Z"
          : minutes || hours ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + "Z"
          : "");
    }

    function dsvFormat(delimiter) {
      var reFormat = new RegExp("[\"" + delimiter + "\n\r]"),
          DELIMITER = delimiter.charCodeAt(0);

      function parse(text, f) {
        var convert, columns, rows = parseRows(text, function(row, i) {
          if (convert) return convert(row, i - 1);
          columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
        });
        rows.columns = columns || [];
        return rows;
      }

      function parseRows(text, f) {
        var rows = [], // output rows
            N = text.length,
            I = 0, // current character index
            n = 0, // current line number
            t, // current token
            eof = N <= 0, // current token followed by EOF?
            eol = false; // current token followed by EOL?

        // Strip the trailing newline.
        if (text.charCodeAt(N - 1) === NEWLINE) --N;
        if (text.charCodeAt(N - 1) === RETURN) --N;

        function token() {
          if (eof) return EOF;
          if (eol) return eol = false, EOL;

          // Unescape quotes.
          var i, j = I, c;
          if (text.charCodeAt(j) === QUOTE) {
            while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE);
            if ((i = I) >= N) eof = true;
            else if ((c = text.charCodeAt(I++)) === NEWLINE) eol = true;
            else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
            return text.slice(j + 1, i - 1).replace(/""/g, "\"");
          }

          // Find next delimiter or newline.
          while (I < N) {
            if ((c = text.charCodeAt(i = I++)) === NEWLINE) eol = true;
            else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
            else if (c !== DELIMITER) continue;
            return text.slice(j, i);
          }

          // Return last token before EOF.
          return eof = true, text.slice(j, N);
        }

        while ((t = token()) !== EOF) {
          var row = [];
          while (t !== EOL && t !== EOF) row.push(t), t = token();
          if (f && (row = f(row, n++)) == null) continue;
          rows.push(row);
        }

        return rows;
      }

      function preformatBody(rows, columns) {
        return rows.map(function(row) {
          return columns.map(function(column) {
            return formatValue(row[column]);
          }).join(delimiter);
        });
      }

      function format(rows, columns) {
        if (columns == null) columns = inferColumns(rows);
        return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join("\n");
      }

      function formatBody(rows, columns) {
        if (columns == null) columns = inferColumns(rows);
        return preformatBody(rows, columns).join("\n");
      }

      function formatRows(rows) {
        return rows.map(formatRow).join("\n");
      }

      function formatRow(row) {
        return row.map(formatValue).join(delimiter);
      }

      function formatValue(value) {
        return value == null ? ""
            : value instanceof Date ? formatDate(value)
            : reFormat.test(value += "") ? "\"" + value.replace(/"/g, "\"\"") + "\""
            : value;
      }

      return {
        parse: parse,
        parseRows: parseRows,
        format: format,
        formatBody: formatBody,
        formatRows: formatRows,
        formatRow: formatRow,
        formatValue: formatValue
      };
    }

    var csv = dsvFormat(",");

    var tsv = dsvFormat("\t");

    // https://github.com/d3/d3-dsv/issues/45
    var fixtz = new Date("2019-01-01T00:00").getHours() || new Date("2019-07-01T00:00").getHours();

    function tree_add(d) {
      var x = +this._x.call(null, d),
          y = +this._y.call(null, d);
      return add$2(this.cover(x, y), x, y, d);
    }

    function add$2(tree, x, y, d) {
      if (isNaN(x) || isNaN(y)) return tree; // ignore invalid points

      var parent,
          node = tree._root,
          leaf = {data: d},
          x0 = tree._x0,
          y0 = tree._y0,
          x1 = tree._x1,
          y1 = tree._y1,
          xm,
          ym,
          xp,
          yp,
          right,
          bottom,
          i,
          j;

      // If the tree is empty, initialize the root as a leaf.
      if (!node) return tree._root = leaf, tree;

      // Find the existing leaf for the new point, or add it.
      while (node.length) {
        if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
        if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
        if (parent = node, !(node = node[i = bottom << 1 | right])) return parent[i] = leaf, tree;
      }

      // Is the new point is exactly coincident with the existing point?
      xp = +tree._x.call(null, node.data);
      yp = +tree._y.call(null, node.data);
      if (x === xp && y === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;

      // Otherwise, split the leaf node until the old and new point are separated.
      do {
        parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
        if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
        if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
      } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | (xp >= xm)));
      return parent[j] = node, parent[i] = leaf, tree;
    }

    function addAll(data) {
      var d, i, n = data.length,
          x,
          y,
          xz = new Array(n),
          yz = new Array(n),
          x0 = Infinity,
          y0 = Infinity,
          x1 = -Infinity,
          y1 = -Infinity;

      // Compute the points and their extent.
      for (i = 0; i < n; ++i) {
        if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d))) continue;
        xz[i] = x;
        yz[i] = y;
        if (x < x0) x0 = x;
        if (x > x1) x1 = x;
        if (y < y0) y0 = y;
        if (y > y1) y1 = y;
      }

      // If there were no (valid) points, abort.
      if (x0 > x1 || y0 > y1) return this;

      // Expand the tree to cover the new points.
      this.cover(x0, y0).cover(x1, y1);

      // Add the new points.
      for (i = 0; i < n; ++i) {
        add$2(this, xz[i], yz[i], data[i]);
      }

      return this;
    }

    function tree_cover(x, y) {
      if (isNaN(x = +x) || isNaN(y = +y)) return this; // ignore invalid points

      var x0 = this._x0,
          y0 = this._y0,
          x1 = this._x1,
          y1 = this._y1;

      // If the quadtree has no extent, initialize them.
      // Integer extent are necessary so that if we later double the extent,
      // the existing quadrant boundaries don’t change due to floating point error!
      if (isNaN(x0)) {
        x1 = (x0 = Math.floor(x)) + 1;
        y1 = (y0 = Math.floor(y)) + 1;
      }

      // Otherwise, double repeatedly to cover.
      else {
        var z = x1 - x0,
            node = this._root,
            parent,
            i;

        while (x0 > x || x >= x1 || y0 > y || y >= y1) {
          i = (y < y0) << 1 | (x < x0);
          parent = new Array(4), parent[i] = node, node = parent, z *= 2;
          switch (i) {
            case 0: x1 = x0 + z, y1 = y0 + z; break;
            case 1: x0 = x1 - z, y1 = y0 + z; break;
            case 2: x1 = x0 + z, y0 = y1 - z; break;
            case 3: x0 = x1 - z, y0 = y1 - z; break;
          }
        }

        if (this._root && this._root.length) this._root = node;
      }

      this._x0 = x0;
      this._y0 = y0;
      this._x1 = x1;
      this._y1 = y1;
      return this;
    }

    function tree_data() {
      var data = [];
      this.visit(function(node) {
        if (!node.length) do data.push(node.data); while (node = node.next)
      });
      return data;
    }

    function tree_extent(_) {
      return arguments.length
          ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1])
          : isNaN(this._x0) ? undefined : [[this._x0, this._y0], [this._x1, this._y1]];
    }

    function Quad(node, x0, y0, x1, y1) {
      this.node = node;
      this.x0 = x0;
      this.y0 = y0;
      this.x1 = x1;
      this.y1 = y1;
    }

    function tree_find(x, y, radius) {
      var data,
          x0 = this._x0,
          y0 = this._y0,
          x1,
          y1,
          x2,
          y2,
          x3 = this._x1,
          y3 = this._y1,
          quads = [],
          node = this._root,
          q,
          i;

      if (node) quads.push(new Quad(node, x0, y0, x3, y3));
      if (radius == null) radius = Infinity;
      else {
        x0 = x - radius, y0 = y - radius;
        x3 = x + radius, y3 = y + radius;
        radius *= radius;
      }

      while (q = quads.pop()) {

        // Stop searching if this quadrant can’t contain a closer node.
        if (!(node = q.node)
            || (x1 = q.x0) > x3
            || (y1 = q.y0) > y3
            || (x2 = q.x1) < x0
            || (y2 = q.y1) < y0) continue;

        // Bisect the current quadrant.
        if (node.length) {
          var xm = (x1 + x2) / 2,
              ym = (y1 + y2) / 2;

          quads.push(
            new Quad(node[3], xm, ym, x2, y2),
            new Quad(node[2], x1, ym, xm, y2),
            new Quad(node[1], xm, y1, x2, ym),
            new Quad(node[0], x1, y1, xm, ym)
          );

          // Visit the closest quadrant first.
          if (i = (y >= ym) << 1 | (x >= xm)) {
            q = quads[quads.length - 1];
            quads[quads.length - 1] = quads[quads.length - 1 - i];
            quads[quads.length - 1 - i] = q;
          }
        }

        // Visit this point. (Visiting coincident points isn’t necessary!)
        else {
          var dx = x - +this._x.call(null, node.data),
              dy = y - +this._y.call(null, node.data),
              d2 = dx * dx + dy * dy;
          if (d2 < radius) {
            var d = Math.sqrt(radius = d2);
            x0 = x - d, y0 = y - d;
            x3 = x + d, y3 = y + d;
            data = node.data;
          }
        }
      }

      return data;
    }

    function tree_remove(d) {
      if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d))) return this; // ignore invalid points

      var parent,
          node = this._root,
          retainer,
          previous,
          next,
          x0 = this._x0,
          y0 = this._y0,
          x1 = this._x1,
          y1 = this._y1,
          x,
          y,
          xm,
          ym,
          right,
          bottom,
          i,
          j;

      // If the tree is empty, initialize the root as a leaf.
      if (!node) return this;

      // Find the leaf node for the point.
      // While descending, also retain the deepest parent with a non-removed sibling.
      if (node.length) while (true) {
        if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
        if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
        if (!(parent = node, node = node[i = bottom << 1 | right])) return this;
        if (!node.length) break;
        if (parent[(i + 1) & 3] || parent[(i + 2) & 3] || parent[(i + 3) & 3]) retainer = parent, j = i;
      }

      // Find the point to remove.
      while (node.data !== d) if (!(previous = node, node = node.next)) return this;
      if (next = node.next) delete node.next;

      // If there are multiple coincident points, remove just the point.
      if (previous) return (next ? previous.next = next : delete previous.next), this;

      // If this is the root point, remove it.
      if (!parent) return this._root = next, this;

      // Remove this leaf.
      next ? parent[i] = next : delete parent[i];

      // If the parent now contains exactly one leaf, collapse superfluous parents.
      if ((node = parent[0] || parent[1] || parent[2] || parent[3])
          && node === (parent[3] || parent[2] || parent[1] || parent[0])
          && !node.length) {
        if (retainer) retainer[j] = node;
        else this._root = node;
      }

      return this;
    }

    function removeAll(data) {
      for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);
      return this;
    }

    function tree_root() {
      return this._root;
    }

    function tree_size() {
      var size = 0;
      this.visit(function(node) {
        if (!node.length) do ++size; while (node = node.next)
      });
      return size;
    }

    function tree_visit(callback) {
      var quads = [], q, node = this._root, child, x0, y0, x1, y1;
      if (node) quads.push(new Quad(node, this._x0, this._y0, this._x1, this._y1));
      while (q = quads.pop()) {
        if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {
          var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
          if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
          if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
          if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
          if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
        }
      }
      return this;
    }

    function tree_visitAfter(callback) {
      var quads = [], next = [], q;
      if (this._root) quads.push(new Quad(this._root, this._x0, this._y0, this._x1, this._y1));
      while (q = quads.pop()) {
        var node = q.node;
        if (node.length) {
          var child, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
          if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
          if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
          if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
          if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
        }
        next.push(q);
      }
      while (q = next.pop()) {
        callback(q.node, q.x0, q.y0, q.x1, q.y1);
      }
      return this;
    }

    function defaultX$1(d) {
      return d[0];
    }

    function tree_x(_) {
      return arguments.length ? (this._x = _, this) : this._x;
    }

    function defaultY$1(d) {
      return d[1];
    }

    function tree_y(_) {
      return arguments.length ? (this._y = _, this) : this._y;
    }

    function quadtree(nodes, x, y) {
      var tree = new Quadtree(x == null ? defaultX$1 : x, y == null ? defaultY$1 : y, NaN, NaN, NaN, NaN);
      return nodes == null ? tree : tree.addAll(nodes);
    }

    function Quadtree(x, y, x0, y0, x1, y1) {
      this._x = x;
      this._y = y;
      this._x0 = x0;
      this._y0 = y0;
      this._x1 = x1;
      this._y1 = y1;
      this._root = undefined;
    }

    function leaf_copy(leaf) {
      var copy = {data: leaf.data}, next = copy;
      while (leaf = leaf.next) next = next.next = {data: leaf.data};
      return copy;
    }

    var treeProto = quadtree.prototype = Quadtree.prototype;

    treeProto.copy = function() {
      var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1),
          node = this._root,
          nodes,
          child;

      if (!node) return copy;

      if (!node.length) return copy._root = leaf_copy(node), copy;

      nodes = [{source: node, target: copy._root = new Array(4)}];
      while (node = nodes.pop()) {
        for (var i = 0; i < 4; ++i) {
          if (child = node.source[i]) {
            if (child.length) nodes.push({source: child, target: node.target[i] = new Array(4)});
            else node.target[i] = leaf_copy(child);
          }
        }
      }

      return copy;
    };

    treeProto.add = tree_add;
    treeProto.addAll = addAll;
    treeProto.cover = tree_cover;
    treeProto.data = tree_data;
    treeProto.extent = tree_extent;
    treeProto.find = tree_find;
    treeProto.remove = tree_remove;
    treeProto.removeAll = removeAll;
    treeProto.root = tree_root;
    treeProto.size = tree_size;
    treeProto.visit = tree_visit;
    treeProto.visitAfter = tree_visitAfter;
    treeProto.x = tree_x;
    treeProto.y = tree_y;

    var initialAngle = Math.PI * (3 - Math.sqrt(5));

    function formatDecimal(x) {
      return Math.abs(x = Math.round(x)) >= 1e21
          ? x.toLocaleString("en").replace(/,/g, "")
          : x.toString(10);
    }

    // Computes the decimal coefficient and exponent of the specified number x with
    // significant digits p, where x is positive and p is in [1, 21] or undefined.
    // For example, formatDecimalParts(1.23) returns ["123", 0].
    function formatDecimalParts(x, p) {
      if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, ±Infinity
      var i, coefficient = x.slice(0, i);

      // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
      // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
      return [
        coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
        +x.slice(i + 1)
      ];
    }

    function exponent$1(x) {
      return x = formatDecimalParts(Math.abs(x)), x ? x[1] : NaN;
    }

    function formatGroup(grouping, thousands) {
      return function(value, width) {
        var i = value.length,
            t = [],
            j = 0,
            g = grouping[0],
            length = 0;

        while (i > 0 && g > 0) {
          if (length + g + 1 > width) g = Math.max(1, width - length);
          t.push(value.substring(i -= g, i + g));
          if ((length += g + 1) > width) break;
          g = grouping[j = (j + 1) % grouping.length];
        }

        return t.reverse().join(thousands);
      };
    }

    function formatNumerals(numerals) {
      return function(value) {
        return value.replace(/[0-9]/g, function(i) {
          return numerals[+i];
        });
      };
    }

    // [[fill]align][sign][symbol][0][width][,][.precision][~][type]
    var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;

    function formatSpecifier(specifier) {
      if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
      var match;
      return new FormatSpecifier({
        fill: match[1],
        align: match[2],
        sign: match[3],
        symbol: match[4],
        zero: match[5],
        width: match[6],
        comma: match[7],
        precision: match[8] && match[8].slice(1),
        trim: match[9],
        type: match[10]
      });
    }

    formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

    function FormatSpecifier(specifier) {
      this.fill = specifier.fill === undefined ? " " : specifier.fill + "";
      this.align = specifier.align === undefined ? ">" : specifier.align + "";
      this.sign = specifier.sign === undefined ? "-" : specifier.sign + "";
      this.symbol = specifier.symbol === undefined ? "" : specifier.symbol + "";
      this.zero = !!specifier.zero;
      this.width = specifier.width === undefined ? undefined : +specifier.width;
      this.comma = !!specifier.comma;
      this.precision = specifier.precision === undefined ? undefined : +specifier.precision;
      this.trim = !!specifier.trim;
      this.type = specifier.type === undefined ? "" : specifier.type + "";
    }

    FormatSpecifier.prototype.toString = function() {
      return this.fill
          + this.align
          + this.sign
          + this.symbol
          + (this.zero ? "0" : "")
          + (this.width === undefined ? "" : Math.max(1, this.width | 0))
          + (this.comma ? "," : "")
          + (this.precision === undefined ? "" : "." + Math.max(0, this.precision | 0))
          + (this.trim ? "~" : "")
          + this.type;
    };

    // Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
    function formatTrim(s) {
      out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
        switch (s[i]) {
          case ".": i0 = i1 = i; break;
          case "0": if (i0 === 0) i0 = i; i1 = i; break;
          default: if (!+s[i]) break out; if (i0 > 0) i0 = 0; break;
        }
      }
      return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
    }

    var prefixExponent;

    function formatPrefixAuto(x, p) {
      var d = formatDecimalParts(x, p);
      if (!d) return x + "";
      var coefficient = d[0],
          exponent = d[1],
          i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
          n = coefficient.length;
      return i === n ? coefficient
          : i > n ? coefficient + new Array(i - n + 1).join("0")
          : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
          : "0." + new Array(1 - i).join("0") + formatDecimalParts(x, Math.max(0, p + i - 1))[0]; // less than 1y!
    }

    function formatRounded(x, p) {
      var d = formatDecimalParts(x, p);
      if (!d) return x + "";
      var coefficient = d[0],
          exponent = d[1];
      return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
          : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
          : coefficient + new Array(exponent - coefficient.length + 2).join("0");
    }

    var formatTypes = {
      "%": function(x, p) { return (x * 100).toFixed(p); },
      "b": function(x) { return Math.round(x).toString(2); },
      "c": function(x) { return x + ""; },
      "d": formatDecimal,
      "e": function(x, p) { return x.toExponential(p); },
      "f": function(x, p) { return x.toFixed(p); },
      "g": function(x, p) { return x.toPrecision(p); },
      "o": function(x) { return Math.round(x).toString(8); },
      "p": function(x, p) { return formatRounded(x * 100, p); },
      "r": formatRounded,
      "s": formatPrefixAuto,
      "X": function(x) { return Math.round(x).toString(16).toUpperCase(); },
      "x": function(x) { return Math.round(x).toString(16); }
    };

    function identity$3(x) {
      return x;
    }

    var map$3 = Array.prototype.map,
        prefixes = ["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"];

    function formatLocale(locale) {
      var group = locale.grouping === undefined || locale.thousands === undefined ? identity$3 : formatGroup(map$3.call(locale.grouping, Number), locale.thousands + ""),
          currencyPrefix = locale.currency === undefined ? "" : locale.currency[0] + "",
          currencySuffix = locale.currency === undefined ? "" : locale.currency[1] + "",
          decimal = locale.decimal === undefined ? "." : locale.decimal + "",
          numerals = locale.numerals === undefined ? identity$3 : formatNumerals(map$3.call(locale.numerals, String)),
          percent = locale.percent === undefined ? "%" : locale.percent + "",
          minus = locale.minus === undefined ? "-" : locale.minus + "",
          nan = locale.nan === undefined ? "NaN" : locale.nan + "";

      function newFormat(specifier) {
        specifier = formatSpecifier(specifier);

        var fill = specifier.fill,
            align = specifier.align,
            sign = specifier.sign,
            symbol = specifier.symbol,
            zero = specifier.zero,
            width = specifier.width,
            comma = specifier.comma,
            precision = specifier.precision,
            trim = specifier.trim,
            type = specifier.type;

        // The "n" type is an alias for ",g".
        if (type === "n") comma = true, type = "g";

        // The "" type, and any invalid type, is an alias for ".12~g".
        else if (!formatTypes[type]) precision === undefined && (precision = 12), trim = true, type = "g";

        // If zero fill is specified, padding goes after sign and before digits.
        if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

        // Compute the prefix and suffix.
        // For SI-prefix, the suffix is lazily computed.
        var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
            suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";

        // What format function should we use?
        // Is this an integer type?
        // Can this type generate exponential notation?
        var formatType = formatTypes[type],
            maybeSuffix = /[defgprs%]/.test(type);

        // Set the default precision if not specified,
        // or clamp the specified precision to the supported range.
        // For significant precision, it must be in [1, 21].
        // For fixed precision, it must be in [0, 20].
        precision = precision === undefined ? 6
            : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
            : Math.max(0, Math.min(20, precision));

        function format(value) {
          var valuePrefix = prefix,
              valueSuffix = suffix,
              i, n, c;

          if (type === "c") {
            valueSuffix = formatType(value) + valueSuffix;
            value = "";
          } else {
            value = +value;

            // Determine the sign. -0 is not less than 0, but 1 / -0 is!
            var valueNegative = value < 0 || 1 / value < 0;

            // Perform the initial formatting.
            value = isNaN(value) ? nan : formatType(Math.abs(value), precision);

            // Trim insignificant zeros.
            if (trim) value = formatTrim(value);

            // If a negative value rounds to zero after formatting, and no explicit positive sign is requested, hide the sign.
            if (valueNegative && +value === 0 && sign !== "+") valueNegative = false;

            // Compute the prefix and suffix.
            valuePrefix = (valueNegative ? (sign === "(" ? sign : minus) : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
            valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");

            // Break the formatted value into the integer “value” part that can be
            // grouped, and fractional or exponential “suffix” part that is not.
            if (maybeSuffix) {
              i = -1, n = value.length;
              while (++i < n) {
                if (c = value.charCodeAt(i), 48 > c || c > 57) {
                  valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
                  value = value.slice(0, i);
                  break;
                }
              }
            }
          }

          // If the fill character is not "0", grouping is applied before padding.
          if (comma && !zero) value = group(value, Infinity);

          // Compute the padding.
          var length = valuePrefix.length + value.length + valueSuffix.length,
              padding = length < width ? new Array(width - length + 1).join(fill) : "";

          // If the fill character is "0", grouping is applied after padding.
          if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

          // Reconstruct the final output based on the desired alignment.
          switch (align) {
            case "<": value = valuePrefix + value + valueSuffix + padding; break;
            case "=": value = valuePrefix + padding + value + valueSuffix; break;
            case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
            default: value = padding + valuePrefix + value + valueSuffix; break;
          }

          return numerals(value);
        }

        format.toString = function() {
          return specifier + "";
        };

        return format;
      }

      function formatPrefix(specifier, value) {
        var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)),
            e = Math.max(-8, Math.min(8, Math.floor(exponent$1(value) / 3))) * 3,
            k = Math.pow(10, -e),
            prefix = prefixes[8 + e / 3];
        return function(value) {
          return f(k * value) + prefix;
        };
      }

      return {
        format: newFormat,
        formatPrefix: formatPrefix
      };
    }

    var locale$1;
    var format$1;
    var formatPrefix;

    defaultLocale({
      decimal: ".",
      thousands: ",",
      grouping: [3],
      currency: ["$", ""],
      minus: "-"
    });

    function defaultLocale(definition) {
      locale$1 = formatLocale(definition);
      format$1 = locale$1.format;
      formatPrefix = locale$1.formatPrefix;
      return locale$1;
    }

    // Adds floating point numbers with twice the normal precision.
    // Reference: J. R. Shewchuk, Adaptive Precision Floating-Point Arithmetic and
    // Fast Robust Geometric Predicates, Discrete & Computational Geometry 18(3)
    // 305–363 (1997).
    // Code adapted from GeographicLib by Charles F. F. Karney,
    // http://geographiclib.sourceforge.net/

    function adder() {
      return new Adder;
    }

    function Adder() {
      this.reset();
    }

    Adder.prototype = {
      constructor: Adder,
      reset: function() {
        this.s = // rounded value
        this.t = 0; // exact error
      },
      add: function(y) {
        add$3(temp, y, this.t);
        add$3(this, temp.s, this.s);
        if (this.s) this.t += temp.t;
        else this.s = temp.t;
      },
      valueOf: function() {
        return this.s;
      }
    };

    var temp = new Adder;

    function add$3(adder, a, b) {
      var x = adder.s = a + b,
          bv = x - a,
          av = x - bv;
      adder.t = (a - av) + (b - bv);
    }

    var pi$3 = Math.PI;

    var areaRingSum = adder();

    var areaSum = adder();

    var deltaSum = adder();

    var sum$1 = adder();

    var lengthSum = adder();

    var areaSum$1 = adder(),
        areaRingSum$1 = adder();

    var lengthSum$1 = adder();

    // Returns the 2D cross product of AB and AC vectors, i.e., the z-component of

    function initRange(domain, range) {
      switch (arguments.length) {
        case 0: break;
        case 1: this.range(domain); break;
        default: this.range(range).domain(domain); break;
      }
      return this;
    }

    var array$3 = Array.prototype;
    var slice$5 = array$3.slice;

    var implicit = {name: "implicit"};

    function ordinal$1() {
      var index = map$2(),
          domain = [],
          range = [],
          unknown = implicit;

      function scale(d) {
        var key = d + "", i = index.get(key);
        if (!i) {
          if (unknown !== implicit) return unknown;
          index.set(key, i = domain.push(d));
        }
        return range[(i - 1) % range.length];
      }

      scale.domain = function(_) {
        if (!arguments.length) return domain.slice();
        domain = [], index = map$2();
        var i = -1, n = _.length, d, key;
        while (++i < n) if (!index.has(key = (d = _[i]) + "")) index.set(key, domain.push(d));
        return scale;
      };

      scale.range = function(_) {
        return arguments.length ? (range = slice$5.call(_), scale) : range.slice();
      };

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      scale.copy = function() {
        return ordinal$1(domain, range).unknown(unknown);
      };

      initRange.apply(scale, arguments);

      return scale;
    }

    var t0$1 = new Date,
        t1$1 = new Date;

    function newInterval(floori, offseti, count, field) {

      function interval(date) {
        return floori(date = arguments.length === 0 ? new Date : new Date(+date)), date;
      }

      interval.floor = function(date) {
        return floori(date = new Date(+date)), date;
      };

      interval.ceil = function(date) {
        return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
      };

      interval.round = function(date) {
        var d0 = interval(date),
            d1 = interval.ceil(date);
        return date - d0 < d1 - date ? d0 : d1;
      };

      interval.offset = function(date, step) {
        return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
      };

      interval.range = function(start, stop, step) {
        var range = [], previous;
        start = interval.ceil(start);
        step = step == null ? 1 : Math.floor(step);
        if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
        do range.push(previous = new Date(+start)), offseti(start, step), floori(start);
        while (previous < start && start < stop);
        return range;
      };

      interval.filter = function(test) {
        return newInterval(function(date) {
          if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);
        }, function(date, step) {
          if (date >= date) {
            if (step < 0) while (++step <= 0) {
              while (offseti(date, -1), !test(date)) {} // eslint-disable-line no-empty
            } else while (--step >= 0) {
              while (offseti(date, +1), !test(date)) {} // eslint-disable-line no-empty
            }
          }
        });
      };

      if (count) {
        interval.count = function(start, end) {
          t0$1.setTime(+start), t1$1.setTime(+end);
          floori(t0$1), floori(t1$1);
          return Math.floor(count(t0$1, t1$1));
        };

        interval.every = function(step) {
          step = Math.floor(step);
          return !isFinite(step) || !(step > 0) ? null
              : !(step > 1) ? interval
              : interval.filter(field
                  ? function(d) { return field(d) % step === 0; }
                  : function(d) { return interval.count(0, d) % step === 0; });
        };
      }

      return interval;
    }

    var millisecond = newInterval(function() {
      // noop
    }, function(date, step) {
      date.setTime(+date + step);
    }, function(start, end) {
      return end - start;
    });

    // An optimized implementation for this simple case.
    millisecond.every = function(k) {
      k = Math.floor(k);
      if (!isFinite(k) || !(k > 0)) return null;
      if (!(k > 1)) return millisecond;
      return newInterval(function(date) {
        date.setTime(Math.floor(date / k) * k);
      }, function(date, step) {
        date.setTime(+date + step * k);
      }, function(start, end) {
        return (end - start) / k;
      });
    };

    var durationSecond = 1e3;
    var durationMinute = 6e4;
    var durationHour = 36e5;
    var durationDay = 864e5;
    var durationWeek = 6048e5;

    var second = newInterval(function(date) {
      date.setTime(date - date.getMilliseconds());
    }, function(date, step) {
      date.setTime(+date + step * durationSecond);
    }, function(start, end) {
      return (end - start) / durationSecond;
    }, function(date) {
      return date.getUTCSeconds();
    });

    var minute = newInterval(function(date) {
      date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond);
    }, function(date, step) {
      date.setTime(+date + step * durationMinute);
    }, function(start, end) {
      return (end - start) / durationMinute;
    }, function(date) {
      return date.getMinutes();
    });

    var hour = newInterval(function(date) {
      date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond - date.getMinutes() * durationMinute);
    }, function(date, step) {
      date.setTime(+date + step * durationHour);
    }, function(start, end) {
      return (end - start) / durationHour;
    }, function(date) {
      return date.getHours();
    });

    var day = newInterval(function(date) {
      date.setHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setDate(date.getDate() + step);
    }, function(start, end) {
      return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay;
    }, function(date) {
      return date.getDate() - 1;
    });

    function weekday(i) {
      return newInterval(function(date) {
        date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
        date.setHours(0, 0, 0, 0);
      }, function(date, step) {
        date.setDate(date.getDate() + step * 7);
      }, function(start, end) {
        return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
      });
    }

    var sunday = weekday(0);
    var monday = weekday(1);
    var tuesday = weekday(2);
    var wednesday = weekday(3);
    var thursday = weekday(4);
    var friday = weekday(5);
    var saturday = weekday(6);

    var month = newInterval(function(date) {
      date.setDate(1);
      date.setHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setMonth(date.getMonth() + step);
    }, function(start, end) {
      return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
    }, function(date) {
      return date.getMonth();
    });

    var year = newInterval(function(date) {
      date.setMonth(0, 1);
      date.setHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setFullYear(date.getFullYear() + step);
    }, function(start, end) {
      return end.getFullYear() - start.getFullYear();
    }, function(date) {
      return date.getFullYear();
    });

    // An optimized implementation for this simple case.
    year.every = function(k) {
      return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
        date.setFullYear(Math.floor(date.getFullYear() / k) * k);
        date.setMonth(0, 1);
        date.setHours(0, 0, 0, 0);
      }, function(date, step) {
        date.setFullYear(date.getFullYear() + step * k);
      });
    };

    var utcMinute = newInterval(function(date) {
      date.setUTCSeconds(0, 0);
    }, function(date, step) {
      date.setTime(+date + step * durationMinute);
    }, function(start, end) {
      return (end - start) / durationMinute;
    }, function(date) {
      return date.getUTCMinutes();
    });

    var utcHour = newInterval(function(date) {
      date.setUTCMinutes(0, 0, 0);
    }, function(date, step) {
      date.setTime(+date + step * durationHour);
    }, function(start, end) {
      return (end - start) / durationHour;
    }, function(date) {
      return date.getUTCHours();
    });

    var utcDay = newInterval(function(date) {
      date.setUTCHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setUTCDate(date.getUTCDate() + step);
    }, function(start, end) {
      return (end - start) / durationDay;
    }, function(date) {
      return date.getUTCDate() - 1;
    });

    function utcWeekday(i) {
      return newInterval(function(date) {
        date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
        date.setUTCHours(0, 0, 0, 0);
      }, function(date, step) {
        date.setUTCDate(date.getUTCDate() + step * 7);
      }, function(start, end) {
        return (end - start) / durationWeek;
      });
    }

    var utcSunday = utcWeekday(0);
    var utcMonday = utcWeekday(1);
    var utcTuesday = utcWeekday(2);
    var utcWednesday = utcWeekday(3);
    var utcThursday = utcWeekday(4);
    var utcFriday = utcWeekday(5);
    var utcSaturday = utcWeekday(6);

    var utcMonth = newInterval(function(date) {
      date.setUTCDate(1);
      date.setUTCHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setUTCMonth(date.getUTCMonth() + step);
    }, function(start, end) {
      return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
    }, function(date) {
      return date.getUTCMonth();
    });

    var utcYear = newInterval(function(date) {
      date.setUTCMonth(0, 1);
      date.setUTCHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setUTCFullYear(date.getUTCFullYear() + step);
    }, function(start, end) {
      return end.getUTCFullYear() - start.getUTCFullYear();
    }, function(date) {
      return date.getUTCFullYear();
    });

    // An optimized implementation for this simple case.
    utcYear.every = function(k) {
      return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
        date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
        date.setUTCMonth(0, 1);
        date.setUTCHours(0, 0, 0, 0);
      }, function(date, step) {
        date.setUTCFullYear(date.getUTCFullYear() + step * k);
      });
    };

    function localDate(d) {
      if (0 <= d.y && d.y < 100) {
        var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
        date.setFullYear(d.y);
        return date;
      }
      return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
    }

    function utcDate(d) {
      if (0 <= d.y && d.y < 100) {
        var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
        date.setUTCFullYear(d.y);
        return date;
      }
      return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
    }

    function newDate(y, m, d) {
      return {y: y, m: m, d: d, H: 0, M: 0, S: 0, L: 0};
    }

    function formatLocale$1(locale) {
      var locale_dateTime = locale.dateTime,
          locale_date = locale.date,
          locale_time = locale.time,
          locale_periods = locale.periods,
          locale_weekdays = locale.days,
          locale_shortWeekdays = locale.shortDays,
          locale_months = locale.months,
          locale_shortMonths = locale.shortMonths;

      var periodRe = formatRe(locale_periods),
          periodLookup = formatLookup(locale_periods),
          weekdayRe = formatRe(locale_weekdays),
          weekdayLookup = formatLookup(locale_weekdays),
          shortWeekdayRe = formatRe(locale_shortWeekdays),
          shortWeekdayLookup = formatLookup(locale_shortWeekdays),
          monthRe = formatRe(locale_months),
          monthLookup = formatLookup(locale_months),
          shortMonthRe = formatRe(locale_shortMonths),
          shortMonthLookup = formatLookup(locale_shortMonths);

      var formats = {
        "a": formatShortWeekday,
        "A": formatWeekday,
        "b": formatShortMonth,
        "B": formatMonth,
        "c": null,
        "d": formatDayOfMonth,
        "e": formatDayOfMonth,
        "f": formatMicroseconds,
        "g": formatYearISO,
        "G": formatFullYearISO,
        "H": formatHour24,
        "I": formatHour12,
        "j": formatDayOfYear,
        "L": formatMilliseconds,
        "m": formatMonthNumber,
        "M": formatMinutes,
        "p": formatPeriod,
        "q": formatQuarter,
        "Q": formatUnixTimestamp,
        "s": formatUnixTimestampSeconds,
        "S": formatSeconds,
        "u": formatWeekdayNumberMonday,
        "U": formatWeekNumberSunday,
        "V": formatWeekNumberISO,
        "w": formatWeekdayNumberSunday,
        "W": formatWeekNumberMonday,
        "x": null,
        "X": null,
        "y": formatYear$1,
        "Y": formatFullYear,
        "Z": formatZone,
        "%": formatLiteralPercent
      };

      var utcFormats = {
        "a": formatUTCShortWeekday,
        "A": formatUTCWeekday,
        "b": formatUTCShortMonth,
        "B": formatUTCMonth,
        "c": null,
        "d": formatUTCDayOfMonth,
        "e": formatUTCDayOfMonth,
        "f": formatUTCMicroseconds,
        "g": formatUTCYearISO,
        "G": formatUTCFullYearISO,
        "H": formatUTCHour24,
        "I": formatUTCHour12,
        "j": formatUTCDayOfYear,
        "L": formatUTCMilliseconds,
        "m": formatUTCMonthNumber,
        "M": formatUTCMinutes,
        "p": formatUTCPeriod,
        "q": formatUTCQuarter,
        "Q": formatUnixTimestamp,
        "s": formatUnixTimestampSeconds,
        "S": formatUTCSeconds,
        "u": formatUTCWeekdayNumberMonday,
        "U": formatUTCWeekNumberSunday,
        "V": formatUTCWeekNumberISO,
        "w": formatUTCWeekdayNumberSunday,
        "W": formatUTCWeekNumberMonday,
        "x": null,
        "X": null,
        "y": formatUTCYear,
        "Y": formatUTCFullYear,
        "Z": formatUTCZone,
        "%": formatLiteralPercent
      };

      var parses = {
        "a": parseShortWeekday,
        "A": parseWeekday,
        "b": parseShortMonth,
        "B": parseMonth,
        "c": parseLocaleDateTime,
        "d": parseDayOfMonth,
        "e": parseDayOfMonth,
        "f": parseMicroseconds,
        "g": parseYear,
        "G": parseFullYear,
        "H": parseHour24,
        "I": parseHour24,
        "j": parseDayOfYear,
        "L": parseMilliseconds,
        "m": parseMonthNumber,
        "M": parseMinutes,
        "p": parsePeriod,
        "q": parseQuarter,
        "Q": parseUnixTimestamp,
        "s": parseUnixTimestampSeconds,
        "S": parseSeconds,
        "u": parseWeekdayNumberMonday,
        "U": parseWeekNumberSunday,
        "V": parseWeekNumberISO,
        "w": parseWeekdayNumberSunday,
        "W": parseWeekNumberMonday,
        "x": parseLocaleDate,
        "X": parseLocaleTime,
        "y": parseYear,
        "Y": parseFullYear,
        "Z": parseZone,
        "%": parseLiteralPercent
      };

      // These recursive directive definitions must be deferred.
      formats.x = newFormat(locale_date, formats);
      formats.X = newFormat(locale_time, formats);
      formats.c = newFormat(locale_dateTime, formats);
      utcFormats.x = newFormat(locale_date, utcFormats);
      utcFormats.X = newFormat(locale_time, utcFormats);
      utcFormats.c = newFormat(locale_dateTime, utcFormats);

      function newFormat(specifier, formats) {
        return function(date) {
          var string = [],
              i = -1,
              j = 0,
              n = specifier.length,
              c,
              pad,
              format;

          if (!(date instanceof Date)) date = new Date(+date);

          while (++i < n) {
            if (specifier.charCodeAt(i) === 37) {
              string.push(specifier.slice(j, i));
              if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);
              else pad = c === "e" ? " " : "0";
              if (format = formats[c]) c = format(date, pad);
              string.push(c);
              j = i + 1;
            }
          }

          string.push(specifier.slice(j, i));
          return string.join("");
        };
      }

      function newParse(specifier, Z) {
        return function(string) {
          var d = newDate(1900, undefined, 1),
              i = parseSpecifier(d, specifier, string += "", 0),
              week, day$$1;
          if (i != string.length) return null;

          // If a UNIX timestamp is specified, return it.
          if ("Q" in d) return new Date(d.Q);
          if ("s" in d) return new Date(d.s * 1000 + ("L" in d ? d.L : 0));

          // If this is utcParse, never use the local timezone.
          if (Z && !("Z" in d)) d.Z = 0;

          // The am-pm flag is 0 for AM, and 1 for PM.
          if ("p" in d) d.H = d.H % 12 + d.p * 12;

          // If the month was not specified, inherit from the quarter.
          if (d.m === undefined) d.m = "q" in d ? d.q : 0;

          // Convert day-of-week and week-of-year to day-of-year.
          if ("V" in d) {
            if (d.V < 1 || d.V > 53) return null;
            if (!("w" in d)) d.w = 1;
            if ("Z" in d) {
              week = utcDate(newDate(d.y, 0, 1)), day$$1 = week.getUTCDay();
              week = day$$1 > 4 || day$$1 === 0 ? utcMonday.ceil(week) : utcMonday(week);
              week = utcDay.offset(week, (d.V - 1) * 7);
              d.y = week.getUTCFullYear();
              d.m = week.getUTCMonth();
              d.d = week.getUTCDate() + (d.w + 6) % 7;
            } else {
              week = localDate(newDate(d.y, 0, 1)), day$$1 = week.getDay();
              week = day$$1 > 4 || day$$1 === 0 ? monday.ceil(week) : monday(week);
              week = day.offset(week, (d.V - 1) * 7);
              d.y = week.getFullYear();
              d.m = week.getMonth();
              d.d = week.getDate() + (d.w + 6) % 7;
            }
          } else if ("W" in d || "U" in d) {
            if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
            day$$1 = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
            d.m = 0;
            d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day$$1 + 5) % 7 : d.w + d.U * 7 - (day$$1 + 6) % 7;
          }

          // If a time zone is specified, all fields are interpreted as UTC and then
          // offset according to the specified time zone.
          if ("Z" in d) {
            d.H += d.Z / 100 | 0;
            d.M += d.Z % 100;
            return utcDate(d);
          }

          // Otherwise, all fields are in local time.
          return localDate(d);
        };
      }

      function parseSpecifier(d, specifier, string, j) {
        var i = 0,
            n = specifier.length,
            m = string.length,
            c,
            parse;

        while (i < n) {
          if (j >= m) return -1;
          c = specifier.charCodeAt(i++);
          if (c === 37) {
            c = specifier.charAt(i++);
            parse = parses[c in pads ? specifier.charAt(i++) : c];
            if (!parse || ((j = parse(d, string, j)) < 0)) return -1;
          } else if (c != string.charCodeAt(j++)) {
            return -1;
          }
        }

        return j;
      }

      function parsePeriod(d, string, i) {
        var n = periodRe.exec(string.slice(i));
        return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;
      }

      function parseShortWeekday(d, string, i) {
        var n = shortWeekdayRe.exec(string.slice(i));
        return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
      }

      function parseWeekday(d, string, i) {
        var n = weekdayRe.exec(string.slice(i));
        return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
      }

      function parseShortMonth(d, string, i) {
        var n = shortMonthRe.exec(string.slice(i));
        return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
      }

      function parseMonth(d, string, i) {
        var n = monthRe.exec(string.slice(i));
        return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
      }

      function parseLocaleDateTime(d, string, i) {
        return parseSpecifier(d, locale_dateTime, string, i);
      }

      function parseLocaleDate(d, string, i) {
        return parseSpecifier(d, locale_date, string, i);
      }

      function parseLocaleTime(d, string, i) {
        return parseSpecifier(d, locale_time, string, i);
      }

      function formatShortWeekday(d) {
        return locale_shortWeekdays[d.getDay()];
      }

      function formatWeekday(d) {
        return locale_weekdays[d.getDay()];
      }

      function formatShortMonth(d) {
        return locale_shortMonths[d.getMonth()];
      }

      function formatMonth(d) {
        return locale_months[d.getMonth()];
      }

      function formatPeriod(d) {
        return locale_periods[+(d.getHours() >= 12)];
      }

      function formatQuarter(d) {
        return 1 + ~~(d.getMonth() / 3);
      }

      function formatUTCShortWeekday(d) {
        return locale_shortWeekdays[d.getUTCDay()];
      }

      function formatUTCWeekday(d) {
        return locale_weekdays[d.getUTCDay()];
      }

      function formatUTCShortMonth(d) {
        return locale_shortMonths[d.getUTCMonth()];
      }

      function formatUTCMonth(d) {
        return locale_months[d.getUTCMonth()];
      }

      function formatUTCPeriod(d) {
        return locale_periods[+(d.getUTCHours() >= 12)];
      }

      function formatUTCQuarter(d) {
        return 1 + ~~(d.getUTCMonth() / 3);
      }

      return {
        format: function(specifier) {
          var f = newFormat(specifier += "", formats);
          f.toString = function() { return specifier; };
          return f;
        },
        parse: function(specifier) {
          var p = newParse(specifier += "", false);
          p.toString = function() { return specifier; };
          return p;
        },
        utcFormat: function(specifier) {
          var f = newFormat(specifier += "", utcFormats);
          f.toString = function() { return specifier; };
          return f;
        },
        utcParse: function(specifier) {
          var p = newParse(specifier += "", true);
          p.toString = function() { return specifier; };
          return p;
        }
      };
    }

    var pads = {"-": "", "_": " ", "0": "0"},
        numberRe = /^\s*\d+/, // note: ignores next directive
        percentRe = /^%/,
        requoteRe = /[\\^$*+?|[\]().{}]/g;

    function pad$1(value, fill, width) {
      var sign = value < 0 ? "-" : "",
          string = (sign ? -value : value) + "",
          length = string.length;
      return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
    }

    function requote(s) {
      return s.replace(requoteRe, "\\$&");
    }

    function formatRe(names) {
      return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
    }

    function formatLookup(names) {
      var map = {}, i = -1, n = names.length;
      while (++i < n) map[names[i].toLowerCase()] = i;
      return map;
    }

    function parseWeekdayNumberSunday(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 1));
      return n ? (d.w = +n[0], i + n[0].length) : -1;
    }

    function parseWeekdayNumberMonday(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 1));
      return n ? (d.u = +n[0], i + n[0].length) : -1;
    }

    function parseWeekNumberSunday(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.U = +n[0], i + n[0].length) : -1;
    }

    function parseWeekNumberISO(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.V = +n[0], i + n[0].length) : -1;
    }

    function parseWeekNumberMonday(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.W = +n[0], i + n[0].length) : -1;
    }

    function parseFullYear(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 4));
      return n ? (d.y = +n[0], i + n[0].length) : -1;
    }

    function parseYear(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
    }

    function parseZone(d, string, i) {
      var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
      return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
    }

    function parseQuarter(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 1));
      return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
    }

    function parseMonthNumber(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
    }

    function parseDayOfMonth(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.d = +n[0], i + n[0].length) : -1;
    }

    function parseDayOfYear(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 3));
      return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
    }

    function parseHour24(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.H = +n[0], i + n[0].length) : -1;
    }

    function parseMinutes(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.M = +n[0], i + n[0].length) : -1;
    }

    function parseSeconds(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.S = +n[0], i + n[0].length) : -1;
    }

    function parseMilliseconds(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 3));
      return n ? (d.L = +n[0], i + n[0].length) : -1;
    }

    function parseMicroseconds(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 6));
      return n ? (d.L = Math.floor(n[0] / 1000), i + n[0].length) : -1;
    }

    function parseLiteralPercent(d, string, i) {
      var n = percentRe.exec(string.slice(i, i + 1));
      return n ? i + n[0].length : -1;
    }

    function parseUnixTimestamp(d, string, i) {
      var n = numberRe.exec(string.slice(i));
      return n ? (d.Q = +n[0], i + n[0].length) : -1;
    }

    function parseUnixTimestampSeconds(d, string, i) {
      var n = numberRe.exec(string.slice(i));
      return n ? (d.s = +n[0], i + n[0].length) : -1;
    }

    function formatDayOfMonth(d, p) {
      return pad$1(d.getDate(), p, 2);
    }

    function formatHour24(d, p) {
      return pad$1(d.getHours(), p, 2);
    }

    function formatHour12(d, p) {
      return pad$1(d.getHours() % 12 || 12, p, 2);
    }

    function formatDayOfYear(d, p) {
      return pad$1(1 + day.count(year(d), d), p, 3);
    }

    function formatMilliseconds(d, p) {
      return pad$1(d.getMilliseconds(), p, 3);
    }

    function formatMicroseconds(d, p) {
      return formatMilliseconds(d, p) + "000";
    }

    function formatMonthNumber(d, p) {
      return pad$1(d.getMonth() + 1, p, 2);
    }

    function formatMinutes(d, p) {
      return pad$1(d.getMinutes(), p, 2);
    }

    function formatSeconds(d, p) {
      return pad$1(d.getSeconds(), p, 2);
    }

    function formatWeekdayNumberMonday(d) {
      var day$$1 = d.getDay();
      return day$$1 === 0 ? 7 : day$$1;
    }

    function formatWeekNumberSunday(d, p) {
      return pad$1(sunday.count(year(d) - 1, d), p, 2);
    }

    function dISO(d) {
      var day$$1 = d.getDay();
      return (day$$1 >= 4 || day$$1 === 0) ? thursday(d) : thursday.ceil(d);
    }

    function formatWeekNumberISO(d, p) {
      d = dISO(d);
      return pad$1(thursday.count(year(d), d) + (year(d).getDay() === 4), p, 2);
    }

    function formatWeekdayNumberSunday(d) {
      return d.getDay();
    }

    function formatWeekNumberMonday(d, p) {
      return pad$1(monday.count(year(d) - 1, d), p, 2);
    }

    function formatYear$1(d, p) {
      return pad$1(d.getFullYear() % 100, p, 2);
    }

    function formatYearISO(d, p) {
      d = dISO(d);
      return pad$1(d.getFullYear() % 100, p, 2);
    }

    function formatFullYear(d, p) {
      return pad$1(d.getFullYear() % 10000, p, 4);
    }

    function formatFullYearISO(d, p) {
      var day$$1 = d.getDay();
      d = (day$$1 >= 4 || day$$1 === 0) ? thursday(d) : thursday.ceil(d);
      return pad$1(d.getFullYear() % 10000, p, 4);
    }

    function formatZone(d) {
      var z = d.getTimezoneOffset();
      return (z > 0 ? "-" : (z *= -1, "+"))
          + pad$1(z / 60 | 0, "0", 2)
          + pad$1(z % 60, "0", 2);
    }

    function formatUTCDayOfMonth(d, p) {
      return pad$1(d.getUTCDate(), p, 2);
    }

    function formatUTCHour24(d, p) {
      return pad$1(d.getUTCHours(), p, 2);
    }

    function formatUTCHour12(d, p) {
      return pad$1(d.getUTCHours() % 12 || 12, p, 2);
    }

    function formatUTCDayOfYear(d, p) {
      return pad$1(1 + utcDay.count(utcYear(d), d), p, 3);
    }

    function formatUTCMilliseconds(d, p) {
      return pad$1(d.getUTCMilliseconds(), p, 3);
    }

    function formatUTCMicroseconds(d, p) {
      return formatUTCMilliseconds(d, p) + "000";
    }

    function formatUTCMonthNumber(d, p) {
      return pad$1(d.getUTCMonth() + 1, p, 2);
    }

    function formatUTCMinutes(d, p) {
      return pad$1(d.getUTCMinutes(), p, 2);
    }

    function formatUTCSeconds(d, p) {
      return pad$1(d.getUTCSeconds(), p, 2);
    }

    function formatUTCWeekdayNumberMonday(d) {
      var dow = d.getUTCDay();
      return dow === 0 ? 7 : dow;
    }

    function formatUTCWeekNumberSunday(d, p) {
      return pad$1(utcSunday.count(utcYear(d) - 1, d), p, 2);
    }

    function UTCdISO(d) {
      var day$$1 = d.getUTCDay();
      return (day$$1 >= 4 || day$$1 === 0) ? utcThursday(d) : utcThursday.ceil(d);
    }

    function formatUTCWeekNumberISO(d, p) {
      d = UTCdISO(d);
      return pad$1(utcThursday.count(utcYear(d), d) + (utcYear(d).getUTCDay() === 4), p, 2);
    }

    function formatUTCWeekdayNumberSunday(d) {
      return d.getUTCDay();
    }

    function formatUTCWeekNumberMonday(d, p) {
      return pad$1(utcMonday.count(utcYear(d) - 1, d), p, 2);
    }

    function formatUTCYear(d, p) {
      return pad$1(d.getUTCFullYear() % 100, p, 2);
    }

    function formatUTCYearISO(d, p) {
      d = UTCdISO(d);
      return pad$1(d.getUTCFullYear() % 100, p, 2);
    }

    function formatUTCFullYear(d, p) {
      return pad$1(d.getUTCFullYear() % 10000, p, 4);
    }

    function formatUTCFullYearISO(d, p) {
      var day$$1 = d.getUTCDay();
      d = (day$$1 >= 4 || day$$1 === 0) ? utcThursday(d) : utcThursday.ceil(d);
      return pad$1(d.getUTCFullYear() % 10000, p, 4);
    }

    function formatUTCZone() {
      return "+0000";
    }

    function formatLiteralPercent() {
      return "%";
    }

    function formatUnixTimestamp(d) {
      return +d;
    }

    function formatUnixTimestampSeconds(d) {
      return Math.floor(+d / 1000);
    }

    var locale$2;
    var timeFormat;
    var timeParse;
    var utcFormat;
    var utcParse;

    defaultLocale$1({
      dateTime: "%x, %X",
      date: "%-m/%-d/%Y",
      time: "%-I:%M:%S %p",
      periods: ["AM", "PM"],
      days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
      shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
      months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
      shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
    });

    function defaultLocale$1(definition) {
      locale$2 = formatLocale$1(definition);
      timeFormat = locale$2.format;
      timeParse = locale$2.parse;
      utcFormat = locale$2.utcFormat;
      utcParse = locale$2.utcParse;
      return locale$2;
    }

    var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";

    function formatIsoNative(date) {
      return date.toISOString();
    }

    var formatIso = Date.prototype.toISOString
        ? formatIsoNative
        : utcFormat(isoSpecifier);

    function parseIsoNative(string) {
      var date = new Date(string);
      return isNaN(date) ? null : date;
    }

    var parseIso$1 = +new Date("2000-01-01T00:00:00.000Z")
        ? parseIsoNative
        : utcParse(isoSpecifier);

    function colors(specifier) {
      var n = specifier.length / 6 | 0, colors = new Array(n), i = 0;
      while (i < n) colors[i] = "#" + specifier.slice(i * 6, ++i * 6);
      return colors;
    }

    var category10 = colors("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");

    colors("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666");

    colors("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666");

    colors("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928");

    colors("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2");

    colors("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc");

    colors("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999");

    colors("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3");

    colors("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f");

    colors("4e79a7f28e2ce1575976b7b259a14fedc949af7aa1ff9da79c755fbab0ab");

    function ramp(scheme) {
      return rgbBasis(scheme[scheme.length - 1]);
    }

    var scheme = new Array(3).concat(
      "d8b365f5f5f55ab4ac",
      "a6611adfc27d80cdc1018571",
      "a6611adfc27df5f5f580cdc1018571",
      "8c510ad8b365f6e8c3c7eae55ab4ac01665e",
      "8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e",
      "8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e",
      "8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e",
      "5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30",
      "5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30"
    ).map(colors);

    ramp(scheme);

    var scheme$1 = new Array(3).concat(
      "af8dc3f7f7f77fbf7b",
      "7b3294c2a5cfa6dba0008837",
      "7b3294c2a5cff7f7f7a6dba0008837",
      "762a83af8dc3e7d4e8d9f0d37fbf7b1b7837",
      "762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837",
      "762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837",
      "762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837",
      "40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b",
      "40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b"
    ).map(colors);

    ramp(scheme$1);

    var scheme$2 = new Array(3).concat(
      "e9a3c9f7f7f7a1d76a",
      "d01c8bf1b6dab8e1864dac26",
      "d01c8bf1b6daf7f7f7b8e1864dac26",
      "c51b7de9a3c9fde0efe6f5d0a1d76a4d9221",
      "c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221",
      "c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221",
      "c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221",
      "8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419",
      "8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419"
    ).map(colors);

    ramp(scheme$2);

    var scheme$3 = new Array(3).concat(
      "998ec3f7f7f7f1a340",
      "5e3c99b2abd2fdb863e66101",
      "5e3c99b2abd2f7f7f7fdb863e66101",
      "542788998ec3d8daebfee0b6f1a340b35806",
      "542788998ec3d8daebf7f7f7fee0b6f1a340b35806",
      "5427888073acb2abd2d8daebfee0b6fdb863e08214b35806",
      "5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806",
      "2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08",
      "2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08"
    ).map(colors);

    ramp(scheme$3);

    var scheme$4 = new Array(3).concat(
      "ef8a62f7f7f767a9cf",
      "ca0020f4a58292c5de0571b0",
      "ca0020f4a582f7f7f792c5de0571b0",
      "b2182bef8a62fddbc7d1e5f067a9cf2166ac",
      "b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac",
      "b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac",
      "b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac",
      "67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061",
      "67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061"
    ).map(colors);

    ramp(scheme$4);

    var scheme$5 = new Array(3).concat(
      "ef8a62ffffff999999",
      "ca0020f4a582bababa404040",
      "ca0020f4a582ffffffbababa404040",
      "b2182bef8a62fddbc7e0e0e09999994d4d4d",
      "b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d",
      "b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d",
      "b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d",
      "67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a",
      "67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a"
    ).map(colors);

    ramp(scheme$5);

    var scheme$6 = new Array(3).concat(
      "fc8d59ffffbf91bfdb",
      "d7191cfdae61abd9e92c7bb6",
      "d7191cfdae61ffffbfabd9e92c7bb6",
      "d73027fc8d59fee090e0f3f891bfdb4575b4",
      "d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4",
      "d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4",
      "d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4",
      "a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695",
      "a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695"
    ).map(colors);

    ramp(scheme$6);

    var scheme$7 = new Array(3).concat(
      "fc8d59ffffbf91cf60",
      "d7191cfdae61a6d96a1a9641",
      "d7191cfdae61ffffbfa6d96a1a9641",
      "d73027fc8d59fee08bd9ef8b91cf601a9850",
      "d73027fc8d59fee08bffffbfd9ef8b91cf601a9850",
      "d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850",
      "d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850",
      "a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837",
      "a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837"
    ).map(colors);

    ramp(scheme$7);

    var scheme$8 = new Array(3).concat(
      "fc8d59ffffbf99d594",
      "d7191cfdae61abdda42b83ba",
      "d7191cfdae61ffffbfabdda42b83ba",
      "d53e4ffc8d59fee08be6f59899d5943288bd",
      "d53e4ffc8d59fee08bffffbfe6f59899d5943288bd",
      "d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd",
      "d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd",
      "9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2",
      "9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2"
    ).map(colors);

    ramp(scheme$8);

    var scheme$9 = new Array(3).concat(
      "e5f5f999d8c92ca25f",
      "edf8fbb2e2e266c2a4238b45",
      "edf8fbb2e2e266c2a42ca25f006d2c",
      "edf8fbccece699d8c966c2a42ca25f006d2c",
      "edf8fbccece699d8c966c2a441ae76238b45005824",
      "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824",
      "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b"
    ).map(colors);

    ramp(scheme$9);

    var scheme$a = new Array(3).concat(
      "e0ecf49ebcda8856a7",
      "edf8fbb3cde38c96c688419d",
      "edf8fbb3cde38c96c68856a7810f7c",
      "edf8fbbfd3e69ebcda8c96c68856a7810f7c",
      "edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b",
      "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b",
      "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b"
    ).map(colors);

    ramp(scheme$a);

    var scheme$b = new Array(3).concat(
      "e0f3dba8ddb543a2ca",
      "f0f9e8bae4bc7bccc42b8cbe",
      "f0f9e8bae4bc7bccc443a2ca0868ac",
      "f0f9e8ccebc5a8ddb57bccc443a2ca0868ac",
      "f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e",
      "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e",
      "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081"
    ).map(colors);

    ramp(scheme$b);

    var scheme$c = new Array(3).concat(
      "fee8c8fdbb84e34a33",
      "fef0d9fdcc8afc8d59d7301f",
      "fef0d9fdcc8afc8d59e34a33b30000",
      "fef0d9fdd49efdbb84fc8d59e34a33b30000",
      "fef0d9fdd49efdbb84fc8d59ef6548d7301f990000",
      "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000",
      "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000"
    ).map(colors);

    ramp(scheme$c);

    var scheme$d = new Array(3).concat(
      "ece2f0a6bddb1c9099",
      "f6eff7bdc9e167a9cf02818a",
      "f6eff7bdc9e167a9cf1c9099016c59",
      "f6eff7d0d1e6a6bddb67a9cf1c9099016c59",
      "f6eff7d0d1e6a6bddb67a9cf3690c002818a016450",
      "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450",
      "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636"
    ).map(colors);

    ramp(scheme$d);

    var scheme$e = new Array(3).concat(
      "ece7f2a6bddb2b8cbe",
      "f1eef6bdc9e174a9cf0570b0",
      "f1eef6bdc9e174a9cf2b8cbe045a8d",
      "f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d",
      "f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b",
      "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b",
      "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858"
    ).map(colors);

    ramp(scheme$e);

    var scheme$f = new Array(3).concat(
      "e7e1efc994c7dd1c77",
      "f1eef6d7b5d8df65b0ce1256",
      "f1eef6d7b5d8df65b0dd1c77980043",
      "f1eef6d4b9dac994c7df65b0dd1c77980043",
      "f1eef6d4b9dac994c7df65b0e7298ace125691003f",
      "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f",
      "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f"
    ).map(colors);

    ramp(scheme$f);

    var scheme$g = new Array(3).concat(
      "fde0ddfa9fb5c51b8a",
      "feebe2fbb4b9f768a1ae017e",
      "feebe2fbb4b9f768a1c51b8a7a0177",
      "feebe2fcc5c0fa9fb5f768a1c51b8a7a0177",
      "feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177",
      "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177",
      "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a"
    ).map(colors);

    ramp(scheme$g);

    var scheme$h = new Array(3).concat(
      "edf8b17fcdbb2c7fb8",
      "ffffcca1dab441b6c4225ea8",
      "ffffcca1dab441b6c42c7fb8253494",
      "ffffccc7e9b47fcdbb41b6c42c7fb8253494",
      "ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84",
      "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84",
      "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58"
    ).map(colors);

    ramp(scheme$h);

    var scheme$i = new Array(3).concat(
      "f7fcb9addd8e31a354",
      "ffffccc2e69978c679238443",
      "ffffccc2e69978c67931a354006837",
      "ffffccd9f0a3addd8e78c67931a354006837",
      "ffffccd9f0a3addd8e78c67941ab5d238443005a32",
      "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32",
      "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529"
    ).map(colors);

    ramp(scheme$i);

    var scheme$j = new Array(3).concat(
      "fff7bcfec44fd95f0e",
      "ffffd4fed98efe9929cc4c02",
      "ffffd4fed98efe9929d95f0e993404",
      "ffffd4fee391fec44ffe9929d95f0e993404",
      "ffffd4fee391fec44ffe9929ec7014cc4c028c2d04",
      "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04",
      "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506"
    ).map(colors);

    ramp(scheme$j);

    var scheme$k = new Array(3).concat(
      "ffeda0feb24cf03b20",
      "ffffb2fecc5cfd8d3ce31a1c",
      "ffffb2fecc5cfd8d3cf03b20bd0026",
      "ffffb2fed976feb24cfd8d3cf03b20bd0026",
      "ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026",
      "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026",
      "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026"
    ).map(colors);

    ramp(scheme$k);

    var scheme$l = new Array(3).concat(
      "deebf79ecae13182bd",
      "eff3ffbdd7e76baed62171b5",
      "eff3ffbdd7e76baed63182bd08519c",
      "eff3ffc6dbef9ecae16baed63182bd08519c",
      "eff3ffc6dbef9ecae16baed64292c62171b5084594",
      "f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594",
      "f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b"
    ).map(colors);

    ramp(scheme$l);

    var scheme$m = new Array(3).concat(
      "e5f5e0a1d99b31a354",
      "edf8e9bae4b374c476238b45",
      "edf8e9bae4b374c47631a354006d2c",
      "edf8e9c7e9c0a1d99b74c47631a354006d2c",
      "edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32",
      "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32",
      "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b"
    ).map(colors);

    ramp(scheme$m);

    var scheme$n = new Array(3).concat(
      "f0f0f0bdbdbd636363",
      "f7f7f7cccccc969696525252",
      "f7f7f7cccccc969696636363252525",
      "f7f7f7d9d9d9bdbdbd969696636363252525",
      "f7f7f7d9d9d9bdbdbd969696737373525252252525",
      "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525",
      "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000"
    ).map(colors);

    ramp(scheme$n);

    var scheme$o = new Array(3).concat(
      "efedf5bcbddc756bb1",
      "f2f0f7cbc9e29e9ac86a51a3",
      "f2f0f7cbc9e29e9ac8756bb154278f",
      "f2f0f7dadaebbcbddc9e9ac8756bb154278f",
      "f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486",
      "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486",
      "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d"
    ).map(colors);

    ramp(scheme$o);

    var scheme$p = new Array(3).concat(
      "fee0d2fc9272de2d26",
      "fee5d9fcae91fb6a4acb181d",
      "fee5d9fcae91fb6a4ade2d26a50f15",
      "fee5d9fcbba1fc9272fb6a4ade2d26a50f15",
      "fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d",
      "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d",
      "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d"
    ).map(colors);

    ramp(scheme$p);

    var scheme$q = new Array(3).concat(
      "fee6cefdae6be6550d",
      "feeddefdbe85fd8d3cd94701",
      "feeddefdbe85fd8d3ce6550da63603",
      "feeddefdd0a2fdae6bfd8d3ce6550da63603",
      "feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04",
      "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04",
      "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704"
    ).map(colors);

    ramp(scheme$q);

    cubehelixLong(cubehelix(300, 0.5, 0.0), cubehelix(-240, 0.5, 1.0));

    var warm = cubehelixLong(cubehelix(-100, 0.75, 0.35), cubehelix(80, 1.50, 0.8));

    var cool = cubehelixLong(cubehelix(260, 0.75, 0.35), cubehelix(80, 1.50, 0.8));

    var c = cubehelix();

    var c$1 = rgb(),
        pi_1_3 = Math.PI / 3,
        pi_2_3 = Math.PI * 2 / 3;

    function ramp$1(range) {
      var n = range.length;
      return function(t) {
        return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
      };
    }

    ramp$1(colors("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));

    var magma = ramp$1(colors("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));

    var inferno = ramp$1(colors("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));

    var plasma = ramp$1(colors("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));

    function constant$b(x) {
      return function constant() {
        return x;
      };
    }

    var abs$3 = Math.abs;
    var atan2$1 = Math.atan2;
    var cos$2 = Math.cos;
    var max$3 = Math.max;
    var min$2 = Math.min;
    var sin$2 = Math.sin;
    var sqrt$2 = Math.sqrt;

    var epsilon$3 = 1e-12;
    var pi$4 = Math.PI;
    var halfPi$3 = pi$4 / 2;
    var tau$4 = 2 * pi$4;

    function acos$1(x) {
      return x > 1 ? 0 : x < -1 ? pi$4 : Math.acos(x);
    }

    function asin$1(x) {
      return x >= 1 ? halfPi$3 : x <= -1 ? -halfPi$3 : Math.asin(x);
    }

    function arcInnerRadius(d) {
      return d.innerRadius;
    }

    function arcOuterRadius(d) {
      return d.outerRadius;
    }

    function arcStartAngle(d) {
      return d.startAngle;
    }

    function arcEndAngle(d) {
      return d.endAngle;
    }

    function arcPadAngle(d) {
      return d && d.padAngle; // Note: optional!
    }

    function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
      var x10 = x1 - x0, y10 = y1 - y0,
          x32 = x3 - x2, y32 = y3 - y2,
          t = y32 * x10 - x32 * y10;
      if (t * t < epsilon$3) return;
      t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t;
      return [x0 + t * x10, y0 + t * y10];
    }

    // Compute perpendicular offset line of length rc.
    // http://mathworld.wolfram.com/Circle-LineIntersection.html
    function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
      var x01 = x0 - x1,
          y01 = y0 - y1,
          lo = (cw ? rc : -rc) / sqrt$2(x01 * x01 + y01 * y01),
          ox = lo * y01,
          oy = -lo * x01,
          x11 = x0 + ox,
          y11 = y0 + oy,
          x10 = x1 + ox,
          y10 = y1 + oy,
          x00 = (x11 + x10) / 2,
          y00 = (y11 + y10) / 2,
          dx = x10 - x11,
          dy = y10 - y11,
          d2 = dx * dx + dy * dy,
          r = r1 - rc,
          D = x11 * y10 - x10 * y11,
          d = (dy < 0 ? -1 : 1) * sqrt$2(max$3(0, r * r * d2 - D * D)),
          cx0 = (D * dy - dx * d) / d2,
          cy0 = (-D * dx - dy * d) / d2,
          cx1 = (D * dy + dx * d) / d2,
          cy1 = (-D * dx + dy * d) / d2,
          dx0 = cx0 - x00,
          dy0 = cy0 - y00,
          dx1 = cx1 - x00,
          dy1 = cy1 - y00;

      // Pick the closer of the two intersection points.
      // TODO Is there a faster way to determine which intersection to use?
      if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;

      return {
        cx: cx0,
        cy: cy0,
        x01: -ox,
        y01: -oy,
        x11: cx0 * (r1 / r - 1),
        y11: cy0 * (r1 / r - 1)
      };
    }

    function arc() {
      var innerRadius = arcInnerRadius,
          outerRadius = arcOuterRadius,
          cornerRadius = constant$b(0),
          padRadius = null,
          startAngle = arcStartAngle,
          endAngle = arcEndAngle,
          padAngle = arcPadAngle,
          context = null;

      function arc() {
        var buffer,
            r,
            r0 = +innerRadius.apply(this, arguments),
            r1 = +outerRadius.apply(this, arguments),
            a0 = startAngle.apply(this, arguments) - halfPi$3,
            a1 = endAngle.apply(this, arguments) - halfPi$3,
            da = abs$3(a1 - a0),
            cw = a1 > a0;

        if (!context) context = buffer = path();

        // Ensure that the outer radius is always larger than the inner radius.
        if (r1 < r0) r = r1, r1 = r0, r0 = r;

        // Is it a point?
        if (!(r1 > epsilon$3)) context.moveTo(0, 0);

        // Or is it a circle or annulus?
        else if (da > tau$4 - epsilon$3) {
          context.moveTo(r1 * cos$2(a0), r1 * sin$2(a0));
          context.arc(0, 0, r1, a0, a1, !cw);
          if (r0 > epsilon$3) {
            context.moveTo(r0 * cos$2(a1), r0 * sin$2(a1));
            context.arc(0, 0, r0, a1, a0, cw);
          }
        }

        // Or is it a circular or annular sector?
        else {
          var a01 = a0,
              a11 = a1,
              a00 = a0,
              a10 = a1,
              da0 = da,
              da1 = da,
              ap = padAngle.apply(this, arguments) / 2,
              rp = (ap > epsilon$3) && (padRadius ? +padRadius.apply(this, arguments) : sqrt$2(r0 * r0 + r1 * r1)),
              rc = min$2(abs$3(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),
              rc0 = rc,
              rc1 = rc,
              t0,
              t1;

          // Apply padding? Note that since r1 ≥ r0, da1 ≥ da0.
          if (rp > epsilon$3) {
            var p0 = asin$1(rp / r0 * sin$2(ap)),
                p1 = asin$1(rp / r1 * sin$2(ap));
            if ((da0 -= p0 * 2) > epsilon$3) p0 *= (cw ? 1 : -1), a00 += p0, a10 -= p0;
            else da0 = 0, a00 = a10 = (a0 + a1) / 2;
            if ((da1 -= p1 * 2) > epsilon$3) p1 *= (cw ? 1 : -1), a01 += p1, a11 -= p1;
            else da1 = 0, a01 = a11 = (a0 + a1) / 2;
          }

          var x01 = r1 * cos$2(a01),
              y01 = r1 * sin$2(a01),
              x10 = r0 * cos$2(a10),
              y10 = r0 * sin$2(a10);

          // Apply rounded corners?
          if (rc > epsilon$3) {
            var x11 = r1 * cos$2(a11),
                y11 = r1 * sin$2(a11),
                x00 = r0 * cos$2(a00),
                y00 = r0 * sin$2(a00),
                oc;

            // Restrict the corner radius according to the sector angle.
            if (da < pi$4 && (oc = intersect(x01, y01, x00, y00, x11, y11, x10, y10))) {
              var ax = x01 - oc[0],
                  ay = y01 - oc[1],
                  bx = x11 - oc[0],
                  by = y11 - oc[1],
                  kc = 1 / sin$2(acos$1((ax * bx + ay * by) / (sqrt$2(ax * ax + ay * ay) * sqrt$2(bx * bx + by * by))) / 2),
                  lc = sqrt$2(oc[0] * oc[0] + oc[1] * oc[1]);
              rc0 = min$2(rc, (r0 - lc) / (kc - 1));
              rc1 = min$2(rc, (r1 - lc) / (kc + 1));
            }
          }

          // Is the sector collapsed to a line?
          if (!(da1 > epsilon$3)) context.moveTo(x01, y01);

          // Does the sector’s outer ring have rounded corners?
          else if (rc1 > epsilon$3) {
            t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
            t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);

            context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);

            // Have the corners merged?
            if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, atan2$1(t0.y01, t0.x01), atan2$1(t1.y01, t1.x01), !cw);

            // Otherwise, draw the two corners and the ring.
            else {
              context.arc(t0.cx, t0.cy, rc1, atan2$1(t0.y01, t0.x01), atan2$1(t0.y11, t0.x11), !cw);
              context.arc(0, 0, r1, atan2$1(t0.cy + t0.y11, t0.cx + t0.x11), atan2$1(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
              context.arc(t1.cx, t1.cy, rc1, atan2$1(t1.y11, t1.x11), atan2$1(t1.y01, t1.x01), !cw);
            }
          }

          // Or is the outer ring just a circular arc?
          else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);

          // Is there no inner ring, and it’s a circular sector?
          // Or perhaps it’s an annular sector collapsed due to padding?
          if (!(r0 > epsilon$3) || !(da0 > epsilon$3)) context.lineTo(x10, y10);

          // Does the sector’s inner ring (or point) have rounded corners?
          else if (rc0 > epsilon$3) {
            t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
            t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);

            context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);

            // Have the corners merged?
            if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, atan2$1(t0.y01, t0.x01), atan2$1(t1.y01, t1.x01), !cw);

            // Otherwise, draw the two corners and the ring.
            else {
              context.arc(t0.cx, t0.cy, rc0, atan2$1(t0.y01, t0.x01), atan2$1(t0.y11, t0.x11), !cw);
              context.arc(0, 0, r0, atan2$1(t0.cy + t0.y11, t0.cx + t0.x11), atan2$1(t1.cy + t1.y11, t1.cx + t1.x11), cw);
              context.arc(t1.cx, t1.cy, rc0, atan2$1(t1.y11, t1.x11), atan2$1(t1.y01, t1.x01), !cw);
            }
          }

          // Or is the inner ring just a circular arc?
          else context.arc(0, 0, r0, a10, a00, cw);
        }

        context.closePath();

        if (buffer) return context = null, buffer + "" || null;
      }

      arc.centroid = function() {
        var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,
            a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi$4 / 2;
        return [cos$2(a) * r, sin$2(a) * r];
      };

      arc.innerRadius = function(_) {
        return arguments.length ? (innerRadius = typeof _ === "function" ? _ : constant$b(+_), arc) : innerRadius;
      };

      arc.outerRadius = function(_) {
        return arguments.length ? (outerRadius = typeof _ === "function" ? _ : constant$b(+_), arc) : outerRadius;
      };

      arc.cornerRadius = function(_) {
        return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : constant$b(+_), arc) : cornerRadius;
      };

      arc.padRadius = function(_) {
        return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : constant$b(+_), arc) : padRadius;
      };

      arc.startAngle = function(_) {
        return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$b(+_), arc) : startAngle;
      };

      arc.endAngle = function(_) {
        return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$b(+_), arc) : endAngle;
      };

      arc.padAngle = function(_) {
        return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant$b(+_), arc) : padAngle;
      };

      arc.context = function(_) {
        return arguments.length ? ((context = _ == null ? null : _), arc) : context;
      };

      return arc;
    }

    function descending$1(a, b) {
      return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
    }

    function identity$8(d) {
      return d;
    }

    function pie() {
      var value = identity$8,
          sortValues = descending$1,
          sort = null,
          startAngle = constant$b(0),
          endAngle = constant$b(tau$4),
          padAngle = constant$b(0);

      function pie(data) {
        var i,
            n = data.length,
            j,
            k,
            sum = 0,
            index = new Array(n),
            arcs = new Array(n),
            a0 = +startAngle.apply(this, arguments),
            da = Math.min(tau$4, Math.max(-tau$4, endAngle.apply(this, arguments) - a0)),
            a1,
            p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)),
            pa = p * (da < 0 ? -1 : 1),
            v;

        for (i = 0; i < n; ++i) {
          if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) {
            sum += v;
          }
        }

        // Optionally sort the arcs by previously-computed values or by data.
        if (sortValues != null) index.sort(function(i, j) { return sortValues(arcs[i], arcs[j]); });
        else if (sort != null) index.sort(function(i, j) { return sort(data[i], data[j]); });

        // Compute the arcs! They are stored in the original data's order.
        for (i = 0, k = sum ? (da - n * pa) / sum : 0; i < n; ++i, a0 = a1) {
          j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k : 0) + pa, arcs[j] = {
            data: data[j],
            index: i,
            value: v,
            startAngle: a0,
            endAngle: a1,
            padAngle: p
          };
        }

        return arcs;
      }

      pie.value = function(_) {
        return arguments.length ? (value = typeof _ === "function" ? _ : constant$b(+_), pie) : value;
      };

      pie.sortValues = function(_) {
        return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;
      };

      pie.sort = function(_) {
        return arguments.length ? (sort = _, sortValues = null, pie) : sort;
      };

      pie.startAngle = function(_) {
        return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$b(+_), pie) : startAngle;
      };

      pie.endAngle = function(_) {
        return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$b(+_), pie) : endAngle;
      };

      pie.padAngle = function(_) {
        return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant$b(+_), pie) : padAngle;
      };

      return pie;
    }

    function sign$2(x) {
      return x < 0 ? -1 : 1;
    }

    // Calculate the slopes of the tangents (Hermite-type interpolation) based on
    // the following paper: Steffen, M. 1990. A Simple Method for Monotonic
    // Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.
    // NOV(II), P. 443, 1990.
    function slope3(that, x2, y2) {
      var h0 = that._x1 - that._x0,
          h1 = x2 - that._x1,
          s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0),
          s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0),
          p = (s0 * h1 + s1 * h0) / (h0 + h1);
      return (sign$2(s0) + sign$2(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
    }

    // Calculate a one-sided slope.
    function slope2(that, t) {
      var h = that._x1 - that._x0;
      return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
    }

    // According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations
    // "you can express cubic Hermite interpolation in terms of cubic Bézier curves
    // with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1".
    function point$5(that, t0, t1) {
      var x0 = that._x0,
          y0 = that._y0,
          x1 = that._x1,
          y1 = that._y1,
          dx = (x1 - x0) / 3;
      that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
    }

    function MonotoneX(context) {
      this._context = context;
    }

    MonotoneX.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 =
        this._y0 = this._y1 =
        this._t0 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 2: this._context.lineTo(this._x1, this._y1); break;
          case 3: point$5(this, this._t0, slope2(this, this._t0)); break;
        }
        if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        var t1 = NaN;

        x = +x, y = +y;
        if (x === this._x1 && y === this._y1) return; // Ignore coincident points.
        switch (this._point) {
          case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
          case 1: this._point = 2; break;
          case 2: this._point = 3; point$5(this, slope2(this, t1 = slope3(this, x, y)), t1); break;
          default: point$5(this, this._t0, t1 = slope3(this, x, y)); break;
        }

        this._x0 = this._x1, this._x1 = x;
        this._y0 = this._y1, this._y1 = y;
        this._t0 = t1;
      }
    };

    function MonotoneY(context) {
      this._context = new ReflectContext(context);
    }

    (MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x, y) {
      MonotoneX.prototype.point.call(this, y, x);
    };

    function ReflectContext(context) {
      this._context = context;
    }

    ReflectContext.prototype = {
      moveTo: function(x, y) { this._context.moveTo(y, x); },
      closePath: function() { this._context.closePath(); },
      lineTo: function(x, y) { this._context.lineTo(y, x); },
      bezierCurveTo: function(x1, y1, x2, y2, x, y) { this._context.bezierCurveTo(y1, x1, y2, x2, y, x); }
    };

    /* src\core\ui\outputs\Alert.html generated by Svelte v2.16.1 */

    function oncreate$g() {
    	// console.log(this.get().field);
    }
    const file$m = "src\\core\\ui\\outputs\\Alert.html";

    function add_css$b() {
    	var style = createElement("style");
    	style.id = 'svelte-nd7j1a-style';
    	style.textContent = ".alert.svelte-nd7j1a{margin:5px 8px;padding:10px 15px;border:1px solid #bbb}.alert.svelte-nd7j1a>.heading.svelte-nd7j1a{font-weight:bold;font-size:14px}.alert.success.svelte-nd7j1a{background:#ebfff8}.alert.warning.svelte-nd7j1a{background:#fdffeb}.alert.danger.svelte-nd7j1a{background:#ffeaea}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQWxlcnQuaHRtbCIsInNvdXJjZXMiOlsiQWxlcnQuaHRtbCJdLCJzb3VyY2VzQ29udGVudCI6WyJ7I2lmIGZpZWxkICE9IG51bGwgJiYgZmllbGQuZGF0YSAhPSBudWxsfVxyXG48ZGl2IGNsYXNzPVwiYWxlcnQge2ZpZWxkLmRhdGEuc3R5bGV9XCI+XHJcblx0eyNpZiBmaWVsZC5kYXRhLmhlYWRpbmcgIT0gbnVsbCB8fCBmaWVsZC5kYXRhLmljb24gIT0gbnVsbH1cclxuXHQ8ZGl2IGNsYXNzPVwiaGVhZGluZ1wiPlxyXG5cdFx0eyNpZiBmaWVsZC5kYXRhLmljb24gIT0gbnVsbH1cclxuXHRcdFx0PHNwYW4+e0BodG1sIGZpZWxkLmRhdGEuaWNvbn08L3NwYW4+XHJcblx0XHR7L2lmfVxyXG5cdFx0e2ZpZWxkLmRhdGEuaGVhZGluZ31cclxuXHQ8L2Rpdj5cclxuXHR7L2lmfVxyXG5cdHsjaWYgZmllbGQuZGF0YS5tZXNzYWdlICE9IG51bGx9XHJcblx0PGRpdiBjbGFzcz1cImJvZHlcIj57QGh0bWwgZmllbGQuZGF0YS5tZXNzYWdlfTwvZGl2PlxyXG5cdHsvaWZ9XHJcbjwvZGl2PlxyXG57L2lmfVxyXG48c2NyaXB0PlxyXG5cdGV4cG9ydCBkZWZhdWx0IHtcclxuXHRcdG9uY3JlYXRlKCkge1xyXG5cdFx0XHQvLyBjb25zb2xlLmxvZyh0aGlzLmdldCgpLmZpZWxkKTtcclxuXHRcdH1cclxuXHR9O1xyXG48L3NjcmlwdD5cclxuXHJcbjxzdHlsZT5cclxuXHQuYWxlcnQge1xyXG5cdFx0bWFyZ2luOiA1cHggOHB4O1xyXG5cdFx0cGFkZGluZzogMTBweCAxNXB4O1xyXG5cdFx0Ym9yZGVyOiAxcHggc29saWQgI2JiYjtcclxuXHR9XHJcblxyXG5cdC5hbGVydCA+IC5oZWFkaW5nIHtcclxuXHRcdGZvbnQtd2VpZ2h0OiBib2xkO1xyXG5cdFx0Zm9udC1zaXplOiAxNHB4O1xyXG5cdH1cclxuXHJcblx0LmFsZXJ0LnN1Y2Nlc3Mge1xyXG5cdFx0YmFja2dyb3VuZDogI2ViZmZmODtcclxuXHR9XHJcblxyXG5cdC5hbGVydC53YXJuaW5nIHtcclxuXHRcdGJhY2tncm91bmQ6ICNmZGZmZWI7XHJcblx0fVxyXG5cclxuXHQuYWxlcnQuZGFuZ2VyIHtcclxuXHRcdGJhY2tncm91bmQ6ICNmZmVhZWE7XHJcblx0fVxyXG48L3N0eWxlPlxyXG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBd0JDLE1BQU0sY0FBQyxDQUFDLEFBQ1AsTUFBTSxDQUFFLEdBQUcsQ0FBQyxHQUFHLENBQ2YsT0FBTyxDQUFFLElBQUksQ0FBQyxJQUFJLENBQ2xCLE1BQU0sQ0FBRSxHQUFHLENBQUMsS0FBSyxDQUFDLElBQUksQUFDdkIsQ0FBQyxBQUVELG9CQUFNLENBQUcsUUFBUSxjQUFDLENBQUMsQUFDbEIsV0FBVyxDQUFFLElBQUksQ0FDakIsU0FBUyxDQUFFLElBQUksQUFDaEIsQ0FBQyxBQUVELE1BQU0sUUFBUSxjQUFDLENBQUMsQUFDZixVQUFVLENBQUUsT0FBTyxBQUNwQixDQUFDLEFBRUQsTUFBTSxRQUFRLGNBQUMsQ0FBQyxBQUNmLFVBQVUsQ0FBRSxPQUFPLEFBQ3BCLENBQUMsQUFFRCxNQUFNLE9BQU8sY0FBQyxDQUFDLEFBQ2QsVUFBVSxDQUFFLE9BQU8sQUFDcEIsQ0FBQyJ9 */";
    	append(document.head, style);
    }

    function create_main_fragment$n(component, ctx) {
    	var if_block_anchor;

    	var if_block = (ctx.field != null && ctx.field.data != null) && create_if_block$f(component, ctx);

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (ctx.field != null && ctx.field.data != null) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block$f(component, ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (if_block) if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (1:0) {#if field != null && field.data != null}
    function create_if_block$f(component, ctx) {
    	var div, text, div_class_value;

    	var if_block0 = (ctx.field.data.heading != null || ctx.field.data.icon != null) && create_if_block_2$5(component, ctx);

    	var if_block1 = (ctx.field.data.message != null) && create_if_block_1$8(component, ctx);

    	return {
    		c: function create() {
    			div = createElement("div");
    			if (if_block0) if_block0.c();
    			text = createText("\r\n\t");
    			if (if_block1) if_block1.c();
    			div.className = div_class_value = "alert " + ctx.field.data.style + " svelte-nd7j1a";
    			addLoc(div, file$m, 1, 0, 43);
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append(div, text);
    			if (if_block1) if_block1.m(div, null);
    		},

    		p: function update(changed, ctx) {
    			if (ctx.field.data.heading != null || ctx.field.data.icon != null) {
    				if (if_block0) {
    					if_block0.p(changed, ctx);
    				} else {
    					if_block0 = create_if_block_2$5(component, ctx);
    					if_block0.c();
    					if_block0.m(div, text);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (ctx.field.data.message != null) {
    				if (if_block1) {
    					if_block1.p(changed, ctx);
    				} else {
    					if_block1 = create_if_block_1$8(component, ctx);
    					if_block1.c();
    					if_block1.m(div, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if ((changed.field) && div_class_value !== (div_class_value = "alert " + ctx.field.data.style + " svelte-nd7j1a")) {
    				div.className = div_class_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(div);
    			}

    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    		}
    	};
    }

    // (3:1) {#if field.data.heading != null || field.data.icon != null}
    function create_if_block_2$5(component, ctx) {
    	var div, text0, text1_value = ctx.field.data.heading, text1;

    	var if_block = (ctx.field.data.icon != null) && create_if_block_3$3(component, ctx);

    	return {
    		c: function create() {
    			div = createElement("div");
    			if (if_block) if_block.c();
    			text0 = createText("\r\n\t\t");
    			text1 = createText(text1_value);
    			div.className = "heading svelte-nd7j1a";
    			addLoc(div, file$m, 3, 1, 146);
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    			append(div, text0);
    			append(div, text1);
    		},

    		p: function update(changed, ctx) {
    			if (ctx.field.data.icon != null) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block_3$3(component, ctx);
    					if_block.c();
    					if_block.m(div, text0);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if ((changed.field) && text1_value !== (text1_value = ctx.field.data.heading)) {
    				setData(text1, text1_value);
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(div);
    			}

    			if (if_block) if_block.d();
    		}
    	};
    }

    // (5:2) {#if field.data.icon != null}
    function create_if_block_3$3(component, ctx) {
    	var span, raw_value = ctx.field.data.icon;

    	return {
    		c: function create() {
    			span = createElement("span");
    			addLoc(span, file$m, 5, 3, 205);
    		},

    		m: function mount(target, anchor) {
    			insert(target, span, anchor);
    			span.innerHTML = raw_value;
    		},

    		p: function update(changed, ctx) {
    			if ((changed.field) && raw_value !== (raw_value = ctx.field.data.icon)) {
    				span.innerHTML = raw_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(span);
    			}
    		}
    	};
    }

    // (11:1) {#if field.data.message != null}
    function create_if_block_1$8(component, ctx) {
    	var div, raw_value = ctx.field.data.message;

    	return {
    		c: function create() {
    			div = createElement("div");
    			div.className = "body";
    			addLoc(div, file$m, 11, 1, 329);
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);
    			div.innerHTML = raw_value;
    		},

    		p: function update(changed, ctx) {
    			if ((changed.field) && raw_value !== (raw_value = ctx.field.data.message)) {
    				div.innerHTML = raw_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(div);
    			}
    		}
    	};
    }

    function SvelteComponent$n(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) {
    		throw new Error("'target' is a required option");
    	}

    	init(this, options);
    	this._state = assign({}, options.data);
    	if (!('field' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'field'");
    	this._intro = true;

    	if (!document.getElementById("svelte-nd7j1a-style")) add_css$b();

    	this._fragment = create_main_fragment$n(this, this._state);

    	this.root._oncreate.push(() => {
    		oncreate$g.call(this);
    		this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
    	});

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);

    		flush(this);
    	}
    }

    assign(SvelteComponent$n.prototype, protoDev);

    SvelteComponent$n.prototype._checkReadOnly = function _checkReadOnly(newState) {
    };

    /* src\core\ui\outputs\PieGraph.html generated by Svelte v2.16.1 */



    function shuffle$2(a) {
    	for (let i = a.length - 1; i > 0; i--) {
    		const j = Math.floor(a.length - 1 * (i + 1));
    		// eslint-disable-next-line no-param-reassign
    		[a[i], a[j]] = [a[j], a[i]];
    	}
    	return a;
    }

    function data$9() {
    	return {
    		message: null
    	};
    }
    function oncreate$h() {
    	const { field } = this.get();

    	if (field.data == null) {
    		return;
    	}

    	// eslint-disable-next-line prefer-destructuring
    	let data = field.data;
    	this.set({
    		message: null
    	});

    	this.set({
    		message: {
    			data: field.data.chartHeader
    		}
    	});
    	
    	data = data.data.map(d => ({ presses: d.data, letter: d.label }));
    	const width = 600,
    		height = 400,
    		radius = Math.min(width, height) / 2;

    	// legend dimensions
    	const legendRectSize = 25; // defines the size of the colored squares in legend
    	const legendSpacing = 8; // defines spacing between squares
    	// eslint-disable-next-line prefer-const
    	let colors = category10;
    	shuffle$2(colors);
    	// define color scale
    	const color$$1 = ordinal$1(colors);
    	// more color scales: https://bl.ocks.org/pstuffa/3393ff2711a53975040077b7453781a9

    	const svg$$1 = select(this.refs.pie) // select element in the DOM with id 'chart'
    		.append("svg") // append an svg element to the element we've selected
    		.attr("viewBox", `25 0 ${width} ${height}`)
    		.attr("preserveAspectRatio", "xMinYMin")
    		.append("g") // append 'g' element to the svg element
    		.attr("transform", `translate(${width / 2},${height / 2})`)
    		.style("padding-right", "60px");

    	const arc$$1 = arc()
    		.outerRadius(radius - 10)
    		.innerRadius(0);

    	const pie$$1 = pie()
    		.value(d => d.count)
    		.sort(null);

    	// define tooltip
    	const tooltip = select(this.refs.pie) // select element in the DOM with id 'chart'
    		.append("div") // append a div element to the element we've selected
    		.attr("class", "tooltips"); // add class 'tooltip' on the divs we just selected

    	tooltip.append("div") // add divs to the tooltip defined above
    		.attr("class", "label"); // add class 'label' on the selection

    	tooltip.append("div") // add divs to the tooltip defined above
    		.attr("class", "count"); // add class 'count' on the selection

    	tooltip.append("div") // add divs to the tooltip defined above
    		.attr("class", "percent"); // add class 'percent' on the selection

    	data.forEach(d => {
    		// eslint-disable-next-line no-param-reassign
    		d.count = +d.presses; // calculate count as we iterate through the data
    		// eslint-disable-next-line no-param-reassign
    		d.enabled = true; // add enabled property to track which entries are checked
    		// eslint-disable-next-line no-param-reassign
    		d.label = d.letter;
    	});

    	// creating the chart
    	let path$$1 = svg$$1.selectAll(".path");
    	path$$1 = path$$1
    		.data(pie$$1(data))
    		.enter()
    		.append("path")
    		.attr("d", arc$$1)
    		.attr("fill", d => color$$1(d.data.label))
    		// eslint-disable-next-line no-underscore-dangle
    		.each(d => path$$1._current - d);

    	let pathText = svg$$1.selectAll(".path")
    		.data(pie$$1(data))
    		.enter()
    		.append("text")
    		.text(d => {
    			const total = sum(data.map(m => ((m.enabled) ? m.count : 0)));
    			const percent = Math.round(1000 * d.data.count / total) / 10; // calculate percent
    			return `${d.data.count} - ${percent}%`;
    		})
    		// eslint-disable-next-line prefer-template
    		.attr("transform", d => "translate(" + arc$$1.centroid(d) + ")")
    		.style("text-anchor", "middle")
    		.style("font-size", 14)
    		.style("direction", "ltr");

    	path$$1.on("mouseover", d => { // when mouse enters div
    		const total = sum(data.map(m => ((m.enabled) ? m.count : 0)));
    		const percent = Math.round(1000 * d.data.count / total) / 10; // calculate percent
    		tooltip.select(".label").html(d.data.label); // set current label
    		tooltip.select(".count").html(`${d.data.count}`); // set current count
    		tooltip.select(".percent").html(`${percent}%`); // set percent calculated above
    		tooltip.style("display", "block"); // set display
    	});

    	path$$1.on("mouseout", () => { // when mouse leaves div
    		tooltip.style("display", "none"); // hide tooltip for that element
    	});

    	path$$1.on("mousemove", () => { // when mouse moves
    		tooltip.style("top", `${event.layerY + 10}px`) // always 10px below the cursor
    			.style("left", `${event.layerX + 10}px`); // always 10px to the right of the mouse
    	});

    	path$$1.transition() // transition of redrawn pie
    		.duration(750) //
    		.attrTween("d", d => {
    			// eslint-disable-next-line no-underscore-dangle
    			const interpolate = interpolateValue(path$$1._current, d);
    			// eslint-disable-next-line no-underscore-dangle
    			path$$1._current = interpolate(0);
    			return t => arc$$1(interpolate(t));
    		});

    	// define legend
    	const legend = svg$$1.selectAll(".legend")
    		.data(color$$1.domain())
    		.enter()
    		.append("g")
    		.attr("class", "legend")
    		.attr("transform", (d, i) => {
    			const legendHeight = legendRectSize + legendSpacing;
    			const offset = legendHeight * color$$1.domain().length / 2;
    			const horz = 8 * legendRectSize;
    			const vert = i * legendHeight - offset;
    			return `translate(${horz},${vert})`;
    		});

    	let rectElement = legend.append("rect");

    	// adding colored squares to legend
    	rectElement = rectElement
    		.attr("width", legendRectSize)
    		.attr("height", legendRectSize)
    		.style("fill", color$$1)
    		.style("direction", "ltr")
    		.style("stroke", color$$1);

    	rectElement.on("click", label => {
    		// eslint-disable-next-line no-param-reassign
    		const { event: event$$1 } = window;
    		const target = event$$1.target || event$$1.srcElement;
    		const rect = select(target);
    		let enabled = true;
    		const totalEnabled = sum(data.map(d => ((d.enabled) ? 1 : 0)));

    		if (rect.attr("class") === "disabled") { // if class is disabled
    			rect.attr("class", ""); // remove class disabled
    		}
    		else { // else
    			if (totalEnabled < 2) return; // if less than two labels are flagged, exit
    			rect.attr("class", "disabled"); // otherwise flag the square disabled
    			enabled = false; // set enabled to false
    		}

    		pie$$1.value(d => {
    			// eslint-disable-next-line no-param-reassign
    			if (d.label === label) d.enabled = enabled;
    			return (d.enabled) ? d.count : 0;
    		});

    		path$$1 = path$$1.data(pie$$1(data)); // update pie with new data
    		// pathText = pathText.data(pie(data));

    		pathText = pathText
    			.data(pie$$1(data))
    			.text(d => {
    				if (!d.data.enabled) {
    					return "";
    				}
    				const total = sum(data.map(m => ((m.enabled) ? m.count : 0)));
    				const percent = Math.round(1000 * d.data.count / total) / 10; // calculate percent
    				return `${d.data.count} - ${percent}%`;
    			})
    			.attr("transform", d => `translate(${arc$$1.centroid(d)})`)
    			.style("text-anchor", "middle")
    			.style("font-size", 14)
    			.style("direction", "ltr");

    		path$$1.transition() // transition of redrawn pie
    			.duration(750) //
    			.attrTween("d", d => {
    				// eslint-disable-next-line no-underscore-dangle
    				const interpolate = interpolateValue(path$$1._current, d);
    				// eslint-disable-next-line no-underscore-dangle
    				path$$1._current = interpolate(0);
    				return t => arc$$1(interpolate(t));
    			});
    	});

    	// adding text to legend
    	legend.append("text")
    		.attr("x", legendRectSize + legendSpacing)
    		.attr("y", legendRectSize - legendSpacing)
    		.style("direction", "ltr")
    		.text(d => d); // return label
    }
    const file$n = "src\\core\\ui\\outputs\\PieGraph.html";

    function add_css$c() {
    	var style = createElement("style");
    	style.id = 'svelte-s328vy-style';
    	style.textContent = "div.svelte-s328vy{max-width:600px;margin:0 auto;position:relative;display:block}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUGllR3JhcGguaHRtbCIsInNvdXJjZXMiOlsiUGllR3JhcGguaHRtbCJdLCJzb3VyY2VzQ29udGVudCI6WyJ7I2lmIGZpZWxkLmRhdGEgIT0gbnVsbH1cclxuXHR7I2lmIG1lc3NhZ2UgIT0gbnVsbH1cclxuXHQ8QWxlcnQgZmllbGQ9e21lc3NhZ2V9Lz5cclxuXHR7L2lmfVxyXG48ZGl2IGNsYXNzPVwicGllLWNoYXJ0XCIgcmVmOnBpZT48L2Rpdj5cclxuey9pZn1cclxuXHJcbjxzY3JpcHQ+XHJcblx0aW1wb3J0ICogYXMgZDMgZnJvbSBcImQzXCI7XHJcblx0aW1wb3J0IEFsZXJ0IGZyb20gXCIuL0FsZXJ0XCI7XHJcblxyXG5cdGZ1bmN0aW9uIHNodWZmbGUoYSkge1xyXG5cdFx0Zm9yIChsZXQgaSA9IGEubGVuZ3RoIC0gMTsgaSA+IDA7IGktLSkge1xyXG5cdFx0XHRjb25zdCBqID0gTWF0aC5mbG9vcihhLmxlbmd0aCAtIDEgKiAoaSArIDEpKTtcclxuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXHJcblx0XHRcdFthW2ldLCBhW2pdXSA9IFthW2pdLCBhW2ldXTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBhO1xyXG5cdH1cclxuXHJcblx0ZXhwb3J0IGRlZmF1bHQge1xyXG5cdFx0b25jcmVhdGUoKSB7XHJcblx0XHRcdGNvbnN0IHsgZmllbGQgfSA9IHRoaXMuZ2V0KCk7XHJcblxyXG5cdFx0XHRpZiAoZmllbGQuZGF0YSA9PSBudWxsKSB7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcclxuXHRcdFx0bGV0IGRhdGEgPSBmaWVsZC5kYXRhO1xyXG5cdFx0XHR0aGlzLnNldCh7XHJcblx0XHRcdFx0bWVzc2FnZTogbnVsbFxyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdHRoaXMuc2V0KHtcclxuXHRcdFx0XHRtZXNzYWdlOiB7XHJcblx0XHRcdFx0XHRkYXRhOiBmaWVsZC5kYXRhLmNoYXJ0SGVhZGVyXHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHRcclxuXHRcdFx0ZGF0YSA9IGRhdGEuZGF0YS5tYXAoZCA9PiAoeyBwcmVzc2VzOiBkLmRhdGEsIGxldHRlcjogZC5sYWJlbCB9KSk7XHJcblx0XHRcdGNvbnN0IHdpZHRoID0gNjAwLFxyXG5cdFx0XHRcdGhlaWdodCA9IDQwMCxcclxuXHRcdFx0XHRyYWRpdXMgPSBNYXRoLm1pbih3aWR0aCwgaGVpZ2h0KSAvIDI7XHJcblxyXG5cdFx0XHQvLyBsZWdlbmQgZGltZW5zaW9uc1xyXG5cdFx0XHRjb25zdCBsZWdlbmRSZWN0U2l6ZSA9IDI1OyAvLyBkZWZpbmVzIHRoZSBzaXplIG9mIHRoZSBjb2xvcmVkIHNxdWFyZXMgaW4gbGVnZW5kXHJcblx0XHRcdGNvbnN0IGxlZ2VuZFNwYWNpbmcgPSA4OyAvLyBkZWZpbmVzIHNwYWNpbmcgYmV0d2VlbiBzcXVhcmVzXHJcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3RcclxuXHRcdFx0bGV0IGNvbG9ycyA9IGQzLnNjaGVtZUNhdGVnb3J5MTA7XHJcblx0XHRcdHNodWZmbGUoY29sb3JzKTtcclxuXHRcdFx0Ly8gZGVmaW5lIGNvbG9yIHNjYWxlXHJcblx0XHRcdGNvbnN0IGNvbG9yID0gZDMuc2NhbGVPcmRpbmFsKGNvbG9ycyk7XHJcblx0XHRcdC8vIG1vcmUgY29sb3Igc2NhbGVzOiBodHRwczovL2JsLm9ja3Mub3JnL3BzdHVmZmEvMzM5M2ZmMjcxMWE1Mzk3NTA0MDA3N2I3NDUzNzgxYTlcclxuXHJcblx0XHRcdGNvbnN0IHN2ZyA9IGQzLnNlbGVjdCh0aGlzLnJlZnMucGllKSAvLyBzZWxlY3QgZWxlbWVudCBpbiB0aGUgRE9NIHdpdGggaWQgJ2NoYXJ0J1xyXG5cdFx0XHRcdC5hcHBlbmQoXCJzdmdcIikgLy8gYXBwZW5kIGFuIHN2ZyBlbGVtZW50IHRvIHRoZSBlbGVtZW50IHdlJ3ZlIHNlbGVjdGVkXHJcblx0XHRcdFx0LmF0dHIoXCJ2aWV3Qm94XCIsIGAyNSAwICR7d2lkdGh9ICR7aGVpZ2h0fWApXHJcblx0XHRcdFx0LmF0dHIoXCJwcmVzZXJ2ZUFzcGVjdFJhdGlvXCIsIFwieE1pbllNaW5cIilcclxuXHRcdFx0XHQuYXBwZW5kKFwiZ1wiKSAvLyBhcHBlbmQgJ2cnIGVsZW1lbnQgdG8gdGhlIHN2ZyBlbGVtZW50XHJcblx0XHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgYHRyYW5zbGF0ZSgke3dpZHRoIC8gMn0sJHtoZWlnaHQgLyAyfSlgKVxyXG5cdFx0XHRcdC5zdHlsZShcInBhZGRpbmctcmlnaHRcIiwgXCI2MHB4XCIpO1xyXG5cclxuXHRcdFx0Y29uc3QgYXJjID0gZDMuYXJjKClcclxuXHRcdFx0XHQub3V0ZXJSYWRpdXMocmFkaXVzIC0gMTApXHJcblx0XHRcdFx0LmlubmVyUmFkaXVzKDApO1xyXG5cclxuXHRcdFx0Y29uc3QgcGllID0gZDMucGllKClcclxuXHRcdFx0XHQudmFsdWUoZCA9PiBkLmNvdW50KVxyXG5cdFx0XHRcdC5zb3J0KG51bGwpO1xyXG5cclxuXHRcdFx0Ly8gZGVmaW5lIHRvb2x0aXBcclxuXHRcdFx0Y29uc3QgdG9vbHRpcCA9IGQzLnNlbGVjdCh0aGlzLnJlZnMucGllKSAvLyBzZWxlY3QgZWxlbWVudCBpbiB0aGUgRE9NIHdpdGggaWQgJ2NoYXJ0J1xyXG5cdFx0XHRcdC5hcHBlbmQoXCJkaXZcIikgLy8gYXBwZW5kIGEgZGl2IGVsZW1lbnQgdG8gdGhlIGVsZW1lbnQgd2UndmUgc2VsZWN0ZWRcclxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIFwidG9vbHRpcHNcIik7IC8vIGFkZCBjbGFzcyAndG9vbHRpcCcgb24gdGhlIGRpdnMgd2UganVzdCBzZWxlY3RlZFxyXG5cclxuXHRcdFx0dG9vbHRpcC5hcHBlbmQoXCJkaXZcIikgLy8gYWRkIGRpdnMgdG8gdGhlIHRvb2x0aXAgZGVmaW5lZCBhYm92ZVxyXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgXCJsYWJlbFwiKTsgLy8gYWRkIGNsYXNzICdsYWJlbCcgb24gdGhlIHNlbGVjdGlvblxyXG5cclxuXHRcdFx0dG9vbHRpcC5hcHBlbmQoXCJkaXZcIikgLy8gYWRkIGRpdnMgdG8gdGhlIHRvb2x0aXAgZGVmaW5lZCBhYm92ZVxyXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgXCJjb3VudFwiKTsgLy8gYWRkIGNsYXNzICdjb3VudCcgb24gdGhlIHNlbGVjdGlvblxyXG5cclxuXHRcdFx0dG9vbHRpcC5hcHBlbmQoXCJkaXZcIikgLy8gYWRkIGRpdnMgdG8gdGhlIHRvb2x0aXAgZGVmaW5lZCBhYm92ZVxyXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgXCJwZXJjZW50XCIpOyAvLyBhZGQgY2xhc3MgJ3BlcmNlbnQnIG9uIHRoZSBzZWxlY3Rpb25cclxuXHJcblx0XHRcdGRhdGEuZm9yRWFjaChkID0+IHtcclxuXHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cclxuXHRcdFx0XHRkLmNvdW50ID0gK2QucHJlc3NlczsgLy8gY2FsY3VsYXRlIGNvdW50IGFzIHdlIGl0ZXJhdGUgdGhyb3VnaCB0aGUgZGF0YVxyXG5cdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxyXG5cdFx0XHRcdGQuZW5hYmxlZCA9IHRydWU7IC8vIGFkZCBlbmFibGVkIHByb3BlcnR5IHRvIHRyYWNrIHdoaWNoIGVudHJpZXMgYXJlIGNoZWNrZWRcclxuXHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cclxuXHRcdFx0XHRkLmxhYmVsID0gZC5sZXR0ZXI7XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0Ly8gY3JlYXRpbmcgdGhlIGNoYXJ0XHJcblx0XHRcdGxldCBwYXRoID0gc3ZnLnNlbGVjdEFsbChcIi5wYXRoXCIpO1xyXG5cdFx0XHRwYXRoID0gcGF0aFxyXG5cdFx0XHRcdC5kYXRhKHBpZShkYXRhKSlcclxuXHRcdFx0XHQuZW50ZXIoKVxyXG5cdFx0XHRcdC5hcHBlbmQoXCJwYXRoXCIpXHJcblx0XHRcdFx0LmF0dHIoXCJkXCIsIGFyYylcclxuXHRcdFx0XHQuYXR0cihcImZpbGxcIiwgZCA9PiBjb2xvcihkLmRhdGEubGFiZWwpKVxyXG5cdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlcnNjb3JlLWRhbmdsZVxyXG5cdFx0XHRcdC5lYWNoKGQgPT4gcGF0aC5fY3VycmVudCAtIGQpO1xyXG5cclxuXHRcdFx0bGV0IHBhdGhUZXh0ID0gc3ZnLnNlbGVjdEFsbChcIi5wYXRoXCIpXHJcblx0XHRcdFx0LmRhdGEocGllKGRhdGEpKVxyXG5cdFx0XHRcdC5lbnRlcigpXHJcblx0XHRcdFx0LmFwcGVuZChcInRleHRcIilcclxuXHRcdFx0XHQudGV4dChkID0+IHtcclxuXHRcdFx0XHRcdGNvbnN0IHRvdGFsID0gZDMuc3VtKGRhdGEubWFwKG0gPT4gKChtLmVuYWJsZWQpID8gbS5jb3VudCA6IDApKSk7XHJcblx0XHRcdFx0XHRjb25zdCBwZXJjZW50ID0gTWF0aC5yb3VuZCgxMDAwICogZC5kYXRhLmNvdW50IC8gdG90YWwpIC8gMTA7IC8vIGNhbGN1bGF0ZSBwZXJjZW50XHJcblx0XHRcdFx0XHRyZXR1cm4gYCR7ZC5kYXRhLmNvdW50fSAtICR7cGVyY2VudH0lYDtcclxuXHRcdFx0XHR9KVxyXG5cdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItdGVtcGxhdGVcclxuXHRcdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCBkID0+IFwidHJhbnNsYXRlKFwiICsgYXJjLmNlbnRyb2lkKGQpICsgXCIpXCIpXHJcblx0XHRcdFx0LnN0eWxlKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIilcclxuXHRcdFx0XHQuc3R5bGUoXCJmb250LXNpemVcIiwgMTQpXHJcblx0XHRcdFx0LnN0eWxlKFwiZGlyZWN0aW9uXCIsIFwibHRyXCIpO1xyXG5cclxuXHRcdFx0cGF0aC5vbihcIm1vdXNlb3ZlclwiLCBkID0+IHsgLy8gd2hlbiBtb3VzZSBlbnRlcnMgZGl2XHJcblx0XHRcdFx0Y29uc3QgdG90YWwgPSBkMy5zdW0oZGF0YS5tYXAobSA9PiAoKG0uZW5hYmxlZCkgPyBtLmNvdW50IDogMCkpKTtcclxuXHRcdFx0XHRjb25zdCBwZXJjZW50ID0gTWF0aC5yb3VuZCgxMDAwICogZC5kYXRhLmNvdW50IC8gdG90YWwpIC8gMTA7IC8vIGNhbGN1bGF0ZSBwZXJjZW50XHJcblx0XHRcdFx0dG9vbHRpcC5zZWxlY3QoXCIubGFiZWxcIikuaHRtbChkLmRhdGEubGFiZWwpOyAvLyBzZXQgY3VycmVudCBsYWJlbFxyXG5cdFx0XHRcdHRvb2x0aXAuc2VsZWN0KFwiLmNvdW50XCIpLmh0bWwoYCR7ZC5kYXRhLmNvdW50fWApOyAvLyBzZXQgY3VycmVudCBjb3VudFxyXG5cdFx0XHRcdHRvb2x0aXAuc2VsZWN0KFwiLnBlcmNlbnRcIikuaHRtbChgJHtwZXJjZW50fSVgKTsgLy8gc2V0IHBlcmNlbnQgY2FsY3VsYXRlZCBhYm92ZVxyXG5cdFx0XHRcdHRvb2x0aXAuc3R5bGUoXCJkaXNwbGF5XCIsIFwiYmxvY2tcIik7IC8vIHNldCBkaXNwbGF5XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0cGF0aC5vbihcIm1vdXNlb3V0XCIsICgpID0+IHsgLy8gd2hlbiBtb3VzZSBsZWF2ZXMgZGl2XHJcblx0XHRcdFx0dG9vbHRpcC5zdHlsZShcImRpc3BsYXlcIiwgXCJub25lXCIpOyAvLyBoaWRlIHRvb2x0aXAgZm9yIHRoYXQgZWxlbWVudFxyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdHBhdGgub24oXCJtb3VzZW1vdmVcIiwgKCkgPT4geyAvLyB3aGVuIG1vdXNlIG1vdmVzXHJcblx0XHRcdFx0dG9vbHRpcC5zdHlsZShcInRvcFwiLCBgJHtkMy5ldmVudC5sYXllclkgKyAxMH1weGApIC8vIGFsd2F5cyAxMHB4IGJlbG93IHRoZSBjdXJzb3JcclxuXHRcdFx0XHRcdC5zdHlsZShcImxlZnRcIiwgYCR7ZDMuZXZlbnQubGF5ZXJYICsgMTB9cHhgKTsgLy8gYWx3YXlzIDEwcHggdG8gdGhlIHJpZ2h0IG9mIHRoZSBtb3VzZVxyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdHBhdGgudHJhbnNpdGlvbigpIC8vIHRyYW5zaXRpb24gb2YgcmVkcmF3biBwaWVcclxuXHRcdFx0XHQuZHVyYXRpb24oNzUwKSAvL1xyXG5cdFx0XHRcdC5hdHRyVHdlZW4oXCJkXCIsIGQgPT4ge1xyXG5cdFx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVyc2NvcmUtZGFuZ2xlXHJcblx0XHRcdFx0XHRjb25zdCBpbnRlcnBvbGF0ZSA9IGQzLmludGVycG9sYXRlKHBhdGguX2N1cnJlbnQsIGQpO1xyXG5cdFx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVyc2NvcmUtZGFuZ2xlXHJcblx0XHRcdFx0XHRwYXRoLl9jdXJyZW50ID0gaW50ZXJwb2xhdGUoMCk7XHJcblx0XHRcdFx0XHRyZXR1cm4gdCA9PiBhcmMoaW50ZXJwb2xhdGUodCkpO1xyXG5cdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0Ly8gZGVmaW5lIGxlZ2VuZFxyXG5cdFx0XHRjb25zdCBsZWdlbmQgPSBzdmcuc2VsZWN0QWxsKFwiLmxlZ2VuZFwiKVxyXG5cdFx0XHRcdC5kYXRhKGNvbG9yLmRvbWFpbigpKVxyXG5cdFx0XHRcdC5lbnRlcigpXHJcblx0XHRcdFx0LmFwcGVuZChcImdcIilcclxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIFwibGVnZW5kXCIpXHJcblx0XHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgKGQsIGkpID0+IHtcclxuXHRcdFx0XHRcdGNvbnN0IGxlZ2VuZEhlaWdodCA9IGxlZ2VuZFJlY3RTaXplICsgbGVnZW5kU3BhY2luZztcclxuXHRcdFx0XHRcdGNvbnN0IG9mZnNldCA9IGxlZ2VuZEhlaWdodCAqIGNvbG9yLmRvbWFpbigpLmxlbmd0aCAvIDI7XHJcblx0XHRcdFx0XHRjb25zdCBob3J6ID0gOCAqIGxlZ2VuZFJlY3RTaXplO1xyXG5cdFx0XHRcdFx0Y29uc3QgdmVydCA9IGkgKiBsZWdlbmRIZWlnaHQgLSBvZmZzZXQ7XHJcblx0XHRcdFx0XHRyZXR1cm4gYHRyYW5zbGF0ZSgke2hvcnp9LCR7dmVydH0pYDtcclxuXHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdGxldCByZWN0RWxlbWVudCA9IGxlZ2VuZC5hcHBlbmQoXCJyZWN0XCIpO1xyXG5cclxuXHRcdFx0Ly8gYWRkaW5nIGNvbG9yZWQgc3F1YXJlcyB0byBsZWdlbmRcclxuXHRcdFx0cmVjdEVsZW1lbnQgPSByZWN0RWxlbWVudFxyXG5cdFx0XHRcdC5hdHRyKFwid2lkdGhcIiwgbGVnZW5kUmVjdFNpemUpXHJcblx0XHRcdFx0LmF0dHIoXCJoZWlnaHRcIiwgbGVnZW5kUmVjdFNpemUpXHJcblx0XHRcdFx0LnN0eWxlKFwiZmlsbFwiLCBjb2xvcilcclxuXHRcdFx0XHQuc3R5bGUoXCJkaXJlY3Rpb25cIiwgXCJsdHJcIilcclxuXHRcdFx0XHQuc3R5bGUoXCJzdHJva2VcIiwgY29sb3IpO1xyXG5cclxuXHRcdFx0cmVjdEVsZW1lbnQub24oXCJjbGlja1wiLCBsYWJlbCA9PiB7XHJcblx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXHJcblx0XHRcdFx0Y29uc3QgeyBldmVudCB9ID0gd2luZG93O1xyXG5cdFx0XHRcdGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldCB8fCBldmVudC5zcmNFbGVtZW50O1xyXG5cdFx0XHRcdGNvbnN0IHJlY3QgPSBkMy5zZWxlY3QodGFyZ2V0KTtcclxuXHRcdFx0XHRsZXQgZW5hYmxlZCA9IHRydWU7XHJcblx0XHRcdFx0Y29uc3QgdG90YWxFbmFibGVkID0gZDMuc3VtKGRhdGEubWFwKGQgPT4gKChkLmVuYWJsZWQpID8gMSA6IDApKSk7XHJcblxyXG5cdFx0XHRcdGlmIChyZWN0LmF0dHIoXCJjbGFzc1wiKSA9PT0gXCJkaXNhYmxlZFwiKSB7IC8vIGlmIGNsYXNzIGlzIGRpc2FibGVkXHJcblx0XHRcdFx0XHRyZWN0LmF0dHIoXCJjbGFzc1wiLCBcIlwiKTsgLy8gcmVtb3ZlIGNsYXNzIGRpc2FibGVkXHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2UgeyAvLyBlbHNlXHJcblx0XHRcdFx0XHRpZiAodG90YWxFbmFibGVkIDwgMikgcmV0dXJuOyAvLyBpZiBsZXNzIHRoYW4gdHdvIGxhYmVscyBhcmUgZmxhZ2dlZCwgZXhpdFxyXG5cdFx0XHRcdFx0cmVjdC5hdHRyKFwiY2xhc3NcIiwgXCJkaXNhYmxlZFwiKTsgLy8gb3RoZXJ3aXNlIGZsYWcgdGhlIHNxdWFyZSBkaXNhYmxlZFxyXG5cdFx0XHRcdFx0ZW5hYmxlZCA9IGZhbHNlOyAvLyBzZXQgZW5hYmxlZCB0byBmYWxzZVxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cGllLnZhbHVlKGQgPT4ge1xyXG5cdFx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXHJcblx0XHRcdFx0XHRpZiAoZC5sYWJlbCA9PT0gbGFiZWwpIGQuZW5hYmxlZCA9IGVuYWJsZWQ7XHJcblx0XHRcdFx0XHRyZXR1cm4gKGQuZW5hYmxlZCkgPyBkLmNvdW50IDogMDtcclxuXHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdFx0cGF0aCA9IHBhdGguZGF0YShwaWUoZGF0YSkpOyAvLyB1cGRhdGUgcGllIHdpdGggbmV3IGRhdGFcclxuXHRcdFx0XHQvLyBwYXRoVGV4dCA9IHBhdGhUZXh0LmRhdGEocGllKGRhdGEpKTtcclxuXHJcblx0XHRcdFx0cGF0aFRleHQgPSBwYXRoVGV4dFxyXG5cdFx0XHRcdFx0LmRhdGEocGllKGRhdGEpKVxyXG5cdFx0XHRcdFx0LnRleHQoZCA9PiB7XHJcblx0XHRcdFx0XHRcdGlmICghZC5kYXRhLmVuYWJsZWQpIHtcclxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gXCJcIjtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRjb25zdCB0b3RhbCA9IGQzLnN1bShkYXRhLm1hcChtID0+ICgobS5lbmFibGVkKSA/IG0uY291bnQgOiAwKSkpO1xyXG5cdFx0XHRcdFx0XHRjb25zdCBwZXJjZW50ID0gTWF0aC5yb3VuZCgxMDAwICogZC5kYXRhLmNvdW50IC8gdG90YWwpIC8gMTA7IC8vIGNhbGN1bGF0ZSBwZXJjZW50XHJcblx0XHRcdFx0XHRcdHJldHVybiBgJHtkLmRhdGEuY291bnR9IC0gJHtwZXJjZW50fSVgO1xyXG5cdFx0XHRcdFx0fSlcclxuXHRcdFx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsIGQgPT4gYHRyYW5zbGF0ZSgke2FyYy5jZW50cm9pZChkKX0pYClcclxuXHRcdFx0XHRcdC5zdHlsZShcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpXHJcblx0XHRcdFx0XHQuc3R5bGUoXCJmb250LXNpemVcIiwgMTQpXHJcblx0XHRcdFx0XHQuc3R5bGUoXCJkaXJlY3Rpb25cIiwgXCJsdHJcIik7XHJcblxyXG5cdFx0XHRcdHBhdGgudHJhbnNpdGlvbigpIC8vIHRyYW5zaXRpb24gb2YgcmVkcmF3biBwaWVcclxuXHRcdFx0XHRcdC5kdXJhdGlvbig3NTApIC8vXHJcblx0XHRcdFx0XHQuYXR0clR3ZWVuKFwiZFwiLCBkID0+IHtcclxuXHRcdFx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVyc2NvcmUtZGFuZ2xlXHJcblx0XHRcdFx0XHRcdGNvbnN0IGludGVycG9sYXRlID0gZDMuaW50ZXJwb2xhdGUocGF0aC5fY3VycmVudCwgZCk7XHJcblx0XHRcdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlcnNjb3JlLWRhbmdsZVxyXG5cdFx0XHRcdFx0XHRwYXRoLl9jdXJyZW50ID0gaW50ZXJwb2xhdGUoMCk7XHJcblx0XHRcdFx0XHRcdHJldHVybiB0ID0+IGFyYyhpbnRlcnBvbGF0ZSh0KSk7XHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHQvLyBhZGRpbmcgdGV4dCB0byBsZWdlbmRcclxuXHRcdFx0bGVnZW5kLmFwcGVuZChcInRleHRcIilcclxuXHRcdFx0XHQuYXR0cihcInhcIiwgbGVnZW5kUmVjdFNpemUgKyBsZWdlbmRTcGFjaW5nKVxyXG5cdFx0XHRcdC5hdHRyKFwieVwiLCBsZWdlbmRSZWN0U2l6ZSAtIGxlZ2VuZFNwYWNpbmcpXHJcblx0XHRcdFx0LnN0eWxlKFwiZGlyZWN0aW9uXCIsIFwibHRyXCIpXHJcblx0XHRcdFx0LnRleHQoZCA9PiBkKTsgLy8gcmV0dXJuIGxhYmVsXHJcblx0XHR9LFxyXG5cdFx0ZGF0YSgpIHtcclxuXHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHRtZXNzYWdlOiBudWxsXHJcblx0XHRcdH07XHJcblx0XHR9LFxyXG5cdFx0Y29tcG9uZW50czoge1xyXG5cdFx0XHRBbGVydFxyXG5cdFx0fVxyXG5cdH07XHJcbjwvc2NyaXB0PlxyXG48c3R5bGU+XHJcblx0LmxlZ2VuZCB7XHJcblx0XHRmb250LXNpemU6IDE0cHg7XHJcblx0fVxyXG5cclxuXHRyZWN0IHtcclxuXHRcdGN1cnNvcjogcG9pbnRlcjsgXHJcblx0XHRzdHJva2Utd2lkdGg6IDI7XHJcblx0fVxyXG5cclxuXHRyZWN0LmRpc2FibGVkIHtcclxuXHRcdGZpbGw6IHRyYW5zcGFyZW50ICFpbXBvcnRhbnQ7XHJcblx0fVxyXG5cclxuXHRkaXYge1xyXG5cdFx0bWF4LXdpZHRoOiA2MDBweDtcclxuXHRcdG1hcmdpbjogMCBhdXRvO1xyXG5cdFx0cG9zaXRpb246IHJlbGF0aXZlO1xyXG5cdFx0ZGlzcGxheTogYmxvY2s7XHJcblx0fVxyXG5cclxuXHQvKiB0b29sdGlwICovXHJcblx0LnRvb2x0aXBzIHtcclxuXHRcdGJhY2tncm91bmQ6ICNlZWU7XHJcblx0XHRib3gtc2hhZG93OiAwIDAgNXB4ICNlYmU1ZTU7XHJcblx0XHRjb2xvcjogIzMzMztcclxuXHRcdGRpc3BsYXk6IG5vbmU7XHJcblx0XHRmb250LXNpemU6IDE4cHg7XHJcblx0XHRyaWdodDogMTMwcHg7XHJcblx0XHRwYWRkaW5nOiAxMHB4O1xyXG5cdFx0cG9zaXRpb246IGFic29sdXRlO1xyXG5cdFx0dGV4dC1hbGlnbjogY2VudGVyO1xyXG5cdFx0dG9wOiA5NXB4O1xyXG5cdFx0d2lkdGg6IDgwcHg7XHJcblx0XHR6LWluZGV4OiAxMDtcclxuXHR9XHJcblx0LnBhdGgtbGFiZWwge1xyXG5cdFx0ZGlzcGxheTogYmxvY2s7XHJcblx0XHRjb2xvcjojMDAwO1xyXG5cdFx0ei1pbmRleDogMjA7XHJcblx0fVxyXG48L3N0eWxlPlxyXG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBK1BDLEdBQUcsY0FBQyxDQUFDLEFBQ0osU0FBUyxDQUFFLEtBQUssQ0FDaEIsTUFBTSxDQUFFLENBQUMsQ0FBQyxJQUFJLENBQ2QsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsT0FBTyxDQUFFLEtBQUssQUFDZixDQUFDIn0= */";
    	append(document.head, style);
    }

    function create_main_fragment$o(component, ctx) {
    	var if_block_anchor;

    	var if_block = (ctx.field.data != null) && create_if_block$g(component, ctx);

    	return {
    		c: function create$$1() {
    			if (if_block) if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (ctx.field.data != null) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block$g(component, ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (if_block) if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (1:0) {#if field.data != null}
    function create_if_block$g(component, ctx) {
    	var text$$1, div;

    	var if_block = (ctx.message != null) && create_if_block_1$9(component, ctx);

    	return {
    		c: function create$$1() {
    			if (if_block) if_block.c();
    			text$$1 = createText("\r\n");
    			div = createElement("div");
    			div.className = "pie-chart svelte-s328vy";
    			addLoc(div, file$n, 4, 0, 85);
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert(target, text$$1, anchor);
    			insert(target, div, anchor);
    			component.refs.pie = div;
    		},

    		p: function update(changed, ctx) {
    			if (ctx.message != null) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block_1$9(component, ctx);
    					if_block.c();
    					if_block.m(text$$1.parentNode, text$$1);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (if_block) if_block.d(detach);
    			if (detach) {
    				detachNode(text$$1);
    				detachNode(div);
    			}

    			if (component.refs.pie === div) component.refs.pie = null;
    		}
    	};
    }

    // (2:1) {#if message != null}
    function create_if_block_1$9(component, ctx) {

    	var alert_initial_data = { field: ctx.message };
    	var alert = new SvelteComponent$n({
    		root: component.root,
    		store: component.store,
    		data: alert_initial_data
    	});

    	return {
    		c: function create$$1() {
    			alert._fragment.c();
    		},

    		m: function mount(target, anchor) {
    			alert._mount(target, anchor);
    		},

    		p: function update(changed, ctx) {
    			var alert_changes = {};
    			if (changed.message) alert_changes.field = ctx.message;
    			alert._set(alert_changes);
    		},

    		d: function destroy$$1(detach) {
    			alert.destroy(detach);
    		}
    	};
    }

    function SvelteComponent$o(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) {
    		throw new Error("'target' is a required option");
    	}

    	init(this, options);
    	this.refs = {};
    	this._state = assign(data$9(), options.data);
    	if (!('field' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'field'");
    	if (!('message' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'message'");
    	this._intro = true;

    	if (!document.getElementById("svelte-s328vy-style")) add_css$c();

    	this._fragment = create_main_fragment$o(this, this._state);

    	this.root._oncreate.push(() => {
    		oncreate$h.call(this);
    		this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
    	});

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);

    		flush(this);
    	}
    }

    assign(SvelteComponent$o.prototype, protoDev);

    SvelteComponent$o.prototype._checkReadOnly = function _checkReadOnly(newState) {
    };

    /**
     * Represents an event triggered by an action-list.
     */
    var ActionListEventArguments = /** @class */ (function (_super) {
        __extends(ActionListEventArguments, _super);
        function ActionListEventArguments(app, actionFormId) {
            var _this = _super.call(this, app) || this;
            _this.actionFormId = actionFormId;
            return _this;
        }
        return ActionListEventArguments;
    }(FormEventArguments));

    /* src\core\ui\outputs\ActionList.html generated by Svelte v2.16.1 */



    // eslint-disable-next-line no-debugger
    const alertify$2 = alertify;

    let modalId = 0;
    const modals = [];

    // https://stackoverflow.com/a/3369743/111438
    // Close topmost modal when user presses escape key.
    document.addEventListener("keydown", e => {
    	const evt = e || window.event;
    	let isEscape = false;
    	if ("key" in evt) {
    		isEscape = (evt.key === "Escape" || evt.key === "Esc");
    	}
    	else {
    		isEscape = (evt.keyCode === 27);
    	}
    	if (isEscape) {
    		if (modals.length > 0) {
    			// Close topmost modal.
    			modals[modals.length - 1].close();
    		}
    	}
    });

    function data$a() {
    	modalId += 1;
    	return {
    		open: false,
    		current: null,
    		modalId,
    		disabled: false
    	};
    }
    var methods$9 = {
    	enableActionButton() {
    		this.set({
    			disabled: false
    		});
    	},
    	async run(action, app) {
    		this.set({ disabled: true });
    		const self = this;
    		const formInstance = app.getFormInstance(action.form, true);
    		// eslint-disable-next-line no-debugger

    		// TODO: find a way to initialize from action.inputFieldValues directly.
    		const serializedInputValues = formInstance.getSerializedInputValuesFromObject(action.inputFieldValues);
    		await formInstance.initializeInputFields(serializedInputValues);

    		const allRequiredInputsHaveData = await formInstance.allRequiredInputsHaveData(false);
    		if (action.action === "run" && allRequiredInputsHaveData) {
    			if (action.confirmationMessage) {
    				alertify$2.confirm(
    					"Caution",
    					action.confirmationMessage,
    					async () => {
    						try {
    							const response = await formInstance.submit(self.get().app, false);
    							self.onActionRun(formInstance.metadata.id, response, action);
    						}
    						catch (e) {
    							this.enableActionButton();
    						}
    					},
    					() => {
    						this.enableActionButton();
    					}
    				);
    			}
    			else {
    				try {
    					const response = await formInstance.submit(this.get().app, false);
    					this.onActionRun(formInstance.metadata.id, response, action);
    				}
    				catch (e) {
    					this.enableActionButton();
    				}
    			}
    		}
    		else {
    			this.set({ open: true });

    			const f = new SvelteComponent$8({
    				target: this.refs.container,
    				data: {
    					metadata: formInstance.metadata,
    					form: formInstance,
    					app,
    					useUrl: false
    				}
    			});

    			f.init();

    			f.on("form:responseHandled", e => {
    				if (e.invokedByUser && formInstance.metadata.closeOnPostIfModal) {
    					self.close(e.response);
    				}
    			});

    			this.set({ current: f });

    			modals.push(self);
    		}
    	},
    	close(response) {
    		this.set({ open: false });
    		this.enableActionButton();

    		// Destroy underlying form instance.
    		const modalForm = this.get().current;

    		if (response != null) {
    			const formId = modalForm.get().metadata.id;
    			this.onActionRun(formId, response);
    		}

    		modalForm.destroy();
    		modals.pop();
    	},
    	async onActionRun(formId, response) {
    		const parentForm = this.get().parent;
    		const { app } = parentForm.get();

    		if (response.metadata.handler !== "redirect" &&
    			response.metadata.handler !== "reload") {
    			// If asked to redirect to another form, then we redirect
    			// and do not reload parent form, as that would be a wasted effort.
    			await parentForm.submit(null, true);
    		}

    		const eventArgs = new ActionListEventArguments(app, formId);
    		parentForm.fireAndBubbleUp("action-list:run", eventArgs);
    	}
    };

    const file$o = "src\\core\\ui\\outputs\\ActionList.html";

    function add_css$d() {
    	var style = createElement("style");
    	style.id = 'svelte-1yns50m-style';
    	style.textContent = ".hidden.svelte-1yns50m{width:0;height:0;position:absolute;left:-1000px}.actionlist.svelte-1yns50m{margin:0 0;padding:0 5px;text-align:right;margin-bottom:15px}.actionlist.svelte-1yns50m>li.svelte-1yns50m{list-style-type:none;display:inline-block}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQWN0aW9uTGlzdC5odG1sIiwic291cmNlcyI6WyJBY3Rpb25MaXN0Lmh0bWwiXSwic291cmNlc0NvbnRlbnQiOlsieyNpZiBmaWVsZC5kYXRhICE9IG51bGwgJiYgZmllbGQuZGF0YS5hY3Rpb25zICE9IG51bGwgJiYgZmllbGQuZGF0YS5hY3Rpb25zLmxlbmd0aCA+IDB9XHJcbjx1bCBjbGFzcz1cImFjdGlvbmxpc3RcIj5cclxuXHR7I2VhY2ggZmllbGQuZGF0YS5hY3Rpb25zIGFzIGFjdGlvbn1cclxuXHQ8bGk+XHJcblx0XHR7I2lmIGFjdGlvbi5hY3Rpb24gIT09IFwicmVkaXJlY3RcIn1cclxuXHRcdDxidXR0b24gb246Y2xpY2s9XCJydW4oYWN0aW9uLCBhcHApXCIgZGlzYWJsZWQ9XCJ7ZGlzYWJsZWR9XCIgY2xhc3M9XCJidG4gYnRuLWRlZmF1bHQge2FjdGlvbi5jc3NDbGFzc31cIj57QGh0bWwgYWN0aW9uLmxhYmVsfTwvYnV0dG9uPlxyXG5cdFx0ezplbHNlIH1cclxuXHRcdDxhIGhyZWY9XCJ7YXBwLm1ha2VVcmwoYWN0aW9uLmZvcm0sIGFjdGlvbi5pbnB1dEZpZWxkVmFsdWVzKX1cIiBjbGFzcz1cImJ0biBidG4tZGVmYXVsdCB7YWN0aW9uLmNzc0NsYXNzfVwiPnthY3Rpb24ubGFiZWx9PC9hPlxyXG5cdFx0ey9pZn1cclxuXHQ8L2xpPlxyXG5cdHsvZWFjaH1cclxuPC91bD5cclxuXHJcbjxpbnB1dCBpZD1cIm1vZGFsLXttb2RhbElkfVwiIHR5cGU9XCJjaGVja2JveFwiIGJpbmQ6Y2hlY2tlZD1cIm9wZW5cIiBjbGFzcz1cImhpZGRlblwiIC8+XHJcbjxkaXYgY2xhc3M9XCJtb2RhbFwiPlxyXG5cdDxkaXYgY2xhc3M9XCJjYXJkXCI+XHJcblx0XHQ8bGFiZWwgY2xhc3M9XCJjbG9zZVwiIG9uOmNsaWNrPVwiY2xvc2UoKVwiPjwvbGFiZWw+XHJcblx0XHQ8ZGl2IHJlZjpjb250YWluZXI+PC9kaXY+XHJcblx0PC9kaXY+XHJcbjwvZGl2PlxyXG57L2lmfVxyXG5cclxuPHNjcmlwdD5cclxuXHRpbXBvcnQgRm9ybUNvbXBvbmVudCBmcm9tIFwiY29yZS11aS9Gb3JtXCI7XHJcblx0aW1wb3J0ICogYXMgYWxlcnRpZnlMaWIgZnJvbSBcImFsZXJ0aWZ5anNcIjtcclxuXHRpbXBvcnQgeyBBY3Rpb25MaXN0RXZlbnRBcmd1bWVudHMgfSBmcm9tIFwiLi9BY3Rpb25MaXN0RXZlbnRBcmd1bWVudHNcIjtcclxuXHJcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWRlYnVnZ2VyXHJcblx0Y29uc3QgYWxlcnRpZnkgPSBhbGVydGlmeUxpYi5kZWZhdWx0O1xyXG5cclxuXHRsZXQgbW9kYWxJZCA9IDA7XHJcblx0Y29uc3QgbW9kYWxzID0gW107XHJcblxyXG5cdC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zMzY5NzQzLzExMTQzOFxyXG5cdC8vIENsb3NlIHRvcG1vc3QgbW9kYWwgd2hlbiB1c2VyIHByZXNzZXMgZXNjYXBlIGtleS5cclxuXHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBlID0+IHtcclxuXHRcdGNvbnN0IGV2dCA9IGUgfHwgd2luZG93LmV2ZW50O1xyXG5cdFx0bGV0IGlzRXNjYXBlID0gZmFsc2U7XHJcblx0XHRpZiAoXCJrZXlcIiBpbiBldnQpIHtcclxuXHRcdFx0aXNFc2NhcGUgPSAoZXZ0LmtleSA9PT0gXCJFc2NhcGVcIiB8fCBldnQua2V5ID09PSBcIkVzY1wiKTtcclxuXHRcdH1cclxuXHRcdGVsc2Uge1xyXG5cdFx0XHRpc0VzY2FwZSA9IChldnQua2V5Q29kZSA9PT0gMjcpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGlzRXNjYXBlKSB7XHJcblx0XHRcdGlmIChtb2RhbHMubGVuZ3RoID4gMCkge1xyXG5cdFx0XHRcdC8vIENsb3NlIHRvcG1vc3QgbW9kYWwuXHJcblx0XHRcdFx0bW9kYWxzW21vZGFscy5sZW5ndGggLSAxXS5jbG9zZSgpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSk7XHJcblxyXG5cdGV4cG9ydCBkZWZhdWx0IHtcclxuXHRcdG1ldGhvZHM6IHtcclxuXHRcdFx0ZW5hYmxlQWN0aW9uQnV0dG9uKCkge1xyXG5cdFx0XHRcdHRoaXMuc2V0KHtcclxuXHRcdFx0XHRcdGRpc2FibGVkOiBmYWxzZVxyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRhc3luYyBydW4oYWN0aW9uLCBhcHApIHtcclxuXHRcdFx0XHR0aGlzLnNldCh7IGRpc2FibGVkOiB0cnVlIH0pO1xyXG5cdFx0XHRcdGNvbnN0IHNlbGYgPSB0aGlzO1xyXG5cdFx0XHRcdGNvbnN0IGZvcm1JbnN0YW5jZSA9IGFwcC5nZXRGb3JtSW5zdGFuY2UoYWN0aW9uLmZvcm0sIHRydWUpO1xyXG5cdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kZWJ1Z2dlclxyXG5cclxuXHRcdFx0XHQvLyBUT0RPOiBmaW5kIGEgd2F5IHRvIGluaXRpYWxpemUgZnJvbSBhY3Rpb24uaW5wdXRGaWVsZFZhbHVlcyBkaXJlY3RseS5cclxuXHRcdFx0XHRjb25zdCBzZXJpYWxpemVkSW5wdXRWYWx1ZXMgPSBmb3JtSW5zdGFuY2UuZ2V0U2VyaWFsaXplZElucHV0VmFsdWVzRnJvbU9iamVjdChhY3Rpb24uaW5wdXRGaWVsZFZhbHVlcyk7XHJcblx0XHRcdFx0YXdhaXQgZm9ybUluc3RhbmNlLmluaXRpYWxpemVJbnB1dEZpZWxkcyhzZXJpYWxpemVkSW5wdXRWYWx1ZXMpO1xyXG5cclxuXHRcdFx0XHRjb25zdCBhbGxSZXF1aXJlZElucHV0c0hhdmVEYXRhID0gYXdhaXQgZm9ybUluc3RhbmNlLmFsbFJlcXVpcmVkSW5wdXRzSGF2ZURhdGEoZmFsc2UpO1xyXG5cdFx0XHRcdGlmIChhY3Rpb24uYWN0aW9uID09PSBcInJ1blwiICYmIGFsbFJlcXVpcmVkSW5wdXRzSGF2ZURhdGEpIHtcclxuXHRcdFx0XHRcdGlmIChhY3Rpb24uY29uZmlybWF0aW9uTWVzc2FnZSkge1xyXG5cdFx0XHRcdFx0XHRhbGVydGlmeS5jb25maXJtKFxyXG5cdFx0XHRcdFx0XHRcdFwiQ2F1dGlvblwiLFxyXG5cdFx0XHRcdFx0XHRcdGFjdGlvbi5jb25maXJtYXRpb25NZXNzYWdlLFxyXG5cdFx0XHRcdFx0XHRcdGFzeW5jICgpID0+IHtcclxuXHRcdFx0XHRcdFx0XHRcdHRyeSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZm9ybUluc3RhbmNlLnN1Ym1pdChzZWxmLmdldCgpLmFwcCwgZmFsc2UpO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRzZWxmLm9uQWN0aW9uUnVuKGZvcm1JbnN0YW5jZS5tZXRhZGF0YS5pZCwgcmVzcG9uc2UsIGFjdGlvbik7XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0XHRjYXRjaCAoZSkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzLmVuYWJsZUFjdGlvbkJ1dHRvbigpO1xyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdH0sXHJcblx0XHRcdFx0XHRcdFx0KCkgPT4ge1xyXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5lbmFibGVBY3Rpb25CdXR0b24oKTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRcdFx0XHRjb25zdCByZXNwb25zZSA9IGF3YWl0IGZvcm1JbnN0YW5jZS5zdWJtaXQodGhpcy5nZXQoKS5hcHAsIGZhbHNlKTtcclxuXHRcdFx0XHRcdFx0XHR0aGlzLm9uQWN0aW9uUnVuKGZvcm1JbnN0YW5jZS5tZXRhZGF0YS5pZCwgcmVzcG9uc2UsIGFjdGlvbik7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0Y2F0Y2ggKGUpIHtcclxuXHRcdFx0XHRcdFx0XHR0aGlzLmVuYWJsZUFjdGlvbkJ1dHRvbigpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0dGhpcy5zZXQoeyBvcGVuOiB0cnVlIH0pO1xyXG5cclxuXHRcdFx0XHRcdGNvbnN0IGYgPSBuZXcgRm9ybUNvbXBvbmVudCh7XHJcblx0XHRcdFx0XHRcdHRhcmdldDogdGhpcy5yZWZzLmNvbnRhaW5lcixcclxuXHRcdFx0XHRcdFx0ZGF0YToge1xyXG5cdFx0XHRcdFx0XHRcdG1ldGFkYXRhOiBmb3JtSW5zdGFuY2UubWV0YWRhdGEsXHJcblx0XHRcdFx0XHRcdFx0Zm9ybTogZm9ybUluc3RhbmNlLFxyXG5cdFx0XHRcdFx0XHRcdGFwcCxcclxuXHRcdFx0XHRcdFx0XHR1c2VVcmw6IGZhbHNlXHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0XHRcdGYuaW5pdCgpO1xyXG5cclxuXHRcdFx0XHRcdGYub24oXCJmb3JtOnJlc3BvbnNlSGFuZGxlZFwiLCBlID0+IHtcclxuXHRcdFx0XHRcdFx0aWYgKGUuaW52b2tlZEJ5VXNlciAmJiBmb3JtSW5zdGFuY2UubWV0YWRhdGEuY2xvc2VPblBvc3RJZk1vZGFsKSB7XHJcblx0XHRcdFx0XHRcdFx0c2VsZi5jbG9zZShlLnJlc3BvbnNlKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5zZXQoeyBjdXJyZW50OiBmIH0pO1xyXG5cclxuXHRcdFx0XHRcdG1vZGFscy5wdXNoKHNlbGYpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSxcclxuXHRcdFx0Y2xvc2UocmVzcG9uc2UpIHtcclxuXHRcdFx0XHR0aGlzLnNldCh7IG9wZW46IGZhbHNlIH0pO1xyXG5cdFx0XHRcdHRoaXMuZW5hYmxlQWN0aW9uQnV0dG9uKCk7XHJcblxyXG5cdFx0XHRcdC8vIERlc3Ryb3kgdW5kZXJseWluZyBmb3JtIGluc3RhbmNlLlxyXG5cdFx0XHRcdGNvbnN0IG1vZGFsRm9ybSA9IHRoaXMuZ2V0KCkuY3VycmVudDtcclxuXHJcblx0XHRcdFx0aWYgKHJlc3BvbnNlICE9IG51bGwpIHtcclxuXHRcdFx0XHRcdGNvbnN0IGZvcm1JZCA9IG1vZGFsRm9ybS5nZXQoKS5tZXRhZGF0YS5pZDtcclxuXHRcdFx0XHRcdHRoaXMub25BY3Rpb25SdW4oZm9ybUlkLCByZXNwb25zZSk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRtb2RhbEZvcm0uZGVzdHJveSgpO1xyXG5cdFx0XHRcdG1vZGFscy5wb3AoKTtcclxuXHRcdFx0fSxcclxuXHRcdFx0YXN5bmMgb25BY3Rpb25SdW4oZm9ybUlkLCByZXNwb25zZSkge1xyXG5cdFx0XHRcdGNvbnN0IHBhcmVudEZvcm0gPSB0aGlzLmdldCgpLnBhcmVudDtcclxuXHRcdFx0XHRjb25zdCB7IGFwcCB9ID0gcGFyZW50Rm9ybS5nZXQoKTtcclxuXHJcblx0XHRcdFx0aWYgKHJlc3BvbnNlLm1ldGFkYXRhLmhhbmRsZXIgIT09IFwicmVkaXJlY3RcIiAmJlxyXG5cdFx0XHRcdFx0cmVzcG9uc2UubWV0YWRhdGEuaGFuZGxlciAhPT0gXCJyZWxvYWRcIikge1xyXG5cdFx0XHRcdFx0Ly8gSWYgYXNrZWQgdG8gcmVkaXJlY3QgdG8gYW5vdGhlciBmb3JtLCB0aGVuIHdlIHJlZGlyZWN0XHJcblx0XHRcdFx0XHQvLyBhbmQgZG8gbm90IHJlbG9hZCBwYXJlbnQgZm9ybSwgYXMgdGhhdCB3b3VsZCBiZSBhIHdhc3RlZCBlZmZvcnQuXHJcblx0XHRcdFx0XHRhd2FpdCBwYXJlbnRGb3JtLnN1Ym1pdChudWxsLCB0cnVlKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGNvbnN0IGV2ZW50QXJncyA9IG5ldyBBY3Rpb25MaXN0RXZlbnRBcmd1bWVudHMoYXBwLCBmb3JtSWQpO1xyXG5cdFx0XHRcdHBhcmVudEZvcm0uZmlyZUFuZEJ1YmJsZVVwKFwiYWN0aW9uLWxpc3Q6cnVuXCIsIGV2ZW50QXJncyk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRkYXRhKCkge1xyXG5cdFx0XHRtb2RhbElkICs9IDE7XHJcblx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0b3BlbjogZmFsc2UsXHJcblx0XHRcdFx0Y3VycmVudDogbnVsbCxcclxuXHRcdFx0XHRtb2RhbElkLFxyXG5cdFx0XHRcdGRpc2FibGVkOiBmYWxzZVxyXG5cdFx0XHR9O1xyXG5cdFx0fVxyXG5cdH07XHJcbjwvc2NyaXB0PlxyXG5cclxuPHN0eWxlPlxyXG5cdC5oaWRkZW4ge1xyXG5cdFx0d2lkdGg6IDA7XHJcblx0XHRoZWlnaHQ6IDA7XHJcblx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XHJcblx0XHRsZWZ0OiAtMTAwMHB4O1xyXG5cdH1cclxuXHJcblx0LmFjdGlvbmxpc3Qge1xyXG5cdFx0bWFyZ2luOiAwIDA7XHJcblx0XHRwYWRkaW5nOiAwIDVweDtcclxuXHRcdHRleHQtYWxpZ246IHJpZ2h0O1xyXG5cdFx0bWFyZ2luLWJvdHRvbTogMTVweDtcclxuXHR9XHJcblxyXG5cdC5hY3Rpb25saXN0ID4gbGkge1xyXG5cdFx0bGlzdC1zdHlsZS10eXBlOiBub25lO1xyXG5cdFx0ZGlzcGxheTogaW5saW5lLWJsb2NrO1xyXG5cdH1cclxuPC9zdHlsZT5cclxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQXdLQyxPQUFPLGVBQUMsQ0FBQyxBQUNSLEtBQUssQ0FBRSxDQUFDLENBQ1IsTUFBTSxDQUFFLENBQUMsQ0FDVCxRQUFRLENBQUUsUUFBUSxDQUNsQixJQUFJLENBQUUsT0FBTyxBQUNkLENBQUMsQUFFRCxXQUFXLGVBQUMsQ0FBQyxBQUNaLE1BQU0sQ0FBRSxDQUFDLENBQUMsQ0FBQyxDQUNYLE9BQU8sQ0FBRSxDQUFDLENBQUMsR0FBRyxDQUNkLFVBQVUsQ0FBRSxLQUFLLENBQ2pCLGFBQWEsQ0FBRSxJQUFJLEFBQ3BCLENBQUMsQUFFRCwwQkFBVyxDQUFHLEVBQUUsZUFBQyxDQUFDLEFBQ2pCLGVBQWUsQ0FBRSxJQUFJLENBQ3JCLE9BQU8sQ0FBRSxZQUFZLEFBQ3RCLENBQUMifQ== */";
    	append(document.head, style);
    }

    function click_handler$1(event) {
    	const { component, ctx } = this._svelte;

    	component.run(ctx.action, ctx.app);
    }

    function get_each_context$6(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.action = list[i];
    	return child_ctx;
    }

    function create_main_fragment$p(component, ctx) {
    	var if_block_anchor;

    	var if_block = (ctx.field.data != null && ctx.field.data.actions != null && ctx.field.data.actions.length > 0) && create_if_block$h(component, ctx);

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (ctx.field.data != null && ctx.field.data.actions != null && ctx.field.data.actions.length > 0) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block$h(component, ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (if_block) if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (1:0) {#if field.data != null && field.data.actions != null && field.data.actions.length > 0}
    function create_if_block$h(component, ctx) {
    	var ul, text0, input, input_id_value, text1, div2, div1, label, text2, div0;

    	var each_value = ctx.field.data.actions;

    	var each_blocks = [];

    	for (var i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$6(component, get_each_context$6(ctx, each_value, i));
    	}

    	function input_change_handler() {
    		component.set({ open: input.checked });
    	}

    	function click_handler_1(event) {
    		component.close();
    	}

    	return {
    		c: function create() {
    			ul = createElement("ul");

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			text0 = createText("\r\n\r\n");
    			input = createElement("input");
    			text1 = createText("\r\n");
    			div2 = createElement("div");
    			div1 = createElement("div");
    			label = createElement("label");
    			text2 = createText("\r\n\t\t");
    			div0 = createElement("div");
    			ul.className = "actionlist svelte-1yns50m";
    			addLoc(ul, file$o, 1, 0, 89);
    			addListener(input, "change", input_change_handler);
    			input.id = input_id_value = "modal-" + ctx.modalId;
    			setAttribute(input, "type", "checkbox");
    			input.className = "hidden svelte-1yns50m";
    			addLoc(input, file$o, 13, 0, 505);
    			addListener(label, "click", click_handler_1);
    			label.className = "close";
    			addLoc(label, file$o, 16, 2, 632);
    			addLoc(div0, file$o, 17, 2, 684);
    			div1.className = "card";
    			addLoc(div1, file$o, 15, 1, 610);
    			div2.className = "modal";
    			addLoc(div2, file$o, 14, 0, 588);
    		},

    		m: function mount(target, anchor) {
    			insert(target, ul, anchor);

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}

    			insert(target, text0, anchor);
    			insert(target, input, anchor);

    			input.checked = ctx.open;

    			insert(target, text1, anchor);
    			insert(target, div2, anchor);
    			append(div2, div1);
    			append(div1, label);
    			append(div1, text2);
    			append(div1, div0);
    			component.refs.container = div0;
    		},

    		p: function update(changed, ctx) {
    			if (changed.field || changed.disabled || changed.app) {
    				each_value = ctx.field.data.actions;

    				for (var i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$6(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    					} else {
    						each_blocks[i] = create_each_block$6(component, child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(ul, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}
    				each_blocks.length = each_value.length;
    			}

    			if (changed.open) input.checked = ctx.open;
    			if ((changed.modalId) && input_id_value !== (input_id_value = "modal-" + ctx.modalId)) {
    				input.id = input_id_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(ul);
    			}

    			destroyEach(each_blocks, detach);

    			if (detach) {
    				detachNode(text0);
    				detachNode(input);
    			}

    			removeListener(input, "change", input_change_handler);
    			if (detach) {
    				detachNode(text1);
    				detachNode(div2);
    			}

    			removeListener(label, "click", click_handler_1);
    			if (component.refs.container === div0) component.refs.container = null;
    		}
    	};
    }

    // (7:2) {:else }
    function create_else_block$7(component, ctx) {
    	var a, text_value = ctx.action.label, text, a_href_value, a_class_value;

    	return {
    		c: function create() {
    			a = createElement("a");
    			text = createText(text_value);
    			a.href = a_href_value = ctx.app.makeUrl(ctx.action.form, ctx.action.inputFieldValues);
    			a.className = a_class_value = "btn btn-default " + ctx.action.cssClass + " svelte-1yns50m";
    			addLoc(a, file$o, 7, 2, 345);
    		},

    		m: function mount(target, anchor) {
    			insert(target, a, anchor);
    			append(a, text);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.field) && text_value !== (text_value = ctx.action.label)) {
    				setData(text, text_value);
    			}

    			if ((changed.app || changed.field) && a_href_value !== (a_href_value = ctx.app.makeUrl(ctx.action.form, ctx.action.inputFieldValues))) {
    				a.href = a_href_value;
    			}

    			if ((changed.field) && a_class_value !== (a_class_value = "btn btn-default " + ctx.action.cssClass + " svelte-1yns50m")) {
    				a.className = a_class_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(a);
    			}
    		}
    	};
    }

    // (5:2) {#if action.action !== "redirect"}
    function create_if_block_1$a(component, ctx) {
    	var button, raw_value = ctx.action.label, button_class_value;

    	return {
    		c: function create() {
    			button = createElement("button");
    			button._svelte = { component, ctx };

    			addListener(button, "click", click_handler$1);
    			button.disabled = ctx.disabled;
    			button.className = button_class_value = "btn btn-default " + ctx.action.cssClass + " svelte-1yns50m";
    			addLoc(button, file$o, 5, 2, 200);
    		},

    		m: function mount(target, anchor) {
    			insert(target, button, anchor);
    			button.innerHTML = raw_value;
    		},

    		p: function update(changed, _ctx) {
    			ctx = _ctx;
    			if ((changed.field) && raw_value !== (raw_value = ctx.action.label)) {
    				button.innerHTML = raw_value;
    			}

    			button._svelte.ctx = ctx;
    			if (changed.disabled) {
    				button.disabled = ctx.disabled;
    			}

    			if ((changed.field) && button_class_value !== (button_class_value = "btn btn-default " + ctx.action.cssClass + " svelte-1yns50m")) {
    				button.className = button_class_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(button);
    			}

    			removeListener(button, "click", click_handler$1);
    		}
    	};
    }

    // (3:1) {#each field.data.actions as action}
    function create_each_block$6(component, ctx) {
    	var li;

    	function select_block_type(ctx) {
    		if (ctx.action.action !== "redirect") return create_if_block_1$a;
    		return create_else_block$7;
    	}

    	var current_block_type = select_block_type(ctx);
    	var if_block = current_block_type(component, ctx);

    	return {
    		c: function create() {
    			li = createElement("li");
    			if_block.c();
    			li.className = "svelte-1yns50m";
    			addLoc(li, file$o, 3, 1, 154);
    		},

    		m: function mount(target, anchor) {
    			insert(target, li, anchor);
    			if_block.m(li, null);
    		},

    		p: function update(changed, ctx) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(changed, ctx);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(component, ctx);
    				if_block.c();
    				if_block.m(li, null);
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(li);
    			}

    			if_block.d();
    		}
    	};
    }

    function SvelteComponent$p(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) {
    		throw new Error("'target' is a required option");
    	}

    	init(this, options);
    	this.refs = {};
    	this._state = assign(data$a(), options.data);
    	if (!('field' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'field'");
    	if (!('app' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'app'");
    	if (!('disabled' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'disabled'");
    	if (!('modalId' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'modalId'");
    	if (!('open' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'open'");
    	this._intro = true;

    	if (!document.getElementById("svelte-1yns50m-style")) add_css$d();

    	this._fragment = create_main_fragment$p(this, this._state);

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);
    	}
    }

    assign(SvelteComponent$p.prototype, protoDev);
    assign(SvelteComponent$p.prototype, methods$9);

    SvelteComponent$p.prototype._checkReadOnly = function _checkReadOnly(newState) {
    };

    /* src\core\ui\outputs\Alert.html generated by Svelte v2.16.1 */

    function oncreate$i() {
    	// console.log(this.get().field);
    }
    const file$p = "src\\core\\ui\\outputs\\Alert.html";

    function add_css$e() {
    	var style = createElement("style");
    	style.id = 'svelte-nd7j1a-style';
    	style.textContent = ".alert.svelte-nd7j1a{margin:5px 8px;padding:10px 15px;border:1px solid #bbb}.alert.svelte-nd7j1a>.heading.svelte-nd7j1a{font-weight:bold;font-size:14px}.alert.success.svelte-nd7j1a{background:#ebfff8}.alert.warning.svelte-nd7j1a{background:#fdffeb}.alert.danger.svelte-nd7j1a{background:#ffeaea}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQWxlcnQuaHRtbCIsInNvdXJjZXMiOlsiQWxlcnQuaHRtbCJdLCJzb3VyY2VzQ29udGVudCI6WyJ7I2lmIGZpZWxkICE9IG51bGwgJiYgZmllbGQuZGF0YSAhPSBudWxsfVxyXG48ZGl2IGNsYXNzPVwiYWxlcnQge2ZpZWxkLmRhdGEuc3R5bGV9XCI+XHJcblx0eyNpZiBmaWVsZC5kYXRhLmhlYWRpbmcgIT0gbnVsbCB8fCBmaWVsZC5kYXRhLmljb24gIT0gbnVsbH1cclxuXHQ8ZGl2IGNsYXNzPVwiaGVhZGluZ1wiPlxyXG5cdFx0eyNpZiBmaWVsZC5kYXRhLmljb24gIT0gbnVsbH1cclxuXHRcdFx0PHNwYW4+e0BodG1sIGZpZWxkLmRhdGEuaWNvbn08L3NwYW4+XHJcblx0XHR7L2lmfVxyXG5cdFx0e2ZpZWxkLmRhdGEuaGVhZGluZ31cclxuXHQ8L2Rpdj5cclxuXHR7L2lmfVxyXG5cdHsjaWYgZmllbGQuZGF0YS5tZXNzYWdlICE9IG51bGx9XHJcblx0PGRpdiBjbGFzcz1cImJvZHlcIj57QGh0bWwgZmllbGQuZGF0YS5tZXNzYWdlfTwvZGl2PlxyXG5cdHsvaWZ9XHJcbjwvZGl2PlxyXG57L2lmfVxyXG48c2NyaXB0PlxyXG5cdGV4cG9ydCBkZWZhdWx0IHtcclxuXHRcdG9uY3JlYXRlKCkge1xyXG5cdFx0XHQvLyBjb25zb2xlLmxvZyh0aGlzLmdldCgpLmZpZWxkKTtcclxuXHRcdH1cclxuXHR9O1xyXG48L3NjcmlwdD5cclxuXHJcbjxzdHlsZT5cclxuXHQuYWxlcnQge1xyXG5cdFx0bWFyZ2luOiA1cHggOHB4O1xyXG5cdFx0cGFkZGluZzogMTBweCAxNXB4O1xyXG5cdFx0Ym9yZGVyOiAxcHggc29saWQgI2JiYjtcclxuXHR9XHJcblxyXG5cdC5hbGVydCA+IC5oZWFkaW5nIHtcclxuXHRcdGZvbnQtd2VpZ2h0OiBib2xkO1xyXG5cdFx0Zm9udC1zaXplOiAxNHB4O1xyXG5cdH1cclxuXHJcblx0LmFsZXJ0LnN1Y2Nlc3Mge1xyXG5cdFx0YmFja2dyb3VuZDogI2ViZmZmODtcclxuXHR9XHJcblxyXG5cdC5hbGVydC53YXJuaW5nIHtcclxuXHRcdGJhY2tncm91bmQ6ICNmZGZmZWI7XHJcblx0fVxyXG5cclxuXHQuYWxlcnQuZGFuZ2VyIHtcclxuXHRcdGJhY2tncm91bmQ6ICNmZmVhZWE7XHJcblx0fVxyXG48L3N0eWxlPlxyXG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBd0JDLE1BQU0sY0FBQyxDQUFDLEFBQ1AsTUFBTSxDQUFFLEdBQUcsQ0FBQyxHQUFHLENBQ2YsT0FBTyxDQUFFLElBQUksQ0FBQyxJQUFJLENBQ2xCLE1BQU0sQ0FBRSxHQUFHLENBQUMsS0FBSyxDQUFDLElBQUksQUFDdkIsQ0FBQyxBQUVELG9CQUFNLENBQUcsUUFBUSxjQUFDLENBQUMsQUFDbEIsV0FBVyxDQUFFLElBQUksQ0FDakIsU0FBUyxDQUFFLElBQUksQUFDaEIsQ0FBQyxBQUVELE1BQU0sUUFBUSxjQUFDLENBQUMsQUFDZixVQUFVLENBQUUsT0FBTyxBQUNwQixDQUFDLEFBRUQsTUFBTSxRQUFRLGNBQUMsQ0FBQyxBQUNmLFVBQVUsQ0FBRSxPQUFPLEFBQ3BCLENBQUMsQUFFRCxNQUFNLE9BQU8sY0FBQyxDQUFDLEFBQ2QsVUFBVSxDQUFFLE9BQU8sQUFDcEIsQ0FBQyJ9 */";
    	append(document.head, style);
    }

    function create_main_fragment$q(component, ctx) {
    	var if_block_anchor;

    	var if_block = (ctx.field != null && ctx.field.data != null) && create_if_block$i(component, ctx);

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (ctx.field != null && ctx.field.data != null) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block$i(component, ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (if_block) if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (1:0) {#if field != null && field.data != null}
    function create_if_block$i(component, ctx) {
    	var div, text, div_class_value;

    	var if_block0 = (ctx.field.data.heading != null || ctx.field.data.icon != null) && create_if_block_2$6(component, ctx);

    	var if_block1 = (ctx.field.data.message != null) && create_if_block_1$b(component, ctx);

    	return {
    		c: function create() {
    			div = createElement("div");
    			if (if_block0) if_block0.c();
    			text = createText("\r\n\t");
    			if (if_block1) if_block1.c();
    			div.className = div_class_value = "alert " + ctx.field.data.style + " svelte-nd7j1a";
    			addLoc(div, file$p, 1, 0, 43);
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append(div, text);
    			if (if_block1) if_block1.m(div, null);
    		},

    		p: function update(changed, ctx) {
    			if (ctx.field.data.heading != null || ctx.field.data.icon != null) {
    				if (if_block0) {
    					if_block0.p(changed, ctx);
    				} else {
    					if_block0 = create_if_block_2$6(component, ctx);
    					if_block0.c();
    					if_block0.m(div, text);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (ctx.field.data.message != null) {
    				if (if_block1) {
    					if_block1.p(changed, ctx);
    				} else {
    					if_block1 = create_if_block_1$b(component, ctx);
    					if_block1.c();
    					if_block1.m(div, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if ((changed.field) && div_class_value !== (div_class_value = "alert " + ctx.field.data.style + " svelte-nd7j1a")) {
    				div.className = div_class_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(div);
    			}

    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    		}
    	};
    }

    // (3:1) {#if field.data.heading != null || field.data.icon != null}
    function create_if_block_2$6(component, ctx) {
    	var div, text0, text1_value = ctx.field.data.heading, text1;

    	var if_block = (ctx.field.data.icon != null) && create_if_block_3$4(component, ctx);

    	return {
    		c: function create() {
    			div = createElement("div");
    			if (if_block) if_block.c();
    			text0 = createText("\r\n\t\t");
    			text1 = createText(text1_value);
    			div.className = "heading svelte-nd7j1a";
    			addLoc(div, file$p, 3, 1, 146);
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    			append(div, text0);
    			append(div, text1);
    		},

    		p: function update(changed, ctx) {
    			if (ctx.field.data.icon != null) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block_3$4(component, ctx);
    					if_block.c();
    					if_block.m(div, text0);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if ((changed.field) && text1_value !== (text1_value = ctx.field.data.heading)) {
    				setData(text1, text1_value);
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(div);
    			}

    			if (if_block) if_block.d();
    		}
    	};
    }

    // (5:2) {#if field.data.icon != null}
    function create_if_block_3$4(component, ctx) {
    	var span, raw_value = ctx.field.data.icon;

    	return {
    		c: function create() {
    			span = createElement("span");
    			addLoc(span, file$p, 5, 3, 205);
    		},

    		m: function mount(target, anchor) {
    			insert(target, span, anchor);
    			span.innerHTML = raw_value;
    		},

    		p: function update(changed, ctx) {
    			if ((changed.field) && raw_value !== (raw_value = ctx.field.data.icon)) {
    				span.innerHTML = raw_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(span);
    			}
    		}
    	};
    }

    // (11:1) {#if field.data.message != null}
    function create_if_block_1$b(component, ctx) {
    	var div, raw_value = ctx.field.data.message;

    	return {
    		c: function create() {
    			div = createElement("div");
    			div.className = "body";
    			addLoc(div, file$p, 11, 1, 329);
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);
    			div.innerHTML = raw_value;
    		},

    		p: function update(changed, ctx) {
    			if ((changed.field) && raw_value !== (raw_value = ctx.field.data.message)) {
    				div.innerHTML = raw_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(div);
    			}
    		}
    	};
    }

    function SvelteComponent$q(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) {
    		throw new Error("'target' is a required option");
    	}

    	init(this, options);
    	this._state = assign({}, options.data);
    	if (!('field' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'field'");
    	this._intro = true;

    	if (!document.getElementById("svelte-nd7j1a-style")) add_css$e();

    	this._fragment = create_main_fragment$q(this, this._state);

    	this.root._oncreate.push(() => {
    		oncreate$i.call(this);
    		this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
    	});

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);

    		flush(this);
    	}
    }

    assign(SvelteComponent$q.prototype, protoDev);

    SvelteComponent$q.prototype._checkReadOnly = function _checkReadOnly(newState) {
    };

    /* src\core\ui\outputs\Datetime.html generated by Svelte v2.16.1 */

    function relativeFormat(field) {
    	if (field.data != null &&
    	field.metadata.getCustomProperty("dateTimeStyle") === "relativeTime") {
    		return momentWithLocales.utc(field.data).local().fromNow();
    	}
    	return "";
    }
    function format$2(field) {
    	if (field.data != null) {
    		const dateTimeStyle = field.metadata.getCustomProperty("dateTimeStyle");
    		let format = "D-MM-YYYY hh:mm A";
    		if (dateTimeStyle === "dateTime") {
    			format = "D-MM-YYYY hh:mm A";
    		}
    		else if (dateTimeStyle === "time") {
    			format = "HH:mm";
    		}
    		else if (dateTimeStyle === "relativeTime") {
    			return momentWithLocales.utc(field.data).local().fromNow();
    		}
    		else if (dateTimeStyle === "date") {
    			format = "D-M-YYYY";
    			return momentWithLocales.utc(field.data).local().format(format);
    		}
    		return momentWithLocales.utc(field.data).local().format(format);
    	}
    	return "";
    }
    const file$q = "src\\core\\ui\\outputs\\Datetime.html";

    function add_css$f() {
    	var style = createElement("style");
    	style.id = 'svelte-1d7e158-style';
    	style.textContent = ".date-special.svelte-1d7e158{text-align:center}.date-inner.svelte-1d7e158{direction:ltr !important;font-size:14px;display:block}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRGF0ZXRpbWUuaHRtbCIsInNvdXJjZXMiOlsiRGF0ZXRpbWUuaHRtbCJdLCJzb3VyY2VzQ29udGVudCI6WyI8ZGl2IGNsYXNzPVwiZGF0ZS1zcGVjaWFsXCI+e3JlbGF0aXZlRm9ybWF0KGZpZWxkKX1cclxuXHQ8c3BhbiBjbGFzcz0nZGF0ZS1pbm5lcic+XHJcblx0XHR7Zm9ybWF0KGZpZWxkKX1cclxuXHQ8L3NwYW4+XHJcbjwvZGl2PlxyXG5cclxuPHNjcmlwdD5cclxuXHRpbXBvcnQgbW9tZW50IGZyb20gXCJtb21lbnQvbWluL21vbWVudC13aXRoLWxvY2FsZXNcIjtcclxuXHJcblx0ZXhwb3J0IGRlZmF1bHQge1xyXG5cdFx0aGVscGVyczoge1xyXG5cdFx0XHRyZWxhdGl2ZUZvcm1hdChmaWVsZCkge1xyXG5cdFx0XHRcdGlmIChmaWVsZC5kYXRhICE9IG51bGwgJiZcclxuXHRcdFx0XHRmaWVsZC5tZXRhZGF0YS5nZXRDdXN0b21Qcm9wZXJ0eShcImRhdGVUaW1lU3R5bGVcIikgPT09IFwicmVsYXRpdmVUaW1lXCIpIHtcclxuXHRcdFx0XHRcdHJldHVybiBtb21lbnQudXRjKGZpZWxkLmRhdGEpLmxvY2FsKCkuZnJvbU5vdygpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm4gXCJcIjtcclxuXHRcdFx0fSxcclxuXHRcdFx0Zm9ybWF0KGZpZWxkKSB7XHJcblx0XHRcdFx0aWYgKGZpZWxkLmRhdGEgIT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0Y29uc3QgZGF0ZVRpbWVTdHlsZSA9IGZpZWxkLm1ldGFkYXRhLmdldEN1c3RvbVByb3BlcnR5KFwiZGF0ZVRpbWVTdHlsZVwiKTtcclxuXHRcdFx0XHRcdGxldCBmb3JtYXQgPSBcIkQtTU0tWVlZWSBoaDptbSBBXCI7XHJcblx0XHRcdFx0XHRpZiAoZGF0ZVRpbWVTdHlsZSA9PT0gXCJkYXRlVGltZVwiKSB7XHJcblx0XHRcdFx0XHRcdGZvcm1hdCA9IFwiRC1NTS1ZWVlZIGhoOm1tIEFcIjtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGVsc2UgaWYgKGRhdGVUaW1lU3R5bGUgPT09IFwidGltZVwiKSB7XHJcblx0XHRcdFx0XHRcdGZvcm1hdCA9IFwiSEg6bW1cIjtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGVsc2UgaWYgKGRhdGVUaW1lU3R5bGUgPT09IFwicmVsYXRpdmVUaW1lXCIpIHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIG1vbWVudC51dGMoZmllbGQuZGF0YSkubG9jYWwoKS5mcm9tTm93KCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRlbHNlIGlmIChkYXRlVGltZVN0eWxlID09PSBcImRhdGVcIikge1xyXG5cdFx0XHRcdFx0XHRmb3JtYXQgPSBcIkQtTS1ZWVlZXCI7XHJcblx0XHRcdFx0XHRcdHJldHVybiBtb21lbnQudXRjKGZpZWxkLmRhdGEpLmxvY2FsKCkuZm9ybWF0KGZvcm1hdCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRyZXR1cm4gbW9tZW50LnV0YyhmaWVsZC5kYXRhKS5sb2NhbCgpLmZvcm1hdChmb3JtYXQpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm4gXCJcIjtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH07XHJcbjwvc2NyaXB0PlxyXG5cclxuPHN0eWxlPlxyXG5cdC5kYXRlLXNwZWNpYWwge1xyXG5cdFx0dGV4dC1hbGlnbjogY2VudGVyO1xyXG5cdH1cclxuXHQuZGF0ZS1pbm5lciB7XHJcblx0XHRkaXJlY3Rpb246IGx0ciAhaW1wb3J0YW50O1xyXG5cdFx0Zm9udC1zaXplOiAxNHB4O1xyXG5cdFx0ZGlzcGxheTogYmxvY2s7XHJcblx0fVxyXG48L3N0eWxlPlxyXG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBNENDLGFBQWEsZUFBQyxDQUFDLEFBQ2QsVUFBVSxDQUFFLE1BQU0sQUFDbkIsQ0FBQyxBQUNELFdBQVcsZUFBQyxDQUFDLEFBQ1osU0FBUyxDQUFFLEdBQUcsQ0FBQyxVQUFVLENBQ3pCLFNBQVMsQ0FBRSxJQUFJLENBQ2YsT0FBTyxDQUFFLEtBQUssQUFDZixDQUFDIn0= */";
    	append(document.head, style);
    }

    function create_main_fragment$r(component, ctx) {
    	var div, text0_value = relativeFormat(ctx.field), text0, text1, span, text2_value = format$2(ctx.field), text2;

    	return {
    		c: function create() {
    			div = createElement("div");
    			text0 = createText(text0_value);
    			text1 = createText("\r\n\t");
    			span = createElement("span");
    			text2 = createText(text2_value);
    			span.className = "date-inner svelte-1d7e158";
    			addLoc(span, file$q, 1, 1, 52);
    			div.className = "date-special svelte-1d7e158";
    			addLoc(div, file$q, 0, 0, 0);
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);
    			append(div, text0);
    			append(div, text1);
    			append(div, span);
    			append(span, text2);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.field) && text0_value !== (text0_value = relativeFormat(ctx.field))) {
    				setData(text0, text0_value);
    			}

    			if ((changed.field) && text2_value !== (text2_value = format$2(ctx.field))) {
    				setData(text2, text2_value);
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(div);
    			}
    		}
    	};
    }

    function SvelteComponent$r(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) {
    		throw new Error("'target' is a required option");
    	}

    	init(this, options);
    	this._state = assign({}, options.data);
    	if (!('field' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'field'");
    	this._intro = true;

    	if (!document.getElementById("svelte-1d7e158-style")) add_css$f();

    	this._fragment = create_main_fragment$r(this, this._state);

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);
    	}
    }

    assign(SvelteComponent$r.prototype, protoDev);

    SvelteComponent$r.prototype._checkReadOnly = function _checkReadOnly(newState) {
    };

    /* src\core\ui\outputs\Documentation.html generated by Svelte v2.16.1 */

    function oncreate$j() {
    	const content = this.refs.container;
    	const output = this.refs.toc;

    	let closeLevel = 1;
    	let result = "<ul>";
    	let counter = 0;

    	content.querySelectorAll("h1, h2, h3").forEach(e => {
    		e.setAttribute("id", counter);
    		const openLevel = e.tagName.match(/\d/g)[0];
    		if (openLevel > closeLevel) {
    			result += `${"<ul><li><a data-target='"}${counter}'>${e.innerText}</a>`;
    		}

    		else if (openLevel < closeLevel) {
    			const closingTags = Array(closeLevel - openLevel)
    				.fill()
    				.map(() => "</li></ul>")
    				.join("");

    			result += `${closingTags}</li><li><a data-target='${counter}'>${e.innerText}</a>`;
    		}
    		else {
    			if (closeLevel !== 1) {
    				result += "</li>";
    			}
    			result += `<li><a data-target='${counter}'>${e.innerText}</a>`;
    		}
    		closeLevel = openLevel;
    		counter += 1;
    	});

    	result += Array(closeLevel).fill().map(() => "</li></ul>").join("");

    	output.innerHTML = result;

    	document.querySelectorAll(".table-of-contents a").forEach(a => {
    		a.addEventListener("click", event => {
    			const target = event.currentTarget.getAttribute("data-target");
    			document.getElementById(target).scrollIntoView({ behavior: "smooth" });

    			// clear active
    			document.querySelectorAll(".table-of-contents li.active").forEach(li => {
    				li.classList.remove("active");
    			});

    			// set active
    			let parent = a.parentElement;
    			while (parent) {
    				if (parent.tagName === "LI") {
    					parent.classList.add("active");
    				}
    				parent = parent.parentElement;
    			}

    			event.stopPropagation();
    		});
    	});
    }
    const file$r = "src\\core\\ui\\outputs\\Documentation.html";

    function add_css$g() {
    	var style = createElement("style");
    	style.id = 'svelte-p5uztd-style';
    	style.textContent = ".wrapper.svelte-p5uztd{max-width:1224px;margin:0 auto;display:grid;grid-gap:20px;grid-template-areas:\"content\" \"nav\"}.table-of-contents.svelte-p5uztd{background:white;grid-area:nav;margin-top:35px}.content.svelte-p5uztd{grid-area:content;margin-bottom:100px}@media(min-width: 700px){.wrapper.svelte-p5uztd{grid-template-columns:75% auto;grid-template-areas:\"content nav\"}}@media(max-width: 699px){.wrapper.svelte-p5uztd{grid-template-areas:\"nav\"}.content.svelte-p5uztd{grid-area:unset}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRG9jdW1lbnRhdGlvbi5odG1sIiwic291cmNlcyI6WyJEb2N1bWVudGF0aW9uLmh0bWwiXSwic291cmNlc0NvbnRlbnQiOlsiPGRpdiBjbGFzcz1cIndyYXBwZXJcIj5cclxuXHQ8ZGl2IGNsYXNzPVwiY29udGVudFwiIHJlZjpjb250YWluZXI+XHJcblx0XHR7I2lmIGZpZWxkLmRhdGEgIT0gbnVsbCAmJiBmaWVsZC5kYXRhLnZhbHVlICE9IG51bGx9IHtAaHRtbCBmaWVsZC5kYXRhLnZhbHVlfSB7L2lmfVxyXG5cdDwvZGl2PlxyXG5cclxuXHQ8ZGl2IGNsYXNzPSd0YWJsZS1vZi1jb250ZW50cycgcmVmOnRvYz5cclxuXHQ8L2Rpdj5cclxuPC9kaXY+XHJcblxyXG48c2NyaXB0PlxyXG5cdGV4cG9ydCBkZWZhdWx0IHtcclxuXHRcdG9uY3JlYXRlKCkge1xyXG5cdFx0XHRjb25zdCBjb250ZW50ID0gdGhpcy5yZWZzLmNvbnRhaW5lcjtcclxuXHRcdFx0Y29uc3Qgb3V0cHV0ID0gdGhpcy5yZWZzLnRvYztcclxuXHJcblx0XHRcdGxldCBjbG9zZUxldmVsID0gMTtcclxuXHRcdFx0bGV0IHJlc3VsdCA9IFwiPHVsPlwiO1xyXG5cdFx0XHRsZXQgY291bnRlciA9IDA7XHJcblxyXG5cdFx0XHRjb250ZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJoMSwgaDIsIGgzXCIpLmZvckVhY2goZSA9PiB7XHJcblx0XHRcdFx0ZS5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBjb3VudGVyKTtcclxuXHRcdFx0XHRjb25zdCBvcGVuTGV2ZWwgPSBlLnRhZ05hbWUubWF0Y2goL1xcZC9nKVswXTtcclxuXHRcdFx0XHRpZiAob3BlbkxldmVsID4gY2xvc2VMZXZlbCkge1xyXG5cdFx0XHRcdFx0cmVzdWx0ICs9IGAke1wiPHVsPjxsaT48YSBkYXRhLXRhcmdldD0nXCJ9JHtjb3VudGVyfSc+JHtlLmlubmVyVGV4dH08L2E+YDtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGVsc2UgaWYgKG9wZW5MZXZlbCA8IGNsb3NlTGV2ZWwpIHtcclxuXHRcdFx0XHRcdGNvbnN0IGNsb3NpbmdUYWdzID0gQXJyYXkoY2xvc2VMZXZlbCAtIG9wZW5MZXZlbClcclxuXHRcdFx0XHRcdFx0LmZpbGwoKVxyXG5cdFx0XHRcdFx0XHQubWFwKCgpID0+IFwiPC9saT48L3VsPlwiKVxyXG5cdFx0XHRcdFx0XHQuam9pbihcIlwiKTtcclxuXHJcblx0XHRcdFx0XHRyZXN1bHQgKz0gYCR7Y2xvc2luZ1RhZ3N9PC9saT48bGk+PGEgZGF0YS10YXJnZXQ9JyR7Y291bnRlcn0nPiR7ZS5pbm5lclRleHR9PC9hPmA7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0aWYgKGNsb3NlTGV2ZWwgIT09IDEpIHtcclxuXHRcdFx0XHRcdFx0cmVzdWx0ICs9IFwiPC9saT5cIjtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHJlc3VsdCArPSBgPGxpPjxhIGRhdGEtdGFyZ2V0PScke2NvdW50ZXJ9Jz4ke2UuaW5uZXJUZXh0fTwvYT5gO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRjbG9zZUxldmVsID0gb3BlbkxldmVsO1xyXG5cdFx0XHRcdGNvdW50ZXIgKz0gMTtcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHRyZXN1bHQgKz0gQXJyYXkoY2xvc2VMZXZlbCkuZmlsbCgpLm1hcCgoKSA9PiBcIjwvbGk+PC91bD5cIikuam9pbihcIlwiKTtcclxuXHJcblx0XHRcdG91dHB1dC5pbm5lckhUTUwgPSByZXN1bHQ7XHJcblxyXG5cdFx0XHRkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLnRhYmxlLW9mLWNvbnRlbnRzIGFcIikuZm9yRWFjaChhID0+IHtcclxuXHRcdFx0XHRhLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBldmVudCA9PiB7XHJcblx0XHRcdFx0XHRjb25zdCB0YXJnZXQgPSBldmVudC5jdXJyZW50VGFyZ2V0LmdldEF0dHJpYnV0ZShcImRhdGEtdGFyZ2V0XCIpO1xyXG5cdFx0XHRcdFx0ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGFyZ2V0KS5zY3JvbGxJbnRvVmlldyh7IGJlaGF2aW9yOiBcInNtb290aFwiIH0pO1xyXG5cclxuXHRcdFx0XHRcdC8vIGNsZWFyIGFjdGl2ZVxyXG5cdFx0XHRcdFx0ZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi50YWJsZS1vZi1jb250ZW50cyBsaS5hY3RpdmVcIikuZm9yRWFjaChsaSA9PiB7XHJcblx0XHRcdFx0XHRcdGxpLmNsYXNzTGlzdC5yZW1vdmUoXCJhY3RpdmVcIik7XHJcblx0XHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdFx0XHQvLyBzZXQgYWN0aXZlXHJcblx0XHRcdFx0XHRsZXQgcGFyZW50ID0gYS5wYXJlbnRFbGVtZW50O1xyXG5cdFx0XHRcdFx0d2hpbGUgKHBhcmVudCkge1xyXG5cdFx0XHRcdFx0XHRpZiAocGFyZW50LnRhZ05hbWUgPT09IFwiTElcIikge1xyXG5cdFx0XHRcdFx0XHRcdHBhcmVudC5jbGFzc0xpc3QuYWRkKFwiYWN0aXZlXCIpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdHBhcmVudCA9IHBhcmVudC5wYXJlbnRFbGVtZW50O1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHR9O1xyXG48L3NjcmlwdD5cclxuXHJcbjxzdHlsZT5cclxuXHQud3JhcHBlciB7XHJcblx0XHRtYXgtd2lkdGg6IDEyMjRweDtcclxuXHRcdG1hcmdpbjogMCBhdXRvO1xyXG5cdFx0ZGlzcGxheTogZ3JpZDtcclxuXHRcdGdyaWQtZ2FwOiAyMHB4O1xyXG5cdFx0Z3JpZC10ZW1wbGF0ZS1hcmVhczogXCJjb250ZW50XCIgXCJuYXZcIjtcclxuXHR9XHJcblxyXG5cdC50YWJsZS1vZi1jb250ZW50cyB7XHJcblx0XHRiYWNrZ3JvdW5kOiB3aGl0ZTtcclxuXHRcdGdyaWQtYXJlYTogbmF2O1xyXG5cdFx0bWFyZ2luLXRvcDogMzVweDtcclxuXHR9XHJcblxyXG5cdC5jb250ZW50IHtcclxuXHRcdGdyaWQtYXJlYTogY29udGVudDtcclxuXHRcdG1hcmdpbi1ib3R0b206IDEwMHB4O1xyXG5cdH1cclxuXHJcblx0QG1lZGlhIChtaW4td2lkdGg6IDcwMHB4KSB7XHJcblx0XHQud3JhcHBlciB7XHJcblx0XHRcdGdyaWQtdGVtcGxhdGUtY29sdW1uczogNzUlIGF1dG87XHJcblx0XHRcdGdyaWQtdGVtcGxhdGUtYXJlYXM6IFwiY29udGVudCBuYXZcIjtcclxuXHRcdH1cclxuXHJcblx0XHQudGFibGUtb2YtY29udGVudHMgPiB1bCB7XHJcblx0XHRcdHBvc2l0aW9uOiBmaXhlZDtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdEBtZWRpYSAobWF4LXdpZHRoOiA2OTlweCkge1xyXG5cdFx0LndyYXBwZXIge1xyXG5cdFx0XHRncmlkLXRlbXBsYXRlLWFyZWFzOiBcIm5hdlwiO1xyXG5cdFx0fVxyXG5cclxuXHRcdC5jb250ZW50IHtcclxuXHRcdFx0Z3JpZC1hcmVhOiB1bnNldDtcclxuXHRcdH1cclxuXHJcblx0XHQuY29udGVudCBpbWcge1xyXG5cdFx0XHR3aWR0aDogMTAwJTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC5jb250ZW50IGgxIGVtIHtcclxuXHRcdGZvbnQtc2l6ZTogdW5zZXQ7XHJcblx0fVxyXG5cclxuXHQuY29udGVudCBoMSB7XHJcblx0XHRib3JkZXItYm90dG9tOiAzcHggc29saWQgI2VjZWNlYztcclxuXHRcdG1hcmdpbjogMzBweCAwIDIwcHg7XHJcblx0XHR0ZXh0LWFsaWduOiBjZW50ZXI7XHJcblx0XHRwYWRkaW5nOiAwIDAgNXB4IDA7XHJcblx0fVxyXG5cclxuXHQuY29udGVudCBoMiB7XHJcblx0XHRtYXJnaW4tdG9wOiAyNXB4O1xyXG5cdFx0cGFkZGluZzogMTBweCAwO1xyXG5cdFx0Ym9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICNiNGI0YjQ7XHJcblx0XHRtYXJnaW4tYm90dG9tOiAyNXB4O1xyXG5cdFx0Zm9udC13ZWlnaHQ6IGJvbGQ7XHJcblx0fVxyXG5cclxuXHQuY29udGVudCBoMyB7XHJcblx0XHRtYXJnaW4tdG9wOiAyNXB4O1xyXG5cdH1cclxuXHJcblx0LmNvbnRlbnQgaDQge1xyXG5cdFx0Zm9udC1zaXplOiAxLjVyZW07XHJcblx0XHRvcGFjaXR5OiAwLjg7XHJcblx0fVxyXG5cclxuXHQuY29udGVudCA+IHVsIHtcclxuXHRcdG1hcmdpbi1sZWZ0OiAyNXB4O1xyXG5cdH1cclxuXHJcblx0LmNvbnRlbnQgaW1nIHtcclxuXHRcdG1hcmdpbi1ib3R0b206IDM1cHg7XHJcblx0XHRib3JkZXI6IDFweCBzb2xpZCAjZWNlY2VjO1xyXG5cdFx0YmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XHJcblx0XHRib3gtc2hhZG93OiA1cHggNXB4IDEwcHggI2FhYTtcclxuXHRcdG1heC13aWR0aDogMTAwJTtcclxuXHR9XHJcblxyXG5cdC50YWJsZS1vZi1jb250ZW50cyB1bCB7XHJcblx0XHRsaXN0LXN0eWxlOiBub25lO1xyXG5cdH1cclxuXHJcblx0bGkuYWN0aXZlID4gYSB7XHJcblx0XHRmb250LXdlaWdodDogNTAwO1xyXG5cdH1cclxuXHJcblx0LnRhYmxlLW9mLWNvbnRlbnRzIGE6aG92ZXIge1xyXG5cdFx0Zm9udC13ZWlnaHQ6IDYwMDtcclxuXHR9XHJcblxyXG5cdC50YWJsZS1vZi1jb250ZW50cyBsaSB7XHJcblx0XHRjdXJzb3I6IHBvaW50ZXI7XHJcblx0fVxyXG5cclxuXHQudGFibGUtb2YtY29udGVudHMgdWwgbGkge1xyXG5cdFx0ZGlzcGxheTogbm9uZTtcclxuXHR9XHJcblxyXG5cdC50YWJsZS1vZi1jb250ZW50cyA+IHVsID4gbGksXHJcblx0LnRhYmxlLW9mLWNvbnRlbnRzID4gdWwgPiBsaSA+IHVsID4gbGkge1xyXG5cdFx0ZGlzcGxheTogYmxvY2s7XHJcblx0fVxyXG5cclxuXHQudGFibGUtb2YtY29udGVudHMgbGkuYWN0aXZlID4gdWwgPiBsaSB7XHJcblx0XHRkaXNwbGF5OiBibG9jaztcclxuXHR9XHJcbjwvc3R5bGU+XHJcbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUEyRUMsUUFBUSxjQUFDLENBQUMsQUFDVCxTQUFTLENBQUUsTUFBTSxDQUNqQixNQUFNLENBQUUsQ0FBQyxDQUFDLElBQUksQ0FDZCxPQUFPLENBQUUsSUFBSSxDQUNiLFFBQVEsQ0FBRSxJQUFJLENBQ2QsbUJBQW1CLENBQUUsU0FBUyxDQUFDLEtBQUssQUFDckMsQ0FBQyxBQUVELGtCQUFrQixjQUFDLENBQUMsQUFDbkIsVUFBVSxDQUFFLEtBQUssQ0FDakIsU0FBUyxDQUFFLEdBQUcsQ0FDZCxVQUFVLENBQUUsSUFBSSxBQUNqQixDQUFDLEFBRUQsUUFBUSxjQUFDLENBQUMsQUFDVCxTQUFTLENBQUUsT0FBTyxDQUNsQixhQUFhLENBQUUsS0FBSyxBQUNyQixDQUFDLEFBRUQsTUFBTSxBQUFDLFlBQVksS0FBSyxDQUFDLEFBQUMsQ0FBQyxBQUMxQixRQUFRLGNBQUMsQ0FBQyxBQUNULHFCQUFxQixDQUFFLEdBQUcsQ0FBQyxJQUFJLENBQy9CLG1CQUFtQixDQUFFLGFBQWEsQUFDbkMsQ0FBQyxBQUtGLENBQUMsQUFFRCxNQUFNLEFBQUMsWUFBWSxLQUFLLENBQUMsQUFBQyxDQUFDLEFBQzFCLFFBQVEsY0FBQyxDQUFDLEFBQ1QsbUJBQW1CLENBQUUsS0FBSyxBQUMzQixDQUFDLEFBRUQsUUFBUSxjQUFDLENBQUMsQUFDVCxTQUFTLENBQUUsS0FBSyxBQUNqQixDQUFDLEFBS0YsQ0FBQyJ9 */";
    	append(document.head, style);
    }

    function create_main_fragment$s(component, ctx) {
    	var div2, div0, text, div1;

    	var if_block = (ctx.field.data != null && ctx.field.data.value != null) && create_if_block$j(component, ctx);

    	return {
    		c: function create() {
    			div2 = createElement("div");
    			div0 = createElement("div");
    			if (if_block) if_block.c();
    			text = createText("\r\n\r\n\t");
    			div1 = createElement("div");
    			div0.className = "content svelte-p5uztd";
    			addLoc(div0, file$r, 1, 1, 24);
    			div1.className = "table-of-contents svelte-p5uztd";
    			addLoc(div1, file$r, 5, 1, 160);
    			div2.className = "wrapper svelte-p5uztd";
    			addLoc(div2, file$r, 0, 0, 0);
    		},

    		m: function mount(target, anchor) {
    			insert(target, div2, anchor);
    			append(div2, div0);
    			if (if_block) if_block.m(div0, null);
    			component.refs.container = div0;
    			append(div2, text);
    			append(div2, div1);
    			component.refs.toc = div1;
    		},

    		p: function update(changed, ctx) {
    			if (ctx.field.data != null && ctx.field.data.value != null) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block$j(component, ctx);
    					if_block.c();
    					if_block.m(div0, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(div2);
    			}

    			if (if_block) if_block.d();
    			if (component.refs.container === div0) component.refs.container = null;
    			if (component.refs.toc === div1) component.refs.toc = null;
    		}
    	};
    }

    // (3:2) {#if field.data != null && field.data.value != null}
    function create_if_block$j(component, ctx) {
    	var raw_value = ctx.field.data.value, raw_before, raw_after;

    	return {
    		c: function create() {
    			raw_before = createElement('noscript');
    			raw_after = createElement('noscript');
    		},

    		m: function mount(target, anchor) {
    			insert(target, raw_before, anchor);
    			raw_before.insertAdjacentHTML("afterend", raw_value);
    			insert(target, raw_after, anchor);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.field) && raw_value !== (raw_value = ctx.field.data.value)) {
    				detachBetween(raw_before, raw_after);
    				raw_before.insertAdjacentHTML("afterend", raw_value);
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachBetween(raw_before, raw_after);
    				detachNode(raw_before);
    				detachNode(raw_after);
    			}
    		}
    	};
    }

    function SvelteComponent$s(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) {
    		throw new Error("'target' is a required option");
    	}

    	init(this, options);
    	this.refs = {};
    	this._state = assign({}, options.data);
    	if (!('field' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'field'");
    	this._intro = true;

    	if (!document.getElementById("svelte-p5uztd-style")) add_css$g();

    	this._fragment = create_main_fragment$s(this, this._state);

    	this.root._oncreate.push(() => {
    		oncreate$j.call(this);
    		this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
    	});

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);

    		flush(this);
    	}
    }

    assign(SvelteComponent$s.prototype, protoDev);

    SvelteComponent$s.prototype._checkReadOnly = function _checkReadOnly(newState) {
    };

    /* src\core\ui\outputs\DownloadableFile.html generated by Svelte v2.16.1 */

    const file$s = "src\\core\\ui\\outputs\\DownloadableFile.html";

    function create_main_fragment$t(component, ctx) {
    	var a, text_value = ctx.field.data.name, text, a_href_value;

    	return {
    		c: function create() {
    			a = createElement("a");
    			text = createText(text_value);
    			a.href = a_href_value = "/file/download?id=" + ctx.field.data.id;
    			addLoc(a, file$s, 0, 0, 0);
    		},

    		m: function mount(target, anchor) {
    			insert(target, a, anchor);
    			append(a, text);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.field) && text_value !== (text_value = ctx.field.data.name)) {
    				setData(text, text_value);
    			}

    			if ((changed.field) && a_href_value !== (a_href_value = "/file/download?id=" + ctx.field.data.id)) {
    				a.href = a_href_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(a);
    			}
    		}
    	};
    }

    function SvelteComponent$t(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) {
    		throw new Error("'target' is a required option");
    	}

    	init(this, options);
    	this._state = assign({}, options.data);
    	if (!('field' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'field'");
    	this._intro = true;

    	this._fragment = create_main_fragment$t(this, this._state);

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);
    	}
    }

    assign(SvelteComponent$t.prototype, protoDev);

    SvelteComponent$t.prototype._checkReadOnly = function _checkReadOnly(newState) {
    };

    /* src\core\ui\outputs\FileSize.html generated by Svelte v2.16.1 */

    function filesize(bytes) {
    	const thresh = 1000;
    	if (Math.abs(bytes) < thresh) {
    		return `${bytes} B`;
    	}

    	const units = ["kB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"];

    	let u = -1;
    	let result = bytes;

    	do {
    		result /= thresh;
    		u += 1;
    	} while (Math.abs(result) >= thresh && u < units.length - 1);

    	return `${result.toFixed(1)} ${units[u]}`;
    }
    function create_main_fragment$u(component, ctx) {
    	var text_value = filesize(ctx.field.data.bytes), text;

    	return {
    		c: function create() {
    			text = createText(text_value);
    		},

    		m: function mount(target, anchor) {
    			insert(target, text, anchor);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.field) && text_value !== (text_value = filesize(ctx.field.data.bytes))) {
    				setData(text, text_value);
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(text);
    			}
    		}
    	};
    }

    function SvelteComponent$u(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) {
    		throw new Error("'target' is a required option");
    	}

    	init(this, options);
    	this._state = assign({}, options.data);
    	if (!('field' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'field'");
    	this._intro = true;

    	this._fragment = create_main_fragment$u(this, this._state);

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);
    	}
    }

    assign(SvelteComponent$u.prototype, protoDev);

    SvelteComponent$u.prototype._checkReadOnly = function _checkReadOnly(newState) {
    };

    /* src\core\ui\outputs\FormLink.html generated by Svelte v2.16.1 */

    const file$u = "src\\core\\ui\\outputs\\FormLink.html";

    function add_css$h() {
    	var style = createElement("style");
    	style.id = 'svelte-1ki0of6-style';
    	style.textContent = "a.svelte-1ki0of6{color:#333 !important;font-weight:700}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRm9ybUxpbmsuaHRtbCIsInNvdXJjZXMiOlsiRm9ybUxpbmsuaHRtbCJdLCJzb3VyY2VzQ29udGVudCI6WyJ7I2lmIGZpZWxkLmRhdGEgIT0gbnVsbH1cclxuXHR7I2lmIGZpZWxkLmRhdGEuZm9ybSAhPSBudWxsfVxyXG5cdFx0PGEgaHJlZj1cInthcHAubWFrZVVybChmaWVsZC5kYXRhLmZvcm0sIGZpZWxkLmRhdGEuaW5wdXRGaWVsZFZhbHVlcyl9XCI+e2ZpZWxkLmRhdGEubGFiZWx9PC9hPlxyXG5cdHs6ZWxzZX1cclxuXHRcdDxzcGFuPntmaWVsZC5kYXRhLmxhYmVsfTwvc3Bhbj5cclxuXHR7L2lmfVxyXG57L2lmfVxyXG5cclxuPHN0eWxlPlxyXG5hIHtcclxuXHRjb2xvcjogIzMzMyAhaW1wb3J0YW50O1xyXG5cdGZvbnQtd2VpZ2h0OiA3MDA7XHJcbn1cclxuPC9zdHlsZT5cclxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQVNBLENBQUMsZUFBQyxDQUFDLEFBQ0YsS0FBSyxDQUFFLElBQUksQ0FBQyxVQUFVLENBQ3RCLFdBQVcsQ0FBRSxHQUFHLEFBQ2pCLENBQUMifQ== */";
    	append(document.head, style);
    }

    function create_main_fragment$v(component, ctx) {
    	var if_block_anchor;

    	var if_block = (ctx.field.data != null) && create_if_block$k(component, ctx);

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (ctx.field.data != null) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block$k(component, ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (if_block) if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (1:0) {#if field.data != null}
    function create_if_block$k(component, ctx) {
    	var if_block_anchor;

    	function select_block_type(ctx) {
    		if (ctx.field.data.form != null) return create_if_block_1$c;
    		return create_else_block$8;
    	}

    	var current_block_type = select_block_type(ctx);
    	var if_block = current_block_type(component, ctx);

    	return {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(changed, ctx);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(component, ctx);
    				if_block.c();
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},

    		d: function destroy$$1(detach) {
    			if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (4:1) {:else}
    function create_else_block$8(component, ctx) {
    	var span, text_value = ctx.field.data.label, text;

    	return {
    		c: function create() {
    			span = createElement("span");
    			text = createText(text_value);
    			addLoc(span, file$u, 4, 2, 166);
    		},

    		m: function mount(target, anchor) {
    			insert(target, span, anchor);
    			append(span, text);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.field) && text_value !== (text_value = ctx.field.data.label)) {
    				setData(text, text_value);
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(span);
    			}
    		}
    	};
    }

    // (2:1) {#if field.data.form != null}
    function create_if_block_1$c(component, ctx) {
    	var a, text_value = ctx.field.data.label, text, a_href_value;

    	return {
    		c: function create() {
    			a = createElement("a");
    			text = createText(text_value);
    			a.href = a_href_value = ctx.app.makeUrl(ctx.field.data.form, ctx.field.data.inputFieldValues);
    			a.className = "svelte-1ki0of6";
    			addLoc(a, file$u, 2, 2, 60);
    		},

    		m: function mount(target, anchor) {
    			insert(target, a, anchor);
    			append(a, text);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.field) && text_value !== (text_value = ctx.field.data.label)) {
    				setData(text, text_value);
    			}

    			if ((changed.app || changed.field) && a_href_value !== (a_href_value = ctx.app.makeUrl(ctx.field.data.form, ctx.field.data.inputFieldValues))) {
    				a.href = a_href_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(a);
    			}
    		}
    	};
    }

    function SvelteComponent$v(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) {
    		throw new Error("'target' is a required option");
    	}

    	init(this, options);
    	this._state = assign({}, options.data);
    	if (!('field' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'field'");
    	if (!('app' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'app'");
    	this._intro = true;

    	if (!document.getElementById("svelte-1ki0of6-style")) add_css$h();

    	this._fragment = create_main_fragment$v(this, this._state);

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);
    	}
    }

    assign(SvelteComponent$v.prototype, protoDev);

    SvelteComponent$v.prototype._checkReadOnly = function _checkReadOnly(newState) {
    };

    /* src\core\ui\outputs\HtmlString.html generated by Svelte v2.16.1 */

    function create_main_fragment$w(component, ctx) {
    	var if_block_anchor;

    	var if_block = (ctx.field.data != null && ctx.field.data.value != null) && create_if_block$l(component, ctx);

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (ctx.field.data != null && ctx.field.data.value != null) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block$l(component, ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (if_block) if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (1:0) {#if field.data != null && field.data.value != null}
    function create_if_block$l(component, ctx) {
    	var raw_value = ctx.field.data.value, raw_before, raw_after;

    	return {
    		c: function create() {
    			raw_before = createElement('noscript');
    			raw_after = createElement('noscript');
    		},

    		m: function mount(target, anchor) {
    			insert(target, raw_before, anchor);
    			raw_before.insertAdjacentHTML("afterend", raw_value);
    			insert(target, raw_after, anchor);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.field) && raw_value !== (raw_value = ctx.field.data.value)) {
    				detachBetween(raw_before, raw_after);
    				raw_before.insertAdjacentHTML("afterend", raw_value);
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachBetween(raw_before, raw_after);
    				detachNode(raw_before);
    				detachNode(raw_after);
    			}
    		}
    	};
    }

    function SvelteComponent$w(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) {
    		throw new Error("'target' is a required option");
    	}

    	init(this, options);
    	this._state = assign({}, options.data);
    	if (!('field' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'field'");
    	this._intro = true;

    	this._fragment = create_main_fragment$w(this, this._state);

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);
    	}
    }

    assign(SvelteComponent$w.prototype, protoDev);

    SvelteComponent$w.prototype._checkReadOnly = function _checkReadOnly(newState) {
    };

    /* src\core\ui\outputs\Image.html generated by Svelte v2.16.1 */

    const file$w = "src\\core\\ui\\outputs\\Image.html";

    function create_main_fragment$x(component, ctx) {
    	var if_block_anchor;

    	var if_block = (ctx.field.data != null) && create_if_block$m(component, ctx);

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (ctx.field.data != null) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block$m(component, ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (if_block) if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (1:0) {#if field.data != null}
    function create_if_block$m(component, ctx) {
    	var img, img_src_value;

    	return {
    		c: function create() {
    			img = createElement("img");
    			img.src = img_src_value = ctx.field.data.url;
    			img.width = "100";
    			img.alt = "";
    			addLoc(img, file$w, 1, 0, 26);
    		},

    		m: function mount(target, anchor) {
    			insert(target, img, anchor);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.field) && img_src_value !== (img_src_value = ctx.field.data.url)) {
    				img.src = img_src_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(img);
    			}
    		}
    	};
    }

    function SvelteComponent$x(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) {
    		throw new Error("'target' is a required option");
    	}

    	init(this, options);
    	this._state = assign({}, options.data);
    	if (!('field' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'field'");
    	this._intro = true;

    	this._fragment = create_main_fragment$x(this, this._state);

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);
    	}
    }

    assign(SvelteComponent$x.prototype, protoDev);

    SvelteComponent$x.prototype._checkReadOnly = function _checkReadOnly(newState) {
    };

    /* src\core\ui\outputs\InlineForm.html generated by Svelte v2.16.1 */

    function oncreate$k() {
    	const { app, field } = this.get();
    	const parentFormComponent = this.get().parent;

    	const formInstance = app.getFormInstance(field.data.form, true);

    	formInstance.initializeInputFields(field.data.inputFieldValues).then(() => {
    		const f = new SvelteComponent$8({
    			target: this.refs.container,
    			data: {
    				metadata: formInstance.metadata,
    				form: formInstance,
    				app,
    				useUrl: false,
    				parent: parentFormComponent
    			}
    		});

    		f.init();

    		this.set({ current: f });
    	});

    	this.get().parent.on("destroy", () => this.destroy());
    }
    function ondestroy$1() {
    	const form = this.get().current;

    	if (form != null) {
    		form.destroy();
    	}
    }
    const file$x = "src\\core\\ui\\outputs\\InlineForm.html";

    function add_css$i() {
    	var style = createElement("style");
    	style.id = 'svelte-1ntlhhh-style';
    	style.textContent = ".inline-form.svelte-1ntlhhh{border-width:1px 1px 1px;border-style:solid;border-color:#899294;margin:30px 0;border-radius:5px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSW5saW5lRm9ybS5odG1sIiwic291cmNlcyI6WyJJbmxpbmVGb3JtLmh0bWwiXSwic291cmNlc0NvbnRlbnQiOlsiPGRpdiByZWY6Y29udGFpbmVyIGNsYXNzPVwiaW5saW5lLWZvcm1cIj48L2Rpdj5cclxuXHJcbjxzY3JpcHQ+XHJcblx0aW1wb3J0IEZvcm1Db21wb25lbnQgZnJvbSBcImNvcmUtdWkvRm9ybVwiO1xyXG5cclxuXHRleHBvcnQgZGVmYXVsdCB7XHJcblx0XHRvbmNyZWF0ZSgpIHtcclxuXHRcdFx0Y29uc3QgeyBhcHAsIGZpZWxkIH0gPSB0aGlzLmdldCgpO1xyXG5cdFx0XHRjb25zdCBwYXJlbnRGb3JtQ29tcG9uZW50ID0gdGhpcy5nZXQoKS5wYXJlbnQ7XHJcblxyXG5cdFx0XHRjb25zdCBmb3JtSW5zdGFuY2UgPSBhcHAuZ2V0Rm9ybUluc3RhbmNlKGZpZWxkLmRhdGEuZm9ybSwgdHJ1ZSk7XHJcblxyXG5cdFx0XHRmb3JtSW5zdGFuY2UuaW5pdGlhbGl6ZUlucHV0RmllbGRzKGZpZWxkLmRhdGEuaW5wdXRGaWVsZFZhbHVlcykudGhlbigoKSA9PiB7XHJcblx0XHRcdFx0Y29uc3QgZiA9IG5ldyBGb3JtQ29tcG9uZW50KHtcclxuXHRcdFx0XHRcdHRhcmdldDogdGhpcy5yZWZzLmNvbnRhaW5lcixcclxuXHRcdFx0XHRcdGRhdGE6IHtcclxuXHRcdFx0XHRcdFx0bWV0YWRhdGE6IGZvcm1JbnN0YW5jZS5tZXRhZGF0YSxcclxuXHRcdFx0XHRcdFx0Zm9ybTogZm9ybUluc3RhbmNlLFxyXG5cdFx0XHRcdFx0XHRhcHAsXHJcblx0XHRcdFx0XHRcdHVzZVVybDogZmFsc2UsXHJcblx0XHRcdFx0XHRcdHBhcmVudDogcGFyZW50Rm9ybUNvbXBvbmVudFxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0XHRmLmluaXQoKTtcclxuXHJcblx0XHRcdFx0dGhpcy5zZXQoeyBjdXJyZW50OiBmIH0pO1xyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdHRoaXMuZ2V0KCkucGFyZW50Lm9uKFwiZGVzdHJveVwiLCAoKSA9PiB0aGlzLmRlc3Ryb3koKSk7XHJcblx0XHR9LFxyXG5cdFx0b25kZXN0cm95KCkge1xyXG5cdFx0XHRjb25zdCBmb3JtID0gdGhpcy5nZXQoKS5jdXJyZW50O1xyXG5cclxuXHRcdFx0aWYgKGZvcm0gIT0gbnVsbCkge1xyXG5cdFx0XHRcdGZvcm0uZGVzdHJveSgpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fTtcclxuPC9zY3JpcHQ+XHJcblxyXG48c3R5bGU+XHJcblx0LmlubGluZS1mb3JtIHtcclxuXHRcdGJvcmRlci13aWR0aDogMXB4IDFweCAxcHg7XHJcblx0XHRib3JkZXItc3R5bGU6IHNvbGlkO1xyXG5cdFx0Ym9yZGVyLWNvbG9yOiAjODk5Mjk0O1xyXG5cdFx0bWFyZ2luOiAzMHB4IDA7XHJcblx0XHRib3JkZXItcmFkaXVzOiA1cHg7XHJcblx0fVxyXG5cclxuXHQuaW5saW5lLWZvcm0gLmZvcm0taGVhZGVyIHtcclxuXHRcdGJvcmRlci1ib3R0b206IG5vbmU7XHJcblx0XHRwYWRkaW5nLXRvcDogMDtcclxuXHRcdHBhZGRpbmctYm90dG9tOiAwO1xyXG5cdFx0YmFja2dyb3VuZDogI2VlZTtcclxuXHR9XHJcblxyXG5cdC5pbmxpbmUtZm9ybSAucmVzcG9uc2Uge1xyXG5cdFx0bWFyZ2luLXRvcDogMDtcclxuXHRcdHBhZGRpbmc6IDEwcHggMTVweDtcclxuXHR9XHJcblxyXG5cdC5pbmxpbmUtZm9ybSBoMiB7XHJcblx0XHRtYXJnaW46IDA7XHJcblx0XHRmb250LXNpemU6IDE1cHg7XHJcblx0XHRwYWRkaW5nOiAxMHB4IDE1cHggMTVweDtcclxuXHR9XHJcblxyXG5cdC5pbmxpbmUtZm9ybSAucmVzcG9uc2UgLmZvcm0taGVhZGVyIHtcclxuXHRcdHBhZGRpbmctdG9wOiAxMHB4O1xyXG5cdFx0Ym9yZGVyLWJvdHRvbTogMXB4IHNvbGlkIHJnYigyMzEsIDE1NCwgMTQ3KTtcclxuXHRcdGJhY2tncm91bmQtY29sb3I6ICNmZmY7XHJcblx0fVxyXG5cclxuXHQuaW5saW5lLWZvcm0gLnJlc3BvbnNlIGgyIHtcclxuXHRcdGZvbnQtc2l6ZTogMnJlbTtcclxuXHR9XHJcbjwvc3R5bGU+XHJcbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUEwQ0MsWUFBWSxlQUFDLENBQUMsQUFDYixZQUFZLENBQUUsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQ3pCLFlBQVksQ0FBRSxLQUFLLENBQ25CLFlBQVksQ0FBRSxPQUFPLENBQ3JCLE1BQU0sQ0FBRSxJQUFJLENBQUMsQ0FBQyxDQUNkLGFBQWEsQ0FBRSxHQUFHLEFBQ25CLENBQUMifQ== */";
    	append(document.head, style);
    }

    function create_main_fragment$y(component, ctx) {
    	var div;

    	return {
    		c: function create() {
    			div = createElement("div");
    			div.className = "inline-form svelte-1ntlhhh";
    			addLoc(div, file$x, 0, 0, 0);
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);
    			component.refs.container = div;
    		},

    		p: noop,

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(div);
    			}

    			if (component.refs.container === div) component.refs.container = null;
    		}
    	};
    }

    function SvelteComponent$y(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) {
    		throw new Error("'target' is a required option");
    	}

    	init(this, options);
    	this.refs = {};
    	this._state = assign({}, options.data);
    	this._intro = true;

    	this._handlers.destroy = [ondestroy$1];

    	if (!document.getElementById("svelte-1ntlhhh-style")) add_css$i();

    	this._fragment = create_main_fragment$y(this, this._state);

    	this.root._oncreate.push(() => {
    		oncreate$k.call(this);
    		this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
    	});

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);

    		flush(this);
    	}
    }

    assign(SvelteComponent$y.prototype, protoDev);

    SvelteComponent$y.prototype._checkReadOnly = function _checkReadOnly(newState) {
    };

    /* src\core\ui\outputs\Link.html generated by Svelte v2.16.1 */

    const file$y = "src\\core\\ui\\outputs\\Link.html";

    function create_main_fragment$z(component, ctx) {
    	var if_block_anchor;

    	var if_block = (ctx.field.data != null) && create_if_block$n(component, ctx);

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (ctx.field.data != null) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block$n(component, ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (if_block) if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (1:0) {#if field.data != null}
    function create_if_block$n(component, ctx) {
    	var a, text_value = ctx.field.data.anchor, text, a_href_value, a_target_value, a_class_value;

    	return {
    		c: function create() {
    			a = createElement("a");
    			text = createText(text_value);
    			a.href = a_href_value = ctx.field.data.url;
    			a.target = a_target_value = ctx.field.data.target;
    			a.className = a_class_value = ctx.field.data.cssClass;
    			addLoc(a, file$y, 1, 0, 26);
    		},

    		m: function mount(target, anchor) {
    			insert(target, a, anchor);
    			append(a, text);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.field) && text_value !== (text_value = ctx.field.data.anchor)) {
    				setData(text, text_value);
    			}

    			if ((changed.field) && a_href_value !== (a_href_value = ctx.field.data.url)) {
    				a.href = a_href_value;
    			}

    			if ((changed.field) && a_target_value !== (a_target_value = ctx.field.data.target)) {
    				a.target = a_target_value;
    			}

    			if ((changed.field) && a_class_value !== (a_class_value = ctx.field.data.cssClass)) {
    				a.className = a_class_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(a);
    			}
    		}
    	};
    }

    function SvelteComponent$z(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) {
    		throw new Error("'target' is a required option");
    	}

    	init(this, options);
    	this._state = assign({}, options.data);
    	if (!('field' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'field'");
    	this._intro = true;

    	this._fragment = create_main_fragment$z(this, this._state);

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);
    	}
    }

    assign(SvelteComponent$z.prototype, protoDev);

    SvelteComponent$z.prototype._checkReadOnly = function _checkReadOnly(newState) {
    };

    /* src\core\ui\outputs\Number.html generated by Svelte v2.16.1 */

    function formatted({ field }) {
    	if (field.data == null) {
    		return "";
    	}

    	const x = field.data;
    	const parts = x.toString().split(".");
    	parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ",");

    	return parts.join(".");
    }

    function create_main_fragment$A(component, ctx) {
    	var if_block_anchor;

    	var if_block = (ctx.field.data != null) && create_if_block$o(component, ctx);

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (ctx.field.data != null) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block$o(component, ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (if_block) if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (1:0) {#if field.data != null}
    function create_if_block$o(component, ctx) {
    	var text;

    	return {
    		c: function create() {
    			text = createText(ctx.formatted);
    		},

    		m: function mount(target, anchor) {
    			insert(target, text, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (changed.formatted) {
    				setData(text, ctx.formatted);
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(text);
    			}
    		}
    	};
    }

    function SvelteComponent$A(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) {
    		throw new Error("'target' is a required option");
    	}

    	init(this, options);
    	this._state = assign({}, options.data);

    	this._recompute({ field: 1 }, this._state);
    	if (!('field' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'field'");
    	this._intro = true;

    	this._fragment = create_main_fragment$A(this, this._state);

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);
    	}
    }

    assign(SvelteComponent$A.prototype, protoDev);

    SvelteComponent$A.prototype._checkReadOnly = function _checkReadOnly(newState) {
    	if ('formatted' in newState && !this._updatingReadonlyProperty) throw new Error("<SvelteComponent>: Cannot set read-only property 'formatted'");
    };

    SvelteComponent$A.prototype._recompute = function _recompute(changed, state) {
    	if (changed.field) {
    		if (this._differs(state.formatted, (state.formatted = formatted(state)))) changed.formatted = true;
    	}
    };

    /* src\core\ui\outputs\ObjectList.html generated by Svelte v2.16.1 */



    function oncreate$l() {
    	const { field } = this.get();
    	if (field.data == null || field.data.metadata == null) {
    		return;
    	}

    	const columns = field.data.metadata;
    	delete columns.customProperties;

    	const formMetadata = new FormMetadata({
    		customProperties: field.data.metadata.customProperties,
    		outputFields: columns,
    		inputFields: []
    	});

    	const items = [];
    	for (const item of field.data.items) {
    		items.push(FormInstance.getOutputFieldValues(formMetadata.outputFields, item));
    	}

    	this.set({
    		items,
    		cssClass: formMetadata.getCustomProperty("cssClass") || ""
    	});
    }
    const file$A = "src\\core\\ui\\outputs\\ObjectList.html";

    function add_css$j() {
    	var style = createElement("style");
    	style.id = 'svelte-1hhmh3x-style';
    	style.textContent = ".object-list-item.svelte-1hhmh3x{margin:10px 0;border-bottom:1px solid #eee;padding:10px 0}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiT2JqZWN0TGlzdC5odG1sIiwic291cmNlcyI6WyJPYmplY3RMaXN0Lmh0bWwiXSwic291cmNlc0NvbnRlbnQiOlsieyNpZiBmaWVsZC5kYXRhICE9IG51bGwgJiYgaXRlbXMgIT0gbnVsbH1cclxueyNlYWNoIGl0ZW1zIGFzIGl0ZW1GaWVsZHN9XHJcblx0PGRpdiBjbGFzcz1cIm9iamVjdC1saXN0LWl0ZW0ge2Nzc0NsYXNzfVwiPlxyXG5cdFx0eyNlYWNoIGl0ZW1GaWVsZHMgYXMgaXRlbUZpZWxkfVxyXG5cdFx0eyNpZiBpdGVtRmllbGQubWV0YWRhdGEuaGlkZGVuID09IGZhbHNlICYmICEoaXRlbUZpZWxkLm1ldGFkYXRhLmdldEN1c3RvbVByb3BlcnR5KFwiaGlkZUlmTnVsbFwiKSA9PT0gdHJ1ZSAmJiBpdGVtRmllbGQuZGF0YSA9PT0gbnVsbCl9XHJcblx0XHQgXHQ8Rm9ybU91dHB1dCBmaWVsZD1cIntpdGVtRmllbGR9XCIgYXBwPVwie2FwcH1cIiBmb3JtPVwie2Zvcm19XCIgcGFyZW50PVwie3BhcmVudH1cIiAvPlxyXG5cdFx0ey9pZn1cclxuXHRcdHsvZWFjaH1cclxuXHQ8L2Rpdj5cclxuey9lYWNofVxyXG57L2lmfVxyXG5cclxuPHNjcmlwdD5cclxuXHRpbXBvcnQgKiBhcyB1bWYgZnJvbSBcImNvcmUtZnJhbWV3b3JrXCI7XHJcblx0aW1wb3J0ICogYXMgdWltZmNvcmUgZnJvbSBcInVpbWYtY29yZVwiO1xyXG5cdGltcG9ydCBGb3JtT3V0cHV0IGZyb20gXCIuLi9PdXRwdXRcIjtcclxuXHJcblx0ZXhwb3J0IGRlZmF1bHQge1xyXG5cdFx0b25jcmVhdGUoKSB7XHJcblx0XHRcdGNvbnN0IHsgZmllbGQgfSA9IHRoaXMuZ2V0KCk7XHJcblx0XHRcdGlmIChmaWVsZC5kYXRhID09IG51bGwgfHwgZmllbGQuZGF0YS5tZXRhZGF0YSA9PSBudWxsKSB7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRjb25zdCBjb2x1bW5zID0gZmllbGQuZGF0YS5tZXRhZGF0YTtcclxuXHRcdFx0ZGVsZXRlIGNvbHVtbnMuY3VzdG9tUHJvcGVydGllcztcclxuXHJcblx0XHRcdGNvbnN0IGZvcm1NZXRhZGF0YSA9IG5ldyB1aW1mY29yZS5Gb3JtTWV0YWRhdGEoe1xyXG5cdFx0XHRcdGN1c3RvbVByb3BlcnRpZXM6IGZpZWxkLmRhdGEubWV0YWRhdGEuY3VzdG9tUHJvcGVydGllcyxcclxuXHRcdFx0XHRvdXRwdXRGaWVsZHM6IGNvbHVtbnMsXHJcblx0XHRcdFx0aW5wdXRGaWVsZHM6IFtdXHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0Y29uc3QgaXRlbXMgPSBbXTtcclxuXHRcdFx0Zm9yIChjb25zdCBpdGVtIG9mIGZpZWxkLmRhdGEuaXRlbXMpIHtcclxuXHRcdFx0XHRpdGVtcy5wdXNoKHVtZi5Gb3JtSW5zdGFuY2UuZ2V0T3V0cHV0RmllbGRWYWx1ZXMoZm9ybU1ldGFkYXRhLm91dHB1dEZpZWxkcywgaXRlbSkpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLnNldCh7XHJcblx0XHRcdFx0aXRlbXMsXHJcblx0XHRcdFx0Y3NzQ2xhc3M6IGZvcm1NZXRhZGF0YS5nZXRDdXN0b21Qcm9wZXJ0eShcImNzc0NsYXNzXCIpIHx8IFwiXCJcclxuXHRcdFx0fSk7XHJcblx0XHR9LFxyXG5cdFx0Y29tcG9uZW50czoge1xyXG5cdFx0XHRGb3JtT3V0cHV0XHJcblx0XHR9XHJcblx0fTtcclxuPC9zY3JpcHQ+XHJcblxyXG48c3R5bGU+XHJcblx0Lm9iamVjdC1saXN0LWl0ZW0ge1xyXG5cdFx0bWFyZ2luOiAxMHB4IDA7XHJcblx0XHRib3JkZXItYm90dG9tOiAxcHggc29saWQgI2VlZTtcclxuXHRcdHBhZGRpbmc6IDEwcHggMDtcclxuXHR9XHJcbjwvc3R5bGU+XHJcbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFrREMsaUJBQWlCLGVBQUMsQ0FBQyxBQUNsQixNQUFNLENBQUUsSUFBSSxDQUFDLENBQUMsQ0FDZCxhQUFhLENBQUUsR0FBRyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQzdCLE9BQU8sQ0FBRSxJQUFJLENBQUMsQ0FBQyxBQUNoQixDQUFDIn0= */";
    	append(document.head, style);
    }

    function get_each_context_1$2(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.itemField = list[i];
    	return child_ctx;
    }

    function get_each_context$7(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.itemFields = list[i];
    	return child_ctx;
    }

    function create_main_fragment$B(component, ctx) {
    	var if_block_anchor;

    	var if_block = (ctx.field.data != null && ctx.items != null) && create_if_block$p(component, ctx);

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (ctx.field.data != null && ctx.items != null) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block$p(component, ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (if_block) if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (1:0) {#if field.data != null && items != null}
    function create_if_block$p(component, ctx) {
    	var each_anchor;

    	var each_value = ctx.items;

    	var each_blocks = [];

    	for (var i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$7(component, get_each_context$7(ctx, each_value, i));
    	}

    	return {
    		c: function create() {
    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert(target, each_anchor, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (changed.cssClass || changed.items || changed.app || changed.form || changed.parent) {
    				each_value = ctx.items;

    				for (var i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$7(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    					} else {
    						each_blocks[i] = create_each_block$7(component, child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_anchor.parentNode, each_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}
    				each_blocks.length = each_value.length;
    			}
    		},

    		d: function destroy$$1(detach) {
    			destroyEach(each_blocks, detach);

    			if (detach) {
    				detachNode(each_anchor);
    			}
    		}
    	};
    }

    // (5:2) {#if itemField.metadata.hidden == false && !(itemField.metadata.getCustomProperty("hideIfNull") === true && itemField.data === null)}
    function create_if_block_1$d(component, ctx) {

    	var formoutput_initial_data = {
    	 	field: ctx.itemField,
    	 	app: ctx.app,
    	 	form: ctx.form,
    	 	parent: ctx.parent
    	 };
    	var formoutput = new SvelteComponent$6({
    		root: component.root,
    		store: component.store,
    		data: formoutput_initial_data
    	});

    	return {
    		c: function create() {
    			formoutput._fragment.c();
    		},

    		m: function mount(target, anchor) {
    			formoutput._mount(target, anchor);
    		},

    		p: function update(changed, ctx) {
    			var formoutput_changes = {};
    			if (changed.items) formoutput_changes.field = ctx.itemField;
    			if (changed.app) formoutput_changes.app = ctx.app;
    			if (changed.form) formoutput_changes.form = ctx.form;
    			if (changed.parent) formoutput_changes.parent = ctx.parent;
    			formoutput._set(formoutput_changes);
    		},

    		d: function destroy$$1(detach) {
    			formoutput.destroy(detach);
    		}
    	};
    }

    // (4:2) {#each itemFields as itemField}
    function create_each_block_1$2(component, ctx) {
    	var if_block_anchor;

    	var if_block = (ctx.itemField.metadata.hidden == false && !(ctx.itemField.metadata.getCustomProperty("hideIfNull") === true && ctx.itemField.data === null)) && create_if_block_1$d(component, ctx);

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (ctx.itemField.metadata.hidden == false && !(ctx.itemField.metadata.getCustomProperty("hideIfNull") === true && ctx.itemField.data === null)) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block_1$d(component, ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (if_block) if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (2:0) {#each items as itemFields}
    function create_each_block$7(component, ctx) {
    	var div, text, div_class_value;

    	var each_value_1 = ctx.itemFields;

    	var each_blocks = [];

    	for (var i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$2(component, get_each_context_1$2(ctx, each_value_1, i));
    	}

    	return {
    		c: function create() {
    			div = createElement("div");

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			text = createText("\r\n\t");
    			div.className = div_class_value = "object-list-item " + ctx.cssClass + " svelte-1hhmh3x";
    			addLoc(div, file$A, 2, 1, 73);
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			append(div, text);
    		},

    		p: function update(changed, ctx) {
    			if (changed.items || changed.app || changed.form || changed.parent) {
    				each_value_1 = ctx.itemFields;

    				for (var i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$2(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    					} else {
    						each_blocks[i] = create_each_block_1$2(component, child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div, text);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}
    				each_blocks.length = each_value_1.length;
    			}

    			if ((changed.cssClass) && div_class_value !== (div_class_value = "object-list-item " + ctx.cssClass + " svelte-1hhmh3x")) {
    				div.className = div_class_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(div);
    			}

    			destroyEach(each_blocks, detach);
    		}
    	};
    }

    function SvelteComponent$B(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) {
    		throw new Error("'target' is a required option");
    	}

    	init(this, options);
    	this._state = assign({}, options.data);
    	if (!('field' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'field'");
    	if (!('items' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'items'");
    	if (!('cssClass' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'cssClass'");
    	if (!('app' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'app'");
    	if (!('form' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'form'");
    	if (!('parent' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'parent'");
    	this._intro = true;

    	if (!document.getElementById("svelte-1hhmh3x-style")) add_css$j();

    	this._fragment = create_main_fragment$B(this, this._state);

    	this.root._oncreate.push(() => {
    		oncreate$l.call(this);
    		this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
    	});

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);

    		flush(this);
    	}
    }

    assign(SvelteComponent$B.prototype, protoDev);

    SvelteComponent$B.prototype._checkReadOnly = function _checkReadOnly(newState) {
    };

    /* src\core\ui\outputs\Table.html generated by Svelte v2.16.1 */



    function buildFilter$3(currentFormInstance, parameters) {
    	let promise;

    	const filter = {};
    	if (parameters != null && parameters.length > 0) {
    		promise = currentFormInstance.getSerializedInputValues().then(data => {
    			for (const p of parameters) {
    				filter[p] = data[p];
    			}

    			return filter;
    		});
    	}
    	else {
    		promise = Promise.resolve(filter);
    	}

    	return promise;
    }

    const modals$1 = [];

    // https://stackoverflow.com/a/3369743/111438
    // Close topmost modal when user presses escape key.
    document.addEventListener("keydown", e => {
    	const evt = e || window.event;
    	let isEscape = false;
    	if ("key" in evt) {
    		isEscape = evt.key === "Escape" || evt.key === "Esc";
    	}
    	else {
    		isEscape = evt.keyCode === 27;
    	}
    	if (isEscape) {
    		if (modals$1.length > 0) {
    			// Close topmost modal.
    			modals$1[modals$1.length - 1].closeBulkActionModal();
    		}
    	}
    });

    function columnsOrdered({ field }) {
    	return field.metadata.customProperties.columns
    	.filter(b => !b.hidden)
    	.sort((a, b) => a.orderIndex - b.orderIndex);
    }

    function data$b() {
    	return {
    		bulkActions: [],
    		getRowCssClass: () => "",
    		disabled: false
    	};
    }
    var methods$a = {
    	enableBulkButton() {
    		this.set({
    			disabled: false
    		});
    	},
    	async runBulkAction(action) {
    		this.set({ disabled: true });
    		// eslint-disable-next-line no-underscore-dangle
    		const selectedItems = this.get().field.data.filter(t => t.__selected === true);
    		const { map } = this.get();
    		const selectedItemIds = selectedItems.map(t => t[map[action.itemIdentifierField.toLowerCase()]]);

    		const { app } = this.get();
    		const formInstance = app.getFormInstance(action.formId, true);

    		const filter = await buildFilter$3(this.get().form, action.parameters);
    		filter.Items = { items: selectedItemIds };
    		formInstance.setInputFields(filter);

    		const isAllInputsHidden =
    			formInstance.inputs.filter(t => t.metadata.hidden === false)
    				.length > 0;

    		if (!isAllInputsHidden) {
    			try {
    				const response = await formInstance.submit(this.get().app, false);
    				this.onActionRun(formInstance.metadata.id, response, action);
    				this.enableBulkButton();
    			}
    			catch (e) {
    				this.enableBulkButton();
    			}
    		}
    		else {
    			this.set({
    				isBulkActionModalOpen: true
    			});
    			const f = new SvelteComponent$8({
    				target: this.refs.bulkActionContainer,
    				data: {
    					metadata: formInstance.metadata,
    					form: formInstance,
    					app,
    					useUrl: false
    				}
    			});

    			f.init();

    			const self = this;
    			f.on("form:responseHandled", e => {
    				self.closeBulkActionModal(e.response);
    			});

    			this.set({
    				currentBulkActionForm: f
    			});

    			modals$1.push(this);
    		}
    	},
    	async onActionRun(formId, response) {
    		const parentForm = this.get().parent;
    		const { app } = parentForm.get();

    		if (
    			response.metadata.handler !== "redirect" &&
    			response.metadata.handler !== "reload"
    		) {
    			// If asked to redirect to another form, then we redirect
    			// and do not reload parent form, as that would be a wasted effort.
    			await parentForm.submit(null, true);
    		}

    		const eventArgs = new ActionListEventArguments(app, formId);
    		parentForm.fireAndBubbleUp("action-list:run", eventArgs);
    	},
    	async closeBulkActionModal(response) {
    		const { currentBulkActionForm } = this.get();
    		this.enableBulkButton();
    		this.set({
    			isBulkActionModalOpen: false,
    			currentBulkActionForm: null
    		});

    		currentBulkActionForm.destroy();

    		const parentFormComponent = this.get().parent;

    		if (
    			response != null &&
    			response.metadata.handler !== "redirect" &&
    			response.metadata.handler !== "reload"
    		) {
    			// If asked to redirect to another form, then we redirect
    			// and do not reload parent form, as that would be a wasted effort.
    			await parentFormComponent.submit(null, true);
    		}

    		modals$1.pop();
    	},
    	isDisabled(row) {
    		return (
    			row.actions == null ||
    			row.actions.actions == null ||
    			row.actions.actions.filter(t => this.get().bulkActions.some(r => r.formId === t.form)).length === 0
    		);
    	},
    	selectItem(checkboxElement, row) {
    		// eslint-disable-next-line no-underscore-dangle, no-param-reassign
    		row.__selected = checkboxElement.checked;

    		// eslint-disable-next-line no-underscore-dangle
    		const selectedItems = this.get().field.data.filter(t => t.__selected === true);
    		this.set({ selectedItemsCount: selectedItems.length });
    	},
    	selectAllItems(checkboxElement) {
    		for (const row of this.get().field.data) {
    			if (!this.isDisabled(row)) {
    				// eslint-disable-next-line no-underscore-dangle, no-param-reassign
    				row.__selected = checkboxElement.checked;
    			}
    		}

    		const checkboxes = this.refs.table.querySelectorAll("tbody>tr>td .checkbox");

    		for (const checkbox of checkboxes) {
    			if (!checkbox.disabled) {
    				checkbox.checked = checkboxElement.checked;
    			}
    		}

    		// eslint-disable-next-line no-underscore-dangle
    		const selectedItems = this.get().field.data.filter(t => t.__selected === true);
    		this.set({ selectedItemsCount: selectedItems.length });
    	},
    	sortData(column, columns) {
    		const { parent, form, field } = this.get();

    		const paginatorInput = form.inputs.find(t => t.metadata.id ===
    				field.metadata.customProperties.customizations.paginator);

    		if (paginatorInput != null) {
    			paginatorInput.value.orderBy = column.customProperties.sortableBy;
    			for (const i of columns) {
    				i.ascending = false;
    			}

    			paginatorInput.value.ascending = !paginatorInput.value.ascending;
    			// eslint-disable-next-line no-param-reassign
    			column.ascending = paginatorInput.value.ascending;

    			const params = {};
    			for (const i of form.inputs) {
    				params[i.metadata.id] = i.value;
    			}
    			form.setInputFields(params);
    			parent.submit(null, false);
    		}
    	}
    };

    function oncreate$m() {
    	const { data } = this.get().field;

    	if (data == null) {
    		return;
    	}

    	const { metadata } = this.get().field;
    	const { rowCssClass } = metadata.customProperties || {};

    	// Create map, with key being the lowercase version of the property name
    	// and value being the actual property name.
    	const map = {};
    	if (data.length > 0) {
    		const firstRow = data[0];

    		for (const property of Object.keys(firstRow)) {
    			map[property.toLowerCase()] = property;
    		}
    	}

    	this.set({
    		// Show table only after the `oncreate` method has run.
    		visible: true,
    		bulkActions: (metadata.customProperties || {}).bulkAction || [],
    		map,
    		getField(row, column) {
    			const value = row[map[column.id.toLowerCase()]];

    			return {
    				data: value,
    				metadata: column
    			};
    		},
    		getRowCssClass(row) {
    			let cssClass = "";

    			if (rowCssClass != null) {
    				cssClass = rowCssClass.cssClass || "";

    				if (rowCssClass.suffix != null) {
    					cssClass += row[map[rowCssClass.suffix.toLowerCase()]];
    				}
    			}

    			return cssClass;
    		},
    		selectedItemsCount: 0
    	});
    }
    const file$B = "src\\core\\ui\\outputs\\Table.html";

    function add_css$k() {
    	var style = createElement("style");
    	style.id = 'svelte-bip1ia-style';
    	style.textContent = ".btn-row.svelte-bip1ia{text-align:right}.checkbox.svelte-bip1ia{clip:unset;clip-path:unset;position:unset;width:15px;height:15px}.sortable-column.svelte-bip1ia{cursor:pointer}.horizontal-scroll.svelte-bip1ia{overflow:hidden;overflow-x:auto;clear:both;width:100%}.table.svelte-bip1ia{min-width:rem-calc(640);text-align:center}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGFibGUuaHRtbCIsInNvdXJjZXMiOlsiVGFibGUuaHRtbCJdLCJzb3VyY2VzQ29udGVudCI6WyJ7I2lmIHZpc2libGUgJiYgZmllbGQuZGF0YSAhPSBudWxsICYmIGZpZWxkLmRhdGEubGVuZ3RoID4gMH1cclxuPGRpdiBjbGFzcz1cImhvcml6b250YWwtc2Nyb2xsXCI+XHJcblx0PHRhYmxlIGNsYXNzPVwidGFibGVcIiByZWY6dGFibGU+XHJcblx0XHQ8dGhlYWQ+XHJcblx0XHRcdHsjaWYgYnVsa0FjdGlvbnMubGVuZ3RoID4gMCB9XHJcblx0XHRcdDx0cj5cclxuXHRcdFx0XHQ8dGQgY29sc3Bhbj1cIntjb2x1bW5zT3JkZXJlZC5sZW5ndGggKyAxfVwiIGNsYXNzPVwiYnRuLXJvd1wiPlxyXG5cdFx0XHRcdFx0eyNlYWNoIGJ1bGtBY3Rpb25zIGFzIGFjdGlvbn0geyNpZiBzZWxlY3RlZEl0ZW1zQ291bnQgPiAwfVxyXG5cdFx0XHRcdFx0PGJ1dHRvbiBkaXNhYmxlZD1cIntkaXNhYmxlZH1cIiBzdHlsZT1cImRpcmVjdGlvbjogcnRsO1wiIGNsYXNzPVwiYnRuIGJ0bi1kZWZhdWx0XCIgb246Y2xpY2s9XCJydW5CdWxrQWN0aW9uKGFjdGlvbilcIj5cclxuXHRcdFx0XHRcdFx0e2FjdGlvbi5sYWJlbH0gPHNtYWxsPih7c2VsZWN0ZWRJdGVtc0NvdW50fSk8L3NtYWxsPlxyXG5cdFx0XHRcdFx0PC9idXR0b24+XHJcblx0XHRcdFx0XHR7OmVsc2V9XHJcblx0XHRcdFx0XHQ8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1kZWZhdWx0XCIgZGlzYWJsZWQ+e2FjdGlvbi5sYWJlbH08L2J1dHRvbj5cclxuXHRcdFx0XHRcdHsvaWZ9IHsvZWFjaH1cclxuXHRcdFx0XHQ8L3RkPlxyXG5cdFx0XHQ8L3RyPlxyXG5cdFx0XHR7L2lmfVxyXG5cdFx0XHQ8dHI+XHJcblx0XHRcdFx0eyNpZiBidWxrQWN0aW9ucy5sZW5ndGggPiAwfVxyXG5cdFx0XHRcdDx0aD5cclxuXHRcdFx0XHRcdDxpbnB1dFxyXG5cdFx0XHRcdFx0XHR0eXBlPVwiY2hlY2tib3hcIlxyXG5cdFx0XHRcdFx0XHRjbGFzcz1cImNoZWNrYm94XCJcclxuXHRcdFx0XHRcdFx0b246Y2hhbmdlPVwic2VsZWN0QWxsSXRlbXModGhpcylcIlxyXG5cdFx0XHRcdFx0Lz5cclxuXHRcdFx0XHQ8L3RoPlxyXG5cdFx0XHRcdHsvaWZ9IHsjZWFjaCBjb2x1bW5zT3JkZXJlZCBhcyBjb2x1bW59IHsjaWYgY29sdW1uLmN1c3RvbVByb3BlcnRpZXMgIT1cclxuXHRcdFx0XHRudWxsICYmIGNvbHVtbi5jdXN0b21Qcm9wZXJ0aWVzW1wic29ydGFibGVCeVwiXSAhPSBudWxsfSB7I2lmXHJcblx0XHRcdFx0Y29sdW1uLmFzY2VuZGluZ31cclxuXHRcdFx0XHQ8dGggY2xhc3M9XCJzb3J0YWJsZS1jb2x1bW5cIiBvbjpjbGljaz1cInNvcnREYXRhKGNvbHVtbixjb2x1bW5zT3JkZXJlZClcIj5cclxuXHRcdFx0XHRcdHtjb2x1bW4ubGFiZWx9IDxpIGNsYXNzPVwiZmEgZmEtc29ydC1kb3duXCI+PC9pPlxyXG5cdFx0XHRcdDwvdGg+XHJcblx0XHRcdFx0ezplbHNlfVxyXG5cdFx0XHRcdDx0aCBjbGFzcz1cInNvcnRhYmxlLWNvbHVtblwiIG9uOmNsaWNrPVwic29ydERhdGEoY29sdW1uLGNvbHVtbnNPcmRlcmVkKVwiPlxyXG5cdFx0XHRcdFx0e2NvbHVtbi5sYWJlbH0gPGkgY2xhc3M9XCJmYSBmYS1zb3J0LXVwXCI+PC9pPlxyXG5cdFx0XHRcdDwvdGg+XHJcblx0XHRcdFx0ey9pZn0gezplbHNlfVxyXG5cdFx0XHRcdDx0aD5cclxuXHRcdFx0XHRcdHsjaWYgY29sdW1uLmN1c3RvbVByb3BlcnRpZXMgIT0gbnVsbCAmJlxyXG5cdFx0XHRcdFx0Y29sdW1uLmN1c3RvbVByb3BlcnRpZXNbXCJkb2N1bWVudGF0aW9uXCJdICE9IG51bGx9XHJcblx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwiaGVscC10b29sdGlwXCI+XHJcblx0XHRcdFx0XHRcdHtjb2x1bW4ubGFiZWx9XHJcblx0XHRcdFx0XHRcdDxUb29sdGlwXHJcblx0XHRcdFx0XHRcdFx0ZGF0YT1cIntjb2x1bW4uY3VzdG9tUHJvcGVydGllcy5kb2N1bWVudGF0aW9uWzBdfVwiXHJcblx0XHRcdFx0XHRcdD48L1Rvb2x0aXA+XHJcblx0XHRcdFx0XHQ8L2Rpdj5cclxuXHRcdFx0XHRcdHs6ZWxzZX0ge2NvbHVtbi5sYWJlbH0gey9pZn1cclxuXHRcdFx0XHQ8L3RoPlxyXG5cdFx0XHRcdHsvaWZ9IHsvZWFjaH1cclxuXHRcdFx0PC90cj5cclxuXHRcdDwvdGhlYWQ+XHJcblx0XHQ8dGJvZHk+XHJcblx0XHRcdHsjaWYgbWFwICE9IG51bGx9IHsjZWFjaCBmaWVsZC5kYXRhIGFzIHJvd31cclxuXHRcdFx0PHRyIGNsYXNzPVwie2dldFJvd0Nzc0NsYXNzKHJvdyl9XCI+XHJcblx0XHRcdFx0eyNpZiBidWxrQWN0aW9ucy5sZW5ndGggPiAwfVxyXG5cdFx0XHRcdDx0ZD5cclxuXHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwIGZvcm0tY2hlY2tcIj5cclxuXHRcdFx0XHRcdFx0PGlucHV0XHJcblx0XHRcdFx0XHRcdFx0ZGlzYWJsZWQ9XCJ7cm93LmFjdGlvbnMgPT0gbnVsbCB8fCByb3cuYWN0aW9ucy5hY3Rpb25zID09IG51bGwgfHwgcm93LmFjdGlvbnMuYWN0aW9ucy5maWx0ZXIodCA9PiBidWxrQWN0aW9ucy5zb21lKHIgPT4gci5mb3JtSWQgPT09IHQuZm9ybSkpLmxlbmd0aCA9PT0gMH1cIlxyXG5cdFx0XHRcdFx0XHRcdHR5cGU9XCJjaGVja2JveFwiXHJcblx0XHRcdFx0XHRcdFx0Y2xhc3M9XCJjaGVja2JveFwiXHJcblx0XHRcdFx0XHRcdFx0b246Y2hhbmdlPVwic2VsZWN0SXRlbSh0aGlzLCByb3cpXCJcclxuXHRcdFx0XHRcdFx0Lz5cclxuXHRcdFx0XHRcdDwvZGl2PlxyXG5cdFx0XHRcdDwvdGQ+XHJcblx0XHRcdFx0ey9pZn0geyNlYWNoIGNvbHVtbnNPcmRlcmVkIGFzIGNvbHVtbn1cclxuXHRcdFx0XHQ8dGQ+XHJcblx0XHRcdFx0XHR7I2lmICEoZ2V0RmllbGQocm93LCBjb2x1bW4pLm1ldGFkYXRhLmdldEN1c3RvbVByb3BlcnR5KFwiaGlkZUlmTnVsbFwiKVxyXG5cdFx0XHRcdFx0PT09IHRydWUgJiYgZ2V0RmllbGQocm93LCBjb2x1bW4pLmRhdGEgPT09IG51bGwpfVxyXG5cdFx0XHRcdFx0PEZvcm1PdXRwdXRcclxuXHRcdFx0XHRcdFx0ZmllbGQ9XCJ7Z2V0RmllbGQocm93LCBjb2x1bW4pfVwiXHJcblx0XHRcdFx0XHRcdGFwcD1cInthcHB9XCJcclxuXHRcdFx0XHRcdFx0Zm9ybT1cIntmb3JtfVwiXHJcblx0XHRcdFx0XHRcdHBhcmVudD1cIntwYXJlbnR9XCJcclxuXHRcdFx0XHRcdFx0c2hvd0xhYmVsPVwiZmFsc2VcIlxyXG5cdFx0XHRcdFx0Lz5cclxuXHRcdFx0XHRcdHsvaWZ9XHJcblx0XHRcdFx0PC90ZD5cclxuXHRcdFx0XHR7L2VhY2h9XHJcblx0XHRcdDwvdHI+XHJcblx0XHRcdHsvZWFjaH0gey9pZn1cclxuXHRcdDwvdGJvZHk+XHJcblx0PC90YWJsZT5cclxuPC9kaXY+XHJcblxyXG57I2lmIGJ1bGtBY3Rpb25zLmxlbmd0aCA+IDB9XHJcbjxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBiaW5kOmNoZWNrZWQ9XCJpc0J1bGtBY3Rpb25Nb2RhbE9wZW5cIiBjbGFzcz1cImhpZGRlblwiIC8+XHJcbjxkaXYgY2xhc3M9XCJtb2RhbFwiPlxyXG5cdDxkaXYgY2xhc3M9XCJjYXJkXCI+XHJcblx0XHQ8bGFiZWwgY2xhc3M9XCJjbG9zZVwiIG9uOmNsaWNrPVwiY2xvc2VCdWxrQWN0aW9uTW9kYWwobnVsbClcIj48L2xhYmVsPlxyXG5cdFx0PGRpdiByZWY6YnVsa0FjdGlvbkNvbnRhaW5lcj48L2Rpdj5cclxuXHQ8L2Rpdj5cclxuPC9kaXY+XHJcbnsvaWZ9IHs6ZWxzZX1cclxuPGRpdiBjbGFzcz1cImFsZXJ0LW5vZGF0YVwiPk5vIGRhdGEgZm91bmQuPC9kaXY+XHJcbnsvaWZ9XHJcblxyXG48c2NyaXB0PlxyXG5cdGltcG9ydCBGb3JtQ29tcG9uZW50IGZyb20gXCJjb3JlLXVpL0Zvcm1cIjtcclxuXHRpbXBvcnQgRm9ybU91dHB1dCBmcm9tIFwiLi4vT3V0cHV0XCI7XHJcblx0aW1wb3J0IFRvb2x0aXAgZnJvbSBcIi4uL2hlbHAvVG9vbHRpcFwiO1xyXG5cdGltcG9ydCB7IEFjdGlvbkxpc3RFdmVudEFyZ3VtZW50cyB9IGZyb20gXCIuL0FjdGlvbkxpc3RFdmVudEFyZ3VtZW50c1wiO1xyXG5cclxuXHRmdW5jdGlvbiBidWlsZEZpbHRlcihjdXJyZW50Rm9ybUluc3RhbmNlLCBwYXJhbWV0ZXJzKSB7XHJcblx0XHRsZXQgcHJvbWlzZTtcclxuXHJcblx0XHRjb25zdCBmaWx0ZXIgPSB7fTtcclxuXHRcdGlmIChwYXJhbWV0ZXJzICE9IG51bGwgJiYgcGFyYW1ldGVycy5sZW5ndGggPiAwKSB7XHJcblx0XHRcdHByb21pc2UgPSBjdXJyZW50Rm9ybUluc3RhbmNlLmdldFNlcmlhbGl6ZWRJbnB1dFZhbHVlcygpLnRoZW4oZGF0YSA9PiB7XHJcblx0XHRcdFx0Zm9yIChjb25zdCBwIG9mIHBhcmFtZXRlcnMpIHtcclxuXHRcdFx0XHRcdGZpbHRlcltwXSA9IGRhdGFbcF07XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXR1cm4gZmlsdGVyO1xyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHRcdGVsc2Uge1xyXG5cdFx0XHRwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKGZpbHRlcik7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHByb21pc2U7XHJcblx0fVxyXG5cclxuXHRjb25zdCBtb2RhbHMgPSBbXTtcclxuXHJcblx0Ly8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzMzNjk3NDMvMTExNDM4XHJcblx0Ly8gQ2xvc2UgdG9wbW9zdCBtb2RhbCB3aGVuIHVzZXIgcHJlc3NlcyBlc2NhcGUga2V5LlxyXG5cdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGUgPT4ge1xyXG5cdFx0Y29uc3QgZXZ0ID0gZSB8fCB3aW5kb3cuZXZlbnQ7XHJcblx0XHRsZXQgaXNFc2NhcGUgPSBmYWxzZTtcclxuXHRcdGlmIChcImtleVwiIGluIGV2dCkge1xyXG5cdFx0XHRpc0VzY2FwZSA9IGV2dC5rZXkgPT09IFwiRXNjYXBlXCIgfHwgZXZ0LmtleSA9PT0gXCJFc2NcIjtcclxuXHRcdH1cclxuXHRcdGVsc2Uge1xyXG5cdFx0XHRpc0VzY2FwZSA9IGV2dC5rZXlDb2RlID09PSAyNztcclxuXHRcdH1cclxuXHRcdGlmIChpc0VzY2FwZSkge1xyXG5cdFx0XHRpZiAobW9kYWxzLmxlbmd0aCA+IDApIHtcclxuXHRcdFx0XHQvLyBDbG9zZSB0b3Btb3N0IG1vZGFsLlxyXG5cdFx0XHRcdG1vZGFsc1ttb2RhbHMubGVuZ3RoIC0gMV0uY2xvc2VCdWxrQWN0aW9uTW9kYWwoKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0pO1xyXG5cclxuXHRleHBvcnQgZGVmYXVsdCB7XHJcblx0XHRvbmNyZWF0ZSgpIHtcclxuXHRcdFx0Y29uc3QgeyBkYXRhIH0gPSB0aGlzLmdldCgpLmZpZWxkO1xyXG5cclxuXHRcdFx0aWYgKGRhdGEgPT0gbnVsbCkge1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Y29uc3QgeyBtZXRhZGF0YSB9ID0gdGhpcy5nZXQoKS5maWVsZDtcclxuXHRcdFx0Y29uc3QgeyByb3dDc3NDbGFzcyB9ID0gbWV0YWRhdGEuY3VzdG9tUHJvcGVydGllcyB8fCB7fTtcclxuXHJcblx0XHRcdC8vIENyZWF0ZSBtYXAsIHdpdGgga2V5IGJlaW5nIHRoZSBsb3dlcmNhc2UgdmVyc2lvbiBvZiB0aGUgcHJvcGVydHkgbmFtZVxyXG5cdFx0XHQvLyBhbmQgdmFsdWUgYmVpbmcgdGhlIGFjdHVhbCBwcm9wZXJ0eSBuYW1lLlxyXG5cdFx0XHRjb25zdCBtYXAgPSB7fTtcclxuXHRcdFx0aWYgKGRhdGEubGVuZ3RoID4gMCkge1xyXG5cdFx0XHRcdGNvbnN0IGZpcnN0Um93ID0gZGF0YVswXTtcclxuXHJcblx0XHRcdFx0Zm9yIChjb25zdCBwcm9wZXJ0eSBvZiBPYmplY3Qua2V5cyhmaXJzdFJvdykpIHtcclxuXHRcdFx0XHRcdG1hcFtwcm9wZXJ0eS50b0xvd2VyQ2FzZSgpXSA9IHByb3BlcnR5O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5zZXQoe1xyXG5cdFx0XHRcdC8vIFNob3cgdGFibGUgb25seSBhZnRlciB0aGUgYG9uY3JlYXRlYCBtZXRob2QgaGFzIHJ1bi5cclxuXHRcdFx0XHR2aXNpYmxlOiB0cnVlLFxyXG5cdFx0XHRcdGJ1bGtBY3Rpb25zOiAobWV0YWRhdGEuY3VzdG9tUHJvcGVydGllcyB8fCB7fSkuYnVsa0FjdGlvbiB8fCBbXSxcclxuXHRcdFx0XHRtYXAsXHJcblx0XHRcdFx0Z2V0RmllbGQocm93LCBjb2x1bW4pIHtcclxuXHRcdFx0XHRcdGNvbnN0IHZhbHVlID0gcm93W21hcFtjb2x1bW4uaWQudG9Mb3dlckNhc2UoKV1dO1xyXG5cclxuXHRcdFx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0XHRcdGRhdGE6IHZhbHVlLFxyXG5cdFx0XHRcdFx0XHRtZXRhZGF0YTogY29sdW1uXHJcblx0XHRcdFx0XHR9O1xyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0Z2V0Um93Q3NzQ2xhc3Mocm93KSB7XHJcblx0XHRcdFx0XHRsZXQgY3NzQ2xhc3MgPSBcIlwiO1xyXG5cclxuXHRcdFx0XHRcdGlmIChyb3dDc3NDbGFzcyAhPSBudWxsKSB7XHJcblx0XHRcdFx0XHRcdGNzc0NsYXNzID0gcm93Q3NzQ2xhc3MuY3NzQ2xhc3MgfHwgXCJcIjtcclxuXHJcblx0XHRcdFx0XHRcdGlmIChyb3dDc3NDbGFzcy5zdWZmaXggIT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0XHRcdGNzc0NsYXNzICs9IHJvd1ttYXBbcm93Q3NzQ2xhc3Muc3VmZml4LnRvTG93ZXJDYXNlKCldXTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdHJldHVybiBjc3NDbGFzcztcclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdHNlbGVjdGVkSXRlbXNDb3VudDogMFxyXG5cdFx0XHR9KTtcclxuXHRcdH0sXHJcblx0XHRjb21wdXRlZDoge1xyXG5cdFx0XHRjb2x1bW5zT3JkZXJlZDogKHsgZmllbGQgfSkgPT4gZmllbGQubWV0YWRhdGEuY3VzdG9tUHJvcGVydGllcy5jb2x1bW5zXHJcblx0XHRcdFx0LmZpbHRlcihiID0+ICFiLmhpZGRlbilcclxuXHRcdFx0XHQuc29ydCgoYSwgYikgPT4gYS5vcmRlckluZGV4IC0gYi5vcmRlckluZGV4KVxyXG5cdFx0fSxcclxuXHRcdG1ldGhvZHM6IHtcclxuXHRcdFx0ZW5hYmxlQnVsa0J1dHRvbigpIHtcclxuXHRcdFx0XHR0aGlzLnNldCh7XHJcblx0XHRcdFx0XHRkaXNhYmxlZDogZmFsc2VcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fSxcclxuXHRcdFx0YXN5bmMgcnVuQnVsa0FjdGlvbihhY3Rpb24pIHtcclxuXHRcdFx0XHR0aGlzLnNldCh7IGRpc2FibGVkOiB0cnVlIH0pO1xyXG5cdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlcnNjb3JlLWRhbmdsZVxyXG5cdFx0XHRcdGNvbnN0IHNlbGVjdGVkSXRlbXMgPSB0aGlzLmdldCgpLmZpZWxkLmRhdGEuZmlsdGVyKHQgPT4gdC5fX3NlbGVjdGVkID09PSB0cnVlKTtcclxuXHRcdFx0XHRjb25zdCB7IG1hcCB9ID0gdGhpcy5nZXQoKTtcclxuXHRcdFx0XHRjb25zdCBzZWxlY3RlZEl0ZW1JZHMgPSBzZWxlY3RlZEl0ZW1zLm1hcCh0ID0+IHRbbWFwW2FjdGlvbi5pdGVtSWRlbnRpZmllckZpZWxkLnRvTG93ZXJDYXNlKCldXSk7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHsgYXBwIH0gPSB0aGlzLmdldCgpO1xyXG5cdFx0XHRcdGNvbnN0IGZvcm1JbnN0YW5jZSA9IGFwcC5nZXRGb3JtSW5zdGFuY2UoYWN0aW9uLmZvcm1JZCwgdHJ1ZSk7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGZpbHRlciA9IGF3YWl0IGJ1aWxkRmlsdGVyKHRoaXMuZ2V0KCkuZm9ybSwgYWN0aW9uLnBhcmFtZXRlcnMpO1xyXG5cdFx0XHRcdGZpbHRlci5JdGVtcyA9IHsgaXRlbXM6IHNlbGVjdGVkSXRlbUlkcyB9O1xyXG5cdFx0XHRcdGZvcm1JbnN0YW5jZS5zZXRJbnB1dEZpZWxkcyhmaWx0ZXIpO1xyXG5cclxuXHRcdFx0XHRjb25zdCBpc0FsbElucHV0c0hpZGRlbiA9XHJcblx0XHRcdFx0XHRmb3JtSW5zdGFuY2UuaW5wdXRzLmZpbHRlcih0ID0+IHQubWV0YWRhdGEuaGlkZGVuID09PSBmYWxzZSlcclxuXHRcdFx0XHRcdFx0Lmxlbmd0aCA+IDA7XHJcblxyXG5cdFx0XHRcdGlmICghaXNBbGxJbnB1dHNIaWRkZW4pIHtcclxuXHRcdFx0XHRcdHRyeSB7XHJcblx0XHRcdFx0XHRcdGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZm9ybUluc3RhbmNlLnN1Ym1pdCh0aGlzLmdldCgpLmFwcCwgZmFsc2UpO1xyXG5cdFx0XHRcdFx0XHR0aGlzLm9uQWN0aW9uUnVuKGZvcm1JbnN0YW5jZS5tZXRhZGF0YS5pZCwgcmVzcG9uc2UsIGFjdGlvbik7XHJcblx0XHRcdFx0XHRcdHRoaXMuZW5hYmxlQnVsa0J1dHRvbigpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0Y2F0Y2ggKGUpIHtcclxuXHRcdFx0XHRcdFx0dGhpcy5lbmFibGVCdWxrQnV0dG9uKCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0dGhpcy5zZXQoe1xyXG5cdFx0XHRcdFx0XHRpc0J1bGtBY3Rpb25Nb2RhbE9wZW46IHRydWVcclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdFx0Y29uc3QgZiA9IG5ldyBGb3JtQ29tcG9uZW50KHtcclxuXHRcdFx0XHRcdFx0dGFyZ2V0OiB0aGlzLnJlZnMuYnVsa0FjdGlvbkNvbnRhaW5lcixcclxuXHRcdFx0XHRcdFx0ZGF0YToge1xyXG5cdFx0XHRcdFx0XHRcdG1ldGFkYXRhOiBmb3JtSW5zdGFuY2UubWV0YWRhdGEsXHJcblx0XHRcdFx0XHRcdFx0Zm9ybTogZm9ybUluc3RhbmNlLFxyXG5cdFx0XHRcdFx0XHRcdGFwcCxcclxuXHRcdFx0XHRcdFx0XHR1c2VVcmw6IGZhbHNlXHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0XHRcdGYuaW5pdCgpO1xyXG5cclxuXHRcdFx0XHRcdGNvbnN0IHNlbGYgPSB0aGlzO1xyXG5cdFx0XHRcdFx0Zi5vbihcImZvcm06cmVzcG9uc2VIYW5kbGVkXCIsIGUgPT4ge1xyXG5cdFx0XHRcdFx0XHRzZWxmLmNsb3NlQnVsa0FjdGlvbk1vZGFsKGUucmVzcG9uc2UpO1xyXG5cdFx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5zZXQoe1xyXG5cdFx0XHRcdFx0XHRjdXJyZW50QnVsa0FjdGlvbkZvcm06IGZcclxuXHRcdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0XHRcdG1vZGFscy5wdXNoKHRoaXMpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSxcclxuXHRcdFx0YXN5bmMgb25BY3Rpb25SdW4oZm9ybUlkLCByZXNwb25zZSkge1xyXG5cdFx0XHRcdGNvbnN0IHBhcmVudEZvcm0gPSB0aGlzLmdldCgpLnBhcmVudDtcclxuXHRcdFx0XHRjb25zdCB7IGFwcCB9ID0gcGFyZW50Rm9ybS5nZXQoKTtcclxuXHJcblx0XHRcdFx0aWYgKFxyXG5cdFx0XHRcdFx0cmVzcG9uc2UubWV0YWRhdGEuaGFuZGxlciAhPT0gXCJyZWRpcmVjdFwiICYmXHJcblx0XHRcdFx0XHRyZXNwb25zZS5tZXRhZGF0YS5oYW5kbGVyICE9PSBcInJlbG9hZFwiXHJcblx0XHRcdFx0KSB7XHJcblx0XHRcdFx0XHQvLyBJZiBhc2tlZCB0byByZWRpcmVjdCB0byBhbm90aGVyIGZvcm0sIHRoZW4gd2UgcmVkaXJlY3RcclxuXHRcdFx0XHRcdC8vIGFuZCBkbyBub3QgcmVsb2FkIHBhcmVudCBmb3JtLCBhcyB0aGF0IHdvdWxkIGJlIGEgd2FzdGVkIGVmZm9ydC5cclxuXHRcdFx0XHRcdGF3YWl0IHBhcmVudEZvcm0uc3VibWl0KG51bGwsIHRydWUpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Y29uc3QgZXZlbnRBcmdzID0gbmV3IEFjdGlvbkxpc3RFdmVudEFyZ3VtZW50cyhhcHAsIGZvcm1JZCk7XHJcblx0XHRcdFx0cGFyZW50Rm9ybS5maXJlQW5kQnViYmxlVXAoXCJhY3Rpb24tbGlzdDpydW5cIiwgZXZlbnRBcmdzKTtcclxuXHRcdFx0fSxcclxuXHRcdFx0YXN5bmMgY2xvc2VCdWxrQWN0aW9uTW9kYWwocmVzcG9uc2UpIHtcclxuXHRcdFx0XHRjb25zdCB7IGN1cnJlbnRCdWxrQWN0aW9uRm9ybSB9ID0gdGhpcy5nZXQoKTtcclxuXHRcdFx0XHR0aGlzLmVuYWJsZUJ1bGtCdXR0b24oKTtcclxuXHRcdFx0XHR0aGlzLnNldCh7XHJcblx0XHRcdFx0XHRpc0J1bGtBY3Rpb25Nb2RhbE9wZW46IGZhbHNlLFxyXG5cdFx0XHRcdFx0Y3VycmVudEJ1bGtBY3Rpb25Gb3JtOiBudWxsXHJcblx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRcdGN1cnJlbnRCdWxrQWN0aW9uRm9ybS5kZXN0cm95KCk7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHBhcmVudEZvcm1Db21wb25lbnQgPSB0aGlzLmdldCgpLnBhcmVudDtcclxuXHJcblx0XHRcdFx0aWYgKFxyXG5cdFx0XHRcdFx0cmVzcG9uc2UgIT0gbnVsbCAmJlxyXG5cdFx0XHRcdFx0cmVzcG9uc2UubWV0YWRhdGEuaGFuZGxlciAhPT0gXCJyZWRpcmVjdFwiICYmXHJcblx0XHRcdFx0XHRyZXNwb25zZS5tZXRhZGF0YS5oYW5kbGVyICE9PSBcInJlbG9hZFwiXHJcblx0XHRcdFx0KSB7XHJcblx0XHRcdFx0XHQvLyBJZiBhc2tlZCB0byByZWRpcmVjdCB0byBhbm90aGVyIGZvcm0sIHRoZW4gd2UgcmVkaXJlY3RcclxuXHRcdFx0XHRcdC8vIGFuZCBkbyBub3QgcmVsb2FkIHBhcmVudCBmb3JtLCBhcyB0aGF0IHdvdWxkIGJlIGEgd2FzdGVkIGVmZm9ydC5cclxuXHRcdFx0XHRcdGF3YWl0IHBhcmVudEZvcm1Db21wb25lbnQuc3VibWl0KG51bGwsIHRydWUpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0bW9kYWxzLnBvcCgpO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRpc0Rpc2FibGVkKHJvdykge1xyXG5cdFx0XHRcdHJldHVybiAoXHJcblx0XHRcdFx0XHRyb3cuYWN0aW9ucyA9PSBudWxsIHx8XHJcblx0XHRcdFx0XHRyb3cuYWN0aW9ucy5hY3Rpb25zID09IG51bGwgfHxcclxuXHRcdFx0XHRcdHJvdy5hY3Rpb25zLmFjdGlvbnMuZmlsdGVyKHQgPT4gdGhpcy5nZXQoKS5idWxrQWN0aW9ucy5zb21lKHIgPT4gci5mb3JtSWQgPT09IHQuZm9ybSkpLmxlbmd0aCA9PT0gMFxyXG5cdFx0XHRcdCk7XHJcblx0XHRcdH0sXHJcblx0XHRcdHNlbGVjdEl0ZW0oY2hlY2tib3hFbGVtZW50LCByb3cpIHtcclxuXHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZXJzY29yZS1kYW5nbGUsIG5vLXBhcmFtLXJlYXNzaWduXHJcblx0XHRcdFx0cm93Ll9fc2VsZWN0ZWQgPSBjaGVja2JveEVsZW1lbnQuY2hlY2tlZDtcclxuXHJcblx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVyc2NvcmUtZGFuZ2xlXHJcblx0XHRcdFx0Y29uc3Qgc2VsZWN0ZWRJdGVtcyA9IHRoaXMuZ2V0KCkuZmllbGQuZGF0YS5maWx0ZXIodCA9PiB0Ll9fc2VsZWN0ZWQgPT09IHRydWUpO1xyXG5cdFx0XHRcdHRoaXMuc2V0KHsgc2VsZWN0ZWRJdGVtc0NvdW50OiBzZWxlY3RlZEl0ZW1zLmxlbmd0aCB9KTtcclxuXHRcdFx0fSxcclxuXHRcdFx0c2VsZWN0QWxsSXRlbXMoY2hlY2tib3hFbGVtZW50KSB7XHJcblx0XHRcdFx0Zm9yIChjb25zdCByb3cgb2YgdGhpcy5nZXQoKS5maWVsZC5kYXRhKSB7XHJcblx0XHRcdFx0XHRpZiAoIXRoaXMuaXNEaXNhYmxlZChyb3cpKSB7XHJcblx0XHRcdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlcnNjb3JlLWRhbmdsZSwgbm8tcGFyYW0tcmVhc3NpZ25cclxuXHRcdFx0XHRcdFx0cm93Ll9fc2VsZWN0ZWQgPSBjaGVja2JveEVsZW1lbnQuY2hlY2tlZDtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGNvbnN0IGNoZWNrYm94ZXMgPSB0aGlzLnJlZnMudGFibGUucXVlcnlTZWxlY3RvckFsbChcInRib2R5PnRyPnRkIC5jaGVja2JveFwiKTtcclxuXHJcblx0XHRcdFx0Zm9yIChjb25zdCBjaGVja2JveCBvZiBjaGVja2JveGVzKSB7XHJcblx0XHRcdFx0XHRpZiAoIWNoZWNrYm94LmRpc2FibGVkKSB7XHJcblx0XHRcdFx0XHRcdGNoZWNrYm94LmNoZWNrZWQgPSBjaGVja2JveEVsZW1lbnQuY2hlY2tlZDtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlcnNjb3JlLWRhbmdsZVxyXG5cdFx0XHRcdGNvbnN0IHNlbGVjdGVkSXRlbXMgPSB0aGlzLmdldCgpLmZpZWxkLmRhdGEuZmlsdGVyKHQgPT4gdC5fX3NlbGVjdGVkID09PSB0cnVlKTtcclxuXHRcdFx0XHR0aGlzLnNldCh7IHNlbGVjdGVkSXRlbXNDb3VudDogc2VsZWN0ZWRJdGVtcy5sZW5ndGggfSk7XHJcblx0XHRcdH0sXHJcblx0XHRcdHNvcnREYXRhKGNvbHVtbiwgY29sdW1ucykge1xyXG5cdFx0XHRcdGNvbnN0IHsgcGFyZW50LCBmb3JtLCBmaWVsZCB9ID0gdGhpcy5nZXQoKTtcclxuXHJcblx0XHRcdFx0Y29uc3QgcGFnaW5hdG9ySW5wdXQgPSBmb3JtLmlucHV0cy5maW5kKHQgPT4gdC5tZXRhZGF0YS5pZCA9PT1cclxuXHRcdFx0XHRcdFx0ZmllbGQubWV0YWRhdGEuY3VzdG9tUHJvcGVydGllcy5jdXN0b21pemF0aW9ucy5wYWdpbmF0b3IpO1xyXG5cclxuXHRcdFx0XHRpZiAocGFnaW5hdG9ySW5wdXQgIT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0cGFnaW5hdG9ySW5wdXQudmFsdWUub3JkZXJCeSA9IGNvbHVtbi5jdXN0b21Qcm9wZXJ0aWVzLnNvcnRhYmxlQnk7XHJcblx0XHRcdFx0XHRmb3IgKGNvbnN0IGkgb2YgY29sdW1ucykge1xyXG5cdFx0XHRcdFx0XHRpLmFzY2VuZGluZyA9IGZhbHNlO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdHBhZ2luYXRvcklucHV0LnZhbHVlLmFzY2VuZGluZyA9ICFwYWdpbmF0b3JJbnB1dC52YWx1ZS5hc2NlbmRpbmc7XHJcblx0XHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cclxuXHRcdFx0XHRcdGNvbHVtbi5hc2NlbmRpbmcgPSBwYWdpbmF0b3JJbnB1dC52YWx1ZS5hc2NlbmRpbmc7XHJcblxyXG5cdFx0XHRcdFx0Y29uc3QgcGFyYW1zID0ge307XHJcblx0XHRcdFx0XHRmb3IgKGNvbnN0IGkgb2YgZm9ybS5pbnB1dHMpIHtcclxuXHRcdFx0XHRcdFx0cGFyYW1zW2kubWV0YWRhdGEuaWRdID0gaS52YWx1ZTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGZvcm0uc2V0SW5wdXRGaWVsZHMocGFyYW1zKTtcclxuXHRcdFx0XHRcdHBhcmVudC5zdWJtaXQobnVsbCwgZmFsc2UpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdGRhdGEoKSB7XHJcblx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0YnVsa0FjdGlvbnM6IFtdLFxyXG5cdFx0XHRcdGdldFJvd0Nzc0NsYXNzOiAoKSA9PiBcIlwiLFxyXG5cdFx0XHRcdGRpc2FibGVkOiBmYWxzZVxyXG5cdFx0XHR9O1xyXG5cdFx0fSxcclxuXHRcdGNvbXBvbmVudHM6IHtcclxuXHRcdFx0Rm9ybU91dHB1dCxcclxuXHRcdFx0VG9vbHRpcFxyXG5cdFx0fVxyXG5cdH07XHJcbjwvc2NyaXB0PlxyXG5cclxuPHN0eWxlPlxyXG5cdC5idG4tcm93IHtcclxuXHRcdHRleHQtYWxpZ246IHJpZ2h0O1xyXG5cdH1cclxuXHJcblx0LmNoZWNrYm94IHtcclxuXHRcdGNsaXA6IHVuc2V0O1xyXG5cdFx0Y2xpcC1wYXRoOiB1bnNldDtcclxuXHRcdHBvc2l0aW9uOiB1bnNldDtcclxuXHRcdHdpZHRoOiAxNXB4O1xyXG5cdFx0aGVpZ2h0OiAxNXB4O1xyXG5cdH1cclxuXHJcblx0LnNvcnRhYmxlLWNvbHVtbiB7XHJcblx0XHRjdXJzb3I6IHBvaW50ZXI7XHJcblx0fVxyXG5cclxuXHQuaG9yaXpvbnRhbC1zY3JvbGwge1xyXG5cdFx0b3ZlcmZsb3c6IGhpZGRlbjtcclxuXHRcdG92ZXJmbG93LXg6IGF1dG87XHJcblx0XHRjbGVhcjogYm90aDtcclxuXHRcdHdpZHRoOiAxMDAlO1xyXG5cdH1cclxuXHJcblx0LnRhYmxlIHtcclxuXHRcdG1pbi13aWR0aDogcmVtLWNhbGMoNjQwKTtcclxuXHRcdHRleHQtYWxpZ246IGNlbnRlcjtcclxuXHR9XHJcbjwvc3R5bGU+XHJcbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUF5WEMsUUFBUSxjQUFDLENBQUMsQUFDVCxVQUFVLENBQUUsS0FBSyxBQUNsQixDQUFDLEFBRUQsU0FBUyxjQUFDLENBQUMsQUFDVixJQUFJLENBQUUsS0FBSyxDQUNYLFNBQVMsQ0FBRSxLQUFLLENBQ2hCLFFBQVEsQ0FBRSxLQUFLLENBQ2YsS0FBSyxDQUFFLElBQUksQ0FDWCxNQUFNLENBQUUsSUFBSSxBQUNiLENBQUMsQUFFRCxnQkFBZ0IsY0FBQyxDQUFDLEFBQ2pCLE1BQU0sQ0FBRSxPQUFPLEFBQ2hCLENBQUMsQUFFRCxrQkFBa0IsY0FBQyxDQUFDLEFBQ25CLFFBQVEsQ0FBRSxNQUFNLENBQ2hCLFVBQVUsQ0FBRSxJQUFJLENBQ2hCLEtBQUssQ0FBRSxJQUFJLENBQ1gsS0FBSyxDQUFFLElBQUksQUFDWixDQUFDLEFBRUQsTUFBTSxjQUFDLENBQUMsQUFDUCxTQUFTLENBQUUsU0FBUyxHQUFHLENBQUMsQ0FDeEIsVUFBVSxDQUFFLE1BQU0sQUFDbkIsQ0FBQyJ9 */";
    	append(document.head, style);
    }

    function get_each_context_3(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.column = list[i];
    	return child_ctx;
    }

    function change_handler(event) {
    	const { component, ctx } = this._svelte;

    	component.selectItem(this, ctx.row);
    }

    function get_each_context_2$1(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.row = list[i];
    	return child_ctx;
    }

    function click_handler_2(event) {
    	const { component, ctx } = this._svelte;

    	component.sortData(ctx.column,ctx.columnsOrdered);
    }

    function click_handler_1(event) {
    	const { component, ctx } = this._svelte;

    	component.sortData(ctx.column,ctx.columnsOrdered);
    }

    function get_each_context_1$3(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.column = list[i];
    	return child_ctx;
    }

    function click_handler$2(event) {
    	const { component, ctx } = this._svelte;

    	component.runBulkAction(ctx.action);
    }

    function get_each_context$8(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.action = list[i];
    	return child_ctx;
    }

    function create_main_fragment$C(component, ctx) {
    	var if_block_anchor;

    	function select_block_type(ctx) {
    		if (ctx.visible && ctx.field.data != null && ctx.field.data.length > 0) return create_if_block$q;
    		return create_else_block_4;
    	}

    	var current_block_type = select_block_type(ctx);
    	var if_block = current_block_type(component, ctx);

    	return {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(changed, ctx);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(component, ctx);
    				if_block.c();
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},

    		d: function destroy$$1(detach) {
    			if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (94:6) {:else}
    function create_else_block_4(component, ctx) {
    	var div;

    	return {
    		c: function create() {
    			div = createElement("div");
    			div.textContent = "No data found.";
    			div.className = "alert-nodata";
    			addLoc(div, file$B, 94, 0, 2870);
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);
    		},

    		p: noop,

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(div);
    			}
    		}
    	};
    }

    // (1:0) {#if visible && field.data != null && field.data.length > 0}
    function create_if_block$q(component, ctx) {
    	var div, table, thead, text0, tr, text1, text2, tbody, text3, if_block3_anchor;

    	var if_block0 = (ctx.bulkActions.length > 0) && create_if_block_9$1(component, ctx);

    	var if_block1 = (ctx.bulkActions.length > 0) && create_if_block_8$1(component, ctx);

    	var each_value_1 = ctx.columnsOrdered;

    	var each_blocks = [];

    	for (var i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_2$1(component, get_each_context_1$3(ctx, each_value_1, i));
    	}

    	var if_block2 = (ctx.map != null) && create_if_block_2$7(component, ctx);

    	var if_block3 = (ctx.bulkActions.length > 0) && create_if_block_1$e(component, ctx);

    	return {
    		c: function create() {
    			div = createElement("div");
    			table = createElement("table");
    			thead = createElement("thead");
    			if (if_block0) if_block0.c();
    			text0 = createText("\r\n\t\t\t");
    			tr = createElement("tr");
    			if (if_block1) if_block1.c();
    			text1 = createText(" ");

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			text2 = createText("\r\n\t\t");
    			tbody = createElement("tbody");
    			if (if_block2) if_block2.c();
    			text3 = createText("\r\n\r\n");
    			if (if_block3) if_block3.c();
    			if_block3_anchor = createComment();
    			addLoc(tr, file$B, 17, 3, 645);
    			addLoc(thead, file$B, 3, 2, 131);
    			addLoc(tbody, file$B, 51, 2, 1653);
    			table.className = "table svelte-bip1ia";
    			addLoc(table, file$B, 2, 1, 96);
    			div.className = "horizontal-scroll svelte-bip1ia";
    			addLoc(div, file$B, 1, 0, 62);
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);
    			append(div, table);
    			append(table, thead);
    			if (if_block0) if_block0.m(thead, null);
    			append(thead, text0);
    			append(thead, tr);
    			if (if_block1) if_block1.m(tr, null);
    			append(tr, text1);

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tr, null);
    			}

    			append(table, text2);
    			append(table, tbody);
    			if (if_block2) if_block2.m(tbody, null);
    			component.refs.table = table;
    			insert(target, text3, anchor);
    			if (if_block3) if_block3.m(target, anchor);
    			insert(target, if_block3_anchor, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (ctx.bulkActions.length > 0) {
    				if (if_block0) {
    					if_block0.p(changed, ctx);
    				} else {
    					if_block0 = create_if_block_9$1(component, ctx);
    					if_block0.c();
    					if_block0.m(thead, text0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (ctx.bulkActions.length > 0) {
    				if (!if_block1) {
    					if_block1 = create_if_block_8$1(component, ctx);
    					if_block1.c();
    					if_block1.m(tr, text1);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (changed.columnsOrdered) {
    				each_value_1 = ctx.columnsOrdered;

    				for (var i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$3(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    					} else {
    						each_blocks[i] = create_each_block_2$1(component, child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tr, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}
    				each_blocks.length = each_value_1.length;
    			}

    			if (ctx.map != null) {
    				if (if_block2) {
    					if_block2.p(changed, ctx);
    				} else {
    					if_block2 = create_if_block_2$7(component, ctx);
    					if_block2.c();
    					if_block2.m(tbody, null);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}

    			if (ctx.bulkActions.length > 0) {
    				if (if_block3) {
    					if_block3.p(changed, ctx);
    				} else {
    					if_block3 = create_if_block_1$e(component, ctx);
    					if_block3.c();
    					if_block3.m(if_block3_anchor.parentNode, if_block3_anchor);
    				}
    			} else if (if_block3) {
    				if_block3.d(1);
    				if_block3 = null;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(div);
    			}

    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();

    			destroyEach(each_blocks, detach);

    			if (if_block2) if_block2.d();
    			if (component.refs.table === table) component.refs.table = null;
    			if (detach) {
    				detachNode(text3);
    			}

    			if (if_block3) if_block3.d(detach);
    			if (detach) {
    				detachNode(if_block3_anchor);
    			}
    		}
    	};
    }

    // (5:3) {#if bulkActions.length > 0 }
    function create_if_block_9$1(component, ctx) {
    	var tr, td, td_colspan_value;

    	var each_value = ctx.bulkActions;

    	var each_blocks = [];

    	for (var i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block_3(component, get_each_context$8(ctx, each_value, i));
    	}

    	return {
    		c: function create() {
    			tr = createElement("tr");
    			td = createElement("td");

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}
    			td.colSpan = td_colspan_value = ctx.columnsOrdered.length + 1;
    			td.className = "btn-row svelte-bip1ia";
    			addLoc(td, file$B, 6, 4, 187);
    			addLoc(tr, file$B, 5, 3, 177);
    		},

    		m: function mount(target, anchor) {
    			insert(target, tr, anchor);
    			append(tr, td);

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(td, null);
    			}
    		},

    		p: function update(changed, ctx) {
    			if (changed.selectedItemsCount || changed.disabled || changed.bulkActions) {
    				each_value = ctx.bulkActions;

    				for (var i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$8(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    					} else {
    						each_blocks[i] = create_each_block_3(component, child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(td, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}
    				each_blocks.length = each_value.length;
    			}

    			if ((changed.columnsOrdered) && td_colspan_value !== (td_colspan_value = ctx.columnsOrdered.length + 1)) {
    				td.colSpan = td_colspan_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(tr);
    			}

    			destroyEach(each_blocks, detach);
    		}
    	};
    }

    // (12:5) {:else}
    function create_else_block_3(component, ctx) {
    	var button, text_value = ctx.action.label, text;

    	return {
    		c: function create() {
    			button = createElement("button");
    			text = createText(text_value);
    			button.className = "btn btn-default";
    			button.disabled = true;
    			addLoc(button, file$B, 12, 5, 525);
    		},

    		m: function mount(target, anchor) {
    			insert(target, button, anchor);
    			append(button, text);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.bulkActions) && text_value !== (text_value = ctx.action.label)) {
    				setData(text, text_value);
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(button);
    			}
    		}
    	};
    }

    // (8:35) {#if selectedItemsCount > 0}
    function create_if_block_10$1(component, ctx) {
    	var button, text0_value = ctx.action.label, text0, text1, small, text2, text3, text4;

    	return {
    		c: function create() {
    			button = createElement("button");
    			text0 = createText(text0_value);
    			text1 = createText(" ");
    			small = createElement("small");
    			text2 = createText("(");
    			text3 = createText(ctx.selectedItemsCount);
    			text4 = createText(")");
    			addLoc(small, file$B, 9, 21, 451);

    			button._svelte = { component, ctx };

    			addListener(button, "click", click_handler$2);
    			button.disabled = ctx.disabled;
    			setStyle(button, "direction", "rtl");
    			button.className = "btn btn-default";
    			addLoc(button, file$B, 8, 5, 317);
    		},

    		m: function mount(target, anchor) {
    			insert(target, button, anchor);
    			append(button, text0);
    			append(button, text1);
    			append(button, small);
    			append(small, text2);
    			append(small, text3);
    			append(small, text4);
    		},

    		p: function update(changed, _ctx) {
    			ctx = _ctx;
    			if ((changed.bulkActions) && text0_value !== (text0_value = ctx.action.label)) {
    				setData(text0, text0_value);
    			}

    			if (changed.selectedItemsCount) {
    				setData(text3, ctx.selectedItemsCount);
    			}

    			button._svelte.ctx = ctx;
    			if (changed.disabled) {
    				button.disabled = ctx.disabled;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(button);
    			}

    			removeListener(button, "click", click_handler$2);
    		}
    	};
    }

    // (8:5) {#each bulkActions as action}
    function create_each_block_3(component, ctx) {
    	var if_block_anchor;

    	function select_block_type_1(ctx) {
    		if (ctx.selectedItemsCount > 0) return create_if_block_10$1;
    		return create_else_block_3;
    	}

    	var current_block_type = select_block_type_1(ctx);
    	var if_block = current_block_type(component, ctx);

    	return {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
    				if_block.p(changed, ctx);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(component, ctx);
    				if_block.c();
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},

    		d: function destroy$$1(detach) {
    			if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (19:4) {#if bulkActions.length > 0}
    function create_if_block_8$1(component, ctx) {
    	var th, input;

    	function change_handler(event) {
    		component.selectAllItems(this);
    	}

    	return {
    		c: function create() {
    			th = createElement("th");
    			input = createElement("input");
    			addListener(input, "change", change_handler);
    			setAttribute(input, "type", "checkbox");
    			input.className = "checkbox svelte-bip1ia";
    			addLoc(input, file$B, 20, 5, 700);
    			addLoc(th, file$B, 19, 4, 689);
    		},

    		m: function mount(target, anchor) {
    			insert(target, th, anchor);
    			append(th, input);
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(th);
    			}

    			removeListener(input, "change", change_handler);
    		}
    	};
    }

    // (37:10) {:else}
    function create_else_block_1$3(component, ctx) {
    	var th;

    	function select_block_type_4(ctx) {
    		if (ctx.column.customProperties != null &&
    					ctx.column.customProperties["documentation"] != null) return create_if_block_7$1;
    		return create_else_block_2$1;
    	}

    	var current_block_type = select_block_type_4(ctx);
    	var if_block = current_block_type(component, ctx);

    	return {
    		c: function create() {
    			th = createElement("th");
    			if_block.c();
    			addLoc(th, file$B, 37, 4, 1295);
    		},

    		m: function mount(target, anchor) {
    			insert(target, th, anchor);
    			if_block.m(th, null);
    		},

    		p: function update(changed, ctx) {
    			if (current_block_type === (current_block_type = select_block_type_4(ctx)) && if_block) {
    				if_block.p(changed, ctx);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(component, ctx);
    				if_block.c();
    				if_block.m(th, null);
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(th);
    			}

    			if_block.d();
    		}
    	};
    }

    // (27:43) {#if column.customProperties !=      null && column.customProperties["sortableBy"] != null}
    function create_if_block_5$1(component, ctx) {
    	var if_block_anchor;

    	function select_block_type_3(ctx) {
    		if (ctx.column.ascending) return create_if_block_6$1;
    		return create_else_block$9;
    	}

    	var current_block_type = select_block_type_3(ctx);
    	var if_block = current_block_type(component, ctx);

    	return {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (current_block_type === (current_block_type = select_block_type_3(ctx)) && if_block) {
    				if_block.p(changed, ctx);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(component, ctx);
    				if_block.c();
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},

    		d: function destroy$$1(detach) {
    			if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (47:5) {:else}
    function create_else_block_2$1(component, ctx) {
    	var text_value = ctx.column.label, text;

    	return {
    		c: function create() {
    			text = createText(text_value);
    		},

    		m: function mount(target, anchor) {
    			insert(target, text, anchor);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.columnsOrdered) && text_value !== (text_value = ctx.column.label)) {
    				setData(text, text_value);
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(text);
    			}
    		}
    	};
    }

    // (39:5) {#if column.customProperties != null &&       column.customProperties["documentation"] != null}
    function create_if_block_7$1(component, ctx) {
    	var div, text0_value = ctx.column.label, text0, text1;

    	var tooltip_initial_data = { data: ctx.column.customProperties.documentation[0] };
    	var tooltip = new SvelteComponent$4({
    		root: component.root,
    		store: component.store,
    		data: tooltip_initial_data
    	});

    	return {
    		c: function create() {
    			div = createElement("div");
    			text0 = createText(text0_value);
    			text1 = createText("\r\n\t\t\t\t\t\t");
    			tooltip._fragment.c();
    			div.className = "help-tooltip";
    			addLoc(div, file$B, 40, 5, 1408);
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);
    			append(div, text0);
    			append(div, text1);
    			tooltip._mount(div, null);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.columnsOrdered) && text0_value !== (text0_value = ctx.column.label)) {
    				setData(text0, text0_value);
    			}

    			var tooltip_changes = {};
    			if (changed.columnsOrdered) tooltip_changes.data = ctx.column.customProperties.documentation[0];
    			tooltip._set(tooltip_changes);
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(div);
    			}

    			tooltip.destroy();
    		}
    	};
    }

    // (33:4) {:else}
    function create_else_block$9(component, ctx) {
    	var th, text0_value = ctx.column.label, text0, text1, i;

    	return {
    		c: function create() {
    			th = createElement("th");
    			text0 = createText(text0_value);
    			text1 = createText(" ");
    			i = createElement("i");
    			i.className = "fa fa-sort-up";
    			addLoc(i, file$B, 34, 20, 1230);

    			th._svelte = { component, ctx };

    			addListener(th, "click", click_handler_2);
    			th.className = "sortable-column svelte-bip1ia";
    			addLoc(th, file$B, 33, 4, 1137);
    		},

    		m: function mount(target, anchor) {
    			insert(target, th, anchor);
    			append(th, text0);
    			append(th, text1);
    			append(th, i);
    		},

    		p: function update(changed, _ctx) {
    			ctx = _ctx;
    			if ((changed.columnsOrdered) && text0_value !== (text0_value = ctx.column.label)) {
    				setData(text0, text0_value);
    			}

    			th._svelte.ctx = ctx;
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(th);
    			}

    			removeListener(th, "click", click_handler_2);
    		}
    	};
    }

    // (28:59) {#if      column.ascending}
    function create_if_block_6$1(component, ctx) {
    	var th, text0_value = ctx.column.label, text0, text1, i;

    	return {
    		c: function create() {
    			th = createElement("th");
    			text0 = createText(text0_value);
    			text1 = createText(" ");
    			i = createElement("i");
    			i.className = "fa fa-sort-down";
    			addLoc(i, file$B, 30, 20, 1076);

    			th._svelte = { component, ctx };

    			addListener(th, "click", click_handler_1);
    			th.className = "sortable-column svelte-bip1ia";
    			addLoc(th, file$B, 29, 4, 983);
    		},

    		m: function mount(target, anchor) {
    			insert(target, th, anchor);
    			append(th, text0);
    			append(th, text1);
    			append(th, i);
    		},

    		p: function update(changed, _ctx) {
    			ctx = _ctx;
    			if ((changed.columnsOrdered) && text0_value !== (text0_value = ctx.column.label)) {
    				setData(text0, text0_value);
    			}

    			th._svelte.ctx = ctx;
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(th);
    			}

    			removeListener(th, "click", click_handler_1);
    		}
    	};
    }

    // (27:10) {#each columnsOrdered as column}
    function create_each_block_2$1(component, ctx) {
    	var if_block_anchor;

    	function select_block_type_2(ctx) {
    		if (ctx.column.customProperties !=
    				null && ctx.column.customProperties["sortableBy"] != null) return create_if_block_5$1;
    		return create_else_block_1$3;
    	}

    	var current_block_type = select_block_type_2(ctx);
    	var if_block = current_block_type(component, ctx);

    	return {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (current_block_type === (current_block_type = select_block_type_2(ctx)) && if_block) {
    				if_block.p(changed, ctx);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(component, ctx);
    				if_block.c();
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},

    		d: function destroy$$1(detach) {
    			if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (53:3) {#if map != null}
    function create_if_block_2$7(component, ctx) {
    	var each_anchor;

    	var each_value_2 = ctx.field.data;

    	var each_blocks = [];

    	for (var i = 0; i < each_value_2.length; i += 1) {
    		each_blocks[i] = create_each_block$8(component, get_each_context_2$1(ctx, each_value_2, i));
    	}

    	return {
    		c: function create() {
    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert(target, each_anchor, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (changed.getRowCssClass || changed.field || changed.columnsOrdered || changed.getField || changed.app || changed.form || changed.parent || changed.bulkActions) {
    				each_value_2 = ctx.field.data;

    				for (var i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2$1(ctx, each_value_2, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    					} else {
    						each_blocks[i] = create_each_block$8(component, child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_anchor.parentNode, each_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}
    				each_blocks.length = each_value_2.length;
    			}
    		},

    		d: function destroy$$1(detach) {
    			destroyEach(each_blocks, detach);

    			if (detach) {
    				detachNode(each_anchor);
    			}
    		}
    	};
    }

    // (55:4) {#if bulkActions.length > 0}
    function create_if_block_4$2(component, ctx) {
    	var td, div, input, input_disabled_value;

    	return {
    		c: function create() {
    			td = createElement("td");
    			div = createElement("div");
    			input = createElement("input");
    			input._svelte = { component, ctx };

    			addListener(input, "change", change_handler);
    			input.disabled = input_disabled_value = ctx.row.actions == null || ctx.row.actions.actions == null || ctx.row.actions.actions.filter(t => ctx.bulkActions.some(r => r.formId === t.form)).length === 0;
    			setAttribute(input, "type", "checkbox");
    			input.className = "checkbox svelte-bip1ia";
    			addLoc(input, file$B, 57, 6, 1841);
    			div.className = "form-group form-check";
    			addLoc(div, file$B, 56, 5, 1798);
    			addLoc(td, file$B, 55, 4, 1787);
    		},

    		m: function mount(target, anchor) {
    			insert(target, td, anchor);
    			append(td, div);
    			append(div, input);
    		},

    		p: function update(changed, _ctx) {
    			ctx = _ctx;
    			input._svelte.ctx = ctx;
    			if ((changed.field || changed.bulkActions) && input_disabled_value !== (input_disabled_value = ctx.row.actions == null || ctx.row.actions.actions == null || ctx.row.actions.actions.filter(t => ctx.bulkActions.some(r => r.formId === t.form)).length === 0)) {
    				input.disabled = input_disabled_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(td);
    			}

    			removeListener(input, "change", change_handler);
    		}
    	};
    }

    // (68:5) {#if !(getField(row, column).metadata.getCustomProperty("hideIfNull")       === true && getField(row, column).data === null)}
    function create_if_block_3$5(component, ctx) {

    	var formoutput_initial_data = {
    	 	field: ctx.getField(ctx.row, ctx.column),
    	 	app: ctx.app,
    	 	form: ctx.form,
    	 	parent: ctx.parent,
    	 	showLabel: "false"
    	 };
    	var formoutput = new SvelteComponent$6({
    		root: component.root,
    		store: component.store,
    		data: formoutput_initial_data
    	});

    	return {
    		c: function create() {
    			formoutput._fragment.c();
    		},

    		m: function mount(target, anchor) {
    			formoutput._mount(target, anchor);
    		},

    		p: function update(changed, ctx) {
    			var formoutput_changes = {};
    			if (changed.getField || changed.field || changed.columnsOrdered) formoutput_changes.field = ctx.getField(ctx.row, ctx.column);
    			if (changed.app) formoutput_changes.app = ctx.app;
    			if (changed.form) formoutput_changes.form = ctx.form;
    			if (changed.parent) formoutput_changes.parent = ctx.parent;
    			formoutput._set(formoutput_changes);
    		},

    		d: function destroy$$1(detach) {
    			formoutput.destroy(detach);
    		}
    	};
    }

    // (66:10) {#each columnsOrdered as column}
    function create_each_block_1$3(component, ctx) {
    	var td;

    	var if_block = (!(ctx.getField(ctx.row, ctx.column).metadata.getCustomProperty("hideIfNull")
    					=== true && ctx.getField(ctx.row, ctx.column).data === null)) && create_if_block_3$5(component, ctx);

    	return {
    		c: function create() {
    			td = createElement("td");
    			if (if_block) if_block.c();
    			addLoc(td, file$B, 66, 4, 2186);
    		},

    		m: function mount(target, anchor) {
    			insert(target, td, anchor);
    			if (if_block) if_block.m(td, null);
    		},

    		p: function update(changed, ctx) {
    			if (!(ctx.getField(ctx.row, ctx.column).metadata.getCustomProperty("hideIfNull")
    					=== true && ctx.getField(ctx.row, ctx.column).data === null)) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block_3$5(component, ctx);
    					if_block.c();
    					if_block.m(td, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(td);
    			}

    			if (if_block) if_block.d();
    		}
    	};
    }

    // (53:21) {#each field.data as row}
    function create_each_block$8(component, ctx) {
    	var tr, text, tr_class_value;

    	var if_block = (ctx.bulkActions.length > 0) && create_if_block_4$2(component, ctx);

    	var each_value_3 = ctx.columnsOrdered;

    	var each_blocks = [];

    	for (var i = 0; i < each_value_3.length; i += 1) {
    		each_blocks[i] = create_each_block_1$3(component, get_each_context_3(ctx, each_value_3, i));
    	}

    	return {
    		c: function create() {
    			tr = createElement("tr");
    			if (if_block) if_block.c();
    			text = createText(" ");

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}
    			tr.className = tr_class_value = "" + ctx.getRowCssClass(ctx.row) + " svelte-bip1ia";
    			addLoc(tr, file$B, 53, 3, 1713);
    		},

    		m: function mount(target, anchor) {
    			insert(target, tr, anchor);
    			if (if_block) if_block.m(tr, null);
    			append(tr, text);

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tr, null);
    			}
    		},

    		p: function update(changed, ctx) {
    			if (ctx.bulkActions.length > 0) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block_4$2(component, ctx);
    					if_block.c();
    					if_block.m(tr, text);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (changed.getField || changed.field || changed.columnsOrdered || changed.app || changed.form || changed.parent) {
    				each_value_3 = ctx.columnsOrdered;

    				for (var i = 0; i < each_value_3.length; i += 1) {
    					const child_ctx = get_each_context_3(ctx, each_value_3, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    					} else {
    						each_blocks[i] = create_each_block_1$3(component, child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tr, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}
    				each_blocks.length = each_value_3.length;
    			}

    			if ((changed.getRowCssClass || changed.field) && tr_class_value !== (tr_class_value = "" + ctx.getRowCssClass(ctx.row) + " svelte-bip1ia")) {
    				tr.className = tr_class_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(tr);
    			}

    			if (if_block) if_block.d();

    			destroyEach(each_blocks, detach);
    		}
    	};
    }

    // (86:0) {#if bulkActions.length > 0}
    function create_if_block_1$e(component, ctx) {
    	var input, text0, div2, div1, label, text1, div0;

    	function input_change_handler() {
    		component.set({ isBulkActionModalOpen: input.checked });
    	}

    	function click_handler_3(event) {
    		component.closeBulkActionModal(null);
    	}

    	return {
    		c: function create() {
    			input = createElement("input");
    			text0 = createText("\r\n");
    			div2 = createElement("div");
    			div1 = createElement("div");
    			label = createElement("label");
    			text1 = createText("\r\n\t\t");
    			div0 = createElement("div");
    			addListener(input, "change", input_change_handler);
    			setAttribute(input, "type", "checkbox");
    			input.className = "hidden";
    			addLoc(input, file$B, 86, 0, 2607);
    			addListener(label, "click", click_handler_3);
    			label.className = "close";
    			addLoc(label, file$B, 89, 2, 2730);
    			addLoc(div0, file$B, 90, 2, 2801);
    			div1.className = "card";
    			addLoc(div1, file$B, 88, 1, 2708);
    			div2.className = "modal";
    			addLoc(div2, file$B, 87, 0, 2686);
    		},

    		m: function mount(target, anchor) {
    			insert(target, input, anchor);

    			input.checked = ctx.isBulkActionModalOpen;

    			insert(target, text0, anchor);
    			insert(target, div2, anchor);
    			append(div2, div1);
    			append(div1, label);
    			append(div1, text1);
    			append(div1, div0);
    			component.refs.bulkActionContainer = div0;
    		},

    		p: function update(changed, ctx) {
    			if (changed.isBulkActionModalOpen) input.checked = ctx.isBulkActionModalOpen;
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(input);
    			}

    			removeListener(input, "change", input_change_handler);
    			if (detach) {
    				detachNode(text0);
    				detachNode(div2);
    			}

    			removeListener(label, "click", click_handler_3);
    			if (component.refs.bulkActionContainer === div0) component.refs.bulkActionContainer = null;
    		}
    	};
    }

    function SvelteComponent$C(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) {
    		throw new Error("'target' is a required option");
    	}

    	init(this, options);
    	this.refs = {};
    	this._state = assign(data$b(), options.data);

    	this._recompute({ field: 1 }, this._state);
    	if (!('field' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'field'");
    	if (!('visible' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'visible'");
    	if (!('bulkActions' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'bulkActions'");

    	if (!('selectedItemsCount' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'selectedItemsCount'");
    	if (!('disabled' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'disabled'");
    	if (!('map' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'map'");
    	if (!('getRowCssClass' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'getRowCssClass'");
    	if (!('getField' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'getField'");
    	if (!('app' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'app'");
    	if (!('form' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'form'");
    	if (!('parent' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'parent'");
    	if (!('isBulkActionModalOpen' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'isBulkActionModalOpen'");
    	this._intro = true;

    	if (!document.getElementById("svelte-bip1ia-style")) add_css$k();

    	this._fragment = create_main_fragment$C(this, this._state);

    	this.root._oncreate.push(() => {
    		oncreate$m.call(this);
    		this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
    	});

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);

    		flush(this);
    	}
    }

    assign(SvelteComponent$C.prototype, protoDev);
    assign(SvelteComponent$C.prototype, methods$a);

    SvelteComponent$C.prototype._checkReadOnly = function _checkReadOnly(newState) {
    	if ('columnsOrdered' in newState && !this._updatingReadonlyProperty) throw new Error("<SvelteComponent>: Cannot set read-only property 'columnsOrdered'");
    };

    SvelteComponent$C.prototype._recompute = function _recompute(changed, state) {
    	if (changed.field) {
    		if (this._differs(state.columnsOrdered, (state.columnsOrdered = columnsOrdered(state)))) changed.columnsOrdered = true;
    	}
    };

    /* src\core\ui\outputs\Paginator.html generated by Svelte v2.16.1 */



    function pages({ field, form, parent }) {
    	const paginatorInput = form.inputs
    		.find(t => t.metadata.id === field.metadata.customProperties.customizations.paginator);

    	const pageCount = Math.ceil(field.data.totalCount / paginatorInput.value.pageSize);

    	const params = {};
    	for (const i of form.inputs) {
    		params[i.metadata.id] = i.value;
    	}

    	if (pageCount > 0) {
    		if (pageCount < paginatorInput.value.pageIndex) {
    			paginatorInput.value.pageIndex = 1;
    			form.setInputFields(params);
    			parent.submit(null, false);
    		}
    		const pages = [];

    		for (let p = 1; p <= pageCount; ++p) {
    			const pageParams = Object.assign({}, params);
    			pageParams[paginatorInput.metadata.id] = Object.assign({}, pageParams[paginatorInput.metadata.id]);
    			pageParams[paginatorInput.metadata.id].pageIndex = p;

    			pages.push({
    				text: p,
    				params: pageParams,
    				cssClass: paginatorInput.value.pageIndex === p ? "current" : ""
    			});
    		}

    		const firstParams = Object.assign({}, params);
    		firstParams[paginatorInput.metadata.id] = Object.assign({}, firstParams[paginatorInput.metadata.id]);
    		firstParams[paginatorInput.metadata.id].pageIndex = 1;

    		const first = {
    			text: "الأول",
    			params: firstParams,
    			cssClass: paginatorInput.value.pageIndex === 1 ? "btn disabled" : ""
    		};
    		const prevParams = Object.assign({}, params);
    		prevParams[paginatorInput.metadata.id] = Object.assign({}, prevParams[paginatorInput.metadata.id]);
    		prevParams[paginatorInput.metadata.id].pageIndex = paginatorInput.value.pageIndex - 1;

    		const previous = {
    			text: "السابق",
    			params: prevParams,
    			cssClass: paginatorInput.value.pageIndex === 1 ? "btn disabled" : ""
    		};

    		const nextParams = Object.assign({}, params);
    		nextParams[paginatorInput.metadata.id] = Object.assign({}, nextParams[paginatorInput.metadata.id]);
    		nextParams[paginatorInput.metadata.id].pageIndex = paginatorInput.value.pageIndex + 1;

    		const next = {
    			text: "التالي",
    			params: nextParams,
    			cssClass: paginatorInput.value.pageIndex === pageCount ? "btn disabled" : ""
    		};

    		const lastParams = Object.assign({}, params);
    		lastParams[paginatorInput.metadata.id] = Object.assign({}, lastParams[paginatorInput.metadata.id]);
    		lastParams[paginatorInput.metadata.id].pageIndex = pageCount;

    		const last = {
    			text: "الأخير",
    			params: lastParams,
    			cssClass: paginatorInput.value.pageIndex === pageCount ? "btn disabled" : ""
    		};

    		let from = paginatorInput.value.pageIndex;
    		let to = paginatorInput.value.pageIndex;

    		if (from < 5) {
    			from = 0; to = 10;
    		}
    		else if (from > pageCount - 5 && pageCount > 10) {
    			to = pageCount; from = pageCount - 10;
    		}
    		else {
    			from -= 5;
    			to += 5;
    		}

    		const innerPages = pages.slice(from, to);
    		innerPages.unshift(previous);
    		innerPages.unshift(first);
    		innerPages.push(next);
    		innerPages.push(last);
    		return innerPages;
    	}

    	return [];
    }

    function data$c() {
    	return {
    		totalCount: 0
    	};
    }
    var methods$b = {
    	goToPage(page) {
    		const { parent, form } = this.get();

    		form.setInputFields(page.params);
    		parent.submit(null, false);
    	},
    	changePageSize() {
    		const { parent, form, field } = this.get();

    		const paginatorInput = form.inputs
    			.find(t => t.metadata.id === field.metadata.customProperties.customizations.paginator);

    		paginatorInput.value.pageSize = field.pageSize;
    		paginatorInput.value.pageIndex = 1;
    		const params = {};
    		for (const i of form.inputs) {
    			params[i.metadata.id] = i.value;
    		}
    		form.setInputFields(params);
    		parent.submit(null, false);
    	}
    };

    function oncreate$n() {
    	const { field, form } = this.get();

    	if (field.data == null) {
    		return;
    	}

    	const paginatorInput = form.inputs
    		.find(t => t.metadata.id === field.metadata.customProperties.customizations.paginator);

    	field.pageSize = paginatorInput.value.pageSize;
    	this.set({
    		pageSize: field.pageSize
    	});
    	const tableField = new OutputFieldValue();
    	tableField.data = field.data.results;
    	tableField.metadata = field.metadata;

    	// eslint-disable-next-line no-new
    	new SvelteComponent$C({
    		target: this.refs.container,
    		data: {
    			field: tableField,
    			app: this.get().app,
    			form,
    			parent: this.get().parent
    		}
    	});
    }
    const file$C = "src\\core\\ui\\outputs\\Paginator.html";

    function click_handler$3(event) {
    	const { component, ctx } = this._svelte;

    	component.goToPage(ctx.page);
    }

    function get_each_context$9(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.page = list[i];
    	return child_ctx;
    }

    function create_main_fragment$D(component, ctx) {
    	var text, div;

    	var if_block = (ctx.field.data != null && ctx.pages.length > 0) && create_if_block$r(component, ctx);

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			text = createText("\r\n\r\n");
    			div = createElement("div");
    			addLoc(div, file$C, 23, 0, 844);
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert(target, text, anchor);
    			insert(target, div, anchor);
    			component.refs.container = div;
    		},

    		p: function update(changed, ctx) {
    			if (ctx.field.data != null && ctx.pages.length > 0) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block$r(component, ctx);
    					if_block.c();
    					if_block.m(text.parentNode, text);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (if_block) if_block.d(detach);
    			if (detach) {
    				detachNode(text);
    				detachNode(div);
    			}

    			if (component.refs.container === div) component.refs.container = null;
    		}
    	};
    }

    // (1:0) {#if field.data != null && pages.length > 0}
    function create_if_block$r(component, ctx) {
    	var div0, select, option0, option1, option2, option3, option4, select_updating = false, text5, ul, text6, div1, text7, text8_value = ctx.field.data.results.length, text8, text9, text10_value = ctx.field.data.totalCount, text10, text11;

    	function select_change_handler() {
    		select_updating = true;
    		ctx.field.pageSize = selectValue(select);
    		component.set({ field: ctx.field });
    		select_updating = false;
    	}

    	function change_handler(event) {
    		component.changePageSize();
    	}

    	var each_value = ctx.pages;

    	var each_blocks = [];

    	for (var i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$9(component, get_each_context$9(ctx, each_value, i));
    	}

    	return {
    		c: function create() {
    			div0 = createElement("div");
    			select = createElement("select");
    			option0 = createElement("option");
    			option0.textContent = "10";
    			option1 = createElement("option");
    			option1.textContent = "20";
    			option2 = createElement("option");
    			option2.textContent = "50";
    			option3 = createElement("option");
    			option3.textContent = "100";
    			option4 = createElement("option");
    			option4.textContent = "200";
    			text5 = createText("\r\n\r\n\t");
    			ul = createElement("ul");

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			text6 = createText("\r\n");
    			div1 = createElement("div");
    			text7 = createText("عرض ");
    			text8 = createText(text8_value);
    			text9 = createText(" من ");
    			text10 = createText(text10_value);
    			text11 = createText(" عنصر");
    			option0.__value = "10";
    			option0.value = option0.__value;
    			addLoc(option0, file$C, 3, 2, 147);
    			option1.__value = "20";
    			option1.value = option1.__value;
    			addLoc(option1, file$C, 4, 2, 181);
    			option2.__value = "50";
    			option2.value = option2.__value;
    			addLoc(option2, file$C, 5, 2, 215);
    			option3.__value = "100";
    			option3.value = option3.__value;
    			addLoc(option3, file$C, 6, 2, 249);
    			option4.__value = "100";
    			option4.value = option4.__value;
    			addLoc(option4, file$C, 7, 2, 285);
    			addListener(select, "change", select_change_handler);
    			if (!('field' in ctx)) component.root._beforecreate.push(select_change_handler);
    			addListener(select, "change", change_handler);
    			select.className = "pagination-size";
    			addLoc(select, file$C, 2, 1, 54);
    			ul.className = "pagination pagination-sm";
    			addLoc(ul, file$C, 10, 1, 334);
    			addLoc(div0, file$C, 1, 0, 46);
    			div1.className = "paginator-summary";
    			addLoc(div1, file$C, 20, 0, 733);
    		},

    		m: function mount(target, anchor) {
    			insert(target, div0, anchor);
    			append(div0, select);
    			append(select, option0);
    			append(select, option1);
    			append(select, option2);
    			append(select, option3);
    			append(select, option4);

    			selectOption(select, ctx.field.pageSize);

    			append(div0, text5);
    			append(div0, ul);

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}

    			insert(target, text6, anchor);
    			insert(target, div1, anchor);
    			append(div1, text7);
    			append(div1, text8);
    			append(div1, text9);
    			append(div1, text10);
    			append(div1, text11);
    		},

    		p: function update(changed, _ctx) {
    			ctx = _ctx;
    			if (!select_updating && changed.field) selectOption(select, ctx.field.pageSize);

    			if (changed.parent || changed.app || changed.form || changed.pages) {
    				each_value = ctx.pages;

    				for (var i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$9(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    					} else {
    						each_blocks[i] = create_each_block$9(component, child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(ul, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}
    				each_blocks.length = each_value.length;
    			}

    			if ((changed.field) && text8_value !== (text8_value = ctx.field.data.results.length)) {
    				setData(text8, text8_value);
    			}

    			if ((changed.field) && text10_value !== (text10_value = ctx.field.data.totalCount)) {
    				setData(text10, text10_value);
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(div0);
    			}

    			removeListener(select, "change", select_change_handler);
    			removeListener(select, "change", change_handler);

    			destroyEach(each_blocks, detach);

    			if (detach) {
    				detachNode(text6);
    				detachNode(div1);
    			}
    		}
    	};
    }

    // (15:3) {:else}
    function create_else_block$a(component, ctx) {
    	var li, button, text_value = ctx.page.text, text, button_class_value;

    	return {
    		c: function create() {
    			li = createElement("li");
    			button = createElement("button");
    			text = createText(text_value);
    			button._svelte = { component, ctx };

    			addListener(button, "click", click_handler$3);
    			button.className = button_class_value = "" + ctx.page.cssClass + " page-link";
    			addLoc(button, file$C, 15, 25, 601);
    			li.className = "page-item";
    			addLoc(li, file$C, 15, 3, 579);
    		},

    		m: function mount(target, anchor) {
    			insert(target, li, anchor);
    			append(li, button);
    			append(button, text);
    		},

    		p: function update(changed, _ctx) {
    			ctx = _ctx;
    			if ((changed.pages) && text_value !== (text_value = ctx.page.text)) {
    				setData(text, text_value);
    			}

    			button._svelte.ctx = ctx;
    			if ((changed.pages) && button_class_value !== (button_class_value = "" + ctx.page.cssClass + " page-link")) {
    				button.className = button_class_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(li);
    			}

    			removeListener(button, "click", click_handler$3);
    		}
    	};
    }

    // (13:3) {#if parent.get().useUrl}
    function create_if_block_1$f(component, ctx) {
    	var li, a, text_value = ctx.page.text, text, a_href_value, a_class_value;

    	return {
    		c: function create() {
    			li = createElement("li");
    			a = createElement("a");
    			text = createText(text_value);
    			a.href = a_href_value = ctx.app.makeUrl(ctx.form.metadata.id, ctx.page.params);
    			a.className = a_class_value = "" + ctx.page.cssClass + " page-link";
    			addLoc(a, file$C, 13, 25, 453);
    			li.className = "page-item";
    			addLoc(li, file$C, 13, 3, 431);
    		},

    		m: function mount(target, anchor) {
    			insert(target, li, anchor);
    			append(li, a);
    			append(a, text);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.pages) && text_value !== (text_value = ctx.page.text)) {
    				setData(text, text_value);
    			}

    			if ((changed.app || changed.form || changed.pages) && a_href_value !== (a_href_value = ctx.app.makeUrl(ctx.form.metadata.id, ctx.page.params))) {
    				a.href = a_href_value;
    			}

    			if ((changed.pages) && a_class_value !== (a_class_value = "" + ctx.page.cssClass + " page-link")) {
    				a.className = a_class_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(li);
    			}
    		}
    	};
    }

    // (12:2) {#each pages as page}
    function create_each_block$9(component, ctx) {
    	var if_block_anchor;

    	function select_block_type(ctx) {
    		if (ctx.parent.get().useUrl) return create_if_block_1$f;
    		return create_else_block$a;
    	}

    	var current_block_type = select_block_type(ctx);
    	var if_block = current_block_type(component, ctx);

    	return {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(changed, ctx);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(component, ctx);
    				if_block.c();
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},

    		d: function destroy$$1(detach) {
    			if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    function SvelteComponent$D(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) {
    		throw new Error("'target' is a required option");
    	}

    	init(this, options);
    	this.refs = {};
    	this._state = assign(data$c(), options.data);

    	this._recompute({ field: 1, form: 1, parent: 1 }, this._state);
    	if (!('field' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'field'");
    	if (!('form' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'form'");
    	if (!('parent' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'parent'");

    	if (!('app' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'app'");
    	this._intro = true;

    	this._fragment = create_main_fragment$D(this, this._state);

    	this.root._oncreate.push(() => {
    		oncreate$n.call(this);
    		this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
    	});

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);

    		flush(this);
    	}
    }

    assign(SvelteComponent$D.prototype, protoDev);
    assign(SvelteComponent$D.prototype, methods$b);

    SvelteComponent$D.prototype._checkReadOnly = function _checkReadOnly(newState) {
    	if ('pages' in newState && !this._updatingReadonlyProperty) throw new Error("<SvelteComponent>: Cannot set read-only property 'pages'");
    };

    SvelteComponent$D.prototype._recompute = function _recompute(changed, state) {
    	if (changed.field || changed.form || changed.parent) {
    		if (this._differs(state.pages, (state.pages = pages(state)))) changed.pages = true;
    	}
    };

    /* src\core\ui\outputs\Table.html generated by Svelte v2.16.1 */



    function buildFilter$4(currentFormInstance, parameters) {
    	let promise;

    	const filter = {};
    	if (parameters != null && parameters.length > 0) {
    		promise = currentFormInstance.getSerializedInputValues().then(data => {
    			for (const p of parameters) {
    				filter[p] = data[p];
    			}

    			return filter;
    		});
    	}
    	else {
    		promise = Promise.resolve(filter);
    	}

    	return promise;
    }

    const modals$2 = [];

    // https://stackoverflow.com/a/3369743/111438
    // Close topmost modal when user presses escape key.
    document.addEventListener("keydown", e => {
    	const evt = e || window.event;
    	let isEscape = false;
    	if ("key" in evt) {
    		isEscape = evt.key === "Escape" || evt.key === "Esc";
    	}
    	else {
    		isEscape = evt.keyCode === 27;
    	}
    	if (isEscape) {
    		if (modals$2.length > 0) {
    			// Close topmost modal.
    			modals$2[modals$2.length - 1].closeBulkActionModal();
    		}
    	}
    });

    function columnsOrdered$1({ field }) {
    	return field.metadata.customProperties.columns
    	.filter(b => !b.hidden)
    	.sort((a, b) => a.orderIndex - b.orderIndex);
    }

    function data$d() {
    	return {
    		bulkActions: [],
    		getRowCssClass: () => "",
    		disabled: false
    	};
    }
    var methods$c = {
    	enableBulkButton() {
    		this.set({
    			disabled: false
    		});
    	},
    	async runBulkAction(action) {
    		this.set({ disabled: true });
    		// eslint-disable-next-line no-underscore-dangle
    		const selectedItems = this.get().field.data.filter(t => t.__selected === true);
    		const { map } = this.get();
    		const selectedItemIds = selectedItems.map(t => t[map[action.itemIdentifierField.toLowerCase()]]);

    		const { app } = this.get();
    		const formInstance = app.getFormInstance(action.formId, true);

    		const filter = await buildFilter$4(this.get().form, action.parameters);
    		filter.Items = { items: selectedItemIds };
    		formInstance.setInputFields(filter);

    		const isAllInputsHidden =
    			formInstance.inputs.filter(t => t.metadata.hidden === false)
    				.length > 0;

    		if (!isAllInputsHidden) {
    			try {
    				const response = await formInstance.submit(this.get().app, false);
    				this.onActionRun(formInstance.metadata.id, response, action);
    				this.enableBulkButton();
    			}
    			catch (e) {
    				this.enableBulkButton();
    			}
    		}
    		else {
    			this.set({
    				isBulkActionModalOpen: true
    			});
    			const f = new SvelteComponent$8({
    				target: this.refs.bulkActionContainer,
    				data: {
    					metadata: formInstance.metadata,
    					form: formInstance,
    					app,
    					useUrl: false
    				}
    			});

    			f.init();

    			const self = this;
    			f.on("form:responseHandled", e => {
    				self.closeBulkActionModal(e.response);
    			});

    			this.set({
    				currentBulkActionForm: f
    			});

    			modals$2.push(this);
    		}
    	},
    	async onActionRun(formId, response) {
    		const parentForm = this.get().parent;
    		const { app } = parentForm.get();

    		if (
    			response.metadata.handler !== "redirect" &&
    			response.metadata.handler !== "reload"
    		) {
    			// If asked to redirect to another form, then we redirect
    			// and do not reload parent form, as that would be a wasted effort.
    			await parentForm.submit(null, true);
    		}

    		const eventArgs = new ActionListEventArguments(app, formId);
    		parentForm.fireAndBubbleUp("action-list:run", eventArgs);
    	},
    	async closeBulkActionModal(response) {
    		const { currentBulkActionForm } = this.get();
    		this.enableBulkButton();
    		this.set({
    			isBulkActionModalOpen: false,
    			currentBulkActionForm: null
    		});

    		currentBulkActionForm.destroy();

    		const parentFormComponent = this.get().parent;

    		if (
    			response != null &&
    			response.metadata.handler !== "redirect" &&
    			response.metadata.handler !== "reload"
    		) {
    			// If asked to redirect to another form, then we redirect
    			// and do not reload parent form, as that would be a wasted effort.
    			await parentFormComponent.submit(null, true);
    		}

    		modals$2.pop();
    	},
    	isDisabled(row) {
    		return (
    			row.actions == null ||
    			row.actions.actions == null ||
    			row.actions.actions.filter(t => this.get().bulkActions.some(r => r.formId === t.form)).length === 0
    		);
    	},
    	selectItem(checkboxElement, row) {
    		// eslint-disable-next-line no-underscore-dangle, no-param-reassign
    		row.__selected = checkboxElement.checked;

    		// eslint-disable-next-line no-underscore-dangle
    		const selectedItems = this.get().field.data.filter(t => t.__selected === true);
    		this.set({ selectedItemsCount: selectedItems.length });
    	},
    	selectAllItems(checkboxElement) {
    		for (const row of this.get().field.data) {
    			if (!this.isDisabled(row)) {
    				// eslint-disable-next-line no-underscore-dangle, no-param-reassign
    				row.__selected = checkboxElement.checked;
    			}
    		}

    		const checkboxes = this.refs.table.querySelectorAll("tbody>tr>td .checkbox");

    		for (const checkbox of checkboxes) {
    			if (!checkbox.disabled) {
    				checkbox.checked = checkboxElement.checked;
    			}
    		}

    		// eslint-disable-next-line no-underscore-dangle
    		const selectedItems = this.get().field.data.filter(t => t.__selected === true);
    		this.set({ selectedItemsCount: selectedItems.length });
    	},
    	sortData(column, columns) {
    		const { parent, form, field } = this.get();

    		const paginatorInput = form.inputs.find(t => t.metadata.id ===
    				field.metadata.customProperties.customizations.paginator);

    		if (paginatorInput != null) {
    			paginatorInput.value.orderBy = column.customProperties.sortableBy;
    			for (const i of columns) {
    				i.ascending = false;
    			}

    			paginatorInput.value.ascending = !paginatorInput.value.ascending;
    			// eslint-disable-next-line no-param-reassign
    			column.ascending = paginatorInput.value.ascending;

    			const params = {};
    			for (const i of form.inputs) {
    				params[i.metadata.id] = i.value;
    			}
    			form.setInputFields(params);
    			parent.submit(null, false);
    		}
    	}
    };

    function oncreate$o() {
    	const { data } = this.get().field;

    	if (data == null) {
    		return;
    	}

    	const { metadata } = this.get().field;
    	const { rowCssClass } = metadata.customProperties || {};

    	// Create map, with key being the lowercase version of the property name
    	// and value being the actual property name.
    	const map = {};
    	if (data.length > 0) {
    		const firstRow = data[0];

    		for (const property of Object.keys(firstRow)) {
    			map[property.toLowerCase()] = property;
    		}
    	}

    	this.set({
    		// Show table only after the `oncreate` method has run.
    		visible: true,
    		bulkActions: (metadata.customProperties || {}).bulkAction || [],
    		map,
    		getField(row, column) {
    			const value = row[map[column.id.toLowerCase()]];

    			return {
    				data: value,
    				metadata: column
    			};
    		},
    		getRowCssClass(row) {
    			let cssClass = "";

    			if (rowCssClass != null) {
    				cssClass = rowCssClass.cssClass || "";

    				if (rowCssClass.suffix != null) {
    					cssClass += row[map[rowCssClass.suffix.toLowerCase()]];
    				}
    			}

    			return cssClass;
    		},
    		selectedItemsCount: 0
    	});
    }
    const file$D = "src\\core\\ui\\outputs\\Table.html";

    function add_css$l() {
    	var style = createElement("style");
    	style.id = 'svelte-bip1ia-style';
    	style.textContent = ".btn-row.svelte-bip1ia{text-align:right}.checkbox.svelte-bip1ia{clip:unset;clip-path:unset;position:unset;width:15px;height:15px}.sortable-column.svelte-bip1ia{cursor:pointer}.horizontal-scroll.svelte-bip1ia{overflow:hidden;overflow-x:auto;clear:both;width:100%}.table.svelte-bip1ia{min-width:rem-calc(640);text-align:center}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGFibGUuaHRtbCIsInNvdXJjZXMiOlsiVGFibGUuaHRtbCJdLCJzb3VyY2VzQ29udGVudCI6WyJ7I2lmIHZpc2libGUgJiYgZmllbGQuZGF0YSAhPSBudWxsICYmIGZpZWxkLmRhdGEubGVuZ3RoID4gMH1cclxuPGRpdiBjbGFzcz1cImhvcml6b250YWwtc2Nyb2xsXCI+XHJcblx0PHRhYmxlIGNsYXNzPVwidGFibGVcIiByZWY6dGFibGU+XHJcblx0XHQ8dGhlYWQ+XHJcblx0XHRcdHsjaWYgYnVsa0FjdGlvbnMubGVuZ3RoID4gMCB9XHJcblx0XHRcdDx0cj5cclxuXHRcdFx0XHQ8dGQgY29sc3Bhbj1cIntjb2x1bW5zT3JkZXJlZC5sZW5ndGggKyAxfVwiIGNsYXNzPVwiYnRuLXJvd1wiPlxyXG5cdFx0XHRcdFx0eyNlYWNoIGJ1bGtBY3Rpb25zIGFzIGFjdGlvbn0geyNpZiBzZWxlY3RlZEl0ZW1zQ291bnQgPiAwfVxyXG5cdFx0XHRcdFx0PGJ1dHRvbiBkaXNhYmxlZD1cIntkaXNhYmxlZH1cIiBzdHlsZT1cImRpcmVjdGlvbjogcnRsO1wiIGNsYXNzPVwiYnRuIGJ0bi1kZWZhdWx0XCIgb246Y2xpY2s9XCJydW5CdWxrQWN0aW9uKGFjdGlvbilcIj5cclxuXHRcdFx0XHRcdFx0e2FjdGlvbi5sYWJlbH0gPHNtYWxsPih7c2VsZWN0ZWRJdGVtc0NvdW50fSk8L3NtYWxsPlxyXG5cdFx0XHRcdFx0PC9idXR0b24+XHJcblx0XHRcdFx0XHR7OmVsc2V9XHJcblx0XHRcdFx0XHQ8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1kZWZhdWx0XCIgZGlzYWJsZWQ+e2FjdGlvbi5sYWJlbH08L2J1dHRvbj5cclxuXHRcdFx0XHRcdHsvaWZ9IHsvZWFjaH1cclxuXHRcdFx0XHQ8L3RkPlxyXG5cdFx0XHQ8L3RyPlxyXG5cdFx0XHR7L2lmfVxyXG5cdFx0XHQ8dHI+XHJcblx0XHRcdFx0eyNpZiBidWxrQWN0aW9ucy5sZW5ndGggPiAwfVxyXG5cdFx0XHRcdDx0aD5cclxuXHRcdFx0XHRcdDxpbnB1dFxyXG5cdFx0XHRcdFx0XHR0eXBlPVwiY2hlY2tib3hcIlxyXG5cdFx0XHRcdFx0XHRjbGFzcz1cImNoZWNrYm94XCJcclxuXHRcdFx0XHRcdFx0b246Y2hhbmdlPVwic2VsZWN0QWxsSXRlbXModGhpcylcIlxyXG5cdFx0XHRcdFx0Lz5cclxuXHRcdFx0XHQ8L3RoPlxyXG5cdFx0XHRcdHsvaWZ9IHsjZWFjaCBjb2x1bW5zT3JkZXJlZCBhcyBjb2x1bW59IHsjaWYgY29sdW1uLmN1c3RvbVByb3BlcnRpZXMgIT1cclxuXHRcdFx0XHRudWxsICYmIGNvbHVtbi5jdXN0b21Qcm9wZXJ0aWVzW1wic29ydGFibGVCeVwiXSAhPSBudWxsfSB7I2lmXHJcblx0XHRcdFx0Y29sdW1uLmFzY2VuZGluZ31cclxuXHRcdFx0XHQ8dGggY2xhc3M9XCJzb3J0YWJsZS1jb2x1bW5cIiBvbjpjbGljaz1cInNvcnREYXRhKGNvbHVtbixjb2x1bW5zT3JkZXJlZClcIj5cclxuXHRcdFx0XHRcdHtjb2x1bW4ubGFiZWx9IDxpIGNsYXNzPVwiZmEgZmEtc29ydC1kb3duXCI+PC9pPlxyXG5cdFx0XHRcdDwvdGg+XHJcblx0XHRcdFx0ezplbHNlfVxyXG5cdFx0XHRcdDx0aCBjbGFzcz1cInNvcnRhYmxlLWNvbHVtblwiIG9uOmNsaWNrPVwic29ydERhdGEoY29sdW1uLGNvbHVtbnNPcmRlcmVkKVwiPlxyXG5cdFx0XHRcdFx0e2NvbHVtbi5sYWJlbH0gPGkgY2xhc3M9XCJmYSBmYS1zb3J0LXVwXCI+PC9pPlxyXG5cdFx0XHRcdDwvdGg+XHJcblx0XHRcdFx0ey9pZn0gezplbHNlfVxyXG5cdFx0XHRcdDx0aD5cclxuXHRcdFx0XHRcdHsjaWYgY29sdW1uLmN1c3RvbVByb3BlcnRpZXMgIT0gbnVsbCAmJlxyXG5cdFx0XHRcdFx0Y29sdW1uLmN1c3RvbVByb3BlcnRpZXNbXCJkb2N1bWVudGF0aW9uXCJdICE9IG51bGx9XHJcblx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwiaGVscC10b29sdGlwXCI+XHJcblx0XHRcdFx0XHRcdHtjb2x1bW4ubGFiZWx9XHJcblx0XHRcdFx0XHRcdDxUb29sdGlwXHJcblx0XHRcdFx0XHRcdFx0ZGF0YT1cIntjb2x1bW4uY3VzdG9tUHJvcGVydGllcy5kb2N1bWVudGF0aW9uWzBdfVwiXHJcblx0XHRcdFx0XHRcdD48L1Rvb2x0aXA+XHJcblx0XHRcdFx0XHQ8L2Rpdj5cclxuXHRcdFx0XHRcdHs6ZWxzZX0ge2NvbHVtbi5sYWJlbH0gey9pZn1cclxuXHRcdFx0XHQ8L3RoPlxyXG5cdFx0XHRcdHsvaWZ9IHsvZWFjaH1cclxuXHRcdFx0PC90cj5cclxuXHRcdDwvdGhlYWQ+XHJcblx0XHQ8dGJvZHk+XHJcblx0XHRcdHsjaWYgbWFwICE9IG51bGx9IHsjZWFjaCBmaWVsZC5kYXRhIGFzIHJvd31cclxuXHRcdFx0PHRyIGNsYXNzPVwie2dldFJvd0Nzc0NsYXNzKHJvdyl9XCI+XHJcblx0XHRcdFx0eyNpZiBidWxrQWN0aW9ucy5sZW5ndGggPiAwfVxyXG5cdFx0XHRcdDx0ZD5cclxuXHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwIGZvcm0tY2hlY2tcIj5cclxuXHRcdFx0XHRcdFx0PGlucHV0XHJcblx0XHRcdFx0XHRcdFx0ZGlzYWJsZWQ9XCJ7cm93LmFjdGlvbnMgPT0gbnVsbCB8fCByb3cuYWN0aW9ucy5hY3Rpb25zID09IG51bGwgfHwgcm93LmFjdGlvbnMuYWN0aW9ucy5maWx0ZXIodCA9PiBidWxrQWN0aW9ucy5zb21lKHIgPT4gci5mb3JtSWQgPT09IHQuZm9ybSkpLmxlbmd0aCA9PT0gMH1cIlxyXG5cdFx0XHRcdFx0XHRcdHR5cGU9XCJjaGVja2JveFwiXHJcblx0XHRcdFx0XHRcdFx0Y2xhc3M9XCJjaGVja2JveFwiXHJcblx0XHRcdFx0XHRcdFx0b246Y2hhbmdlPVwic2VsZWN0SXRlbSh0aGlzLCByb3cpXCJcclxuXHRcdFx0XHRcdFx0Lz5cclxuXHRcdFx0XHRcdDwvZGl2PlxyXG5cdFx0XHRcdDwvdGQ+XHJcblx0XHRcdFx0ey9pZn0geyNlYWNoIGNvbHVtbnNPcmRlcmVkIGFzIGNvbHVtbn1cclxuXHRcdFx0XHQ8dGQ+XHJcblx0XHRcdFx0XHR7I2lmICEoZ2V0RmllbGQocm93LCBjb2x1bW4pLm1ldGFkYXRhLmdldEN1c3RvbVByb3BlcnR5KFwiaGlkZUlmTnVsbFwiKVxyXG5cdFx0XHRcdFx0PT09IHRydWUgJiYgZ2V0RmllbGQocm93LCBjb2x1bW4pLmRhdGEgPT09IG51bGwpfVxyXG5cdFx0XHRcdFx0PEZvcm1PdXRwdXRcclxuXHRcdFx0XHRcdFx0ZmllbGQ9XCJ7Z2V0RmllbGQocm93LCBjb2x1bW4pfVwiXHJcblx0XHRcdFx0XHRcdGFwcD1cInthcHB9XCJcclxuXHRcdFx0XHRcdFx0Zm9ybT1cIntmb3JtfVwiXHJcblx0XHRcdFx0XHRcdHBhcmVudD1cIntwYXJlbnR9XCJcclxuXHRcdFx0XHRcdFx0c2hvd0xhYmVsPVwiZmFsc2VcIlxyXG5cdFx0XHRcdFx0Lz5cclxuXHRcdFx0XHRcdHsvaWZ9XHJcblx0XHRcdFx0PC90ZD5cclxuXHRcdFx0XHR7L2VhY2h9XHJcblx0XHRcdDwvdHI+XHJcblx0XHRcdHsvZWFjaH0gey9pZn1cclxuXHRcdDwvdGJvZHk+XHJcblx0PC90YWJsZT5cclxuPC9kaXY+XHJcblxyXG57I2lmIGJ1bGtBY3Rpb25zLmxlbmd0aCA+IDB9XHJcbjxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBiaW5kOmNoZWNrZWQ9XCJpc0J1bGtBY3Rpb25Nb2RhbE9wZW5cIiBjbGFzcz1cImhpZGRlblwiIC8+XHJcbjxkaXYgY2xhc3M9XCJtb2RhbFwiPlxyXG5cdDxkaXYgY2xhc3M9XCJjYXJkXCI+XHJcblx0XHQ8bGFiZWwgY2xhc3M9XCJjbG9zZVwiIG9uOmNsaWNrPVwiY2xvc2VCdWxrQWN0aW9uTW9kYWwobnVsbClcIj48L2xhYmVsPlxyXG5cdFx0PGRpdiByZWY6YnVsa0FjdGlvbkNvbnRhaW5lcj48L2Rpdj5cclxuXHQ8L2Rpdj5cclxuPC9kaXY+XHJcbnsvaWZ9IHs6ZWxzZX1cclxuPGRpdiBjbGFzcz1cImFsZXJ0LW5vZGF0YVwiPk5vIGRhdGEgZm91bmQuPC9kaXY+XHJcbnsvaWZ9XHJcblxyXG48c2NyaXB0PlxyXG5cdGltcG9ydCBGb3JtQ29tcG9uZW50IGZyb20gXCJjb3JlLXVpL0Zvcm1cIjtcclxuXHRpbXBvcnQgRm9ybU91dHB1dCBmcm9tIFwiLi4vT3V0cHV0XCI7XHJcblx0aW1wb3J0IFRvb2x0aXAgZnJvbSBcIi4uL2hlbHAvVG9vbHRpcFwiO1xyXG5cdGltcG9ydCB7IEFjdGlvbkxpc3RFdmVudEFyZ3VtZW50cyB9IGZyb20gXCIuL0FjdGlvbkxpc3RFdmVudEFyZ3VtZW50c1wiO1xyXG5cclxuXHRmdW5jdGlvbiBidWlsZEZpbHRlcihjdXJyZW50Rm9ybUluc3RhbmNlLCBwYXJhbWV0ZXJzKSB7XHJcblx0XHRsZXQgcHJvbWlzZTtcclxuXHJcblx0XHRjb25zdCBmaWx0ZXIgPSB7fTtcclxuXHRcdGlmIChwYXJhbWV0ZXJzICE9IG51bGwgJiYgcGFyYW1ldGVycy5sZW5ndGggPiAwKSB7XHJcblx0XHRcdHByb21pc2UgPSBjdXJyZW50Rm9ybUluc3RhbmNlLmdldFNlcmlhbGl6ZWRJbnB1dFZhbHVlcygpLnRoZW4oZGF0YSA9PiB7XHJcblx0XHRcdFx0Zm9yIChjb25zdCBwIG9mIHBhcmFtZXRlcnMpIHtcclxuXHRcdFx0XHRcdGZpbHRlcltwXSA9IGRhdGFbcF07XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXR1cm4gZmlsdGVyO1xyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHRcdGVsc2Uge1xyXG5cdFx0XHRwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKGZpbHRlcik7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHByb21pc2U7XHJcblx0fVxyXG5cclxuXHRjb25zdCBtb2RhbHMgPSBbXTtcclxuXHJcblx0Ly8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzMzNjk3NDMvMTExNDM4XHJcblx0Ly8gQ2xvc2UgdG9wbW9zdCBtb2RhbCB3aGVuIHVzZXIgcHJlc3NlcyBlc2NhcGUga2V5LlxyXG5cdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGUgPT4ge1xyXG5cdFx0Y29uc3QgZXZ0ID0gZSB8fCB3aW5kb3cuZXZlbnQ7XHJcblx0XHRsZXQgaXNFc2NhcGUgPSBmYWxzZTtcclxuXHRcdGlmIChcImtleVwiIGluIGV2dCkge1xyXG5cdFx0XHRpc0VzY2FwZSA9IGV2dC5rZXkgPT09IFwiRXNjYXBlXCIgfHwgZXZ0LmtleSA9PT0gXCJFc2NcIjtcclxuXHRcdH1cclxuXHRcdGVsc2Uge1xyXG5cdFx0XHRpc0VzY2FwZSA9IGV2dC5rZXlDb2RlID09PSAyNztcclxuXHRcdH1cclxuXHRcdGlmIChpc0VzY2FwZSkge1xyXG5cdFx0XHRpZiAobW9kYWxzLmxlbmd0aCA+IDApIHtcclxuXHRcdFx0XHQvLyBDbG9zZSB0b3Btb3N0IG1vZGFsLlxyXG5cdFx0XHRcdG1vZGFsc1ttb2RhbHMubGVuZ3RoIC0gMV0uY2xvc2VCdWxrQWN0aW9uTW9kYWwoKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0pO1xyXG5cclxuXHRleHBvcnQgZGVmYXVsdCB7XHJcblx0XHRvbmNyZWF0ZSgpIHtcclxuXHRcdFx0Y29uc3QgeyBkYXRhIH0gPSB0aGlzLmdldCgpLmZpZWxkO1xyXG5cclxuXHRcdFx0aWYgKGRhdGEgPT0gbnVsbCkge1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Y29uc3QgeyBtZXRhZGF0YSB9ID0gdGhpcy5nZXQoKS5maWVsZDtcclxuXHRcdFx0Y29uc3QgeyByb3dDc3NDbGFzcyB9ID0gbWV0YWRhdGEuY3VzdG9tUHJvcGVydGllcyB8fCB7fTtcclxuXHJcblx0XHRcdC8vIENyZWF0ZSBtYXAsIHdpdGgga2V5IGJlaW5nIHRoZSBsb3dlcmNhc2UgdmVyc2lvbiBvZiB0aGUgcHJvcGVydHkgbmFtZVxyXG5cdFx0XHQvLyBhbmQgdmFsdWUgYmVpbmcgdGhlIGFjdHVhbCBwcm9wZXJ0eSBuYW1lLlxyXG5cdFx0XHRjb25zdCBtYXAgPSB7fTtcclxuXHRcdFx0aWYgKGRhdGEubGVuZ3RoID4gMCkge1xyXG5cdFx0XHRcdGNvbnN0IGZpcnN0Um93ID0gZGF0YVswXTtcclxuXHJcblx0XHRcdFx0Zm9yIChjb25zdCBwcm9wZXJ0eSBvZiBPYmplY3Qua2V5cyhmaXJzdFJvdykpIHtcclxuXHRcdFx0XHRcdG1hcFtwcm9wZXJ0eS50b0xvd2VyQ2FzZSgpXSA9IHByb3BlcnR5O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5zZXQoe1xyXG5cdFx0XHRcdC8vIFNob3cgdGFibGUgb25seSBhZnRlciB0aGUgYG9uY3JlYXRlYCBtZXRob2QgaGFzIHJ1bi5cclxuXHRcdFx0XHR2aXNpYmxlOiB0cnVlLFxyXG5cdFx0XHRcdGJ1bGtBY3Rpb25zOiAobWV0YWRhdGEuY3VzdG9tUHJvcGVydGllcyB8fCB7fSkuYnVsa0FjdGlvbiB8fCBbXSxcclxuXHRcdFx0XHRtYXAsXHJcblx0XHRcdFx0Z2V0RmllbGQocm93LCBjb2x1bW4pIHtcclxuXHRcdFx0XHRcdGNvbnN0IHZhbHVlID0gcm93W21hcFtjb2x1bW4uaWQudG9Mb3dlckNhc2UoKV1dO1xyXG5cclxuXHRcdFx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0XHRcdGRhdGE6IHZhbHVlLFxyXG5cdFx0XHRcdFx0XHRtZXRhZGF0YTogY29sdW1uXHJcblx0XHRcdFx0XHR9O1xyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0Z2V0Um93Q3NzQ2xhc3Mocm93KSB7XHJcblx0XHRcdFx0XHRsZXQgY3NzQ2xhc3MgPSBcIlwiO1xyXG5cclxuXHRcdFx0XHRcdGlmIChyb3dDc3NDbGFzcyAhPSBudWxsKSB7XHJcblx0XHRcdFx0XHRcdGNzc0NsYXNzID0gcm93Q3NzQ2xhc3MuY3NzQ2xhc3MgfHwgXCJcIjtcclxuXHJcblx0XHRcdFx0XHRcdGlmIChyb3dDc3NDbGFzcy5zdWZmaXggIT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0XHRcdGNzc0NsYXNzICs9IHJvd1ttYXBbcm93Q3NzQ2xhc3Muc3VmZml4LnRvTG93ZXJDYXNlKCldXTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdHJldHVybiBjc3NDbGFzcztcclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdHNlbGVjdGVkSXRlbXNDb3VudDogMFxyXG5cdFx0XHR9KTtcclxuXHRcdH0sXHJcblx0XHRjb21wdXRlZDoge1xyXG5cdFx0XHRjb2x1bW5zT3JkZXJlZDogKHsgZmllbGQgfSkgPT4gZmllbGQubWV0YWRhdGEuY3VzdG9tUHJvcGVydGllcy5jb2x1bW5zXHJcblx0XHRcdFx0LmZpbHRlcihiID0+ICFiLmhpZGRlbilcclxuXHRcdFx0XHQuc29ydCgoYSwgYikgPT4gYS5vcmRlckluZGV4IC0gYi5vcmRlckluZGV4KVxyXG5cdFx0fSxcclxuXHRcdG1ldGhvZHM6IHtcclxuXHRcdFx0ZW5hYmxlQnVsa0J1dHRvbigpIHtcclxuXHRcdFx0XHR0aGlzLnNldCh7XHJcblx0XHRcdFx0XHRkaXNhYmxlZDogZmFsc2VcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fSxcclxuXHRcdFx0YXN5bmMgcnVuQnVsa0FjdGlvbihhY3Rpb24pIHtcclxuXHRcdFx0XHR0aGlzLnNldCh7IGRpc2FibGVkOiB0cnVlIH0pO1xyXG5cdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlcnNjb3JlLWRhbmdsZVxyXG5cdFx0XHRcdGNvbnN0IHNlbGVjdGVkSXRlbXMgPSB0aGlzLmdldCgpLmZpZWxkLmRhdGEuZmlsdGVyKHQgPT4gdC5fX3NlbGVjdGVkID09PSB0cnVlKTtcclxuXHRcdFx0XHRjb25zdCB7IG1hcCB9ID0gdGhpcy5nZXQoKTtcclxuXHRcdFx0XHRjb25zdCBzZWxlY3RlZEl0ZW1JZHMgPSBzZWxlY3RlZEl0ZW1zLm1hcCh0ID0+IHRbbWFwW2FjdGlvbi5pdGVtSWRlbnRpZmllckZpZWxkLnRvTG93ZXJDYXNlKCldXSk7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHsgYXBwIH0gPSB0aGlzLmdldCgpO1xyXG5cdFx0XHRcdGNvbnN0IGZvcm1JbnN0YW5jZSA9IGFwcC5nZXRGb3JtSW5zdGFuY2UoYWN0aW9uLmZvcm1JZCwgdHJ1ZSk7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGZpbHRlciA9IGF3YWl0IGJ1aWxkRmlsdGVyKHRoaXMuZ2V0KCkuZm9ybSwgYWN0aW9uLnBhcmFtZXRlcnMpO1xyXG5cdFx0XHRcdGZpbHRlci5JdGVtcyA9IHsgaXRlbXM6IHNlbGVjdGVkSXRlbUlkcyB9O1xyXG5cdFx0XHRcdGZvcm1JbnN0YW5jZS5zZXRJbnB1dEZpZWxkcyhmaWx0ZXIpO1xyXG5cclxuXHRcdFx0XHRjb25zdCBpc0FsbElucHV0c0hpZGRlbiA9XHJcblx0XHRcdFx0XHRmb3JtSW5zdGFuY2UuaW5wdXRzLmZpbHRlcih0ID0+IHQubWV0YWRhdGEuaGlkZGVuID09PSBmYWxzZSlcclxuXHRcdFx0XHRcdFx0Lmxlbmd0aCA+IDA7XHJcblxyXG5cdFx0XHRcdGlmICghaXNBbGxJbnB1dHNIaWRkZW4pIHtcclxuXHRcdFx0XHRcdHRyeSB7XHJcblx0XHRcdFx0XHRcdGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZm9ybUluc3RhbmNlLnN1Ym1pdCh0aGlzLmdldCgpLmFwcCwgZmFsc2UpO1xyXG5cdFx0XHRcdFx0XHR0aGlzLm9uQWN0aW9uUnVuKGZvcm1JbnN0YW5jZS5tZXRhZGF0YS5pZCwgcmVzcG9uc2UsIGFjdGlvbik7XHJcblx0XHRcdFx0XHRcdHRoaXMuZW5hYmxlQnVsa0J1dHRvbigpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0Y2F0Y2ggKGUpIHtcclxuXHRcdFx0XHRcdFx0dGhpcy5lbmFibGVCdWxrQnV0dG9uKCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0dGhpcy5zZXQoe1xyXG5cdFx0XHRcdFx0XHRpc0J1bGtBY3Rpb25Nb2RhbE9wZW46IHRydWVcclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdFx0Y29uc3QgZiA9IG5ldyBGb3JtQ29tcG9uZW50KHtcclxuXHRcdFx0XHRcdFx0dGFyZ2V0OiB0aGlzLnJlZnMuYnVsa0FjdGlvbkNvbnRhaW5lcixcclxuXHRcdFx0XHRcdFx0ZGF0YToge1xyXG5cdFx0XHRcdFx0XHRcdG1ldGFkYXRhOiBmb3JtSW5zdGFuY2UubWV0YWRhdGEsXHJcblx0XHRcdFx0XHRcdFx0Zm9ybTogZm9ybUluc3RhbmNlLFxyXG5cdFx0XHRcdFx0XHRcdGFwcCxcclxuXHRcdFx0XHRcdFx0XHR1c2VVcmw6IGZhbHNlXHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0XHRcdGYuaW5pdCgpO1xyXG5cclxuXHRcdFx0XHRcdGNvbnN0IHNlbGYgPSB0aGlzO1xyXG5cdFx0XHRcdFx0Zi5vbihcImZvcm06cmVzcG9uc2VIYW5kbGVkXCIsIGUgPT4ge1xyXG5cdFx0XHRcdFx0XHRzZWxmLmNsb3NlQnVsa0FjdGlvbk1vZGFsKGUucmVzcG9uc2UpO1xyXG5cdFx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5zZXQoe1xyXG5cdFx0XHRcdFx0XHRjdXJyZW50QnVsa0FjdGlvbkZvcm06IGZcclxuXHRcdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0XHRcdG1vZGFscy5wdXNoKHRoaXMpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSxcclxuXHRcdFx0YXN5bmMgb25BY3Rpb25SdW4oZm9ybUlkLCByZXNwb25zZSkge1xyXG5cdFx0XHRcdGNvbnN0IHBhcmVudEZvcm0gPSB0aGlzLmdldCgpLnBhcmVudDtcclxuXHRcdFx0XHRjb25zdCB7IGFwcCB9ID0gcGFyZW50Rm9ybS5nZXQoKTtcclxuXHJcblx0XHRcdFx0aWYgKFxyXG5cdFx0XHRcdFx0cmVzcG9uc2UubWV0YWRhdGEuaGFuZGxlciAhPT0gXCJyZWRpcmVjdFwiICYmXHJcblx0XHRcdFx0XHRyZXNwb25zZS5tZXRhZGF0YS5oYW5kbGVyICE9PSBcInJlbG9hZFwiXHJcblx0XHRcdFx0KSB7XHJcblx0XHRcdFx0XHQvLyBJZiBhc2tlZCB0byByZWRpcmVjdCB0byBhbm90aGVyIGZvcm0sIHRoZW4gd2UgcmVkaXJlY3RcclxuXHRcdFx0XHRcdC8vIGFuZCBkbyBub3QgcmVsb2FkIHBhcmVudCBmb3JtLCBhcyB0aGF0IHdvdWxkIGJlIGEgd2FzdGVkIGVmZm9ydC5cclxuXHRcdFx0XHRcdGF3YWl0IHBhcmVudEZvcm0uc3VibWl0KG51bGwsIHRydWUpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Y29uc3QgZXZlbnRBcmdzID0gbmV3IEFjdGlvbkxpc3RFdmVudEFyZ3VtZW50cyhhcHAsIGZvcm1JZCk7XHJcblx0XHRcdFx0cGFyZW50Rm9ybS5maXJlQW5kQnViYmxlVXAoXCJhY3Rpb24tbGlzdDpydW5cIiwgZXZlbnRBcmdzKTtcclxuXHRcdFx0fSxcclxuXHRcdFx0YXN5bmMgY2xvc2VCdWxrQWN0aW9uTW9kYWwocmVzcG9uc2UpIHtcclxuXHRcdFx0XHRjb25zdCB7IGN1cnJlbnRCdWxrQWN0aW9uRm9ybSB9ID0gdGhpcy5nZXQoKTtcclxuXHRcdFx0XHR0aGlzLmVuYWJsZUJ1bGtCdXR0b24oKTtcclxuXHRcdFx0XHR0aGlzLnNldCh7XHJcblx0XHRcdFx0XHRpc0J1bGtBY3Rpb25Nb2RhbE9wZW46IGZhbHNlLFxyXG5cdFx0XHRcdFx0Y3VycmVudEJ1bGtBY3Rpb25Gb3JtOiBudWxsXHJcblx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRcdGN1cnJlbnRCdWxrQWN0aW9uRm9ybS5kZXN0cm95KCk7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHBhcmVudEZvcm1Db21wb25lbnQgPSB0aGlzLmdldCgpLnBhcmVudDtcclxuXHJcblx0XHRcdFx0aWYgKFxyXG5cdFx0XHRcdFx0cmVzcG9uc2UgIT0gbnVsbCAmJlxyXG5cdFx0XHRcdFx0cmVzcG9uc2UubWV0YWRhdGEuaGFuZGxlciAhPT0gXCJyZWRpcmVjdFwiICYmXHJcblx0XHRcdFx0XHRyZXNwb25zZS5tZXRhZGF0YS5oYW5kbGVyICE9PSBcInJlbG9hZFwiXHJcblx0XHRcdFx0KSB7XHJcblx0XHRcdFx0XHQvLyBJZiBhc2tlZCB0byByZWRpcmVjdCB0byBhbm90aGVyIGZvcm0sIHRoZW4gd2UgcmVkaXJlY3RcclxuXHRcdFx0XHRcdC8vIGFuZCBkbyBub3QgcmVsb2FkIHBhcmVudCBmb3JtLCBhcyB0aGF0IHdvdWxkIGJlIGEgd2FzdGVkIGVmZm9ydC5cclxuXHRcdFx0XHRcdGF3YWl0IHBhcmVudEZvcm1Db21wb25lbnQuc3VibWl0KG51bGwsIHRydWUpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0bW9kYWxzLnBvcCgpO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRpc0Rpc2FibGVkKHJvdykge1xyXG5cdFx0XHRcdHJldHVybiAoXHJcblx0XHRcdFx0XHRyb3cuYWN0aW9ucyA9PSBudWxsIHx8XHJcblx0XHRcdFx0XHRyb3cuYWN0aW9ucy5hY3Rpb25zID09IG51bGwgfHxcclxuXHRcdFx0XHRcdHJvdy5hY3Rpb25zLmFjdGlvbnMuZmlsdGVyKHQgPT4gdGhpcy5nZXQoKS5idWxrQWN0aW9ucy5zb21lKHIgPT4gci5mb3JtSWQgPT09IHQuZm9ybSkpLmxlbmd0aCA9PT0gMFxyXG5cdFx0XHRcdCk7XHJcblx0XHRcdH0sXHJcblx0XHRcdHNlbGVjdEl0ZW0oY2hlY2tib3hFbGVtZW50LCByb3cpIHtcclxuXHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZXJzY29yZS1kYW5nbGUsIG5vLXBhcmFtLXJlYXNzaWduXHJcblx0XHRcdFx0cm93Ll9fc2VsZWN0ZWQgPSBjaGVja2JveEVsZW1lbnQuY2hlY2tlZDtcclxuXHJcblx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVyc2NvcmUtZGFuZ2xlXHJcblx0XHRcdFx0Y29uc3Qgc2VsZWN0ZWRJdGVtcyA9IHRoaXMuZ2V0KCkuZmllbGQuZGF0YS5maWx0ZXIodCA9PiB0Ll9fc2VsZWN0ZWQgPT09IHRydWUpO1xyXG5cdFx0XHRcdHRoaXMuc2V0KHsgc2VsZWN0ZWRJdGVtc0NvdW50OiBzZWxlY3RlZEl0ZW1zLmxlbmd0aCB9KTtcclxuXHRcdFx0fSxcclxuXHRcdFx0c2VsZWN0QWxsSXRlbXMoY2hlY2tib3hFbGVtZW50KSB7XHJcblx0XHRcdFx0Zm9yIChjb25zdCByb3cgb2YgdGhpcy5nZXQoKS5maWVsZC5kYXRhKSB7XHJcblx0XHRcdFx0XHRpZiAoIXRoaXMuaXNEaXNhYmxlZChyb3cpKSB7XHJcblx0XHRcdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlcnNjb3JlLWRhbmdsZSwgbm8tcGFyYW0tcmVhc3NpZ25cclxuXHRcdFx0XHRcdFx0cm93Ll9fc2VsZWN0ZWQgPSBjaGVja2JveEVsZW1lbnQuY2hlY2tlZDtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGNvbnN0IGNoZWNrYm94ZXMgPSB0aGlzLnJlZnMudGFibGUucXVlcnlTZWxlY3RvckFsbChcInRib2R5PnRyPnRkIC5jaGVja2JveFwiKTtcclxuXHJcblx0XHRcdFx0Zm9yIChjb25zdCBjaGVja2JveCBvZiBjaGVja2JveGVzKSB7XHJcblx0XHRcdFx0XHRpZiAoIWNoZWNrYm94LmRpc2FibGVkKSB7XHJcblx0XHRcdFx0XHRcdGNoZWNrYm94LmNoZWNrZWQgPSBjaGVja2JveEVsZW1lbnQuY2hlY2tlZDtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlcnNjb3JlLWRhbmdsZVxyXG5cdFx0XHRcdGNvbnN0IHNlbGVjdGVkSXRlbXMgPSB0aGlzLmdldCgpLmZpZWxkLmRhdGEuZmlsdGVyKHQgPT4gdC5fX3NlbGVjdGVkID09PSB0cnVlKTtcclxuXHRcdFx0XHR0aGlzLnNldCh7IHNlbGVjdGVkSXRlbXNDb3VudDogc2VsZWN0ZWRJdGVtcy5sZW5ndGggfSk7XHJcblx0XHRcdH0sXHJcblx0XHRcdHNvcnREYXRhKGNvbHVtbiwgY29sdW1ucykge1xyXG5cdFx0XHRcdGNvbnN0IHsgcGFyZW50LCBmb3JtLCBmaWVsZCB9ID0gdGhpcy5nZXQoKTtcclxuXHJcblx0XHRcdFx0Y29uc3QgcGFnaW5hdG9ySW5wdXQgPSBmb3JtLmlucHV0cy5maW5kKHQgPT4gdC5tZXRhZGF0YS5pZCA9PT1cclxuXHRcdFx0XHRcdFx0ZmllbGQubWV0YWRhdGEuY3VzdG9tUHJvcGVydGllcy5jdXN0b21pemF0aW9ucy5wYWdpbmF0b3IpO1xyXG5cclxuXHRcdFx0XHRpZiAocGFnaW5hdG9ySW5wdXQgIT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0cGFnaW5hdG9ySW5wdXQudmFsdWUub3JkZXJCeSA9IGNvbHVtbi5jdXN0b21Qcm9wZXJ0aWVzLnNvcnRhYmxlQnk7XHJcblx0XHRcdFx0XHRmb3IgKGNvbnN0IGkgb2YgY29sdW1ucykge1xyXG5cdFx0XHRcdFx0XHRpLmFzY2VuZGluZyA9IGZhbHNlO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdHBhZ2luYXRvcklucHV0LnZhbHVlLmFzY2VuZGluZyA9ICFwYWdpbmF0b3JJbnB1dC52YWx1ZS5hc2NlbmRpbmc7XHJcblx0XHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cclxuXHRcdFx0XHRcdGNvbHVtbi5hc2NlbmRpbmcgPSBwYWdpbmF0b3JJbnB1dC52YWx1ZS5hc2NlbmRpbmc7XHJcblxyXG5cdFx0XHRcdFx0Y29uc3QgcGFyYW1zID0ge307XHJcblx0XHRcdFx0XHRmb3IgKGNvbnN0IGkgb2YgZm9ybS5pbnB1dHMpIHtcclxuXHRcdFx0XHRcdFx0cGFyYW1zW2kubWV0YWRhdGEuaWRdID0gaS52YWx1ZTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGZvcm0uc2V0SW5wdXRGaWVsZHMocGFyYW1zKTtcclxuXHRcdFx0XHRcdHBhcmVudC5zdWJtaXQobnVsbCwgZmFsc2UpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdGRhdGEoKSB7XHJcblx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0YnVsa0FjdGlvbnM6IFtdLFxyXG5cdFx0XHRcdGdldFJvd0Nzc0NsYXNzOiAoKSA9PiBcIlwiLFxyXG5cdFx0XHRcdGRpc2FibGVkOiBmYWxzZVxyXG5cdFx0XHR9O1xyXG5cdFx0fSxcclxuXHRcdGNvbXBvbmVudHM6IHtcclxuXHRcdFx0Rm9ybU91dHB1dCxcclxuXHRcdFx0VG9vbHRpcFxyXG5cdFx0fVxyXG5cdH07XHJcbjwvc2NyaXB0PlxyXG5cclxuPHN0eWxlPlxyXG5cdC5idG4tcm93IHtcclxuXHRcdHRleHQtYWxpZ246IHJpZ2h0O1xyXG5cdH1cclxuXHJcblx0LmNoZWNrYm94IHtcclxuXHRcdGNsaXA6IHVuc2V0O1xyXG5cdFx0Y2xpcC1wYXRoOiB1bnNldDtcclxuXHRcdHBvc2l0aW9uOiB1bnNldDtcclxuXHRcdHdpZHRoOiAxNXB4O1xyXG5cdFx0aGVpZ2h0OiAxNXB4O1xyXG5cdH1cclxuXHJcblx0LnNvcnRhYmxlLWNvbHVtbiB7XHJcblx0XHRjdXJzb3I6IHBvaW50ZXI7XHJcblx0fVxyXG5cclxuXHQuaG9yaXpvbnRhbC1zY3JvbGwge1xyXG5cdFx0b3ZlcmZsb3c6IGhpZGRlbjtcclxuXHRcdG92ZXJmbG93LXg6IGF1dG87XHJcblx0XHRjbGVhcjogYm90aDtcclxuXHRcdHdpZHRoOiAxMDAlO1xyXG5cdH1cclxuXHJcblx0LnRhYmxlIHtcclxuXHRcdG1pbi13aWR0aDogcmVtLWNhbGMoNjQwKTtcclxuXHRcdHRleHQtYWxpZ246IGNlbnRlcjtcclxuXHR9XHJcbjwvc3R5bGU+XHJcbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUF5WEMsUUFBUSxjQUFDLENBQUMsQUFDVCxVQUFVLENBQUUsS0FBSyxBQUNsQixDQUFDLEFBRUQsU0FBUyxjQUFDLENBQUMsQUFDVixJQUFJLENBQUUsS0FBSyxDQUNYLFNBQVMsQ0FBRSxLQUFLLENBQ2hCLFFBQVEsQ0FBRSxLQUFLLENBQ2YsS0FBSyxDQUFFLElBQUksQ0FDWCxNQUFNLENBQUUsSUFBSSxBQUNiLENBQUMsQUFFRCxnQkFBZ0IsY0FBQyxDQUFDLEFBQ2pCLE1BQU0sQ0FBRSxPQUFPLEFBQ2hCLENBQUMsQUFFRCxrQkFBa0IsY0FBQyxDQUFDLEFBQ25CLFFBQVEsQ0FBRSxNQUFNLENBQ2hCLFVBQVUsQ0FBRSxJQUFJLENBQ2hCLEtBQUssQ0FBRSxJQUFJLENBQ1gsS0FBSyxDQUFFLElBQUksQUFDWixDQUFDLEFBRUQsTUFBTSxjQUFDLENBQUMsQUFDUCxTQUFTLENBQUUsU0FBUyxHQUFHLENBQUMsQ0FDeEIsVUFBVSxDQUFFLE1BQU0sQUFDbkIsQ0FBQyJ9 */";
    	append(document.head, style);
    }

    function get_each_context_3$1(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.column = list[i];
    	return child_ctx;
    }

    function change_handler$1(event) {
    	const { component, ctx } = this._svelte;

    	component.selectItem(this, ctx.row);
    }

    function get_each_context_2$2(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.row = list[i];
    	return child_ctx;
    }

    function click_handler_2$1(event) {
    	const { component, ctx } = this._svelte;

    	component.sortData(ctx.column,ctx.columnsOrdered);
    }

    function click_handler_1$1(event) {
    	const { component, ctx } = this._svelte;

    	component.sortData(ctx.column,ctx.columnsOrdered);
    }

    function get_each_context_1$4(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.column = list[i];
    	return child_ctx;
    }

    function click_handler$4(event) {
    	const { component, ctx } = this._svelte;

    	component.runBulkAction(ctx.action);
    }

    function get_each_context$a(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.action = list[i];
    	return child_ctx;
    }

    function create_main_fragment$E(component, ctx) {
    	var if_block_anchor;

    	function select_block_type(ctx) {
    		if (ctx.visible && ctx.field.data != null && ctx.field.data.length > 0) return create_if_block$s;
    		return create_else_block_4$1;
    	}

    	var current_block_type = select_block_type(ctx);
    	var if_block = current_block_type(component, ctx);

    	return {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(changed, ctx);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(component, ctx);
    				if_block.c();
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},

    		d: function destroy$$1(detach) {
    			if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (94:6) {:else}
    function create_else_block_4$1(component, ctx) {
    	var div;

    	return {
    		c: function create() {
    			div = createElement("div");
    			div.textContent = "No data found.";
    			div.className = "alert-nodata";
    			addLoc(div, file$D, 94, 0, 2870);
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);
    		},

    		p: noop,

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(div);
    			}
    		}
    	};
    }

    // (1:0) {#if visible && field.data != null && field.data.length > 0}
    function create_if_block$s(component, ctx) {
    	var div, table, thead, text0, tr, text1, text2, tbody, text3, if_block3_anchor;

    	var if_block0 = (ctx.bulkActions.length > 0) && create_if_block_9$2(component, ctx);

    	var if_block1 = (ctx.bulkActions.length > 0) && create_if_block_8$2(component, ctx);

    	var each_value_1 = ctx.columnsOrdered;

    	var each_blocks = [];

    	for (var i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_2$2(component, get_each_context_1$4(ctx, each_value_1, i));
    	}

    	var if_block2 = (ctx.map != null) && create_if_block_2$8(component, ctx);

    	var if_block3 = (ctx.bulkActions.length > 0) && create_if_block_1$g(component, ctx);

    	return {
    		c: function create() {
    			div = createElement("div");
    			table = createElement("table");
    			thead = createElement("thead");
    			if (if_block0) if_block0.c();
    			text0 = createText("\r\n\t\t\t");
    			tr = createElement("tr");
    			if (if_block1) if_block1.c();
    			text1 = createText(" ");

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			text2 = createText("\r\n\t\t");
    			tbody = createElement("tbody");
    			if (if_block2) if_block2.c();
    			text3 = createText("\r\n\r\n");
    			if (if_block3) if_block3.c();
    			if_block3_anchor = createComment();
    			addLoc(tr, file$D, 17, 3, 645);
    			addLoc(thead, file$D, 3, 2, 131);
    			addLoc(tbody, file$D, 51, 2, 1653);
    			table.className = "table svelte-bip1ia";
    			addLoc(table, file$D, 2, 1, 96);
    			div.className = "horizontal-scroll svelte-bip1ia";
    			addLoc(div, file$D, 1, 0, 62);
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);
    			append(div, table);
    			append(table, thead);
    			if (if_block0) if_block0.m(thead, null);
    			append(thead, text0);
    			append(thead, tr);
    			if (if_block1) if_block1.m(tr, null);
    			append(tr, text1);

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tr, null);
    			}

    			append(table, text2);
    			append(table, tbody);
    			if (if_block2) if_block2.m(tbody, null);
    			component.refs.table = table;
    			insert(target, text3, anchor);
    			if (if_block3) if_block3.m(target, anchor);
    			insert(target, if_block3_anchor, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (ctx.bulkActions.length > 0) {
    				if (if_block0) {
    					if_block0.p(changed, ctx);
    				} else {
    					if_block0 = create_if_block_9$2(component, ctx);
    					if_block0.c();
    					if_block0.m(thead, text0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (ctx.bulkActions.length > 0) {
    				if (!if_block1) {
    					if_block1 = create_if_block_8$2(component, ctx);
    					if_block1.c();
    					if_block1.m(tr, text1);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (changed.columnsOrdered) {
    				each_value_1 = ctx.columnsOrdered;

    				for (var i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$4(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    					} else {
    						each_blocks[i] = create_each_block_2$2(component, child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tr, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}
    				each_blocks.length = each_value_1.length;
    			}

    			if (ctx.map != null) {
    				if (if_block2) {
    					if_block2.p(changed, ctx);
    				} else {
    					if_block2 = create_if_block_2$8(component, ctx);
    					if_block2.c();
    					if_block2.m(tbody, null);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}

    			if (ctx.bulkActions.length > 0) {
    				if (if_block3) {
    					if_block3.p(changed, ctx);
    				} else {
    					if_block3 = create_if_block_1$g(component, ctx);
    					if_block3.c();
    					if_block3.m(if_block3_anchor.parentNode, if_block3_anchor);
    				}
    			} else if (if_block3) {
    				if_block3.d(1);
    				if_block3 = null;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(div);
    			}

    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();

    			destroyEach(each_blocks, detach);

    			if (if_block2) if_block2.d();
    			if (component.refs.table === table) component.refs.table = null;
    			if (detach) {
    				detachNode(text3);
    			}

    			if (if_block3) if_block3.d(detach);
    			if (detach) {
    				detachNode(if_block3_anchor);
    			}
    		}
    	};
    }

    // (5:3) {#if bulkActions.length > 0 }
    function create_if_block_9$2(component, ctx) {
    	var tr, td, td_colspan_value;

    	var each_value = ctx.bulkActions;

    	var each_blocks = [];

    	for (var i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block_3$1(component, get_each_context$a(ctx, each_value, i));
    	}

    	return {
    		c: function create() {
    			tr = createElement("tr");
    			td = createElement("td");

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}
    			td.colSpan = td_colspan_value = ctx.columnsOrdered.length + 1;
    			td.className = "btn-row svelte-bip1ia";
    			addLoc(td, file$D, 6, 4, 187);
    			addLoc(tr, file$D, 5, 3, 177);
    		},

    		m: function mount(target, anchor) {
    			insert(target, tr, anchor);
    			append(tr, td);

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(td, null);
    			}
    		},

    		p: function update(changed, ctx) {
    			if (changed.selectedItemsCount || changed.disabled || changed.bulkActions) {
    				each_value = ctx.bulkActions;

    				for (var i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$a(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    					} else {
    						each_blocks[i] = create_each_block_3$1(component, child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(td, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}
    				each_blocks.length = each_value.length;
    			}

    			if ((changed.columnsOrdered) && td_colspan_value !== (td_colspan_value = ctx.columnsOrdered.length + 1)) {
    				td.colSpan = td_colspan_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(tr);
    			}

    			destroyEach(each_blocks, detach);
    		}
    	};
    }

    // (12:5) {:else}
    function create_else_block_3$1(component, ctx) {
    	var button, text_value = ctx.action.label, text;

    	return {
    		c: function create() {
    			button = createElement("button");
    			text = createText(text_value);
    			button.className = "btn btn-default";
    			button.disabled = true;
    			addLoc(button, file$D, 12, 5, 525);
    		},

    		m: function mount(target, anchor) {
    			insert(target, button, anchor);
    			append(button, text);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.bulkActions) && text_value !== (text_value = ctx.action.label)) {
    				setData(text, text_value);
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(button);
    			}
    		}
    	};
    }

    // (8:35) {#if selectedItemsCount > 0}
    function create_if_block_10$2(component, ctx) {
    	var button, text0_value = ctx.action.label, text0, text1, small, text2, text3, text4;

    	return {
    		c: function create() {
    			button = createElement("button");
    			text0 = createText(text0_value);
    			text1 = createText(" ");
    			small = createElement("small");
    			text2 = createText("(");
    			text3 = createText(ctx.selectedItemsCount);
    			text4 = createText(")");
    			addLoc(small, file$D, 9, 21, 451);

    			button._svelte = { component, ctx };

    			addListener(button, "click", click_handler$4);
    			button.disabled = ctx.disabled;
    			setStyle(button, "direction", "rtl");
    			button.className = "btn btn-default";
    			addLoc(button, file$D, 8, 5, 317);
    		},

    		m: function mount(target, anchor) {
    			insert(target, button, anchor);
    			append(button, text0);
    			append(button, text1);
    			append(button, small);
    			append(small, text2);
    			append(small, text3);
    			append(small, text4);
    		},

    		p: function update(changed, _ctx) {
    			ctx = _ctx;
    			if ((changed.bulkActions) && text0_value !== (text0_value = ctx.action.label)) {
    				setData(text0, text0_value);
    			}

    			if (changed.selectedItemsCount) {
    				setData(text3, ctx.selectedItemsCount);
    			}

    			button._svelte.ctx = ctx;
    			if (changed.disabled) {
    				button.disabled = ctx.disabled;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(button);
    			}

    			removeListener(button, "click", click_handler$4);
    		}
    	};
    }

    // (8:5) {#each bulkActions as action}
    function create_each_block_3$1(component, ctx) {
    	var if_block_anchor;

    	function select_block_type_1(ctx) {
    		if (ctx.selectedItemsCount > 0) return create_if_block_10$2;
    		return create_else_block_3$1;
    	}

    	var current_block_type = select_block_type_1(ctx);
    	var if_block = current_block_type(component, ctx);

    	return {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
    				if_block.p(changed, ctx);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(component, ctx);
    				if_block.c();
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},

    		d: function destroy$$1(detach) {
    			if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (19:4) {#if bulkActions.length > 0}
    function create_if_block_8$2(component, ctx) {
    	var th, input;

    	function change_handler(event) {
    		component.selectAllItems(this);
    	}

    	return {
    		c: function create() {
    			th = createElement("th");
    			input = createElement("input");
    			addListener(input, "change", change_handler);
    			setAttribute(input, "type", "checkbox");
    			input.className = "checkbox svelte-bip1ia";
    			addLoc(input, file$D, 20, 5, 700);
    			addLoc(th, file$D, 19, 4, 689);
    		},

    		m: function mount(target, anchor) {
    			insert(target, th, anchor);
    			append(th, input);
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(th);
    			}

    			removeListener(input, "change", change_handler);
    		}
    	};
    }

    // (37:10) {:else}
    function create_else_block_1$4(component, ctx) {
    	var th;

    	function select_block_type_4(ctx) {
    		if (ctx.column.customProperties != null &&
    					ctx.column.customProperties["documentation"] != null) return create_if_block_7$2;
    		return create_else_block_2$2;
    	}

    	var current_block_type = select_block_type_4(ctx);
    	var if_block = current_block_type(component, ctx);

    	return {
    		c: function create() {
    			th = createElement("th");
    			if_block.c();
    			addLoc(th, file$D, 37, 4, 1295);
    		},

    		m: function mount(target, anchor) {
    			insert(target, th, anchor);
    			if_block.m(th, null);
    		},

    		p: function update(changed, ctx) {
    			if (current_block_type === (current_block_type = select_block_type_4(ctx)) && if_block) {
    				if_block.p(changed, ctx);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(component, ctx);
    				if_block.c();
    				if_block.m(th, null);
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(th);
    			}

    			if_block.d();
    		}
    	};
    }

    // (27:43) {#if column.customProperties !=      null && column.customProperties["sortableBy"] != null}
    function create_if_block_5$2(component, ctx) {
    	var if_block_anchor;

    	function select_block_type_3(ctx) {
    		if (ctx.column.ascending) return create_if_block_6$2;
    		return create_else_block$b;
    	}

    	var current_block_type = select_block_type_3(ctx);
    	var if_block = current_block_type(component, ctx);

    	return {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (current_block_type === (current_block_type = select_block_type_3(ctx)) && if_block) {
    				if_block.p(changed, ctx);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(component, ctx);
    				if_block.c();
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},

    		d: function destroy$$1(detach) {
    			if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (47:5) {:else}
    function create_else_block_2$2(component, ctx) {
    	var text_value = ctx.column.label, text;

    	return {
    		c: function create() {
    			text = createText(text_value);
    		},

    		m: function mount(target, anchor) {
    			insert(target, text, anchor);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.columnsOrdered) && text_value !== (text_value = ctx.column.label)) {
    				setData(text, text_value);
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(text);
    			}
    		}
    	};
    }

    // (39:5) {#if column.customProperties != null &&       column.customProperties["documentation"] != null}
    function create_if_block_7$2(component, ctx) {
    	var div, text0_value = ctx.column.label, text0, text1;

    	var tooltip_initial_data = { data: ctx.column.customProperties.documentation[0] };
    	var tooltip = new SvelteComponent$4({
    		root: component.root,
    		store: component.store,
    		data: tooltip_initial_data
    	});

    	return {
    		c: function create() {
    			div = createElement("div");
    			text0 = createText(text0_value);
    			text1 = createText("\r\n\t\t\t\t\t\t");
    			tooltip._fragment.c();
    			div.className = "help-tooltip";
    			addLoc(div, file$D, 40, 5, 1408);
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);
    			append(div, text0);
    			append(div, text1);
    			tooltip._mount(div, null);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.columnsOrdered) && text0_value !== (text0_value = ctx.column.label)) {
    				setData(text0, text0_value);
    			}

    			var tooltip_changes = {};
    			if (changed.columnsOrdered) tooltip_changes.data = ctx.column.customProperties.documentation[0];
    			tooltip._set(tooltip_changes);
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(div);
    			}

    			tooltip.destroy();
    		}
    	};
    }

    // (33:4) {:else}
    function create_else_block$b(component, ctx) {
    	var th, text0_value = ctx.column.label, text0, text1, i;

    	return {
    		c: function create() {
    			th = createElement("th");
    			text0 = createText(text0_value);
    			text1 = createText(" ");
    			i = createElement("i");
    			i.className = "fa fa-sort-up";
    			addLoc(i, file$D, 34, 20, 1230);

    			th._svelte = { component, ctx };

    			addListener(th, "click", click_handler_2$1);
    			th.className = "sortable-column svelte-bip1ia";
    			addLoc(th, file$D, 33, 4, 1137);
    		},

    		m: function mount(target, anchor) {
    			insert(target, th, anchor);
    			append(th, text0);
    			append(th, text1);
    			append(th, i);
    		},

    		p: function update(changed, _ctx) {
    			ctx = _ctx;
    			if ((changed.columnsOrdered) && text0_value !== (text0_value = ctx.column.label)) {
    				setData(text0, text0_value);
    			}

    			th._svelte.ctx = ctx;
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(th);
    			}

    			removeListener(th, "click", click_handler_2$1);
    		}
    	};
    }

    // (28:59) {#if      column.ascending}
    function create_if_block_6$2(component, ctx) {
    	var th, text0_value = ctx.column.label, text0, text1, i;

    	return {
    		c: function create() {
    			th = createElement("th");
    			text0 = createText(text0_value);
    			text1 = createText(" ");
    			i = createElement("i");
    			i.className = "fa fa-sort-down";
    			addLoc(i, file$D, 30, 20, 1076);

    			th._svelte = { component, ctx };

    			addListener(th, "click", click_handler_1$1);
    			th.className = "sortable-column svelte-bip1ia";
    			addLoc(th, file$D, 29, 4, 983);
    		},

    		m: function mount(target, anchor) {
    			insert(target, th, anchor);
    			append(th, text0);
    			append(th, text1);
    			append(th, i);
    		},

    		p: function update(changed, _ctx) {
    			ctx = _ctx;
    			if ((changed.columnsOrdered) && text0_value !== (text0_value = ctx.column.label)) {
    				setData(text0, text0_value);
    			}

    			th._svelte.ctx = ctx;
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(th);
    			}

    			removeListener(th, "click", click_handler_1$1);
    		}
    	};
    }

    // (27:10) {#each columnsOrdered as column}
    function create_each_block_2$2(component, ctx) {
    	var if_block_anchor;

    	function select_block_type_2(ctx) {
    		if (ctx.column.customProperties !=
    				null && ctx.column.customProperties["sortableBy"] != null) return create_if_block_5$2;
    		return create_else_block_1$4;
    	}

    	var current_block_type = select_block_type_2(ctx);
    	var if_block = current_block_type(component, ctx);

    	return {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (current_block_type === (current_block_type = select_block_type_2(ctx)) && if_block) {
    				if_block.p(changed, ctx);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(component, ctx);
    				if_block.c();
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},

    		d: function destroy$$1(detach) {
    			if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (53:3) {#if map != null}
    function create_if_block_2$8(component, ctx) {
    	var each_anchor;

    	var each_value_2 = ctx.field.data;

    	var each_blocks = [];

    	for (var i = 0; i < each_value_2.length; i += 1) {
    		each_blocks[i] = create_each_block$a(component, get_each_context_2$2(ctx, each_value_2, i));
    	}

    	return {
    		c: function create() {
    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert(target, each_anchor, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (changed.getRowCssClass || changed.field || changed.columnsOrdered || changed.getField || changed.app || changed.form || changed.parent || changed.bulkActions) {
    				each_value_2 = ctx.field.data;

    				for (var i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2$2(ctx, each_value_2, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    					} else {
    						each_blocks[i] = create_each_block$a(component, child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_anchor.parentNode, each_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}
    				each_blocks.length = each_value_2.length;
    			}
    		},

    		d: function destroy$$1(detach) {
    			destroyEach(each_blocks, detach);

    			if (detach) {
    				detachNode(each_anchor);
    			}
    		}
    	};
    }

    // (55:4) {#if bulkActions.length > 0}
    function create_if_block_4$3(component, ctx) {
    	var td, div, input, input_disabled_value;

    	return {
    		c: function create() {
    			td = createElement("td");
    			div = createElement("div");
    			input = createElement("input");
    			input._svelte = { component, ctx };

    			addListener(input, "change", change_handler$1);
    			input.disabled = input_disabled_value = ctx.row.actions == null || ctx.row.actions.actions == null || ctx.row.actions.actions.filter(t => ctx.bulkActions.some(r => r.formId === t.form)).length === 0;
    			setAttribute(input, "type", "checkbox");
    			input.className = "checkbox svelte-bip1ia";
    			addLoc(input, file$D, 57, 6, 1841);
    			div.className = "form-group form-check";
    			addLoc(div, file$D, 56, 5, 1798);
    			addLoc(td, file$D, 55, 4, 1787);
    		},

    		m: function mount(target, anchor) {
    			insert(target, td, anchor);
    			append(td, div);
    			append(div, input);
    		},

    		p: function update(changed, _ctx) {
    			ctx = _ctx;
    			input._svelte.ctx = ctx;
    			if ((changed.field || changed.bulkActions) && input_disabled_value !== (input_disabled_value = ctx.row.actions == null || ctx.row.actions.actions == null || ctx.row.actions.actions.filter(t => ctx.bulkActions.some(r => r.formId === t.form)).length === 0)) {
    				input.disabled = input_disabled_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(td);
    			}

    			removeListener(input, "change", change_handler$1);
    		}
    	};
    }

    // (68:5) {#if !(getField(row, column).metadata.getCustomProperty("hideIfNull")       === true && getField(row, column).data === null)}
    function create_if_block_3$6(component, ctx) {

    	var formoutput_initial_data = {
    	 	field: ctx.getField(ctx.row, ctx.column),
    	 	app: ctx.app,
    	 	form: ctx.form,
    	 	parent: ctx.parent,
    	 	showLabel: "false"
    	 };
    	var formoutput = new SvelteComponent$6({
    		root: component.root,
    		store: component.store,
    		data: formoutput_initial_data
    	});

    	return {
    		c: function create() {
    			formoutput._fragment.c();
    		},

    		m: function mount(target, anchor) {
    			formoutput._mount(target, anchor);
    		},

    		p: function update(changed, ctx) {
    			var formoutput_changes = {};
    			if (changed.getField || changed.field || changed.columnsOrdered) formoutput_changes.field = ctx.getField(ctx.row, ctx.column);
    			if (changed.app) formoutput_changes.app = ctx.app;
    			if (changed.form) formoutput_changes.form = ctx.form;
    			if (changed.parent) formoutput_changes.parent = ctx.parent;
    			formoutput._set(formoutput_changes);
    		},

    		d: function destroy$$1(detach) {
    			formoutput.destroy(detach);
    		}
    	};
    }

    // (66:10) {#each columnsOrdered as column}
    function create_each_block_1$4(component, ctx) {
    	var td;

    	var if_block = (!(ctx.getField(ctx.row, ctx.column).metadata.getCustomProperty("hideIfNull")
    					=== true && ctx.getField(ctx.row, ctx.column).data === null)) && create_if_block_3$6(component, ctx);

    	return {
    		c: function create() {
    			td = createElement("td");
    			if (if_block) if_block.c();
    			addLoc(td, file$D, 66, 4, 2186);
    		},

    		m: function mount(target, anchor) {
    			insert(target, td, anchor);
    			if (if_block) if_block.m(td, null);
    		},

    		p: function update(changed, ctx) {
    			if (!(ctx.getField(ctx.row, ctx.column).metadata.getCustomProperty("hideIfNull")
    					=== true && ctx.getField(ctx.row, ctx.column).data === null)) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block_3$6(component, ctx);
    					if_block.c();
    					if_block.m(td, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(td);
    			}

    			if (if_block) if_block.d();
    		}
    	};
    }

    // (53:21) {#each field.data as row}
    function create_each_block$a(component, ctx) {
    	var tr, text, tr_class_value;

    	var if_block = (ctx.bulkActions.length > 0) && create_if_block_4$3(component, ctx);

    	var each_value_3 = ctx.columnsOrdered;

    	var each_blocks = [];

    	for (var i = 0; i < each_value_3.length; i += 1) {
    		each_blocks[i] = create_each_block_1$4(component, get_each_context_3$1(ctx, each_value_3, i));
    	}

    	return {
    		c: function create() {
    			tr = createElement("tr");
    			if (if_block) if_block.c();
    			text = createText(" ");

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}
    			tr.className = tr_class_value = "" + ctx.getRowCssClass(ctx.row) + " svelte-bip1ia";
    			addLoc(tr, file$D, 53, 3, 1713);
    		},

    		m: function mount(target, anchor) {
    			insert(target, tr, anchor);
    			if (if_block) if_block.m(tr, null);
    			append(tr, text);

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tr, null);
    			}
    		},

    		p: function update(changed, ctx) {
    			if (ctx.bulkActions.length > 0) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block_4$3(component, ctx);
    					if_block.c();
    					if_block.m(tr, text);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (changed.getField || changed.field || changed.columnsOrdered || changed.app || changed.form || changed.parent) {
    				each_value_3 = ctx.columnsOrdered;

    				for (var i = 0; i < each_value_3.length; i += 1) {
    					const child_ctx = get_each_context_3$1(ctx, each_value_3, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    					} else {
    						each_blocks[i] = create_each_block_1$4(component, child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tr, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}
    				each_blocks.length = each_value_3.length;
    			}

    			if ((changed.getRowCssClass || changed.field) && tr_class_value !== (tr_class_value = "" + ctx.getRowCssClass(ctx.row) + " svelte-bip1ia")) {
    				tr.className = tr_class_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(tr);
    			}

    			if (if_block) if_block.d();

    			destroyEach(each_blocks, detach);
    		}
    	};
    }

    // (86:0) {#if bulkActions.length > 0}
    function create_if_block_1$g(component, ctx) {
    	var input, text0, div2, div1, label, text1, div0;

    	function input_change_handler() {
    		component.set({ isBulkActionModalOpen: input.checked });
    	}

    	function click_handler_3(event) {
    		component.closeBulkActionModal(null);
    	}

    	return {
    		c: function create() {
    			input = createElement("input");
    			text0 = createText("\r\n");
    			div2 = createElement("div");
    			div1 = createElement("div");
    			label = createElement("label");
    			text1 = createText("\r\n\t\t");
    			div0 = createElement("div");
    			addListener(input, "change", input_change_handler);
    			setAttribute(input, "type", "checkbox");
    			input.className = "hidden";
    			addLoc(input, file$D, 86, 0, 2607);
    			addListener(label, "click", click_handler_3);
    			label.className = "close";
    			addLoc(label, file$D, 89, 2, 2730);
    			addLoc(div0, file$D, 90, 2, 2801);
    			div1.className = "card";
    			addLoc(div1, file$D, 88, 1, 2708);
    			div2.className = "modal";
    			addLoc(div2, file$D, 87, 0, 2686);
    		},

    		m: function mount(target, anchor) {
    			insert(target, input, anchor);

    			input.checked = ctx.isBulkActionModalOpen;

    			insert(target, text0, anchor);
    			insert(target, div2, anchor);
    			append(div2, div1);
    			append(div1, label);
    			append(div1, text1);
    			append(div1, div0);
    			component.refs.bulkActionContainer = div0;
    		},

    		p: function update(changed, ctx) {
    			if (changed.isBulkActionModalOpen) input.checked = ctx.isBulkActionModalOpen;
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(input);
    			}

    			removeListener(input, "change", input_change_handler);
    			if (detach) {
    				detachNode(text0);
    				detachNode(div2);
    			}

    			removeListener(label, "click", click_handler_3);
    			if (component.refs.bulkActionContainer === div0) component.refs.bulkActionContainer = null;
    		}
    	};
    }

    function SvelteComponent$E(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) {
    		throw new Error("'target' is a required option");
    	}

    	init(this, options);
    	this.refs = {};
    	this._state = assign(data$d(), options.data);

    	this._recompute({ field: 1 }, this._state);
    	if (!('field' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'field'");
    	if (!('visible' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'visible'");
    	if (!('bulkActions' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'bulkActions'");

    	if (!('selectedItemsCount' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'selectedItemsCount'");
    	if (!('disabled' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'disabled'");
    	if (!('map' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'map'");
    	if (!('getRowCssClass' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'getRowCssClass'");
    	if (!('getField' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'getField'");
    	if (!('app' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'app'");
    	if (!('form' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'form'");
    	if (!('parent' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'parent'");
    	if (!('isBulkActionModalOpen' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'isBulkActionModalOpen'");
    	this._intro = true;

    	if (!document.getElementById("svelte-bip1ia-style")) add_css$l();

    	this._fragment = create_main_fragment$E(this, this._state);

    	this.root._oncreate.push(() => {
    		oncreate$o.call(this);
    		this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
    	});

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);

    		flush(this);
    	}
    }

    assign(SvelteComponent$E.prototype, protoDev);
    assign(SvelteComponent$E.prototype, methods$c);

    SvelteComponent$E.prototype._checkReadOnly = function _checkReadOnly(newState) {
    	if ('columnsOrdered' in newState && !this._updatingReadonlyProperty) throw new Error("<SvelteComponent>: Cannot set read-only property 'columnsOrdered'");
    };

    SvelteComponent$E.prototype._recompute = function _recompute(changed, state) {
    	if (changed.field) {
    		if (this._differs(state.columnsOrdered, (state.columnsOrdered = columnsOrdered$1(state)))) changed.columnsOrdered = true;
    	}
    };

    /* src\core\ui\outputs\Tabstrip.html generated by Svelte v2.16.1 */

    function getCssClass(tab, tabstrip) {
    	return tab.form === tabstrip.currentTab ?
    		"active" :
    		"";
    }
    const file$E = "src\\core\\ui\\outputs\\Tabstrip.html";

    function get_each_context$b(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.tab = list[i];
    	return child_ctx;
    }

    function create_main_fragment$F(component, ctx) {
    	var div;

    	var each_value = ctx.field.data.tabs;

    	var each_blocks = [];

    	for (var i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$b(component, get_each_context$b(ctx, each_value, i));
    	}

    	return {
    		c: function create() {
    			div = createElement("div");

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}
    			div.className = "tabstrip";
    			addLoc(div, file$E, 0, 0, 0);
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}
    		},

    		p: function update(changed, ctx) {
    			if (changed.app || changed.field) {
    				each_value = ctx.field.data.tabs;

    				for (var i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$b(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    					} else {
    						each_blocks[i] = create_each_block$b(component, child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}
    				each_blocks.length = each_value.length;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(div);
    			}

    			destroyEach(each_blocks, detach);
    		}
    	};
    }

    // (2:1) {#each field.data.tabs as tab}
    function create_each_block$b(component, ctx) {
    	var div, a, text0_value = ctx.tab.label, text0, a_href_value, a_class_value, text1;

    	return {
    		c: function create() {
    			div = createElement("div");
    			a = createElement("a");
    			text0 = createText(text0_value);
    			text1 = createText("\r\n\t");
    			a.href = a_href_value = ctx.app.makeUrl(ctx.tab.form, ctx.tab.inputFieldValues);
    			a.className = a_class_value = getCssClass(ctx.tab, ctx.field.data);
    			addLoc(a, file$E, 3, 2, 67);
    			addLoc(div, file$E, 2, 1, 58);
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);
    			append(div, a);
    			append(a, text0);
    			append(div, text1);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.field) && text0_value !== (text0_value = ctx.tab.label)) {
    				setData(text0, text0_value);
    			}

    			if ((changed.app || changed.field) && a_href_value !== (a_href_value = ctx.app.makeUrl(ctx.tab.form, ctx.tab.inputFieldValues))) {
    				a.href = a_href_value;
    			}

    			if ((changed.field) && a_class_value !== (a_class_value = getCssClass(ctx.tab, ctx.field.data))) {
    				a.className = a_class_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(div);
    			}
    		}
    	};
    }

    function SvelteComponent$F(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) {
    		throw new Error("'target' is a required option");
    	}

    	init(this, options);
    	this._state = assign({}, options.data);
    	if (!('field' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'field'");
    	if (!('app' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'app'");
    	this._intro = true;

    	this._fragment = create_main_fragment$F(this, this._state);

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);
    	}
    }

    assign(SvelteComponent$F.prototype, protoDev);

    SvelteComponent$F.prototype._checkReadOnly = function _checkReadOnly(newState) {
    };

    /* src\core\ui\outputs\Text.html generated by Svelte v2.16.1 */

    function cssClass({ field, form }) {
    	let cssClass = "";
    	const dynamicCssClass = field.metadata.getCustomProperty("dynamicCssClass");
    	if (dynamicCssClass != null) {
    		cssClass = dynamicCssClass.cssClassPrefix;
    		if (dynamicCssClass.outputFieldAsSuffix != null) {
    			const suffixOutputField = form.outputs
    				.find(t => t.metadata.id === dynamicCssClass.outputFieldAsSuffix);

    			cssClass += suffixOutputField.data;
    		}
    	}
    	return cssClass;
    }

    function BooleanChecker({ field }) {
    	if (typeof (field.data) === "boolean") {
    		return field.data ? "Yes" : "No";
    	}

    	return field.data;
    }

    const file$F = "src\\core\\ui\\outputs\\Text.html";

    function create_main_fragment$G(component, ctx) {
    	var if_block_anchor;

    	var if_block = (ctx.field.data != null) && create_if_block$t(component, ctx);

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (ctx.field.data != null) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block$t(component, ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (if_block) if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (1:0) {#if field.data != null }
    function create_if_block$t(component, ctx) {
    	var span, text;

    	return {
    		c: function create() {
    			span = createElement("span");
    			text = createText(ctx.BooleanChecker);
    			span.className = ctx.cssClass;
    			addLoc(span, file$F, 1, 0, 27);
    		},

    		m: function mount(target, anchor) {
    			insert(target, span, anchor);
    			append(span, text);
    		},

    		p: function update(changed, ctx) {
    			if (changed.BooleanChecker) {
    				setData(text, ctx.BooleanChecker);
    			}

    			if (changed.cssClass) {
    				span.className = ctx.cssClass;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(span);
    			}
    		}
    	};
    }

    function SvelteComponent$G(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) {
    		throw new Error("'target' is a required option");
    	}

    	init(this, options);
    	this._state = assign({}, options.data);

    	this._recompute({ field: 1, form: 1 }, this._state);
    	if (!('field' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'field'");
    	if (!('form' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'form'");
    	this._intro = true;

    	this._fragment = create_main_fragment$G(this, this._state);

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);
    	}
    }

    assign(SvelteComponent$G.prototype, protoDev);

    SvelteComponent$G.prototype._checkReadOnly = function _checkReadOnly(newState) {
    	if ('cssClass' in newState && !this._updatingReadonlyProperty) throw new Error("<SvelteComponent>: Cannot set read-only property 'cssClass'");
    	if ('BooleanChecker' in newState && !this._updatingReadonlyProperty) throw new Error("<SvelteComponent>: Cannot set read-only property 'BooleanChecker'");
    };

    SvelteComponent$G.prototype._recompute = function _recompute(changed, state) {
    	if (changed.field || changed.form) {
    		if (this._differs(state.cssClass, (state.cssClass = cssClass(state)))) changed.cssClass = true;
    	}

    	if (changed.field) {
    		if (this._differs(state.BooleanChecker, (state.BooleanChecker = BooleanChecker(state)))) changed.BooleanChecker = true;
    	}
    };

    /* src\core\ui\outputs\TextValue.html generated by Svelte v2.16.1 */

    function create_main_fragment$H(component, ctx) {
    	var text_value = ctx.field.data.value, text;

    	return {
    		c: function create() {
    			text = createText(text_value);
    		},

    		m: function mount(target, anchor) {
    			insert(target, text, anchor);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.field) && text_value !== (text_value = ctx.field.data.value)) {
    				setData(text, text_value);
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(text);
    			}
    		}
    	};
    }

    function SvelteComponent$H(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) {
    		throw new Error("'target' is a required option");
    	}

    	init(this, options);
    	this._state = assign({}, options.data);
    	if (!('field' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'field'");
    	this._intro = true;

    	this._fragment = create_main_fragment$H(this, this._state);

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);
    	}
    }

    assign(SvelteComponent$H.prototype, protoDev);

    SvelteComponent$H.prototype._checkReadOnly = function _checkReadOnly(newState) {
    };

    /* src\core\ui\outputs\TextValueMultiline.html generated by Svelte v2.16.1 */

    const file$H = "src\\core\\ui\\outputs\\TextValueMultiline.html";

    function add_css$m() {
    	var style = createElement("style");
    	style.id = 'svelte-1gkz7pl-style';
    	style.textContent = "div.svelte-1gkz7pl{white-space:pre;margin:0 0 5px 0;padding:5px 15px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGV4dFZhbHVlTXVsdGlsaW5lLmh0bWwiLCJzb3VyY2VzIjpbIlRleHRWYWx1ZU11bHRpbGluZS5odG1sIl0sInNvdXJjZXNDb250ZW50IjpbInsjaWYgKGZpZWxkLmRhdGEgfHwge30pLnZhbHVlICE9IG51bGx9XHJcbjxkaXY+e2ZpZWxkLmRhdGEudmFsdWV9PC9kaXY+XHJcbnsvaWZ9XHJcblxyXG48c3R5bGU+XHJcblx0ZGl2IHtcclxuXHRcdHdoaXRlLXNwYWNlOiBwcmU7XHJcblx0XHRtYXJnaW46IDAgMCA1cHggMDtcclxuXHRcdHBhZGRpbmc6IDVweCAxNXB4O1xyXG5cdH1cclxuPC9zdHlsZT5cclxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUtDLEdBQUcsZUFBQyxDQUFDLEFBQ0osV0FBVyxDQUFFLEdBQUcsQ0FDaEIsTUFBTSxDQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FDakIsT0FBTyxDQUFFLEdBQUcsQ0FBQyxJQUFJLEFBQ2xCLENBQUMifQ== */";
    	append(document.head, style);
    }

    function create_main_fragment$I(component, ctx) {
    	var if_block_anchor;

    	var if_block = ((ctx.field.data || {}).value != null) && create_if_block$u(component, ctx);

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    		},

    		p: function update(changed, ctx) {
    			if ((ctx.field.data || {}).value != null) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block$u(component, ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (if_block) if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (1:0) {#if (field.data || {}).value != null}
    function create_if_block$u(component, ctx) {
    	var div, text_value = ctx.field.data.value, text;

    	return {
    		c: function create() {
    			div = createElement("div");
    			text = createText(text_value);
    			div.className = "svelte-1gkz7pl";
    			addLoc(div, file$H, 1, 0, 40);
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);
    			append(div, text);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.field) && text_value !== (text_value = ctx.field.data.value)) {
    				setData(text, text_value);
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(div);
    			}
    		}
    	};
    }

    function SvelteComponent$I(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) {
    		throw new Error("'target' is a required option");
    	}

    	init(this, options);
    	this._state = assign({}, options.data);
    	if (!('field' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'field'");
    	this._intro = true;

    	if (!document.getElementById("svelte-1gkz7pl-style")) add_css$m();

    	this._fragment = create_main_fragment$I(this, this._state);

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);
    	}
    }

    assign(SvelteComponent$I.prototype, protoDev);

    SvelteComponent$I.prototype._checkReadOnly = function _checkReadOnly(newState) {
    };

    var FormLogToConsole = /** @class */ (function (_super) {
        __extends(FormLogToConsole, _super);
        function FormLogToConsole() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        FormLogToConsole.prototype.run = function (form, eventHandlerMetadata, args) {
            // tslint:disable-next-line:no-console
            console.log("[" + eventHandlerMetadata.runAt + "] form event handler '" + eventHandlerMetadata.id + "' from '" + form.metadata.id + "'");
            return Promise.resolve();
        };
        return FormLogToConsole;
    }(FormEventHandler));

    /**
     * Reloads form after an action.
     */
    var ReloadFormAfterAction = /** @class */ (function (_super) {
        __extends(ReloadFormAfterAction, _super);
        function ReloadFormAfterAction() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ReloadFormAfterAction.prototype.run = function (form, eventHandlerMetadata, args) {
            var isTopLevelForm = args.form.get("parent") == null;
            if (isTopLevelForm && eventHandlerMetadata.customProperties.formId === args.actionFormId) {
                args.form.submit(args.app, form, null, false);
            }
            return Promise.resolve();
        };
        return ReloadFormAfterAction;
    }(FormEventHandler));

    var BindToOutput = /** @class */ (function (_super) {
        __extends(BindToOutput, _super);
        function BindToOutput() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        BindToOutput.prototype.run = function (input, eventHandler, args) {
            var promises = [];
            var lowercaseInputId = eventHandler.customProperties.outputFieldId.toLowerCase();
            for (var prop in args.response) {
                if (args.response.hasOwnProperty(prop) && prop.toLowerCase() === lowercaseInputId) {
                    var serializedValue = input.serializeValue(args.response[prop]);
                    var promise = input.init(serializedValue);
                    promises.push(promise);
                    break;
                }
            }
            return Promise.all(promises);
        };
        return BindToOutput;
    }(InputFieldEventHandler));

    var InputLogToConsole = /** @class */ (function (_super) {
        __extends(InputLogToConsole, _super);
        function InputLogToConsole() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        InputLogToConsole.prototype.run = function (input, eventHandlerMetadata, args) {
            return input.serialize().then(function (t) {
                // tslint:disable-next-line:no-console
                console.log("[" + eventHandlerMetadata.runAt + "] input event handler '" + eventHandlerMetadata.id + "' from '" + input.metadata.id + "'");
            });
        };
        return InputLogToConsole;
    }(InputFieldEventHandler));

    var DependOn = /** @class */ (function (_super) {
        __extends(DependOn, _super);
        function DependOn() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DependOn.prototype.run = function (input, eventHandlerMetadata, args) {
            var subscribedToField = eventHandlerMetadata.customProperties.field;
            var subscribedToValue = eventHandlerMetadata.customProperties.value;
            var field = args.input.get("field").metadata != null
                ? args.input.get("field")
                : args.input.get("field").field;
            var fieldChanged = field.metadata.id;
            if (subscribedToField === fieldChanged) {
                return input.serialize().then(function (t) {
                    var parentInputController = field;
                    var childWrapper = args.form.getInputComponent(input.metadata.id);
                    if (childWrapper != null) {
                        var childShouldBeVisible = false;
                        if (["typeahead", "dropdown"].indexOf(parentInputController.metadata.type) !== -1) {
                            if (parentInputController.value != null && parentInputController.value.value != null) {
                                if (subscribedToValue === "isNew") {
                                    childShouldBeVisible = isNaN(parentInputController.value.value);
                                }
                                else if (subscribedToValue === "") {
                                    childShouldBeVisible = true;
                                }
                                else {
                                    childShouldBeVisible = parentInputController.value.value.toString() === subscribedToValue ||
                                        parentInputController.value.value.includes(subscribedToValue);
                                }
                            }
                        }
                        else {
                            if (parentInputController.value != null) {
                                if (subscribedToValue === "") {
                                    childShouldBeVisible = true;
                                }
                                else {
                                    childShouldBeVisible = parentInputController.value.toString() === subscribedToValue ||
                                        parentInputController.value.includes(subscribedToValue);
                                }
                                childShouldBeVisible = parentInputController.value != null
                                    && (parentInputController.value.toString() === subscribedToValue ||
                                        parentInputController.value.includes(subscribedToValue));
                            }
                        }
                        childWrapper.show(childShouldBeVisible);
                    }
                });
            }
            return Promise.resolve();
        };
        return DependOn;
    }(InputFieldEventHandler));

    var OutputLogToConsole = /** @class */ (function (_super) {
        __extends(OutputLogToConsole, _super);
        function OutputLogToConsole() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        OutputLogToConsole.prototype.run = function (output, eventHandlerMetadata, args) {
            // tslint:disable-next-line:no-console
            console.log("[" + eventHandlerMetadata.runAt + "] output event handler '" + eventHandlerMetadata.id + "' from '" + output.metadata.id + "'");
            return Promise.resolve();
        };
        return OutputLogToConsole;
    }(OutputFieldEventHandler));

    var alertify$3 = alertify;
    var Growl = /** @class */ (function () {
        function Growl() {
        }
        Growl.prototype.run = function (metadata) {
            alertify$3.notify(metadata.customProperties.message, metadata.customProperties.style, 500);
            return Promise.resolve();
        };
        return Growl;
    }());

    var Redirect = /** @class */ (function () {
        function Redirect() {
        }
        Redirect.prototype.run = function (metadata) {
            window.app.go(metadata.customProperties.form, metadata.customProperties.inputFieldValues);
            return Promise.resolve();
        };
        return Redirect;
    }());

    var controlRegister = new ControlRegister();
    controlRegister.registerInputFieldControl("text", SvelteComponent$l, StringInputController);
    controlRegister.registerInputFieldControl("email", SvelteComponent$d, EmailInputController);
    controlRegister.registerInputFieldControl("datetime", SvelteComponent$a, DateInputController);
    controlRegister.registerInputFieldControl("date-range", SvelteComponent$b, DateRangeInputController);
    controlRegister.registerInputFieldControl("number", SvelteComponent$g, NumberInputController);
    controlRegister.registerInputFieldControl("onumber", SvelteComponent$i, NumberObjectInputController);
    controlRegister.registerInputFieldControl("dropdown", SvelteComponent$c, DropdownInputController);
    controlRegister.registerInputFieldControl("boolean", SvelteComponent$9, BooleanInputController);
    controlRegister.registerInputFieldControl("paginator", null, PaginatorInputController);
    controlRegister.registerInputFieldControl("typeahead", SvelteComponent$f, TypeaheadInputController);
    controlRegister.registerInputFieldControl("my-typeahead", SvelteComponent$f, TypeaheadInputController);
    controlRegister.registerInputFieldControl("multiselect", SvelteComponent$f, MultiSelectInputController);
    controlRegister.registerInputFieldControl("password", SvelteComponent$j, PasswordInputController);
    controlRegister.registerInputFieldControl("textarea", SvelteComponent$m, TextareaInputController, new OutputControlConfiguration(false, true));
    controlRegister.registerInputFieldControl("file-uploader", SvelteComponent$e, FileUploaderController, new OutputControlConfiguration(false, true));
    controlRegister.registerInputFieldControl("number-range", SvelteComponent$h, NumberRangeInputController);
    // controlRegister.registerInputFieldControl("html-editor", HtmlEditor, HtmlEditorInputController, new umf.OutputControlConfiguration(false, true));
    controlRegister.registerInputFieldControl("receipt-list", SvelteComponent$k, ReceiptListInputController);
    controlRegister.registerOutputFieldControl("text", SvelteComponent$G);
    controlRegister.registerOutputFieldControl("number", SvelteComponent$A);
    controlRegister.registerOutputFieldControl("datetime", SvelteComponent$r);
    controlRegister.registerOutputFieldControl("table", SvelteComponent$E, new OutputControlConfiguration(false, true));
    controlRegister.registerOutputFieldControl("formlink", SvelteComponent$v);
    controlRegister.registerOutputFieldControl("tabstrip", SvelteComponent$F, new OutputControlConfiguration(true, true));
    controlRegister.registerOutputFieldControl("paginated-data", SvelteComponent$D, new OutputControlConfiguration(false, true));
    controlRegister.registerOutputFieldControl("action-list", SvelteComponent$p, new OutputControlConfiguration(true, true));
    controlRegister.registerOutputFieldControl("inline-form", SvelteComponent$y, new OutputControlConfiguration(true, true));
    controlRegister.registerOutputFieldControl("text-value", SvelteComponent$H);
    controlRegister.registerOutputFieldControl("text-value-multiline", SvelteComponent$I, new OutputControlConfiguration(false, true));
    controlRegister.registerOutputFieldControl("downloadable-file", SvelteComponent$t);
    controlRegister.registerOutputFieldControl("alert", SvelteComponent$q, new OutputControlConfiguration(true, true));
    controlRegister.registerOutputFieldControl("file-size", SvelteComponent$u);
    controlRegister.registerOutputFieldControl("image", SvelteComponent$x, new OutputControlConfiguration(false, true));
    controlRegister.registerOutputFieldControl("link", SvelteComponent$z);
    controlRegister.registerOutputFieldControl("object-list", SvelteComponent$B, new OutputControlConfiguration(false, true));
    controlRegister.registerOutputFieldControl("html-string", SvelteComponent$w);
    controlRegister.registerOutputFieldControl("documentation", SvelteComponent$s, new OutputControlConfiguration(true, true));
    controlRegister.registerOutputFieldControl("pie-graph", SvelteComponent$o, new OutputControlConfiguration(false, true));
    // Form event handlers.
    controlRegister.registerFormEventHandler("log-to-console", new FormLogToConsole());
    controlRegister.registerFormEventHandler("reload-form-after-action", new ReloadFormAfterAction());
    // Input event handlers.
    controlRegister.registerInputFieldEventHandler("bind-to-output", new BindToOutput());
    controlRegister.registerInputFieldEventHandler("log-to-console", new InputLogToConsole());
    controlRegister.registerInputFieldEventHandler("depend-on", new DependOn());
    // Output event handlers.
    controlRegister.registerOutputFieldEventHandler("log-to-console", new OutputLogToConsole());
    // Functions.
    controlRegister.registerFunction("growl", new Growl());
    controlRegister.registerFunction("redirect", new Redirect());

    var alertify$4 = alertify;
    momentWithLocales.locale("en-us", {
        postformat: function (t) {
            return t.replace(/\d/g, function (match) {
                return match;
            }).replace(/,/g, "ØŒ");
        }
    });
    alertify$4.defaults = {
        closable: false,
        transition: "pulse",
        notifier: {
            delay: 8,
            position: "bottom-right",
            closeButton: true
        },
        glossary: {
            title: "AlertifyJS",
            ok: "Yes",
            cancel: "No"
        },
        // theme settings
        theme: {
            // class name attached to prompt dialog input textbox.
            input: "ajs-input",
            // class name attached to ok button
            ok: "ajs-ok",
            // class name attached to cancel button
            cancel: "ajs-cancel"
        }
    };
    var alertifyErrorMsg = [];
    var MyApp = /** @class */ (function (_super) {
        __extends(MyApp, _super);
        function MyApp(theServer) {
            return _super.call(this, theServer, controlRegister) || this;
        }
        MyApp.prototype.showError = function (message) {
            var msg = alertify$4.error(message);
            alertifyErrorMsg.push(msg);
        };
        return MyApp;
    }(UmfApp));
    var server = new UmfServer("/api/form/metadata", "/api/form/run", "/api/form/menu");
    var app = new MyApp(server);
    // Create a global variable, which can be accessed from any component.
    window.app = app;
    app.on("request:started", function (request) {
        showLoader();
    });
    app.on("request:completed", function (error) {
        if (error != null) {
            app.showError(error);
        }
        hideLoader();
    });
    app.load().then(function (response) {
        var router = new AppRouter(document.getElementById("main"), app);
        app.useRouter(router);
        router.on("router:activated", function () {
            for (var _i = 0, alertifyErrorMsg_1 = alertifyErrorMsg; _i < alertifyErrorMsg_1.length; _i++) {
                var msg = alertifyErrorMsg_1[_i];
                msg.dismiss();
            }
        });
        app.registerResponseHandler(new FormComponentResponseHandler());
        app.registerResponseHandler(new MessageResponseHandler());
        app.registerResponseHandler(new ReloadResponseHandler(function (form, inputFieldValues) {
            return app.load().then(function (t) {
                buildMenu(app);
                if (form === "home") {
                    return "#/home";
                }
                return app.makeUrl(form, inputFieldValues);
            });
        }));
        app.registerResponseHandler(new RedirectResponseHandler(function (form, inputFieldValues) {
            app.go(form, inputFieldValues);
        }));
        buildMenu(app);
    });
    // setInterval(() => {
    // 	app.loadMenu().then((t) => {
    // 		buildMenu(app);
    // 	});
    // }, 10000);
    function buildMenu(theApp) {
        // Remove old menu.
        var myNode = document.getElementById("topmenu");
        while (myNode.firstChild) {
            myNode.removeChild(myNode.firstChild);
        }
        // tslint:disable-next-line:no-unused-expression
        new SvelteComponent$2({
            target: document.getElementById("topmenu"),
            data: {
                forms: theApp.forms,
                menu: theApp.menu,
                app: theApp,
                makeUrl: function (formId, inputFieldValues) { return theApp.makeUrl(formId, inputFieldValues); }
            }
        });
    }
    function showLoader() {
        var progress = document.getElementById("progress");
        progress.setAttribute("style", "width:50%");
        var loader = document.getElementById("loader");
        loader.setAttribute("class", "");
    }
    function hideLoader() {
        var loader = document.getElementById("loader");
        var progress = document.getElementById("progress");
        progress.setAttribute("style", "width:100%");
        setTimeout(function () {
            loader.setAttribute("class", "d-none");
        }, 500);
    }

}());
